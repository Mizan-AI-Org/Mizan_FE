(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.LuaPop = {}));
})(this, function(exports2) {
  "use strict";var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

  var _focused, _cleanup, _setup, _a, _online, _cleanup2, _setup2, _b, _gcTimeout, _c, _initialState, _revertState, _cache, _client, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _d, _queries, _e2, _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _f, _mutations, _scopes, _mutationId, _g, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _h, _client2, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _i, _client3, _currentResult2, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn2, _j, _k, _l, _m;
  function _mergeNamespaces(n, m2) {
    for (var i = 0; i < m2.length; i++) {
      const e = m2[i];
      if (typeof e !== "string" && !Array.isArray(e)) {
        for (const k in e) {
          if (k !== "default" && !(k in n)) {
            const d = Object.getOwnPropertyDescriptor(e, k);
            if (d) {
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: () => e[k]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  var react = { exports: {} };
  var react_production_min = {};
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReact_production_min;
  function requireReact_production_min() {
    if (hasRequiredReact_production_min) return react_production_min;
    hasRequiredReact_production_min = 1;
    var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
    function A(a) {
      if (null === a || "object" !== typeof a) return null;
      a = z && a[z] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C = Object.assign, D = {};
    function E(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = true;
    var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L2 = { key: true, ref: true, __self: true, __source: true };
    function M(a, b, e) {
      var d, c = {}, k = null, h = null;
      if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L2.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (1 === g) c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m2 = 0; m2 < g; m2++) f[m2] = arguments[m2 + 2];
        c.children = f;
      }
      if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l;
    }
    function escape(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    function Q2(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      if ("undefined" === k || "boolean" === k) a = null;
      var h = false;
      if (null === a) h = true;
      else switch (k) {
        case "string":
        case "number":
          h = true;
          break;
        case "object":
          switch (a.$$typeof) {
            case l:
            case n:
              h = true;
          }
      }
      if (h) return h = a, c = c(h), a = "" === d ? "." + Q2(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
        return a2;
      })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      h = 0;
      d = "" === d ? "." : d + ":";
      if (I(a)) for (var g = 0; g < a.length; g++) {
        k = a[g];
        var f = d + Q2(k, g);
        h += R(k, b, e, f, c);
      }
      else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q2(k, g++), h += R(k, b, e, f, c);
      else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S(a, b, e) {
      if (null == a) return a;
      var d = [], c = 0;
      R(a, d, "", "", function(a2) {
        return b.call(e, a2, c++);
      });
      return d;
    }
    function T(a) {
      if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b2) {
          if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
        }, function(b2) {
          if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
        });
        -1 === a._status && (a._status = 0, a._result = b);
      }
      if (1 === a._status) return a._result.default;
      throw a._result;
    }
    var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    function X() {
      throw Error("act(...) is not supported in production builds of React.");
    }
    react_production_min.Children = { map: S, forEach: function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      S(a, function() {
        b++;
      });
      return b;
    }, toArray: function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    react_production_min.Component = E;
    react_production_min.Fragment = p;
    react_production_min.Profiler = r2;
    react_production_min.PureComponent = G;
    react_production_min.StrictMode = q;
    react_production_min.Suspense = w;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    react_production_min.act = X;
    react_production_min.cloneElement = function(a, b, e) {
      if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (null != b) {
        void 0 !== b.ref && (k = b.ref, h = K.current);
        void 0 !== b.key && (c = "" + b.key);
        if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
        for (f in b) J.call(b, f) && !L2.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (1 === f) d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m2 = 0; m2 < f; m2++) g[m2] = arguments[m2 + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    react_production_min.createContext = function(a) {
      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t, _context: a };
      return a.Consumer = a;
    };
    react_production_min.createElement = M;
    react_production_min.createFactory = function(a) {
      var b = M.bind(null, a);
      b.type = a;
      return b;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    react_production_min.isValidElement = O;
    react_production_min.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    react_production_min.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
    };
    react_production_min.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    react_production_min.unstable_act = X;
    react_production_min.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    react_production_min.useContext = function(a) {
      return U.current.useContext(a);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    react_production_min.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    react_production_min.useId = function() {
      return U.current.useId();
    };
    react_production_min.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    react_production_min.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    react_production_min.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    react_production_min.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    react_production_min.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    react_production_min.useRef = function(a) {
      return U.current.useRef(a);
    };
    react_production_min.useState = function(a) {
      return U.current.useState(a);
    };
    react_production_min.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    react_production_min.useTransition = function() {
      return U.current.useTransition();
    };
    react_production_min.version = "18.3.1";
    return react_production_min;
  }
  {
    react.exports = requireReact_production_min();
  }
  var reactExports = react.exports;
  const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
  const React$1 = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: React
  }, [reactExports]);
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactJsxRuntime_production_min;
  function requireReactJsxRuntime_production_min() {
    if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
    hasRequiredReactJsxRuntime_production_min = 1;
    var f = reactExports, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
    function q(c, a, g) {
      var b, d = {}, e = null, h = null;
      void 0 !== g && (e = "" + g);
      void 0 !== a.key && (e = "" + a.key);
      void 0 !== a.ref && (h = a.ref);
      for (b in a) m2.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
      return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
    }
    reactJsxRuntime_production_min.Fragment = l;
    reactJsxRuntime_production_min.jsx = q;
    reactJsxRuntime_production_min.jsxs = q;
    return reactJsxRuntime_production_min;
  }
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  function setRef$1(ref, value) {
    if (typeof ref === "function") {
      return ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs$1(...refs) {
    return (node2) => {
      let hasCleanup = false;
      const cleanups = refs.map((ref) => {
        const cleanup = setRef$1(ref, node2);
        if (!hasCleanup && typeof cleanup == "function") {
          hasCleanup = true;
        }
        return cleanup;
      });
      if (hasCleanup) {
        return () => {
          for (let i = 0; i < cleanups.length; i++) {
            const cleanup = cleanups[i];
            if (typeof cleanup == "function") {
              cleanup();
            } else {
              setRef$1(refs[i], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs$1(...refs) {
    return reactExports.useCallback(composeRefs$1(...refs), refs);
  }
  // @__NO_SIDE_EFFECTS__
  function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
    const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
      const { children, ...slotProps } = props;
      const childrenArray = reactExports.Children.toArray(children);
      const slottable = childrenArray.find(isSlottable);
      if (slottable) {
        const newElement = slottable.props.children;
        const newChildren = childrenArray.map((child) => {
          if (child === slottable) {
            if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
            return reactExports.isValidElement(newElement) ? newElement.props.children : null;
          } else {
            return child;
          }
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
  }
  var Slot$3 = /* @__PURE__ */ createSlot("Slot");
  // @__NO_SIDE_EFFECTS__
  function createSlotClone(ownerName) {
    const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
      const { children, ...slotProps } = props;
      if (reactExports.isValidElement(children)) {
        const childrenRef = getElementRef$1(children);
        const props2 = mergeProps(slotProps, children.props);
        if (children.type !== reactExports.Fragment) {
          props2.ref = forwardedRef ? composeRefs$1(forwardedRef, childrenRef) : childrenRef;
        }
        return reactExports.cloneElement(children, props2);
      }
      return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
  }
  var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
  // @__NO_SIDE_EFFECTS__
  function createSlottable(ownerName) {
    const Slottable2 = ({ children }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
    };
    Slottable2.displayName = `${ownerName}.Slottable`;
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
    return Slottable2;
  }
  function isSlottable(child) {
    return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
  }
  function mergeProps(slotProps, childProps) {
    const overrideProps = { ...childProps };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue) {
          overrideProps[propName] = (...args) => {
            const result = childPropValue(...args);
            slotPropValue(...args);
            return result;
          };
        } else if (slotPropValue) {
          overrideProps[propName] = slotPropValue;
        }
      } else if (propName === "style") {
        overrideProps[propName] = { ...slotPropValue, ...childPropValue };
      } else if (propName === "className") {
        overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
      }
    }
    return { ...slotProps, ...overrideProps };
  }
  function getElementRef$1(element2) {
    var _a2, _b2;
    let getter = (_a2 = Object.getOwnPropertyDescriptor(element2.props, "ref")) == null ? void 0 : _a2.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element2.ref;
    }
    getter = (_b2 = Object.getOwnPropertyDescriptor(element2, "ref")) == null ? void 0 : _b2.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element2.props.ref;
    }
    return element2.props.ref || element2.ref;
  }
  function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for (f in e) e[f] && (n && (n += " "), n += f);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }
  const falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
  const cx = clsx;
  const cva = (base, config) => (props) => {
    var _config_compoundVariants;
    if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    const { variants, defaultVariants } = config;
    const getVariantClassNames = Object.keys(variants).map((variant) => {
      const variantProp = props === null || props === void 0 ? void 0 : props[variant];
      const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
      if (variantProp === null) return null;
      const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
      return variants[variant][variantKey];
    });
    const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
      let [key, value] = param;
      if (value === void 0) {
        return acc;
      }
      acc[key] = value;
      return acc;
    }, {});
    const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
      let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
      return Object.entries(compoundVariantOptions).every((param2) => {
        let [key, value] = param2;
        return Array.isArray(value) ? value.includes({
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key]) : {
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key] === value;
      }) ? [
        ...acc,
        cvClass,
        cvClassName
      ] : acc;
    }, []);
    return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  };
  const CLASS_PART_SEPARATOR = "-";
  const createClassGroupUtils = (config) => {
    const classMap = createClassMap(config);
    const {
      conflictingClassGroups,
      conflictingClassGroupModifiers
    } = config;
    const getClassGroupId = (className) => {
      const classParts = className.split(CLASS_PART_SEPARATOR);
      if (classParts[0] === "" && classParts.length !== 1) {
        classParts.shift();
      }
      return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    };
    const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
      const conflicts = conflictingClassGroups[classGroupId] || [];
      if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
        return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
      }
      return conflicts;
    };
    return {
      getClassGroupId,
      getConflictingClassGroupIds
    };
  };
  const getGroupRecursive = (classParts, classPartObject) => {
    var _a2;
    if (classParts.length === 0) {
      return classPartObject.classGroupId;
    }
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
    if (classGroupFromNextClassPart) {
      return classGroupFromNextClassPart;
    }
    if (classPartObject.validators.length === 0) {
      return void 0;
    }
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return (_a2 = classPartObject.validators.find(({
      validator: validator2
    }) => validator2(classRest))) == null ? void 0 : _a2.classGroupId;
  };
  const arbitraryPropertyRegex = /^\[(.+)\]$/;
  const getGroupIdForArbitraryProperty = (className) => {
    if (arbitraryPropertyRegex.test(className)) {
      const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
      const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
      if (property) {
        return "arbitrary.." + property;
      }
    }
  };
  const createClassMap = (config) => {
    const {
      theme: theme21,
      prefix
    } = config;
    const classMap = {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    };
    const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
    prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
      processClassesRecursively(classGroup, classMap, classGroupId, theme21);
    });
    return classMap;
  };
  const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme21) => {
    classGroup.forEach((classDefinition) => {
      if (typeof classDefinition === "string") {
        const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
        classPartObjectToEdit.classGroupId = classGroupId;
        return;
      }
      if (typeof classDefinition === "function") {
        if (isThemeGetter(classDefinition)) {
          processClassesRecursively(classDefinition(theme21), classPartObject, classGroupId, theme21);
          return;
        }
        classPartObject.validators.push({
          validator: classDefinition,
          classGroupId
        });
        return;
      }
      Object.entries(classDefinition).forEach(([key, classGroup2]) => {
        processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme21);
      });
    });
  };
  const getPart = (classPartObject, path) => {
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
      if (!currentClassPartObject.nextPart.has(pathPart)) {
        currentClassPartObject.nextPart.set(pathPart, {
          nextPart: /* @__PURE__ */ new Map(),
          validators: []
        });
      }
      currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
  };
  const isThemeGetter = (func) => func.isThemeGetter;
  const getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
    if (!prefix) {
      return classGroupEntries;
    }
    return classGroupEntries.map(([classGroupId, classGroup]) => {
      const prefixedClassGroup = classGroup.map((classDefinition) => {
        if (typeof classDefinition === "string") {
          return prefix + classDefinition;
        }
        if (typeof classDefinition === "object") {
          return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
        }
        return classDefinition;
      });
      return [classGroupId, prefixedClassGroup];
    });
  };
  const createLruCache = (maxCacheSize) => {
    if (maxCacheSize < 1) {
      return {
        get: () => void 0,
        set: () => {
        }
      };
    }
    let cacheSize = 0;
    let cache = /* @__PURE__ */ new Map();
    let previousCache = /* @__PURE__ */ new Map();
    const update = (key, value) => {
      cache.set(key, value);
      cacheSize++;
      if (cacheSize > maxCacheSize) {
        cacheSize = 0;
        previousCache = cache;
        cache = /* @__PURE__ */ new Map();
      }
    };
    return {
      get(key) {
        let value = cache.get(key);
        if (value !== void 0) {
          return value;
        }
        if ((value = previousCache.get(key)) !== void 0) {
          update(key, value);
          return value;
        }
      },
      set(key, value) {
        if (cache.has(key)) {
          cache.set(key, value);
        } else {
          update(key, value);
        }
      }
    };
  };
  const IMPORTANT_MODIFIER = "!";
  const createParseClassName = (config) => {
    const {
      separator,
      experimentalParseClassName
    } = config;
    const isSeparatorSingleCharacter = separator.length === 1;
    const firstSeparatorCharacter = separator[0];
    const separatorLength = separator.length;
    const parseClassName = (className) => {
      const modifiers = [];
      let bracketDepth = 0;
      let modifierStart = 0;
      let postfixModifierPosition;
      for (let index2 = 0; index2 < className.length; index2++) {
        let currentCharacter = className[index2];
        if (bracketDepth === 0) {
          if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
            modifiers.push(className.slice(modifierStart, index2));
            modifierStart = index2 + separatorLength;
            continue;
          }
          if (currentCharacter === "/") {
            postfixModifierPosition = index2;
            continue;
          }
        }
        if (currentCharacter === "[") {
          bracketDepth++;
        } else if (currentCharacter === "]") {
          bracketDepth--;
        }
      }
      const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
      const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
      const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
      const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
      return {
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      };
    };
    if (experimentalParseClassName) {
      return (className) => experimentalParseClassName({
        className,
        parseClassName
      });
    }
    return parseClassName;
  };
  const sortModifiers = (modifiers) => {
    if (modifiers.length <= 1) {
      return modifiers;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier) => {
      const isArbitraryVariant = modifier[0] === "[";
      if (isArbitraryVariant) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  };
  const createConfigUtils = (config) => ({
    cache: createLruCache(config.cacheSize),
    parseClassName: createParseClassName(config),
    ...createClassGroupUtils(config)
  });
  const SPLIT_CLASSES_REGEX = /\s+/;
  const mergeClassList = (classList, configUtils) => {
    const {
      parseClassName,
      getClassGroupId,
      getConflictingClassGroupIds
    } = configUtils;
    const classGroupsInConflict = [];
    const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
    let result = "";
    for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
      const originalClassName = classNames[index2];
      const {
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      } = parseClassName(originalClassName);
      let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
      let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
      if (!classGroupId) {
        if (!hasPostfixModifier) {
          result = originalClassName + (result.length > 0 ? " " + result : result);
          continue;
        }
        classGroupId = getClassGroupId(baseClassName);
        if (!classGroupId) {
          result = originalClassName + (result.length > 0 ? " " + result : result);
          continue;
        }
        hasPostfixModifier = false;
      }
      const variantModifier = sortModifiers(modifiers).join(":");
      const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
      const classId = modifierId + classGroupId;
      if (classGroupsInConflict.includes(classId)) {
        continue;
      }
      classGroupsInConflict.push(classId);
      const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
      for (let i = 0; i < conflictGroups.length; ++i) {
        const group = conflictGroups[i];
        classGroupsInConflict.push(modifierId + group);
      }
      result = originalClassName + (result.length > 0 ? " " + result : result);
    }
    return result;
  };
  function twJoin() {
    let index2 = 0;
    let argument;
    let resolvedValue;
    let string2 = "";
    while (index2 < arguments.length) {
      if (argument = arguments[index2++]) {
        if (resolvedValue = toValue(argument)) {
          string2 && (string2 += " ");
          string2 += resolvedValue;
        }
      }
    }
    return string2;
  }
  const toValue = (mix2) => {
    if (typeof mix2 === "string") {
      return mix2;
    }
    let resolvedValue;
    let string2 = "";
    for (let k = 0; k < mix2.length; k++) {
      if (mix2[k]) {
        if (resolvedValue = toValue(mix2[k])) {
          string2 && (string2 += " ");
          string2 += resolvedValue;
        }
      }
    }
    return string2;
  };
  function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
      const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
      configUtils = createConfigUtils(config);
      cacheGet = configUtils.cache.get;
      cacheSet = configUtils.cache.set;
      functionToCall = tailwindMerge;
      return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
      const cachedResult = cacheGet(classList);
      if (cachedResult) {
        return cachedResult;
      }
      const result = mergeClassList(classList, configUtils);
      cacheSet(classList, result);
      return result;
    }
    return function callTailwindMerge() {
      return functionToCall(twJoin.apply(null, arguments));
    };
  }
  const fromTheme = (key) => {
    const themeGetter = (theme21) => theme21[key] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
  };
  const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
  const fractionRegex = /^\d+\/\d+$/;
  const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
  const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
  const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
  const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
  const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
  const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
  const isLength = (value) => isNumber$2(value) || stringLengths.has(value) || fractionRegex.test(value);
  const isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
  const isNumber$2 = (value) => Boolean(value) && !Number.isNaN(Number(value));
  const isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber$2);
  const isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
  const isPercent = (value) => value.endsWith("%") && isNumber$2(value.slice(0, -1));
  const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
  const isTshirtSize = (value) => tshirtUnitRegex.test(value);
  const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
  const isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
  const isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
  const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
  const isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
  const isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
  const isAny = () => true;
  const getIsArbitraryValue = (value, label, testValue) => {
    const result = arbitraryValueRegex.exec(value);
    if (result) {
      if (result[1]) {
        return typeof label === "string" ? result[1] === label : label.has(result[1]);
      }
      return testValue(result[2]);
    }
    return false;
  };
  const isLengthOnly = (value) => (
    // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
    // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
    // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
    lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
  );
  const isNever = () => false;
  const isShadow = (value) => shadowRegex.test(value);
  const isImage = (value) => imageRegex.test(value);
  const getDefaultConfig = () => {
    const colors2 = fromTheme("colors");
    const spacing = fromTheme("spacing");
    const blur = fromTheme("blur");
    const brightness = fromTheme("brightness");
    const borderColor = fromTheme("borderColor");
    const borderRadius = fromTheme("borderRadius");
    const borderSpacing = fromTheme("borderSpacing");
    const borderWidth = fromTheme("borderWidth");
    const contrast = fromTheme("contrast");
    const grayscale = fromTheme("grayscale");
    const hueRotate = fromTheme("hueRotate");
    const invert = fromTheme("invert");
    const gap = fromTheme("gap");
    const gradientColorStops = fromTheme("gradientColorStops");
    const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
    const inset = fromTheme("inset");
    const margin = fromTheme("margin");
    const opacity = fromTheme("opacity");
    const padding = fromTheme("padding");
    const saturate = fromTheme("saturate");
    const scale2 = fromTheme("scale");
    const sepia = fromTheme("sepia");
    const skew = fromTheme("skew");
    const space2 = fromTheme("space");
    const translate = fromTheme("translate");
    const getOverscroll = () => ["auto", "contain", "none"];
    const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
    const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
    const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
    const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
    const getNumberWithAutoAndArbitrary = () => ["auto", isNumber$2, isArbitraryValue];
    const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
    const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
    const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
    const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
    const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
    const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
    const getNumberAndArbitrary = () => [isNumber$2, isArbitraryValue];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [isAny],
        spacing: [isLength, isArbitraryLength],
        blur: ["none", "", isTshirtSize, isArbitraryValue],
        brightness: getNumberAndArbitrary(),
        borderColor: [colors2],
        borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
        borderSpacing: getSpacingWithArbitrary(),
        borderWidth: getLengthWithEmptyAndArbitrary(),
        contrast: getNumberAndArbitrary(),
        grayscale: getZeroAndEmpty(),
        hueRotate: getNumberAndArbitrary(),
        invert: getZeroAndEmpty(),
        gap: getSpacingWithArbitrary(),
        gradientColorStops: [colors2],
        gradientColorStopPositions: [isPercent, isArbitraryLength],
        inset: getSpacingWithAutoAndArbitrary(),
        margin: getSpacingWithAutoAndArbitrary(),
        opacity: getNumberAndArbitrary(),
        padding: getSpacingWithArbitrary(),
        saturate: getNumberAndArbitrary(),
        scale: getNumberAndArbitrary(),
        sepia: getZeroAndEmpty(),
        skew: getNumberAndArbitrary(),
        space: getSpacingWithArbitrary(),
        translate: getSpacingWithArbitrary()
      },
      classGroups: {
        // Layout
        /**
         * Aspect Ratio
         * @see https://tailwindcss.com/docs/aspect-ratio
         */
        aspect: [{
          aspect: ["auto", "square", "video", isArbitraryValue]
        }],
        /**
         * Container
         * @see https://tailwindcss.com/docs/container
         */
        container: ["container"],
        /**
         * Columns
         * @see https://tailwindcss.com/docs/columns
         */
        columns: [{
          columns: [isTshirtSize]
        }],
        /**
         * Break After
         * @see https://tailwindcss.com/docs/break-after
         */
        "break-after": [{
          "break-after": getBreaks()
        }],
        /**
         * Break Before
         * @see https://tailwindcss.com/docs/break-before
         */
        "break-before": [{
          "break-before": getBreaks()
        }],
        /**
         * Break Inside
         * @see https://tailwindcss.com/docs/break-inside
         */
        "break-inside": [{
          "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
        }],
        /**
         * Box Decoration Break
         * @see https://tailwindcss.com/docs/box-decoration-break
         */
        "box-decoration": [{
          "box-decoration": ["slice", "clone"]
        }],
        /**
         * Box Sizing
         * @see https://tailwindcss.com/docs/box-sizing
         */
        box: [{
          box: ["border", "content"]
        }],
        /**
         * Display
         * @see https://tailwindcss.com/docs/display
         */
        display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
        /**
         * Floats
         * @see https://tailwindcss.com/docs/float
         */
        float: [{
          float: ["right", "left", "none", "start", "end"]
        }],
        /**
         * Clear
         * @see https://tailwindcss.com/docs/clear
         */
        clear: [{
          clear: ["left", "right", "both", "none", "start", "end"]
        }],
        /**
         * Isolation
         * @see https://tailwindcss.com/docs/isolation
         */
        isolation: ["isolate", "isolation-auto"],
        /**
         * Object Fit
         * @see https://tailwindcss.com/docs/object-fit
         */
        "object-fit": [{
          object: ["contain", "cover", "fill", "none", "scale-down"]
        }],
        /**
         * Object Position
         * @see https://tailwindcss.com/docs/object-position
         */
        "object-position": [{
          object: [...getPositions(), isArbitraryValue]
        }],
        /**
         * Overflow
         * @see https://tailwindcss.com/docs/overflow
         */
        overflow: [{
          overflow: getOverflow()
        }],
        /**
         * Overflow X
         * @see https://tailwindcss.com/docs/overflow
         */
        "overflow-x": [{
          "overflow-x": getOverflow()
        }],
        /**
         * Overflow Y
         * @see https://tailwindcss.com/docs/overflow
         */
        "overflow-y": [{
          "overflow-y": getOverflow()
        }],
        /**
         * Overscroll Behavior
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        overscroll: [{
          overscroll: getOverscroll()
        }],
        /**
         * Overscroll Behavior X
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        "overscroll-x": [{
          "overscroll-x": getOverscroll()
        }],
        /**
         * Overscroll Behavior Y
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        "overscroll-y": [{
          "overscroll-y": getOverscroll()
        }],
        /**
         * Position
         * @see https://tailwindcss.com/docs/position
         */
        position: ["static", "fixed", "absolute", "relative", "sticky"],
        /**
         * Top / Right / Bottom / Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        inset: [{
          inset: [inset]
        }],
        /**
         * Right / Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        "inset-x": [{
          "inset-x": [inset]
        }],
        /**
         * Top / Bottom
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        "inset-y": [{
          "inset-y": [inset]
        }],
        /**
         * Start
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        start: [{
          start: [inset]
        }],
        /**
         * End
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        end: [{
          end: [inset]
        }],
        /**
         * Top
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        top: [{
          top: [inset]
        }],
        /**
         * Right
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        right: [{
          right: [inset]
        }],
        /**
         * Bottom
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        bottom: [{
          bottom: [inset]
        }],
        /**
         * Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        left: [{
          left: [inset]
        }],
        /**
         * Visibility
         * @see https://tailwindcss.com/docs/visibility
         */
        visibility: ["visible", "invisible", "collapse"],
        /**
         * Z-Index
         * @see https://tailwindcss.com/docs/z-index
         */
        z: [{
          z: ["auto", isInteger, isArbitraryValue]
        }],
        // Flexbox and Grid
        /**
         * Flex Basis
         * @see https://tailwindcss.com/docs/flex-basis
         */
        basis: [{
          basis: getSpacingWithAutoAndArbitrary()
        }],
        /**
         * Flex Direction
         * @see https://tailwindcss.com/docs/flex-direction
         */
        "flex-direction": [{
          flex: ["row", "row-reverse", "col", "col-reverse"]
        }],
        /**
         * Flex Wrap
         * @see https://tailwindcss.com/docs/flex-wrap
         */
        "flex-wrap": [{
          flex: ["wrap", "wrap-reverse", "nowrap"]
        }],
        /**
         * Flex
         * @see https://tailwindcss.com/docs/flex
         */
        flex: [{
          flex: ["1", "auto", "initial", "none", isArbitraryValue]
        }],
        /**
         * Flex Grow
         * @see https://tailwindcss.com/docs/flex-grow
         */
        grow: [{
          grow: getZeroAndEmpty()
        }],
        /**
         * Flex Shrink
         * @see https://tailwindcss.com/docs/flex-shrink
         */
        shrink: [{
          shrink: getZeroAndEmpty()
        }],
        /**
         * Order
         * @see https://tailwindcss.com/docs/order
         */
        order: [{
          order: ["first", "last", "none", isInteger, isArbitraryValue]
        }],
        /**
         * Grid Template Columns
         * @see https://tailwindcss.com/docs/grid-template-columns
         */
        "grid-cols": [{
          "grid-cols": [isAny]
        }],
        /**
         * Grid Column Start / End
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-start-end": [{
          col: ["auto", {
            span: ["full", isInteger, isArbitraryValue]
          }, isArbitraryValue]
        }],
        /**
         * Grid Column Start
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-start": [{
          "col-start": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Column End
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-end": [{
          "col-end": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Template Rows
         * @see https://tailwindcss.com/docs/grid-template-rows
         */
        "grid-rows": [{
          "grid-rows": [isAny]
        }],
        /**
         * Grid Row Start / End
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-start-end": [{
          row: ["auto", {
            span: [isInteger, isArbitraryValue]
          }, isArbitraryValue]
        }],
        /**
         * Grid Row Start
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-start": [{
          "row-start": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Row End
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-end": [{
          "row-end": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Auto Flow
         * @see https://tailwindcss.com/docs/grid-auto-flow
         */
        "grid-flow": [{
          "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
        }],
        /**
         * Grid Auto Columns
         * @see https://tailwindcss.com/docs/grid-auto-columns
         */
        "auto-cols": [{
          "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
        }],
        /**
         * Grid Auto Rows
         * @see https://tailwindcss.com/docs/grid-auto-rows
         */
        "auto-rows": [{
          "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
        }],
        /**
         * Gap
         * @see https://tailwindcss.com/docs/gap
         */
        gap: [{
          gap: [gap]
        }],
        /**
         * Gap X
         * @see https://tailwindcss.com/docs/gap
         */
        "gap-x": [{
          "gap-x": [gap]
        }],
        /**
         * Gap Y
         * @see https://tailwindcss.com/docs/gap
         */
        "gap-y": [{
          "gap-y": [gap]
        }],
        /**
         * Justify Content
         * @see https://tailwindcss.com/docs/justify-content
         */
        "justify-content": [{
          justify: ["normal", ...getAlign()]
        }],
        /**
         * Justify Items
         * @see https://tailwindcss.com/docs/justify-items
         */
        "justify-items": [{
          "justify-items": ["start", "end", "center", "stretch"]
        }],
        /**
         * Justify Self
         * @see https://tailwindcss.com/docs/justify-self
         */
        "justify-self": [{
          "justify-self": ["auto", "start", "end", "center", "stretch"]
        }],
        /**
         * Align Content
         * @see https://tailwindcss.com/docs/align-content
         */
        "align-content": [{
          content: ["normal", ...getAlign(), "baseline"]
        }],
        /**
         * Align Items
         * @see https://tailwindcss.com/docs/align-items
         */
        "align-items": [{
          items: ["start", "end", "center", "baseline", "stretch"]
        }],
        /**
         * Align Self
         * @see https://tailwindcss.com/docs/align-self
         */
        "align-self": [{
          self: ["auto", "start", "end", "center", "stretch", "baseline"]
        }],
        /**
         * Place Content
         * @see https://tailwindcss.com/docs/place-content
         */
        "place-content": [{
          "place-content": [...getAlign(), "baseline"]
        }],
        /**
         * Place Items
         * @see https://tailwindcss.com/docs/place-items
         */
        "place-items": [{
          "place-items": ["start", "end", "center", "baseline", "stretch"]
        }],
        /**
         * Place Self
         * @see https://tailwindcss.com/docs/place-self
         */
        "place-self": [{
          "place-self": ["auto", "start", "end", "center", "stretch"]
        }],
        // Spacing
        /**
         * Padding
         * @see https://tailwindcss.com/docs/padding
         */
        p: [{
          p: [padding]
        }],
        /**
         * Padding X
         * @see https://tailwindcss.com/docs/padding
         */
        px: [{
          px: [padding]
        }],
        /**
         * Padding Y
         * @see https://tailwindcss.com/docs/padding
         */
        py: [{
          py: [padding]
        }],
        /**
         * Padding Start
         * @see https://tailwindcss.com/docs/padding
         */
        ps: [{
          ps: [padding]
        }],
        /**
         * Padding End
         * @see https://tailwindcss.com/docs/padding
         */
        pe: [{
          pe: [padding]
        }],
        /**
         * Padding Top
         * @see https://tailwindcss.com/docs/padding
         */
        pt: [{
          pt: [padding]
        }],
        /**
         * Padding Right
         * @see https://tailwindcss.com/docs/padding
         */
        pr: [{
          pr: [padding]
        }],
        /**
         * Padding Bottom
         * @see https://tailwindcss.com/docs/padding
         */
        pb: [{
          pb: [padding]
        }],
        /**
         * Padding Left
         * @see https://tailwindcss.com/docs/padding
         */
        pl: [{
          pl: [padding]
        }],
        /**
         * Margin
         * @see https://tailwindcss.com/docs/margin
         */
        m: [{
          m: [margin]
        }],
        /**
         * Margin X
         * @see https://tailwindcss.com/docs/margin
         */
        mx: [{
          mx: [margin]
        }],
        /**
         * Margin Y
         * @see https://tailwindcss.com/docs/margin
         */
        my: [{
          my: [margin]
        }],
        /**
         * Margin Start
         * @see https://tailwindcss.com/docs/margin
         */
        ms: [{
          ms: [margin]
        }],
        /**
         * Margin End
         * @see https://tailwindcss.com/docs/margin
         */
        me: [{
          me: [margin]
        }],
        /**
         * Margin Top
         * @see https://tailwindcss.com/docs/margin
         */
        mt: [{
          mt: [margin]
        }],
        /**
         * Margin Right
         * @see https://tailwindcss.com/docs/margin
         */
        mr: [{
          mr: [margin]
        }],
        /**
         * Margin Bottom
         * @see https://tailwindcss.com/docs/margin
         */
        mb: [{
          mb: [margin]
        }],
        /**
         * Margin Left
         * @see https://tailwindcss.com/docs/margin
         */
        ml: [{
          ml: [margin]
        }],
        /**
         * Space Between X
         * @see https://tailwindcss.com/docs/space
         */
        "space-x": [{
          "space-x": [space2]
        }],
        /**
         * Space Between X Reverse
         * @see https://tailwindcss.com/docs/space
         */
        "space-x-reverse": ["space-x-reverse"],
        /**
         * Space Between Y
         * @see https://tailwindcss.com/docs/space
         */
        "space-y": [{
          "space-y": [space2]
        }],
        /**
         * Space Between Y Reverse
         * @see https://tailwindcss.com/docs/space
         */
        "space-y-reverse": ["space-y-reverse"],
        // Sizing
        /**
         * Width
         * @see https://tailwindcss.com/docs/width
         */
        w: [{
          w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
        }],
        /**
         * Min-Width
         * @see https://tailwindcss.com/docs/min-width
         */
        "min-w": [{
          "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
        }],
        /**
         * Max-Width
         * @see https://tailwindcss.com/docs/max-width
         */
        "max-w": [{
          "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
            screen: [isTshirtSize]
          }, isTshirtSize]
        }],
        /**
         * Height
         * @see https://tailwindcss.com/docs/height
         */
        h: [{
          h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        /**
         * Min-Height
         * @see https://tailwindcss.com/docs/min-height
         */
        "min-h": [{
          "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        /**
         * Max-Height
         * @see https://tailwindcss.com/docs/max-height
         */
        "max-h": [{
          "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        /**
         * Size
         * @see https://tailwindcss.com/docs/size
         */
        size: [{
          size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
        }],
        // Typography
        /**
         * Font Size
         * @see https://tailwindcss.com/docs/font-size
         */
        "font-size": [{
          text: ["base", isTshirtSize, isArbitraryLength]
        }],
        /**
         * Font Smoothing
         * @see https://tailwindcss.com/docs/font-smoothing
         */
        "font-smoothing": ["antialiased", "subpixel-antialiased"],
        /**
         * Font Style
         * @see https://tailwindcss.com/docs/font-style
         */
        "font-style": ["italic", "not-italic"],
        /**
         * Font Weight
         * @see https://tailwindcss.com/docs/font-weight
         */
        "font-weight": [{
          font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
        }],
        /**
         * Font Family
         * @see https://tailwindcss.com/docs/font-family
         */
        "font-family": [{
          font: [isAny]
        }],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-normal": ["normal-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-ordinal": ["ordinal"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-slashed-zero": ["slashed-zero"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-figure": ["lining-nums", "oldstyle-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-spacing": ["proportional-nums", "tabular-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
        /**
         * Letter Spacing
         * @see https://tailwindcss.com/docs/letter-spacing
         */
        tracking: [{
          tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
        }],
        /**
         * Line Clamp
         * @see https://tailwindcss.com/docs/line-clamp
         */
        "line-clamp": [{
          "line-clamp": ["none", isNumber$2, isArbitraryNumber]
        }],
        /**
         * Line Height
         * @see https://tailwindcss.com/docs/line-height
         */
        leading: [{
          leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
        }],
        /**
         * List Style Image
         * @see https://tailwindcss.com/docs/list-style-image
         */
        "list-image": [{
          "list-image": ["none", isArbitraryValue]
        }],
        /**
         * List Style Type
         * @see https://tailwindcss.com/docs/list-style-type
         */
        "list-style-type": [{
          list: ["none", "disc", "decimal", isArbitraryValue]
        }],
        /**
         * List Style Position
         * @see https://tailwindcss.com/docs/list-style-position
         */
        "list-style-position": [{
          list: ["inside", "outside"]
        }],
        /**
         * Placeholder Color
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/placeholder-color
         */
        "placeholder-color": [{
          placeholder: [colors2]
        }],
        /**
         * Placeholder Opacity
         * @see https://tailwindcss.com/docs/placeholder-opacity
         */
        "placeholder-opacity": [{
          "placeholder-opacity": [opacity]
        }],
        /**
         * Text Alignment
         * @see https://tailwindcss.com/docs/text-align
         */
        "text-alignment": [{
          text: ["left", "center", "right", "justify", "start", "end"]
        }],
        /**
         * Text Color
         * @see https://tailwindcss.com/docs/text-color
         */
        "text-color": [{
          text: [colors2]
        }],
        /**
         * Text Opacity
         * @see https://tailwindcss.com/docs/text-opacity
         */
        "text-opacity": [{
          "text-opacity": [opacity]
        }],
        /**
         * Text Decoration
         * @see https://tailwindcss.com/docs/text-decoration
         */
        "text-decoration": ["underline", "overline", "line-through", "no-underline"],
        /**
         * Text Decoration Style
         * @see https://tailwindcss.com/docs/text-decoration-style
         */
        "text-decoration-style": [{
          decoration: [...getLineStyles(), "wavy"]
        }],
        /**
         * Text Decoration Thickness
         * @see https://tailwindcss.com/docs/text-decoration-thickness
         */
        "text-decoration-thickness": [{
          decoration: ["auto", "from-font", isLength, isArbitraryLength]
        }],
        /**
         * Text Underline Offset
         * @see https://tailwindcss.com/docs/text-underline-offset
         */
        "underline-offset": [{
          "underline-offset": ["auto", isLength, isArbitraryValue]
        }],
        /**
         * Text Decoration Color
         * @see https://tailwindcss.com/docs/text-decoration-color
         */
        "text-decoration-color": [{
          decoration: [colors2]
        }],
        /**
         * Text Transform
         * @see https://tailwindcss.com/docs/text-transform
         */
        "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
        /**
         * Text Overflow
         * @see https://tailwindcss.com/docs/text-overflow
         */
        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
        /**
         * Text Wrap
         * @see https://tailwindcss.com/docs/text-wrap
         */
        "text-wrap": [{
          text: ["wrap", "nowrap", "balance", "pretty"]
        }],
        /**
         * Text Indent
         * @see https://tailwindcss.com/docs/text-indent
         */
        indent: [{
          indent: getSpacingWithArbitrary()
        }],
        /**
         * Vertical Alignment
         * @see https://tailwindcss.com/docs/vertical-align
         */
        "vertical-align": [{
          align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
        }],
        /**
         * Whitespace
         * @see https://tailwindcss.com/docs/whitespace
         */
        whitespace: [{
          whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
        }],
        /**
         * Word Break
         * @see https://tailwindcss.com/docs/word-break
         */
        break: [{
          break: ["normal", "words", "all", "keep"]
        }],
        /**
         * Hyphens
         * @see https://tailwindcss.com/docs/hyphens
         */
        hyphens: [{
          hyphens: ["none", "manual", "auto"]
        }],
        /**
         * Content
         * @see https://tailwindcss.com/docs/content
         */
        content: [{
          content: ["none", isArbitraryValue]
        }],
        // Backgrounds
        /**
         * Background Attachment
         * @see https://tailwindcss.com/docs/background-attachment
         */
        "bg-attachment": [{
          bg: ["fixed", "local", "scroll"]
        }],
        /**
         * Background Clip
         * @see https://tailwindcss.com/docs/background-clip
         */
        "bg-clip": [{
          "bg-clip": ["border", "padding", "content", "text"]
        }],
        /**
         * Background Opacity
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/background-opacity
         */
        "bg-opacity": [{
          "bg-opacity": [opacity]
        }],
        /**
         * Background Origin
         * @see https://tailwindcss.com/docs/background-origin
         */
        "bg-origin": [{
          "bg-origin": ["border", "padding", "content"]
        }],
        /**
         * Background Position
         * @see https://tailwindcss.com/docs/background-position
         */
        "bg-position": [{
          bg: [...getPositions(), isArbitraryPosition]
        }],
        /**
         * Background Repeat
         * @see https://tailwindcss.com/docs/background-repeat
         */
        "bg-repeat": [{
          bg: ["no-repeat", {
            repeat: ["", "x", "y", "round", "space"]
          }]
        }],
        /**
         * Background Size
         * @see https://tailwindcss.com/docs/background-size
         */
        "bg-size": [{
          bg: ["auto", "cover", "contain", isArbitrarySize]
        }],
        /**
         * Background Image
         * @see https://tailwindcss.com/docs/background-image
         */
        "bg-image": [{
          bg: ["none", {
            "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isArbitraryImage]
        }],
        /**
         * Background Color
         * @see https://tailwindcss.com/docs/background-color
         */
        "bg-color": [{
          bg: [colors2]
        }],
        /**
         * Gradient Color Stops From Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-from-pos": [{
          from: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops Via Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-via-pos": [{
          via: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops To Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-to-pos": [{
          to: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops From
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-from": [{
          from: [gradientColorStops]
        }],
        /**
         * Gradient Color Stops Via
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-via": [{
          via: [gradientColorStops]
        }],
        /**
         * Gradient Color Stops To
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-to": [{
          to: [gradientColorStops]
        }],
        // Borders
        /**
         * Border Radius
         * @see https://tailwindcss.com/docs/border-radius
         */
        rounded: [{
          rounded: [borderRadius]
        }],
        /**
         * Border Radius Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-s": [{
          "rounded-s": [borderRadius]
        }],
        /**
         * Border Radius End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-e": [{
          "rounded-e": [borderRadius]
        }],
        /**
         * Border Radius Top
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-t": [{
          "rounded-t": [borderRadius]
        }],
        /**
         * Border Radius Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-r": [{
          "rounded-r": [borderRadius]
        }],
        /**
         * Border Radius Bottom
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-b": [{
          "rounded-b": [borderRadius]
        }],
        /**
         * Border Radius Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-l": [{
          "rounded-l": [borderRadius]
        }],
        /**
         * Border Radius Start Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-ss": [{
          "rounded-ss": [borderRadius]
        }],
        /**
         * Border Radius Start End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-se": [{
          "rounded-se": [borderRadius]
        }],
        /**
         * Border Radius End End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-ee": [{
          "rounded-ee": [borderRadius]
        }],
        /**
         * Border Radius End Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-es": [{
          "rounded-es": [borderRadius]
        }],
        /**
         * Border Radius Top Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-tl": [{
          "rounded-tl": [borderRadius]
        }],
        /**
         * Border Radius Top Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-tr": [{
          "rounded-tr": [borderRadius]
        }],
        /**
         * Border Radius Bottom Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-br": [{
          "rounded-br": [borderRadius]
        }],
        /**
         * Border Radius Bottom Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-bl": [{
          "rounded-bl": [borderRadius]
        }],
        /**
         * Border Width
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w": [{
          border: [borderWidth]
        }],
        /**
         * Border Width X
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-x": [{
          "border-x": [borderWidth]
        }],
        /**
         * Border Width Y
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-y": [{
          "border-y": [borderWidth]
        }],
        /**
         * Border Width Start
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-s": [{
          "border-s": [borderWidth]
        }],
        /**
         * Border Width End
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-e": [{
          "border-e": [borderWidth]
        }],
        /**
         * Border Width Top
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-t": [{
          "border-t": [borderWidth]
        }],
        /**
         * Border Width Right
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-r": [{
          "border-r": [borderWidth]
        }],
        /**
         * Border Width Bottom
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-b": [{
          "border-b": [borderWidth]
        }],
        /**
         * Border Width Left
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-l": [{
          "border-l": [borderWidth]
        }],
        /**
         * Border Opacity
         * @see https://tailwindcss.com/docs/border-opacity
         */
        "border-opacity": [{
          "border-opacity": [opacity]
        }],
        /**
         * Border Style
         * @see https://tailwindcss.com/docs/border-style
         */
        "border-style": [{
          border: [...getLineStyles(), "hidden"]
        }],
        /**
         * Divide Width X
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-x": [{
          "divide-x": [borderWidth]
        }],
        /**
         * Divide Width X Reverse
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-x-reverse": ["divide-x-reverse"],
        /**
         * Divide Width Y
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-y": [{
          "divide-y": [borderWidth]
        }],
        /**
         * Divide Width Y Reverse
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-y-reverse": ["divide-y-reverse"],
        /**
         * Divide Opacity
         * @see https://tailwindcss.com/docs/divide-opacity
         */
        "divide-opacity": [{
          "divide-opacity": [opacity]
        }],
        /**
         * Divide Style
         * @see https://tailwindcss.com/docs/divide-style
         */
        "divide-style": [{
          divide: getLineStyles()
        }],
        /**
         * Border Color
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color": [{
          border: [borderColor]
        }],
        /**
         * Border Color X
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-x": [{
          "border-x": [borderColor]
        }],
        /**
         * Border Color Y
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-y": [{
          "border-y": [borderColor]
        }],
        /**
         * Border Color S
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-s": [{
          "border-s": [borderColor]
        }],
        /**
         * Border Color E
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-e": [{
          "border-e": [borderColor]
        }],
        /**
         * Border Color Top
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-t": [{
          "border-t": [borderColor]
        }],
        /**
         * Border Color Right
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-r": [{
          "border-r": [borderColor]
        }],
        /**
         * Border Color Bottom
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-b": [{
          "border-b": [borderColor]
        }],
        /**
         * Border Color Left
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-l": [{
          "border-l": [borderColor]
        }],
        /**
         * Divide Color
         * @see https://tailwindcss.com/docs/divide-color
         */
        "divide-color": [{
          divide: [borderColor]
        }],
        /**
         * Outline Style
         * @see https://tailwindcss.com/docs/outline-style
         */
        "outline-style": [{
          outline: ["", ...getLineStyles()]
        }],
        /**
         * Outline Offset
         * @see https://tailwindcss.com/docs/outline-offset
         */
        "outline-offset": [{
          "outline-offset": [isLength, isArbitraryValue]
        }],
        /**
         * Outline Width
         * @see https://tailwindcss.com/docs/outline-width
         */
        "outline-w": [{
          outline: [isLength, isArbitraryLength]
        }],
        /**
         * Outline Color
         * @see https://tailwindcss.com/docs/outline-color
         */
        "outline-color": [{
          outline: [colors2]
        }],
        /**
         * Ring Width
         * @see https://tailwindcss.com/docs/ring-width
         */
        "ring-w": [{
          ring: getLengthWithEmptyAndArbitrary()
        }],
        /**
         * Ring Width Inset
         * @see https://tailwindcss.com/docs/ring-width
         */
        "ring-w-inset": ["ring-inset"],
        /**
         * Ring Color
         * @see https://tailwindcss.com/docs/ring-color
         */
        "ring-color": [{
          ring: [colors2]
        }],
        /**
         * Ring Opacity
         * @see https://tailwindcss.com/docs/ring-opacity
         */
        "ring-opacity": [{
          "ring-opacity": [opacity]
        }],
        /**
         * Ring Offset Width
         * @see https://tailwindcss.com/docs/ring-offset-width
         */
        "ring-offset-w": [{
          "ring-offset": [isLength, isArbitraryLength]
        }],
        /**
         * Ring Offset Color
         * @see https://tailwindcss.com/docs/ring-offset-color
         */
        "ring-offset-color": [{
          "ring-offset": [colors2]
        }],
        // Effects
        /**
         * Box Shadow
         * @see https://tailwindcss.com/docs/box-shadow
         */
        shadow: [{
          shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
        }],
        /**
         * Box Shadow Color
         * @see https://tailwindcss.com/docs/box-shadow-color
         */
        "shadow-color": [{
          shadow: [isAny]
        }],
        /**
         * Opacity
         * @see https://tailwindcss.com/docs/opacity
         */
        opacity: [{
          opacity: [opacity]
        }],
        /**
         * Mix Blend Mode
         * @see https://tailwindcss.com/docs/mix-blend-mode
         */
        "mix-blend": [{
          "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
        }],
        /**
         * Background Blend Mode
         * @see https://tailwindcss.com/docs/background-blend-mode
         */
        "bg-blend": [{
          "bg-blend": getBlendModes()
        }],
        // Filters
        /**
         * Filter
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/filter
         */
        filter: [{
          filter: ["", "none"]
        }],
        /**
         * Blur
         * @see https://tailwindcss.com/docs/blur
         */
        blur: [{
          blur: [blur]
        }],
        /**
         * Brightness
         * @see https://tailwindcss.com/docs/brightness
         */
        brightness: [{
          brightness: [brightness]
        }],
        /**
         * Contrast
         * @see https://tailwindcss.com/docs/contrast
         */
        contrast: [{
          contrast: [contrast]
        }],
        /**
         * Drop Shadow
         * @see https://tailwindcss.com/docs/drop-shadow
         */
        "drop-shadow": [{
          "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
        }],
        /**
         * Grayscale
         * @see https://tailwindcss.com/docs/grayscale
         */
        grayscale: [{
          grayscale: [grayscale]
        }],
        /**
         * Hue Rotate
         * @see https://tailwindcss.com/docs/hue-rotate
         */
        "hue-rotate": [{
          "hue-rotate": [hueRotate]
        }],
        /**
         * Invert
         * @see https://tailwindcss.com/docs/invert
         */
        invert: [{
          invert: [invert]
        }],
        /**
         * Saturate
         * @see https://tailwindcss.com/docs/saturate
         */
        saturate: [{
          saturate: [saturate]
        }],
        /**
         * Sepia
         * @see https://tailwindcss.com/docs/sepia
         */
        sepia: [{
          sepia: [sepia]
        }],
        /**
         * Backdrop Filter
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/backdrop-filter
         */
        "backdrop-filter": [{
          "backdrop-filter": ["", "none"]
        }],
        /**
         * Backdrop Blur
         * @see https://tailwindcss.com/docs/backdrop-blur
         */
        "backdrop-blur": [{
          "backdrop-blur": [blur]
        }],
        /**
         * Backdrop Brightness
         * @see https://tailwindcss.com/docs/backdrop-brightness
         */
        "backdrop-brightness": [{
          "backdrop-brightness": [brightness]
        }],
        /**
         * Backdrop Contrast
         * @see https://tailwindcss.com/docs/backdrop-contrast
         */
        "backdrop-contrast": [{
          "backdrop-contrast": [contrast]
        }],
        /**
         * Backdrop Grayscale
         * @see https://tailwindcss.com/docs/backdrop-grayscale
         */
        "backdrop-grayscale": [{
          "backdrop-grayscale": [grayscale]
        }],
        /**
         * Backdrop Hue Rotate
         * @see https://tailwindcss.com/docs/backdrop-hue-rotate
         */
        "backdrop-hue-rotate": [{
          "backdrop-hue-rotate": [hueRotate]
        }],
        /**
         * Backdrop Invert
         * @see https://tailwindcss.com/docs/backdrop-invert
         */
        "backdrop-invert": [{
          "backdrop-invert": [invert]
        }],
        /**
         * Backdrop Opacity
         * @see https://tailwindcss.com/docs/backdrop-opacity
         */
        "backdrop-opacity": [{
          "backdrop-opacity": [opacity]
        }],
        /**
         * Backdrop Saturate
         * @see https://tailwindcss.com/docs/backdrop-saturate
         */
        "backdrop-saturate": [{
          "backdrop-saturate": [saturate]
        }],
        /**
         * Backdrop Sepia
         * @see https://tailwindcss.com/docs/backdrop-sepia
         */
        "backdrop-sepia": [{
          "backdrop-sepia": [sepia]
        }],
        // Tables
        /**
         * Border Collapse
         * @see https://tailwindcss.com/docs/border-collapse
         */
        "border-collapse": [{
          border: ["collapse", "separate"]
        }],
        /**
         * Border Spacing
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing": [{
          "border-spacing": [borderSpacing]
        }],
        /**
         * Border Spacing X
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing-x": [{
          "border-spacing-x": [borderSpacing]
        }],
        /**
         * Border Spacing Y
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing-y": [{
          "border-spacing-y": [borderSpacing]
        }],
        /**
         * Table Layout
         * @see https://tailwindcss.com/docs/table-layout
         */
        "table-layout": [{
          table: ["auto", "fixed"]
        }],
        /**
         * Caption Side
         * @see https://tailwindcss.com/docs/caption-side
         */
        caption: [{
          caption: ["top", "bottom"]
        }],
        // Transitions and Animation
        /**
         * Tranisition Property
         * @see https://tailwindcss.com/docs/transition-property
         */
        transition: [{
          transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
        }],
        /**
         * Transition Duration
         * @see https://tailwindcss.com/docs/transition-duration
         */
        duration: [{
          duration: getNumberAndArbitrary()
        }],
        /**
         * Transition Timing Function
         * @see https://tailwindcss.com/docs/transition-timing-function
         */
        ease: [{
          ease: ["linear", "in", "out", "in-out", isArbitraryValue]
        }],
        /**
         * Transition Delay
         * @see https://tailwindcss.com/docs/transition-delay
         */
        delay: [{
          delay: getNumberAndArbitrary()
        }],
        /**
         * Animation
         * @see https://tailwindcss.com/docs/animation
         */
        animate: [{
          animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
        }],
        // Transforms
        /**
         * Transform
         * @see https://tailwindcss.com/docs/transform
         */
        transform: [{
          transform: ["", "gpu", "none"]
        }],
        /**
         * Scale
         * @see https://tailwindcss.com/docs/scale
         */
        scale: [{
          scale: [scale2]
        }],
        /**
         * Scale X
         * @see https://tailwindcss.com/docs/scale
         */
        "scale-x": [{
          "scale-x": [scale2]
        }],
        /**
         * Scale Y
         * @see https://tailwindcss.com/docs/scale
         */
        "scale-y": [{
          "scale-y": [scale2]
        }],
        /**
         * Rotate
         * @see https://tailwindcss.com/docs/rotate
         */
        rotate: [{
          rotate: [isInteger, isArbitraryValue]
        }],
        /**
         * Translate X
         * @see https://tailwindcss.com/docs/translate
         */
        "translate-x": [{
          "translate-x": [translate]
        }],
        /**
         * Translate Y
         * @see https://tailwindcss.com/docs/translate
         */
        "translate-y": [{
          "translate-y": [translate]
        }],
        /**
         * Skew X
         * @see https://tailwindcss.com/docs/skew
         */
        "skew-x": [{
          "skew-x": [skew]
        }],
        /**
         * Skew Y
         * @see https://tailwindcss.com/docs/skew
         */
        "skew-y": [{
          "skew-y": [skew]
        }],
        /**
         * Transform Origin
         * @see https://tailwindcss.com/docs/transform-origin
         */
        "transform-origin": [{
          origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
        }],
        // Interactivity
        /**
         * Accent Color
         * @see https://tailwindcss.com/docs/accent-color
         */
        accent: [{
          accent: ["auto", colors2]
        }],
        /**
         * Appearance
         * @see https://tailwindcss.com/docs/appearance
         */
        appearance: [{
          appearance: ["none", "auto"]
        }],
        /**
         * Cursor
         * @see https://tailwindcss.com/docs/cursor
         */
        cursor: [{
          cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
        }],
        /**
         * Caret Color
         * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
         */
        "caret-color": [{
          caret: [colors2]
        }],
        /**
         * Pointer Events
         * @see https://tailwindcss.com/docs/pointer-events
         */
        "pointer-events": [{
          "pointer-events": ["none", "auto"]
        }],
        /**
         * Resize
         * @see https://tailwindcss.com/docs/resize
         */
        resize: [{
          resize: ["none", "y", "x", ""]
        }],
        /**
         * Scroll Behavior
         * @see https://tailwindcss.com/docs/scroll-behavior
         */
        "scroll-behavior": [{
          scroll: ["auto", "smooth"]
        }],
        /**
         * Scroll Margin
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-m": [{
          "scroll-m": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin X
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mx": [{
          "scroll-mx": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Y
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-my": [{
          "scroll-my": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Start
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-ms": [{
          "scroll-ms": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin End
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-me": [{
          "scroll-me": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Top
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mt": [{
          "scroll-mt": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Right
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mr": [{
          "scroll-mr": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Bottom
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mb": [{
          "scroll-mb": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Left
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-ml": [{
          "scroll-ml": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-p": [{
          "scroll-p": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding X
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-px": [{
          "scroll-px": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Y
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-py": [{
          "scroll-py": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Start
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-ps": [{
          "scroll-ps": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding End
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pe": [{
          "scroll-pe": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Top
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pt": [{
          "scroll-pt": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Right
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pr": [{
          "scroll-pr": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Bottom
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pb": [{
          "scroll-pb": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Left
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pl": [{
          "scroll-pl": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Snap Align
         * @see https://tailwindcss.com/docs/scroll-snap-align
         */
        "snap-align": [{
          snap: ["start", "end", "center", "align-none"]
        }],
        /**
         * Scroll Snap Stop
         * @see https://tailwindcss.com/docs/scroll-snap-stop
         */
        "snap-stop": [{
          snap: ["normal", "always"]
        }],
        /**
         * Scroll Snap Type
         * @see https://tailwindcss.com/docs/scroll-snap-type
         */
        "snap-type": [{
          snap: ["none", "x", "y", "both"]
        }],
        /**
         * Scroll Snap Type Strictness
         * @see https://tailwindcss.com/docs/scroll-snap-type
         */
        "snap-strictness": [{
          snap: ["mandatory", "proximity"]
        }],
        /**
         * Touch Action
         * @see https://tailwindcss.com/docs/touch-action
         */
        touch: [{
          touch: ["auto", "none", "manipulation"]
        }],
        /**
         * Touch Action X
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-x": [{
          "touch-pan": ["x", "left", "right"]
        }],
        /**
         * Touch Action Y
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-y": [{
          "touch-pan": ["y", "up", "down"]
        }],
        /**
         * Touch Action Pinch Zoom
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-pz": ["touch-pinch-zoom"],
        /**
         * User Select
         * @see https://tailwindcss.com/docs/user-select
         */
        select: [{
          select: ["none", "text", "all", "auto"]
        }],
        /**
         * Will Change
         * @see https://tailwindcss.com/docs/will-change
         */
        "will-change": [{
          "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
        }],
        // SVG
        /**
         * Fill
         * @see https://tailwindcss.com/docs/fill
         */
        fill: [{
          fill: [colors2, "none"]
        }],
        /**
         * Stroke Width
         * @see https://tailwindcss.com/docs/stroke-width
         */
        "stroke-w": [{
          stroke: [isLength, isArbitraryLength, isArbitraryNumber]
        }],
        /**
         * Stroke
         * @see https://tailwindcss.com/docs/stroke
         */
        stroke: [{
          stroke: [colors2, "none"]
        }],
        // Accessibility
        /**
         * Screen Readers
         * @see https://tailwindcss.com/docs/screen-readers
         */
        sr: ["sr-only", "not-sr-only"],
        /**
         * Forced Color Adjust
         * @see https://tailwindcss.com/docs/forced-color-adjust
         */
        "forced-color-adjust": [{
          "forced-color-adjust": ["auto", "none"]
        }]
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        size: ["w", "h"],
        "font-size": ["leading"],
        "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        "line-clamp": ["display", "overflow"],
        rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"]
      },
      conflictingClassGroupModifiers: {
        "font-size": ["leading"]
      }
    };
  };
  const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
  function composeEventHandlers$1(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler == null ? void 0 : originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented) {
        return ourEventHandler == null ? void 0 : ourEventHandler(event);
      }
    };
  }
  function createContext2(rootComponentName, defaultContext) {
    const Context = reactExports.createContext(defaultContext);
    const Provider2 = (props) => {
      const { children, ...context } = props;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName) {
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  function createContextScope(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext3(rootComponentName, defaultContext) {
      const BaseContext = reactExports.createContext(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [...defaultContexts, defaultContext];
      const Provider2 = (props) => {
        var _a2;
        const { scope, children, ...context } = props;
        const Context = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
        const value = reactExports.useMemo(() => context, Object.values(context));
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
      };
      Provider2.displayName = rootComponentName + "Provider";
      function useContext2(consumerName, scope) {
        var _a2;
        const Context = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
        const context = reactExports.useContext(Context);
        if (context) return context;
        if (defaultContext !== void 0) return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      return [Provider2, useContext2];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return reactExports.createContext(defaultContext);
      });
      return function useScope(scope) {
        const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
        return reactExports.useMemo(
          () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
          [scope, contexts]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
  }
  function composeContextScopes(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    const createScope = () => {
      const scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      }));
      return function useComposedScopes(overrideScopes) {
        const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return { ...nextScopes2, ...currentScope };
        }, {});
        return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
      };
    };
    createScope.scopeName = baseScope.scopeName;
    return createScope;
  }
  function createCollection(name2) {
    const PROVIDER_NAME2 = name2 + "CollectionProvider";
    const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
    const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
      PROVIDER_NAME2,
      { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
    );
    const CollectionProvider = (props) => {
      const { scope, children } = props;
      const ref = React.useRef(null);
      const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
    };
    CollectionProvider.displayName = PROVIDER_NAME2;
    const COLLECTION_SLOT_NAME = name2 + "CollectionSlot";
    const CollectionSlotImpl = /* @__PURE__ */ createSlot(COLLECTION_SLOT_NAME);
    const CollectionSlot = React.forwardRef(
      (props, forwardedRef) => {
        const { scope, children } = props;
        const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
        const composedRefs = useComposedRefs$1(forwardedRef, context.collectionRef);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionSlotImpl, { ref: composedRefs, children });
      }
    );
    CollectionSlot.displayName = COLLECTION_SLOT_NAME;
    const ITEM_SLOT_NAME = name2 + "CollectionItemSlot";
    const ITEM_DATA_ATTR = "data-radix-collection-item";
    const CollectionItemSlotImpl = /* @__PURE__ */ createSlot(ITEM_SLOT_NAME);
    const CollectionItemSlot = React.forwardRef(
      (props, forwardedRef) => {
        const { scope, children, ...itemData } = props;
        const ref = React.useRef(null);
        const composedRefs = useComposedRefs$1(forwardedRef, ref);
        const context = useCollectionContext(ITEM_SLOT_NAME, scope);
        React.useEffect(() => {
          context.itemMap.set(ref, { ref, ...itemData });
          return () => void context.itemMap.delete(ref);
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
      }
    );
    CollectionItemSlot.displayName = ITEM_SLOT_NAME;
    function useCollection2(scope) {
      const context = useCollectionContext(name2 + "CollectionConsumer", scope);
      const getItems = React.useCallback(() => {
        const collectionNode = context.collectionRef.current;
        if (!collectionNode) return [];
        const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
        const items = Array.from(context.itemMap.values());
        const orderedItems = items.sort(
          (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
        );
        return orderedItems;
      }, [context.collectionRef, context.itemMap]);
      return getItems;
    }
    return [
      { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
      useCollection2,
      createCollectionScope2
    ];
  }
  var useLayoutEffect2 = (globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
  };
  var useReactId = React$1[" useId ".trim().toString()] || (() => void 0);
  var count$1 = 0;
  function useId(deterministicId) {
    const [id2, setId] = reactExports.useState(useReactId());
    useLayoutEffect2(() => {
      setId((reactId) => reactId ?? String(count$1++));
    }, [deterministicId]);
    return deterministicId || (id2 ? `radix-${id2}` : "");
  }
  var reactDom = { exports: {} };
  var reactDom_production_min = {};
  var scheduler = { exports: {} };
  var scheduler_production_min = {};
  /**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredScheduler_production_min;
  function requireScheduler_production_min() {
    if (hasRequiredScheduler_production_min) return scheduler_production_min;
    hasRequiredScheduler_production_min = 1;
    (function(exports3) {
      function f(a, b) {
        var c = a.length;
        a.push(b);
        a: for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
          else break a;
        }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 === a.length) return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
            var m2 = 2 * (d + 1) - 1, C = a[m2], n = m2 + 1, x = a[n];
            if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m2] = c, d = m2);
            else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
            else break a;
          }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l = performance;
        exports3.unstable_now = function() {
          return l.now();
        };
      } else {
        var p = Date, q = p.now();
        exports3.unstable_now = function() {
          return p.now() - q;
        };
      }
      var r2 = [], t = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback) k(t);
          else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r2, b);
          else break;
          b = h(t);
        }
      }
      function H(a) {
        B = false;
        G(a);
        if (!A) if (null !== h(r2)) A = true, I(J);
        else {
          var b = h(t);
          null !== b && K(H, b.startTime - a);
        }
      }
      function J(a, b) {
        A = false;
        B && (B = false, E(L2), L2 = -1);
        z = true;
        var c = y;
        try {
          G(b);
          for (v = h(r2); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
            var d = v.callback;
            if ("function" === typeof d) {
              v.callback = null;
              y = v.priorityLevel;
              var e = d(v.expirationTime <= b);
              b = exports3.unstable_now();
              "function" === typeof e ? v.callback = e : v === h(r2) && k(r2);
              G(b);
            } else k(r2);
            v = h(r2);
          }
          if (null !== v) var w = true;
          else {
            var m2 = h(t);
            null !== m2 && K(H, m2.startTime - b);
            w = false;
          }
          return w;
        } finally {
          v = null, y = c, z = false;
        }
      }
      var N = false, O = null, L2 = -1, P = 5, Q2 = -1;
      function M() {
        return exports3.unstable_now() - Q2 < P ? false : true;
      }
      function R() {
        if (null !== O) {
          var a = exports3.unstable_now();
          Q2 = a;
          var b = true;
          try {
            b = O(true, a);
          } finally {
            b ? S() : (N = false, O = null);
          }
        } else N = false;
      }
      var S;
      if ("function" === typeof F) S = function() {
        F(R);
      };
      else if ("undefined" !== typeof MessageChannel) {
        var T = new MessageChannel(), U = T.port2;
        T.port1.onmessage = R;
        S = function() {
          U.postMessage(null);
        };
      } else S = function() {
        D(R, 0);
      };
      function I(a) {
        O = a;
        N || (N = true, S());
      }
      function K(a, b) {
        L2 = D(function() {
          a(exports3.unstable_now());
        }, b);
      }
      exports3.unstable_IdlePriority = 5;
      exports3.unstable_ImmediatePriority = 1;
      exports3.unstable_LowPriority = 4;
      exports3.unstable_NormalPriority = 3;
      exports3.unstable_Profiling = null;
      exports3.unstable_UserBlockingPriority = 2;
      exports3.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports3.unstable_continueExecution = function() {
        A || z || (A = true, I(J));
      };
      exports3.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports3.unstable_getCurrentPriorityLevel = function() {
        return y;
      };
      exports3.unstable_getFirstCallbackNode = function() {
        return h(r2);
      };
      exports3.unstable_next = function(a) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y;
        }
        var c = y;
        y = b;
        try {
          return a();
        } finally {
          y = c;
        }
      };
      exports3.unstable_pauseExecution = function() {
      };
      exports3.unstable_requestPaint = function() {
      };
      exports3.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y;
        y = a;
        try {
          return b();
        } finally {
          y = c;
        }
      };
      exports3.unstable_scheduleCallback = function(a, b, c) {
        var d = exports3.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f(t, a), null === h(r2) && a === h(t) && (B ? (E(L2), L2 = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r2, a), A || z || (A = true, I(J)));
        return a;
      };
      exports3.unstable_shouldYield = M;
      exports3.unstable_wrapCallback = function(a) {
        var b = y;
        return function() {
          var c = y;
          y = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y = c;
          }
        };
      };
    })(scheduler_production_min);
    return scheduler_production_min;
  }
  var hasRequiredScheduler;
  function requireScheduler() {
    if (hasRequiredScheduler) return scheduler.exports;
    hasRequiredScheduler = 1;
    {
      scheduler.exports = requireScheduler_production_min();
    }
    return scheduler.exports;
  }
  /**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactDom_production_min;
  function requireReactDom_production_min() {
    if (hasRequiredReactDom_production_min) return reactDom_production_min;
    hasRequiredReactDom_production_min = 1;
    var aa = reactExports, ca = requireScheduler();
    function p(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a, b) {
      ha(a, b);
      ha(a + "Capture", b);
    }
    function ha(a, b) {
      ea[a] = b;
      for (a = 0; a < b.length; a++) da.add(b[a]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja2 = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a) {
      if (ja2.call(ma, a)) return true;
      if (ja2.call(la, a)) return false;
      if (ka.test(a)) return ma[a] = true;
      la[a] = true;
      return false;
    }
    function pa(a, b, c, d) {
      if (null !== c && 0 === c.type) return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d) return false;
          if (null !== c) return !c.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa(a, b, c, d) {
      if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
      if (d) return false;
      if (null !== c) switch (c.type) {
        case 3:
          return !b;
        case 4:
          return false === b;
        case 5:
          return isNaN(b);
        case 6:
          return isNaN(b) || 1 > b;
      }
      return false;
    }
    function v(a, b, c, d, e, f, g) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a;
      this.type = b;
      this.sanitizeURL = f;
      this.removeEmptyString = g;
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z[a] = new v(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      z[b] = new v(b, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z[a] = new v(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z[a] = new v(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z[a] = new v(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z[a] = new v(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ra,
        sa
      );
      z[b] = new v(b, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b, c, d) {
      var e = z.hasOwnProperty(b) ? z[b] : null;
      if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba2 = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da2 = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa2 = Symbol.for("react.suspense_list"), Ga2 = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka2(a) {
      if (null === a || "object" !== typeof a) return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A = Object.assign, La;
    function Ma(a) {
      if (void 0 === La) try {
        throw Error();
      } catch (c) {
        var b = c.stack.trim().match(/\n( *(at )?)/);
        La = b && b[1] || "";
      }
      return "\n" + La + a;
    }
    var Na = false;
    function Oa2(a, b) {
      if (!a || Na) return "";
      Na = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b) if (b = function() {
          throw Error();
        }, Object.defineProperty(b.prototype, "props", { set: function() {
          throw Error();
        } }), "object" === typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b, []);
          } catch (l) {
            var d = l;
          }
          Reflect.construct(a, [], b);
        } else {
          try {
            b.call();
          } catch (l) {
            d = l;
          }
          a.call(b.prototype);
        }
        else {
          try {
            throw Error();
          } catch (l) {
            d = l;
          }
          a();
        }
      } catch (l) {
        if (l && d && "string" === typeof l.stack) {
          for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
          for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
            if (1 !== g || 1 !== h) {
              do
                if (g--, h--, 0 > h || e[g] !== f[h]) {
                  var k = "\n" + e[g].replace(" at new ", " at ");
                  a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                  return k;
                }
              while (1 <= g && 0 <= h);
            }
            break;
          }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa2(a.type, false), a;
        case 11:
          return a = Oa2(a.type.render, false), a;
        case 1:
          return a = Oa2(a.type, true), a;
        default:
          return "";
      }
    }
    function Qa2(a) {
      if (null == a) return null;
      if ("function" === typeof a) return a.displayName || a.name || null;
      if ("string" === typeof a) return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa2:
          return "SuspenseList";
      }
      if ("object" === typeof a) switch (a.$$typeof) {
        case Ca:
          return (a.displayName || "Context") + ".Consumer";
        case Ba2:
          return (a._context.displayName || "Context") + ".Provider";
        case Da2:
          var b = a.render;
          a = a.displayName;
          a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          return a;
        case Ga2:
          return b = a.displayName || null, null !== b ? b : Qa2(a.type) || "Memo";
        case Ha:
          b = a._payload;
          a = a._init;
          try {
            return Qa2(a(b));
          } catch (c) {
          }
      }
      return null;
    }
    function Ra2(a) {
      var b = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa2(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b) return b.displayName || b.name || null;
          if ("string" === typeof b) return b;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    function Ua2(a) {
      var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
      if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
        var e = c.get, f = c.set;
        Object.defineProperty(a, b, { configurable: true, get: function() {
          return e.call(this);
        }, set: function(a2) {
          d = "" + a2;
          f.call(this, a2);
        } });
        Object.defineProperty(a, b, { enumerable: c.enumerable });
        return { getValue: function() {
          return d;
        }, setValue: function(a2) {
          d = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b];
        } };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua2(a));
    }
    function Wa2(a) {
      if (!a) return false;
      var b = a._valueTracker;
      if (!b) return true;
      var c = b.getValue();
      var d = "";
      a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d;
      return a !== c ? (b.setValue(a), true) : false;
    }
    function Xa2(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a) return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    function Ya(a, b) {
      var c = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
    }
    function Za(a, b) {
      var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
      c = Sa(null != b.value ? b.value : c);
      a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    function ab(a, b) {
      b = b.checked;
      null != b && ta(a, "checked", b, false);
    }
    function bb(a, b) {
      ab(a, b);
      var c = Sa(b.value), d = b.type;
      if (null != c) if ("number" === d) {
        if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
      } else a.value !== "" + c && (a.value = "" + c);
      else if ("submit" === d || "reset" === d) {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
    }
    function db(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
        b = "" + a._wrapperState.initialValue;
        c || b === a.value || (a.value = b);
        a.defaultValue = b;
      }
      c = a.name;
      "" !== c && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c && (a.name = c);
    }
    function cb(a, b, c) {
      if ("number" !== b || Xa2(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    var eb = Array.isArray;
    function fb(a, b, c, d) {
      a = a.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
        for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
      } else {
        c = "" + Sa(c);
        b = null;
        for (e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = true;
            d && (a[e].defaultSelected = true);
            return;
          }
          null !== b || a[e].disabled || (b = a[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    function gb(a, b) {
      if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b) {
      var c = b.value;
      if (null == c) {
        c = b.children;
        b = b.defaultValue;
        if (null != c) {
          if (null != b) throw Error(p(92));
          if (eb(c)) {
            if (1 < c.length) throw Error(p(93));
            c = c[0];
          }
          b = c;
        }
        null == b && (b = "");
        c = b;
      }
      a._wrapperState = { initialValue: Sa(c) };
    }
    function ib(a, b) {
      var c = Sa(b.value), d = Sa(b.defaultValue);
      null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
      null != d && (a.defaultValue = "" + d);
    }
    function jb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb, nb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d, e);
        });
      } : a;
    }(function(a, b) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
        for (; b.firstChild; ) a.appendChild(b.firstChild);
      }
    });
    function ob(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && 3 === c.nodeType) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b] = pb[a];
      });
    });
    function rb(a, b, c) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
    }
    function sb(a, b) {
      a = a.style;
      for (var c in b) if (b.hasOwnProperty(c)) {
        var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
        "float" === c && (c = "cssFloat");
        d ? a.setProperty(c, e) : a[c] = e;
      }
    }
    var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b) {
      if (b) {
        if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children) throw Error(p(60));
          if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
        }
        if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
      }
    }
    function vb(a, b) {
      if (-1 === a.indexOf("-")) return "string" === typeof b.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb) throw Error(p(280));
        var b = a.stateNode;
        b && (b = Db(b), yb(a.stateNode, a.type, b));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b = Ab;
        Ab = zb = null;
        Bb(a);
        if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
      }
    }
    function Gb(a, b) {
      return a(b);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a, b, c) {
      if (Ib) return a(b, c);
      Ib = true;
      try {
        return Gb(a, b, c);
      } finally {
        if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
      }
    }
    function Kb(a, b) {
      var c = a.stateNode;
      if (null === c) return null;
      var d = Db(c);
      if (null === d) return null;
      c = d[b];
      a: switch (b) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
          a = !d;
          break a;
        default:
          a = false;
      }
      if (a) return null;
      if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
      return c;
    }
    var Lb = false;
    if (ia) try {
      var Mb = {};
      Object.defineProperty(Mb, "passive", { get: function() {
        Lb = true;
      } });
      window.addEventListener("test", Mb, Mb);
      window.removeEventListener("test", Mb, Mb);
    } catch (a) {
      Lb = false;
    }
    function Nb(a, b, c, d, e, f, g, h, k) {
      var l = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
      Ob = true;
      Pb = a;
    } };
    function Tb(a, b, c, d, e, f, g, h, k) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a, b, c, d, e, f, g, h, k) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l = Pb;
          Ob = false;
          Pb = null;
        } else throw Error(p(198));
        Qb || (Qb = true, Rb = l);
      }
    }
    function Vb(a) {
      var b = a, c = a;
      if (a.alternate) for (; b.return; ) b = b.return;
      else {
        a = b;
        do
          b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
        while (a);
      }
      return 3 === b.tag ? c : null;
    }
    function Wb(a) {
      if (13 === a.tag) {
        var b = a.memoizedState;
        null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
        if (null !== b) return b.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a) throw Error(p(188));
    }
    function Yb(a) {
      var b = a.alternate;
      if (!b) {
        b = Vb(a);
        if (null === b) throw Error(p(188));
        return b !== a ? null : a;
      }
      for (var c = a, d = b; ; ) {
        var e = c.return;
        if (null === e) break;
        var f = e.alternate;
        if (null === f) {
          d = e.return;
          if (null !== d) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c) return Xb(e), a;
            if (f === d) return Xb(e), b;
            f = f.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d.return) c = e, d = f;
        else {
          for (var g = false, h = e.child; h; ) {
            if (h === c) {
              g = true;
              c = e;
              d = f;
              break;
            }
            if (h === d) {
              g = true;
              d = e;
              c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = true;
                c = f;
                d = e;
                break;
              }
              if (h === d) {
                g = true;
                d = f;
                c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g) throw Error(p(189));
          }
        }
        if (c.alternate !== d) throw Error(p(190));
      }
      if (3 !== c.tag) throw Error(p(188));
      return c.stateNode.current === c ? a : b;
    }
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    function $b(a) {
      if (5 === a.tag || 6 === a.tag) return a;
      for (a = a.child; null !== a; ) {
        var b = $b(a);
        if (null !== b) return b;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot) try {
        lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
      } catch (b) {
      }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b) {
      var c = a.pendingLanes;
      if (0 === c) return 0;
      var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
      if (0 !== g) {
        var h = g & ~e;
        0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
      } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
      if (0 === d) return 0;
      if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
      0 !== (d & 4) && (d |= c & 16);
      b = a.entangledLanes;
      if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
      return d;
    }
    function vc(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b) {
      for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
        var g = 31 - oc(f), h = 1 << g, k = e[g];
        if (-1 === k) {
          if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
        } else k <= b && (a.expiredLanes |= h);
        f &= ~h;
      }
    }
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    function zc(a) {
      for (var b = [], c = 0; 31 > c; c++) b.push(a);
      return b;
    }
    function Ac(a, b, c) {
      a.pendingLanes |= b;
      536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b = 31 - oc(b);
      a[b] = c;
    }
    function Bc(a, b) {
      var c = a.pendingLanes & ~b;
      a.pendingLanes = b;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b;
      a.mutableReadLanes &= b;
      a.entangledLanes &= b;
      b = a.entanglements;
      var d = a.eventTimes;
      for (a = a.expirationTimes; 0 < c; ) {
        var e = 31 - oc(c), f = 1 << e;
        b[e] = 0;
        d[e] = -1;
        a[e] = -1;
        c &= ~f;
      }
    }
    function Cc(a, b) {
      var c = a.entangledLanes |= b;
      for (a = a.entanglements; c; ) {
        var d = 31 - oc(c), e = 1 << d;
        e & b | a[d] & b && (a[d] |= b);
        c &= ~e;
      }
    }
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    function Tc(a, b, c, d, e, f) {
      if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
      a.eventSystemFlags |= d;
      b = a.targetContainers;
      null !== e && -1 === b.indexOf(e) && b.push(e);
      return a;
    }
    function Uc(a, b, c, d, e) {
      switch (b) {
        case "focusin":
          return Lc = Tc(Lc, a, b, c, d, e), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b, c, d, e), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b, c, d, e), true;
        case "pointerover":
          var f = e.pointerId;
          Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
          return true;
        case "gotpointercapture":
          return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
      }
      return false;
    }
    function Vc(a) {
      var b = Wc(a.target);
      if (null !== b) {
        var c = Vb(b);
        if (null !== c) {
          if (b = c.tag, 13 === b) {
            if (b = Wb(c), null !== b) {
              a.blockedOn = b;
              Ic(a.priority, function() {
                Gc(c);
              });
              return;
            }
          } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (null !== a.blockedOn) return false;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (null === c) {
          c = a.nativeEvent;
          var d = new c.constructor(c.type, c);
          wb = d;
          c.target.dispatchEvent(d);
          wb = null;
        } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
        b.shift();
      }
      return true;
    }
    function Zc(a, b, c) {
      Xc(a) && c.delete(b);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a, b) {
      a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b(b2) {
        return ad(b2, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c = 1; c < Kc.length; c++) {
          var d = Kc[c];
          d.blockedOn === a && (d.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b);
      Pc.forEach(b);
      for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
      for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a, b, c, d) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f;
      }
    }
    function gd(a, b, c, d) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f;
      }
    }
    function fd(a, b, c, d) {
      if (dd) {
        var e = Yc(a, b, c, d);
        if (null === e) hd(a, b, d, id2, c), Sc(a, d);
        else if (Uc(e, a, b, c, d)) d.stopPropagation();
        else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e; ) {
            var f = Cb(e);
            null !== f && Ec(f);
            f = Yc(a, b, c, d);
            null === f && hd(a, b, d, id2, c);
            if (f === e) break;
            e = f;
          }
          null !== e && d.stopPropagation();
        } else hd(a, b, d, null, c);
      }
    }
    var id2 = null;
    function Yc(a, b, c, d) {
      id2 = null;
      a = xb(d);
      a = Wc(a);
      if (null !== a) if (b = Vb(a), null === b) a = null;
      else if (c = b.tag, 13 === c) {
        a = Wb(b);
        if (null !== a) return a;
        a = null;
      } else if (3 === c) {
        if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
        a = null;
      } else b !== a && (a = null);
      id2 = a;
      return null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md) return md;
      var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++) ;
      var g = c - a;
      for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
      return md = e.slice(a, 1 < d ? 1 - d : void 0);
    }
    function od(a) {
      var b = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b(b2, d, e, f, g) {
        this._reactName = b2;
        this._targetInst = e;
        this.type = d;
        this.nativeEvent = f;
        this.target = g;
        this.currentTarget = null;
        for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
        this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A(b.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a) return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A({}, ud, { key: function(a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if ("Unidentified" !== b) return b;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be2 = null;
    ia && "documentMode" in document && (be2 = document.documentMode);
    var ce = ia && "TextEvent" in window && !be2, de = ia && (!ae || be2 && 8 < be2 && 11 >= be2), ee = String.fromCharCode(32), fe = false;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which) return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b) {
      if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length) return b.char;
            if (b.which) return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
    }
    function ne(a, b, c, d) {
      Eb(d);
      b = oe(b, "onChange");
      0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
    }
    var pe = null, qe = null;
    function re2(a) {
      se(a, 0);
    }
    function te(a) {
      var b = ue(a);
      if (Wa2(b)) return a;
    }
    function ve(a, b) {
      if ("change" === a) return b;
    }
    var we2 = false;
    if (ia) {
      var xe;
      if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze2 = document.createElement("div");
          ze2.setAttribute("oninput", "return;");
          ye = "function" === typeof ze2.oninput;
        }
        xe = ye;
      } else xe = false;
      we2 = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be2), qe = pe = null);
    }
    function Be2(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b = [];
        ne(b, qe, a, xb(a));
        Jb(re2, b);
      }
    }
    function Ce(a, b, c) {
      "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be2)) : "focusout" === a && Ae();
    }
    function De2(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
    }
    function Ee2(a, b) {
      if ("click" === a) return te(b);
    }
    function Fe2(a, b) {
      if ("input" === a || "change" === a) return te(b);
    }
    function Ge2(a, b) {
      return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var He2 = "function" === typeof Object.is ? Object.is : Ge2;
    function Ie(a, b) {
      if (He2(a, b)) return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
      var c = Object.keys(a), d = Object.keys(b);
      if (c.length !== d.length) return false;
      for (d = 0; d < c.length; d++) {
        var e = c[d];
        if (!ja2.call(b, e) || !He2(a[e], b[e])) return false;
      }
      return true;
    }
    function Je(a) {
      for (; a && a.firstChild; ) a = a.firstChild;
      return a;
    }
    function Ke2(a, b) {
      var c = Je(a);
      a = 0;
      for (var d; c; ) {
        if (3 === c.nodeType) {
          d = a + c.textContent.length;
          if (a <= b && d >= b) return { node: c, offset: b - a };
          a = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Je(c);
      }
    }
    function Le(a, b) {
      return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
    }
    function Me2() {
      for (var a = window, b = Xa2(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = "string" === typeof b.contentWindow.location.href;
        } catch (d) {
          c = false;
        }
        if (c) a = b.contentWindow;
        else break;
        b = Xa2(a.document);
      }
      return b;
    }
    function Ne2(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
    }
    function Oe2(a) {
      var b = Me2(), c = a.focusedElem, d = a.selectionRange;
      if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
        if (null !== d && Ne2(c)) {
          if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
          else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e = c.textContent.length, f = Math.min(d.start, e);
            d = void 0 === d.end ? f : Math.min(d.end, e);
            !a.extend && f > d && (e = d, d = f, f = e);
            e = Ke2(c, f);
            var g = Ke2(
              c,
              d
            );
            e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
          }
        }
        b = [];
        for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c.focus && c.focus();
        for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe2 = null, Re = null, Se2 = null, Te2 = false;
    function Ue(a, b, c) {
      var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
      Te2 || null == Qe2 || Qe2 !== Xa2(d) || (d = Qe2, "selectionStart" in d && Ne2(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se2 && Ie(Se2, d) || (Se2 = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe2)));
    }
    function Ve(a, b) {
      var c = {};
      c[a.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a] = "webkit" + b;
      c["Moz" + a] = "moz" + b;
      return c;
    }
    var We2 = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe2 = {}, Ye2 = {};
    ia && (Ye2 = document.createElement("div").style, "AnimationEvent" in window || (delete We2.animationend.animation, delete We2.animationiteration.animation, delete We2.animationstart.animation), "TransitionEvent" in window || delete We2.transitionend.transition);
    function Ze(a) {
      if (Xe2[a]) return Xe2[a];
      if (!We2[a]) return a;
      var b = We2[a], c;
      for (c in b) if (b.hasOwnProperty(c) && c in Ye2) return Xe2[a] = b[c];
      return a;
    }
    var $e2 = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b) {
      df.set(a, b);
      fa(b, [a]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e2, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b, c) {
      var d = a.type || "unknown-event";
      a.currentTarget = c;
      Ub(d, b, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b) {
      b = 0 !== (b & 4);
      for (var c = 0; c < a.length; c++) {
        var d = a[c], e = d.event;
        d = d.listeners;
        a: {
          var f = void 0;
          if (b) for (var g = d.length - 1; 0 <= g; g--) {
            var h = d[g], k = h.instance, l = h.currentTarget;
            h = h.listener;
            if (k !== f && e.isPropagationStopped()) break a;
            nf(e, h, l);
            f = k;
          }
          else for (g = 0; g < d.length; g++) {
            h = d[g];
            k = h.instance;
            l = h.currentTarget;
            h = h.listener;
            if (k !== f && e.isPropagationStopped()) break a;
            nf(e, h, l);
            f = k;
          }
        }
      }
      if (Qb) throw a = Rb, Qb = false, Rb = null, a;
    }
    function D(a, b) {
      var c = b[of];
      void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
      var d = a + "__bubble";
      c.has(d) || (pf(b, a, 2, false), c.add(d));
    }
    function qf(a, b, c) {
      var d = 0;
      b && (d |= 4);
      pf(c, a, d, b);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function(b2) {
          "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
        });
        var b = 9 === a.nodeType ? a : a.ownerDocument;
        null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
      }
    }
    function pf(a, b, c, d) {
      switch (jd(b)) {
        case 1:
          var e = ed;
          break;
        case 4:
          e = gd;
          break;
        default:
          e = fd;
      }
      c = e.bind(null, b, c, a);
      e = void 0;
      !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
      d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
    }
    function hd(a, b, c, d, e) {
      var f = d;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
        if (null === d) return;
        var g = d.tag;
        if (3 === g || 4 === g) {
          var h = d.stateNode.containerInfo;
          if (h === e || 8 === h.nodeType && h.parentNode === e) break;
          if (4 === g) for (g = d.return; null !== g; ) {
            var k = g.tag;
            if (3 === k || 4 === k) {
              if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
            }
            g = g.return;
          }
          for (; null !== h; ) {
            g = Wc(h);
            if (null === g) return;
            k = g.tag;
            if (5 === k || 6 === k) {
              d = f = g;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d = d.return;
      }
      Jb(function() {
        var d2 = f, e2 = xb(c), g2 = [];
        a: {
          var h2 = df.get(a);
          if (void 0 !== h2) {
            var k2 = td, n = a;
            switch (a) {
              case "keypress":
                if (0 === od(c)) break a;
              case "keydown":
              case "keyup":
                k2 = Rd;
                break;
              case "focusin":
                n = "focus";
                k2 = Fd;
                break;
              case "focusout":
                n = "blur";
                k2 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k2 = Fd;
                break;
              case "click":
                if (2 === c.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k2 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k2 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k2 = Vd;
                break;
              case $e2:
              case af:
              case bf:
                k2 = Hd;
                break;
              case cf:
                k2 = Xd;
                break;
              case "scroll":
                k2 = vd;
                break;
              case "wheel":
                k2 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k2 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k2 = Td;
            }
            var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
            t = [];
            for (var w = d2, u; null !== w; ) {
              u = w;
              var F = u.stateNode;
              5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
              if (J) break;
              w = w.return;
            }
            0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h2 = "mouseover" === a || "pointerover" === a;
            k2 = "mouseout" === a || "pointerout" === a;
            if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
            if (k2 || h2) {
              h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
              if (k2) {
                if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
              } else k2 = null, n = d2;
              if (k2 !== n) {
                t = Bd;
                F = "onMouseLeave";
                x = "onMouseEnter";
                w = "mouse";
                if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                J = null == k2 ? h2 : ue(k2);
                u = null == n ? h2 : ue(n);
                h2 = new t(F, w + "leave", k2, c, e2);
                h2.target = J;
                h2.relatedTarget = u;
                F = null;
                Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                J = F;
                if (k2 && n) b: {
                  t = k2;
                  x = n;
                  w = 0;
                  for (u = t; u; u = vf(u)) w++;
                  u = 0;
                  for (F = x; F; F = vf(F)) u++;
                  for (; 0 < w - u; ) t = vf(t), w--;
                  for (; 0 < u - w; ) x = vf(x), u--;
                  for (; w--; ) {
                    if (t === x || null !== x && t === x.alternate) break b;
                    t = vf(t);
                    x = vf(x);
                  }
                  t = null;
                }
                else t = null;
                null !== k2 && wf(g2, h2, k2, t, false);
                null !== n && null !== J && wf(g2, J, n, t, true);
              }
            }
          }
          a: {
            h2 = d2 ? ue(d2) : window;
            k2 = h2.nodeName && h2.nodeName.toLowerCase();
            if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
            else if (me(h2)) if (we2) na = Fe2;
            else {
              na = De2;
              var xa = Ce;
            }
            else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee2);
            if (na && (na = na(a, d2))) {
              ne(g2, na, c, e2);
              break a;
            }
            xa && xa(a, h2, d2);
            "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
          }
          xa = d2 ? ue(d2) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable) Qe2 = xa, Re = d2, Se2 = null;
              break;
            case "focusout":
              Se2 = Re = Qe2 = null;
              break;
            case "mousedown":
              Te2 = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te2 = false;
              Ue(g2, c, e2);
              break;
            case "selectionchange":
              if (Pe) break;
            case "keydown":
            case "keyup":
              Ue(g2, c, e2);
          }
          var $a2;
          if (ae) b: {
            switch (a) {
              case "compositionstart":
                var ba = "onCompositionStart";
                break b;
              case "compositionend":
                ba = "onCompositionEnd";
                break b;
              case "compositionupdate":
                ba = "onCompositionUpdate";
                break b;
            }
            ba = void 0;
          }
          else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a2 = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a2 ? ba.data = $a2 : ($a2 = he(c), null !== $a2 && (ba.data = $a2))));
          if ($a2 = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a2);
        }
        se(g2, b);
      });
    }
    function tf(a, b, c) {
      return { instance: a, listener: b, currentTarget: c };
    }
    function oe(a, b) {
      for (var c = b + "Capture", d = []; null !== a; ) {
        var e = a, f = e.stateNode;
        5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
        a = a.return;
      }
      return d;
    }
    function vf(a) {
      if (null === a) return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf(a, b, c, d, e) {
      for (var f = b._reactName, g = []; null !== c && c !== d; ) {
        var h = c, k = h.alternate, l = h.stateNode;
        if (null !== k && k === d) break;
        5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
        c = c.return;
      }
      0 !== g.length && a.push({ event: b, listeners: g });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    function Af(a, b, c) {
      b = zf(b);
      if (zf(a) !== b && c) throw Error(p(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a, b) {
      return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b) {
      var c = b, d = 0;
      do {
        var e = c.nextSibling;
        a.removeChild(c);
        if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
          if (0 === d) {
            a.removeChild(e);
            bd(b);
            return;
          }
          d--;
        } else "$" !== c && "$?" !== c && "$!" !== c || d++;
        c = e;
      } while (c);
      bd(b);
    }
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b = a.nodeType;
        if (1 === b || 3 === b) break;
        if (8 === b) {
          b = a.data;
          if ("$" === b || "$!" === b || "$?" === b) break;
          if ("/$" === b) return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("$" === c || "$!" === c || "$?" === c) {
            if (0 === b) return a;
            b--;
          } else "/$" === c && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b = a[Of];
      if (b) return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[uf] || c[Of]) {
          c = b.alternate;
          if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
            if (c = a[Of]) return c;
            a = Mf(a);
          }
          return b;
        }
        a = c;
        c = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function ue(a) {
      if (5 === a.tag || 6 === a.tag) return a.stateNode;
      throw Error(p(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a, b) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a, b) {
      var c = a.type.contextTypes;
      if (!c) return Vf;
      var d = a.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c) e[f] = b[f];
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a, b, c) {
      if (H.current !== Vf) throw Error(p(168));
      G(H, b);
      G(Wf, c);
    }
    function bg(a, b, c) {
      var d = a.stateNode;
      b = b.childContextTypes;
      if ("function" !== typeof d.getChildContext) return c;
      d = d.getChildContext();
      for (var e in d) if (!(e in b)) throw Error(p(108, Ra2(a) || "Unknown", e));
      return A({}, c, d);
    }
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a, b, c) {
      var d = a.stateNode;
      if (!d) throw Error(p(169));
      c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
      G(Wf, c);
    }
    var eg = null, fg = false, gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = true;
      hg(a);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b = C;
        try {
          var c = eg;
          for (C = 1; a < c.length; a++) {
            var d = c[a];
            do
              d = d(true);
            while (null !== d);
          }
          eg = null;
          fg = false;
        } catch (e) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
        } finally {
          C = b, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a, b) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b;
    }
    function ug(a, b, c) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d = rg;
      a = sg;
      var e = 32 - oc(d) - 1;
      d &= ~(1 << e);
      c += 1;
      var f = 32 - oc(b) + e;
      if (30 < f) {
        var g = e - e % 5;
        f = (d & (1 << g) - 1).toString(32);
        d >>= g;
        e -= g;
        rg = 1 << 32 - oc(b) + e | c << e | d;
        sg = f + a;
      } else rg = 1 << f | c << e | d, sg = a;
    }
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = false, zg = null;
    function Ag(a, b) {
      var c = Bg(5, null, null, 0);
      c.elementType = "DELETED";
      c.stateNode = b;
      c.return = a;
      b = a.deletions;
      null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
    }
    function Cg(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
        case 6:
          return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
        case 13:
          return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg(a) {
      if (I) {
        var b = yg;
        if (b) {
          var c = b;
          if (!Cg(a, b)) {
            if (Dg(a)) throw Error(p(418));
            b = Lf(c.nextSibling);
            var d = xg;
            b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
          }
        } else {
          if (Dg(a)) throw Error(p(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg) return false;
      if (!I) return Fg(a), I = true, false;
      var b;
      (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
      if (b && (b = yg)) {
        if (Dg(a)) throw Hg(), Error(p(418));
        for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a) throw Error(p(317));
        a: {
          a = a.nextSibling;
          for (b = 0; a; ) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("/$" === c) {
                if (0 === b) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b--;
              } else "$" !== c && "$!" !== c && "$?" !== c || b++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a = yg; a; ) a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b, c) {
      a = c.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (1 !== c.tag) throw Error(p(309));
            var d = c.stateNode;
          }
          if (!d) throw Error(p(147, a));
          var e = d, f = "" + a;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
          b = function(a2) {
            var b2 = e.refs;
            null === a2 ? delete b2[f] : b2[f] = a2;
          };
          b._stringRef = f;
          return b;
        }
        if ("string" !== typeof a) throw Error(p(284));
        if (!c._owner) throw Error(p(290, a));
      }
      return a;
    }
    function Mg(a, b) {
      a = Object.prototype.toString.call(b);
      throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
    }
    function Ng(a) {
      var b = a._init;
      return b(a._payload);
    }
    function Og(a) {
      function b(b2, c2) {
        if (a) {
          var d2 = b2.deletions;
          null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
        }
      }
      function c(c2, d2) {
        if (!a) return null;
        for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
        return null;
      }
      function d(a2, b2) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
        return a2;
      }
      function e(a2, b2) {
        a2 = Pg(a2, b2);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f(b2, c2, d2) {
        b2.index = d2;
        if (!a) return b2.flags |= 1048576, c2;
        d2 = b2.alternate;
        if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
        b2.flags |= 2;
        return c2;
      }
      function g(b2) {
        a && null === b2.alternate && (b2.flags |= 2);
        return b2;
      }
      function h(a2, b2, c2, d2) {
        if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function k(a2, b2, c2, d2) {
        var f2 = c2.type;
        if (f2 === ya) return m2(a2, b2, c2.props.children, d2, c2.key);
        if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
        d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
        d2.ref = Lg(a2, b2, c2);
        d2.return = a2;
        return d2;
      }
      function l(a2, b2, c2, d2) {
        if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2.children || []);
        b2.return = a2;
        return b2;
      }
      function m2(a2, b2, c2, d2, f2) {
        if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function q(a2, b2, c2) {
        if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case va:
              return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
            case wa:
              return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
            case Ha:
              var d2 = b2._init;
              return q(a2, d2(b2._payload), c2);
          }
          if (eb(b2) || Ka2(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
          Mg(a2, b2);
        }
        return null;
      }
      function r2(a2, b2, c2, d2) {
        var e2 = null !== b2 ? b2.key : null;
        if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
        if ("object" === typeof c2 && null !== c2) {
          switch (c2.$$typeof) {
            case va:
              return c2.key === e2 ? k(a2, b2, c2, d2) : null;
            case wa:
              return c2.key === e2 ? l(a2, b2, c2, d2) : null;
            case Ha:
              return e2 = c2._init, r2(
                a2,
                b2,
                e2(c2._payload),
                d2
              );
          }
          if (eb(c2) || Ka2(c2)) return null !== e2 ? null : m2(a2, b2, c2, d2, null);
          Mg(a2, c2);
        }
        return null;
      }
      function y(a2, b2, c2, d2, e2) {
        if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case va:
              return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
            case wa:
              return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
            case Ha:
              var f2 = d2._init;
              return y(a2, b2, c2, f2(d2._payload), e2);
          }
          if (eb(d2) || Ka2(d2)) return a2 = a2.get(c2) || null, m2(b2, a2, d2, e2, null);
          Mg(b2, d2);
        }
        return null;
      }
      function n(e2, g2, h2, k2) {
        for (var l2 = null, m3 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
          u.index > w ? (x = u, u = null) : x = u.sibling;
          var n2 = r2(e2, u, h2[w], k2);
          if (null === n2) {
            null === u && (u = x);
            break;
          }
          a && u && null === n2.alternate && b(e2, u);
          g2 = f(n2, g2, w);
          null === m3 ? l2 = n2 : m3.sibling = n2;
          m3 = n2;
          u = x;
        }
        if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
        if (null === u) {
          for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m3 ? l2 = u : m3.sibling = u, m3 = u);
          I && tg(e2, w);
          return l2;
        }
        for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m3 ? l2 = x : m3.sibling = x, m3 = x);
        a && u.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w);
        return l2;
      }
      function t(e2, g2, h2, k2) {
        var l2 = Ka2(h2);
        if ("function" !== typeof l2) throw Error(p(150));
        h2 = l2.call(h2);
        if (null == h2) throw Error(p(151));
        for (var u = l2 = null, m3 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m3 && !n2.done; w++, n2 = h2.next()) {
          m3.index > w ? (x = m3, m3 = null) : x = m3.sibling;
          var t2 = r2(e2, m3, n2.value, k2);
          if (null === t2) {
            null === m3 && (m3 = x);
            break;
          }
          a && m3 && null === t2.alternate && b(e2, m3);
          g2 = f(t2, g2, w);
          null === u ? l2 = t2 : u.sibling = t2;
          u = t2;
          m3 = x;
        }
        if (n2.done) return c(
          e2,
          m3
        ), I && tg(e2, w), l2;
        if (null === m3) {
          for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          I && tg(e2, w);
          return l2;
        }
        for (m3 = d(e2, m3); !n2.done; w++, n2 = h2.next()) n2 = y(m3, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m3.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        a && m3.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w);
        return l2;
      }
      function J(a2, d2, f2, h2) {
        "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
        if ("object" === typeof f2 && null !== f2) {
          switch (f2.$$typeof) {
            case va:
              a: {
                for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                  if (l2.key === k2) {
                    k2 = f2.type;
                    if (k2 === ya) {
                      if (7 === l2.tag) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props.children);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                    } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                      c(a2, l2.sibling);
                      d2 = e(l2, f2.props);
                      d2.ref = Lg(a2, l2, f2);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    c(a2, l2);
                    break;
                  } else b(a2, l2);
                  l2 = l2.sibling;
                }
                f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
              }
              return g(a2);
            case wa:
              a: {
                for (l2 = f2.key; null !== d2; ) {
                  if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                    c(a2, d2.sibling);
                    d2 = e(d2, f2.children || []);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  } else {
                    c(a2, d2);
                    break;
                  }
                  else b(a2, d2);
                  d2 = d2.sibling;
                }
                d2 = Sg(f2, a2.mode, h2);
                d2.return = a2;
                a2 = d2;
              }
              return g(a2);
            case Ha:
              return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
          }
          if (eb(f2)) return n(a2, d2, f2, h2);
          if (Ka2(f2)) return t(a2, d2, f2, h2);
          Mg(a2, f2);
        }
        return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
      }
      return J;
    }
    var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
    function $g() {
      Zg = Yg = Xg = null;
    }
    function ah(a) {
      var b = Wg.current;
      E(Wg);
      a._currentValue = b;
    }
    function bh(a, b, c) {
      for (; null !== a; ) {
        var d = a.alternate;
        (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
        if (a === c) break;
        a = a.return;
      }
    }
    function ch(a, b) {
      Xg = a;
      Zg = Yg = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
    }
    function eh(a) {
      var b = a._currentValue;
      if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
        if (null === Xg) throw Error(p(308));
        Yg = a;
        Xg.dependencies = { lanes: 0, firstContext: a };
      } else Yg = Yg.next = a;
      return b;
    }
    var fh = null;
    function gh(a) {
      null === fh ? fh = [a] : fh.push(a);
    }
    function hh(a, b, c, d) {
      var e = b.interleaved;
      null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
      b.interleaved = c;
      return ih(a, d);
    }
    function ih(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      null !== c && (c.lanes |= b);
      c = a;
      for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
      return 3 === c.tag ? c.stateNode : null;
    }
    var jh = false;
    function kh(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function lh(a, b) {
      a = a.updateQueue;
      b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function mh(a, b) {
      return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    function nh(a, b, c) {
      var d = a.updateQueue;
      if (null === d) return null;
      d = d.shared;
      if (0 !== (K & 2)) {
        var e = d.pending;
        null === e ? b.next = b : (b.next = e.next, e.next = b);
        d.pending = b;
        return ih(a, c);
      }
      e = d.interleaved;
      null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
      d.interleaved = b;
      return ih(a, c);
    }
    function oh(a, b, c) {
      b = b.updateQueue;
      if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc(a, c);
      }
    }
    function ph(a, b) {
      var c = a.updateQueue, d = a.alternate;
      if (null !== d && (d = d.updateQueue, c === d)) {
        var e = null, f = null;
        c = c.firstBaseUpdate;
        if (null !== c) {
          do {
            var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
            null === f ? e = f = g : f = f.next = g;
            c = c.next;
          } while (null !== c);
          null === f ? e = f = b : f = f.next = b;
        } else e = f = b;
        c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
        a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate;
      null === a ? c.firstBaseUpdate = b : a.next = b;
      c.lastBaseUpdate = b;
    }
    function qh(a, b, c, d) {
      var e = a.updateQueue;
      jh = false;
      var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
      if (null !== h) {
        e.shared.pending = null;
        var k = h, l = k.next;
        k.next = null;
        null === g ? f = l : g.next = l;
        g = k;
        var m2 = a.alternate;
        null !== m2 && (m2 = m2.updateQueue, h = m2.lastBaseUpdate, h !== g && (null === h ? m2.firstBaseUpdate = l : h.next = l, m2.lastBaseUpdate = k));
      }
      if (null !== f) {
        var q = e.baseState;
        g = 0;
        m2 = l = k = null;
        h = f;
        do {
          var r2 = h.lane, y = h.eventTime;
          if ((d & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null
            });
            a: {
              var n = a, t = h;
              r2 = b;
              y = c;
              switch (t.tag) {
                case 1:
                  n = t.payload;
                  if ("function" === typeof n) {
                    q = n.call(y, q, r2);
                    break a;
                  }
                  q = n;
                  break a;
                case 3:
                  n.flags = n.flags & -65537 | 128;
                case 0:
                  n = t.payload;
                  r2 = "function" === typeof n ? n.call(y, q, r2) : n;
                  if (null === r2 || void 0 === r2) break a;
                  q = A({}, q, r2);
                  break a;
                case 2:
                  jh = true;
              }
            }
            null !== h.callback && 0 !== h.lane && (a.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h] : r2.push(h));
          } else y = { eventTime: y, lane: r2, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m2 ? (l = m2 = y, k = q) : m2 = m2.next = y, g |= r2;
          h = h.next;
          if (null === h) if (h = e.shared.pending, null === h) break;
          else r2 = h, h = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
        } while (1);
        null === m2 && (k = q);
        e.baseState = k;
        e.firstBaseUpdate = l;
        e.lastBaseUpdate = m2;
        b = e.shared.interleaved;
        if (null !== b) {
          e = b;
          do
            g |= e.lane, e = e.next;
          while (e !== b);
        } else null === f && (e.shared.lanes = 0);
        rh |= g;
        a.lanes = g;
        a.memoizedState = q;
      }
    }
    function sh(a, b, c) {
      a = b.effects;
      b.effects = null;
      if (null !== a) for (b = 0; b < a.length; b++) {
        var d = a[b], e = d.callback;
        if (null !== e) {
          d.callback = null;
          d = c;
          if ("function" !== typeof e) throw Error(p(191, e));
          e.call(d);
        }
      }
    }
    var th = {}, uh = Uf(th), vh2 = Uf(th), wh = Uf(th);
    function xh(a) {
      if (a === th) throw Error(p(174));
      return a;
    }
    function yh(a, b) {
      G(wh, b);
      G(vh2, a);
      G(uh, th);
      a = b.nodeType;
      switch (a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
      }
      E(uh);
      G(uh, b);
    }
    function zh() {
      E(uh);
      E(vh2);
      E(wh);
    }
    function Ah(a) {
      xh(wh.current);
      var b = xh(uh.current);
      var c = lb(b, a.type);
      b !== c && (G(vh2, a), G(uh, c));
    }
    function Bh(a) {
      vh2.current === a && (E(uh), E(vh2));
    }
    var L2 = Uf(0);
    function Ch(a) {
      for (var b = a; null !== b; ) {
        if (13 === b.tag) {
          var c = b.memoizedState;
          if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 128)) return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var Dh = [];
    function Eh() {
      for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
      Dh.length = 0;
    }
    var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
    function P() {
      throw Error(p(321));
    }
    function Mh(a, b) {
      if (null === b) return false;
      for (var c = 0; c < b.length && c < a.length; c++) if (!He2(a[c], b[c])) return false;
      return true;
    }
    function Nh(a, b, c, d, e, f) {
      Hh = f;
      M = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
      a = c(d, e);
      if (Jh) {
        f = 0;
        do {
          Jh = false;
          Kh = 0;
          if (25 <= f) throw Error(p(301));
          f += 1;
          O = N = null;
          b.updateQueue = null;
          Fh.current = Qh;
          a = c(d, e);
        } while (Jh);
      }
      Fh.current = Rh;
      b = null !== N && null !== N.next;
      Hh = 0;
      O = N = M = null;
      Ih = false;
      if (b) throw Error(p(300));
      return a;
    }
    function Sh() {
      var a = 0 !== Kh;
      Kh = 0;
      return a;
    }
    function Th() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
      return O;
    }
    function Uh() {
      if (null === N) {
        var a = M.alternate;
        a = null !== a ? a.memoizedState : null;
      } else a = N.next;
      var b = null === O ? M.memoizedState : O.next;
      if (null !== b) O = b, N = a;
      else {
        if (null === a) throw Error(p(310));
        N = a;
        a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
        null === O ? M.memoizedState = O = a : O = O.next = a;
      }
      return O;
    }
    function Vh(a, b) {
      return "function" === typeof b ? b(a) : b;
    }
    function Wh(a) {
      var b = Uh(), c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = N, e = d.baseQueue, f = c.pending;
      if (null !== f) {
        if (null !== e) {
          var g = e.next;
          e.next = f.next;
          f.next = g;
        }
        d.baseQueue = e = f;
        c.pending = null;
      }
      if (null !== e) {
        f = e.next;
        d = d.baseState;
        var h = g = null, k = null, l = f;
        do {
          var m2 = l.lane;
          if ((Hh & m2) === m2) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
          else {
            var q = {
              lane: m2,
              action: l.action,
              hasEagerState: l.hasEagerState,
              eagerState: l.eagerState,
              next: null
            };
            null === k ? (h = k = q, g = d) : k = k.next = q;
            M.lanes |= m2;
            rh |= m2;
          }
          l = l.next;
        } while (null !== l && l !== f);
        null === k ? g = d : k.next = h;
        He2(d, b.memoizedState) || (dh = true);
        b.memoizedState = d;
        b.baseState = g;
        b.baseQueue = k;
        c.lastRenderedState = d;
      }
      a = c.interleaved;
      if (null !== a) {
        e = a;
        do
          f = e.lane, M.lanes |= f, rh |= f, e = e.next;
        while (e !== a);
      } else null === e && (c.lanes = 0);
      return [b.memoizedState, c.dispatch];
    }
    function Xh(a) {
      var b = Uh(), c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = c.dispatch, e = c.pending, f = b.memoizedState;
      if (null !== e) {
        c.pending = null;
        var g = e = e.next;
        do
          f = a(f, g.action), g = g.next;
        while (g !== e);
        He2(f, b.memoizedState) || (dh = true);
        b.memoizedState = f;
        null === b.baseQueue && (b.baseState = f);
        c.lastRenderedState = f;
      }
      return [f, d];
    }
    function Yh() {
    }
    function Zh(a, b) {
      var c = M, d = Uh(), e = b(), f = !He2(d.memoizedState, e);
      f && (d.memoizedState = e, dh = true);
      d = d.queue;
      $h(ai.bind(null, c, d, a), [a]);
      if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
        c.flags |= 2048;
        bi(9, ci.bind(null, c, d, e, b), void 0, null);
        if (null === Q2) throw Error(p(349));
        0 !== (Hh & 30) || di(c, b, e);
      }
      return e;
    }
    function di(a, b, c) {
      a.flags |= 16384;
      a = { getSnapshot: b, value: c };
      b = M.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
    }
    function ci(a, b, c, d) {
      b.value = c;
      b.getSnapshot = d;
      ei(b) && fi(a);
    }
    function ai(a, b, c) {
      return c(function() {
        ei(b) && fi(a);
      });
    }
    function ei(a) {
      var b = a.getSnapshot;
      a = a.value;
      try {
        var c = b();
        return !He2(a, c);
      } catch (d) {
        return true;
      }
    }
    function fi(a) {
      var b = ih(a, 1);
      null !== b && gi(b, a, 1, -1);
    }
    function hi(a) {
      var b = Th();
      "function" === typeof a && (a = a());
      b.memoizedState = b.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
      b.queue = a;
      a = a.dispatch = ii.bind(null, M, a);
      return [b.memoizedState, a];
    }
    function bi(a, b, c, d) {
      a = { tag: a, create: b, destroy: c, deps: d, next: null };
      b = M.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
      return a;
    }
    function ji() {
      return Uh().memoizedState;
    }
    function ki(a, b, c, d) {
      var e = Th();
      M.flags |= a;
      e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
    }
    function li(a, b, c, d) {
      var e = Uh();
      d = void 0 === d ? null : d;
      var f = void 0;
      if (null !== N) {
        var g = N.memoizedState;
        f = g.destroy;
        if (null !== d && Mh(d, g.deps)) {
          e.memoizedState = bi(b, c, f, d);
          return;
        }
      }
      M.flags |= a;
      e.memoizedState = bi(1 | b, c, f, d);
    }
    function mi(a, b) {
      return ki(8390656, 8, a, b);
    }
    function $h(a, b) {
      return li(2048, 8, a, b);
    }
    function ni(a, b) {
      return li(4, 2, a, b);
    }
    function oi(a, b) {
      return li(4, 4, a, b);
    }
    function pi(a, b) {
      if ("function" === typeof b) return a = a(), b(a), function() {
        b(null);
      };
      if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
        b.current = null;
      };
    }
    function qi(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return li(4, 4, pi.bind(null, b, a), c);
    }
    function ri() {
    }
    function si(a, b) {
      var c = Uh();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Mh(b, d[1])) return d[0];
      c.memoizedState = [a, b];
      return a;
    }
    function ti(a, b) {
      var c = Uh();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Mh(b, d[1])) return d[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    }
    function ui(a, b, c) {
      if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
      He2(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
      return b;
    }
    function vi(a, b) {
      var c = C;
      C = 0 !== c && 4 > c ? c : 4;
      a(true);
      var d = Gh.transition;
      Gh.transition = {};
      try {
        a(false), b();
      } finally {
        C = c, Gh.transition = d;
      }
    }
    function wi() {
      return Uh().memoizedState;
    }
    function xi(a, b, c) {
      var d = yi(a);
      c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
      if (zi(a)) Ai(b, c);
      else if (c = hh(a, b, c, d), null !== c) {
        var e = R();
        gi(c, a, d, e);
        Bi(c, b, d);
      }
    }
    function ii(a, b, c) {
      var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
      if (zi(a)) Ai(b, e);
      else {
        var f = a.alternate;
        if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
          var g = b.lastRenderedState, h = f(g, c);
          e.hasEagerState = true;
          e.eagerState = h;
          if (He2(h, g)) {
            var k = b.interleaved;
            null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
            b.interleaved = e;
            return;
          }
        } catch (l) {
        } finally {
        }
        c = hh(a, b, e, d);
        null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
      }
    }
    function zi(a) {
      var b = a.alternate;
      return a === M || null !== b && b === M;
    }
    function Ai(a, b) {
      Jh = Ih = true;
      var c = a.pending;
      null === c ? b.next = b : (b.next = c.next, c.next = b);
      a.pending = b;
    }
    function Bi(a, b, c) {
      if (0 !== (c & 4194240)) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc(a, c);
      }
    }
    var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
      Th().memoizedState = [a, void 0 === b ? null : b];
      return a;
    }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ki(
        4194308,
        4,
        pi.bind(null, b, a),
        c
      );
    }, useLayoutEffect: function(a, b) {
      return ki(4194308, 4, a, b);
    }, useInsertionEffect: function(a, b) {
      return ki(4, 2, a, b);
    }, useMemo: function(a, b) {
      var c = Th();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    }, useReducer: function(a, b, c) {
      var d = Th();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
      d.queue = a;
      a = a.dispatch = xi.bind(null, M, a);
      return [d.memoizedState, a];
    }, useRef: function(a) {
      var b = Th();
      a = { current: a };
      return b.memoizedState = a;
    }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
      return Th().memoizedState = a;
    }, useTransition: function() {
      var a = hi(false), b = a[0];
      a = vi.bind(null, a[1]);
      Th().memoizedState = a;
      return [b, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b, c) {
      var d = M, e = Th();
      if (I) {
        if (void 0 === c) throw Error(p(407));
        c = c();
      } else {
        c = b();
        if (null === Q2) throw Error(p(349));
        0 !== (Hh & 30) || di(d, b, c);
      }
      e.memoizedState = c;
      var f = { value: c, getSnapshot: b };
      e.queue = f;
      mi(ai.bind(
        null,
        d,
        f,
        a
      ), [a]);
      d.flags |= 2048;
      bi(9, ci.bind(null, d, f, c, b), void 0, null);
      return c;
    }, useId: function() {
      var a = Th(), b = Q2.identifierPrefix;
      if (I) {
        var c = sg;
        var d = rg;
        c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
        b = ":" + b + "R" + c;
        c = Kh++;
        0 < c && (b += "H" + c.toString(32));
        b += ":";
      } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    }, unstable_isNewReconciler: false }, Ph = {
      readContext: eh,
      useCallback: si,
      useContext: eh,
      useEffect: $h,
      useImperativeHandle: qi,
      useInsertionEffect: ni,
      useLayoutEffect: oi,
      useMemo: ti,
      useReducer: Wh,
      useRef: ji,
      useState: function() {
        return Wh(Vh);
      },
      useDebugValue: ri,
      useDeferredValue: function(a) {
        var b = Uh();
        return ui(b, N.memoizedState, a);
      },
      useTransition: function() {
        var a = Wh(Vh)[0], b = Uh().memoizedState;
        return [a, b];
      },
      useMutableSource: Yh,
      useSyncExternalStore: Zh,
      useId: wi,
      unstable_isNewReconciler: false
    }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
      return Xh(Vh);
    }, useDebugValue: ri, useDeferredValue: function(a) {
      var b = Uh();
      return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
    }, useTransition: function() {
      var a = Xh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
    function Ci(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b);
        a = a.defaultProps;
        for (var c in a) void 0 === b[c] && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Di(a, b, c, d) {
      b = a.memoizedState;
      c = c(d, b);
      c = null === c || void 0 === c ? b : A({}, b, c);
      a.memoizedState = c;
      0 === a.lanes && (a.updateQueue.baseState = c);
    }
    var Ei = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, enqueueSetState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi(a), f = mh(d, e);
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = nh(a, f, e);
      null !== b && (gi(b, a, e, d), oh(b, a, e));
    }, enqueueReplaceState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi(a), f = mh(d, e);
      f.tag = 1;
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = nh(a, f, e);
      null !== b && (gi(b, a, e, d), oh(b, a, e));
    }, enqueueForceUpdate: function(a, b) {
      a = a._reactInternals;
      var c = R(), d = yi(a), e = mh(c, d);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      b = nh(a, e, d);
      null !== b && (gi(b, a, d, c), oh(b, a, d));
    } };
    function Fi(a, b, c, d, e, f, g) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
    }
    function Gi(a, b, c) {
      var d = false, e = Vf;
      var f = b.contextType;
      "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
      b = new b(c, f);
      a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = Ei;
      a.stateNode = b;
      b._reactInternals = a;
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
      return b;
    }
    function Hi(a, b, c, d) {
      a = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
      b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
    }
    function Ii(a, b, c, d) {
      var e = a.stateNode;
      e.props = c;
      e.state = a.memoizedState;
      e.refs = {};
      kh(a);
      var f = b.contextType;
      "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
      e.state = a.memoizedState;
      f = b.getDerivedStateFromProps;
      "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
      "function" === typeof e.componentDidMount && (a.flags |= 4194308);
    }
    function Ji(a, b) {
      try {
        var c = "", d = b;
        do
          c += Pa(d), d = d.return;
        while (d);
        var e = c;
      } catch (f) {
        e = "\nError generating stack: " + f.message + "\n" + f.stack;
      }
      return { value: a, source: b, stack: e, digest: null };
    }
    function Ki(a, b, c) {
      return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
    }
    function Li(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    var Mi = "function" === typeof WeakMap ? WeakMap : Map;
    function Ni2(a, b, c) {
      c = mh(-1, c);
      c.tag = 3;
      c.payload = { element: null };
      var d = b.value;
      c.callback = function() {
        Oi || (Oi = true, Pi = d);
        Li(a, b);
      };
      return c;
    }
    function Qi(a, b, c) {
      c = mh(-1, c);
      c.tag = 3;
      var d = a.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c.payload = function() {
          return d(e);
        };
        c.callback = function() {
          Li(a, b);
        };
      }
      var f = a.stateNode;
      null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
        Li(a, b);
        "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
        var c2 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
      });
      return c;
    }
    function Si(a, b, c) {
      var d = a.pingCache;
      if (null === d) {
        d = a.pingCache = new Mi();
        var e = /* @__PURE__ */ new Set();
        d.set(b, e);
      } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
      e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
    }
    function Ui(a) {
      do {
        var b;
        if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
        if (b) return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Vi(a, b, c, d, e) {
      if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e;
      return a;
    }
    var Wi = ua.ReactCurrentOwner, dh = false;
    function Xi(a, b, c, d) {
      b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
    }
    function Yi(a, b, c, d, e) {
      c = c.render;
      var f = b.ref;
      ch(b, e);
      d = Nh(a, b, c, d, f, e);
      c = Sh();
      if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
      I && c && vg(b);
      b.flags |= 1;
      Xi(a, b, d, e);
      return b.child;
    }
    function $i(a, b, c, d, e) {
      if (null === a) {
        var f = c.type;
        if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
        a = Rg(c.type, null, d, b, b.mode, e);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      f = a.child;
      if (0 === (a.lanes & e)) {
        var g = f.memoizedProps;
        c = c.compare;
        c = null !== c ? c : Ie;
        if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
      }
      b.flags |= 1;
      a = Pg(f, d);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    function bj(a, b, c, d, e) {
      if (null !== a) {
        var f = a.memoizedProps;
        if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
        else return b.lanes = a.lanes, Zi(a, b, e);
      }
      return cj(a, b, c, d, e);
    }
    function dj(a, b, c) {
      var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
      if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
      else {
        if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
        b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
        d = null !== f ? f.baseLanes : c;
        G(ej, fj);
        fj |= d;
      }
      else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
      Xi(a, b, e, c);
      return b.child;
    }
    function gj(a, b) {
      var c = b.ref;
      if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
    }
    function cj(a, b, c, d, e) {
      var f = Zf(c) ? Xf : H.current;
      f = Yf(b, f);
      ch(b, e);
      c = Nh(a, b, c, d, f, e);
      d = Sh();
      if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
      I && d && vg(b);
      b.flags |= 1;
      Xi(a, b, c, e);
      return b.child;
    }
    function hj(a, b, c, d, e) {
      if (Zf(c)) {
        var f = true;
        cg(b);
      } else f = false;
      ch(b, e);
      if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
      else if (null === a) {
        var g = b.stateNode, h = b.memoizedProps;
        g.props = h;
        var k = g.context, l = c.contextType;
        "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
        var m2 = c.getDerivedStateFromProps, q = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
        q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
        jh = false;
        var r2 = b.memoizedState;
        g.state = r2;
        qh(b, d, g, e);
        k = b.memoizedState;
        h !== d || r2 !== k || Wf.current || jh ? ("function" === typeof m2 && (Di(b, c, m2, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r2, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
      } else {
        g = b.stateNode;
        lh(a, b);
        h = b.memoizedProps;
        l = b.type === b.elementType ? h : Ci(b.type, h);
        g.props = l;
        q = b.pendingProps;
        r2 = g.context;
        k = c.contextType;
        "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
        var y = c.getDerivedStateFromProps;
        (m2 = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r2 !== k) && Hi(b, g, d, k);
        jh = false;
        r2 = b.memoizedState;
        g.state = r2;
        qh(b, d, g, e);
        var n = b.memoizedState;
        h !== q || r2 !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r2, n, k) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d = false);
      }
      return jj(a, b, c, d, f, e);
    }
    function jj(a, b, c, d, e, f) {
      gj(a, b);
      var g = 0 !== (b.flags & 128);
      if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
      d = b.stateNode;
      Wi.current = b;
      var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
      b.flags |= 1;
      null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
      b.memoizedState = d.state;
      e && dg(b, c, true);
      return b.child;
    }
    function kj(a) {
      var b = a.stateNode;
      b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
      yh(a, b.containerInfo);
    }
    function lj(a, b, c, d, e) {
      Ig();
      Jg(e);
      b.flags |= 256;
      Xi(a, b, c, d);
      return b.child;
    }
    var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function nj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function oj(a, b, c) {
      var d = b.pendingProps, e = L2.current, f = false, g = 0 !== (b.flags & 128), h;
      (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
      if (h) f = true, b.flags &= -129;
      else if (null === a || null !== a.memoizedState) e |= 1;
      G(L2, e & 1);
      if (null === a) {
        Eg(b);
        a = b.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
        g = d.children;
        a = d.fallback;
        return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
      }
      e = a.memoizedState;
      if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
      if (f) {
        f = d.fallback;
        g = b.mode;
        e = a.child;
        h = e.sibling;
        var k = { mode: "hidden", children: d.children };
        0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
        null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
        f.return = b;
        d.return = b;
        d.sibling = f;
        b.child = d;
        d = f;
        f = b.child;
        g = a.child.memoizedState;
        g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
        f.memoizedState = g;
        f.childLanes = a.childLanes & ~c;
        b.memoizedState = mj;
        return d;
      }
      f = a.child;
      a = f.sibling;
      d = Pg(f, { mode: "visible", children: d.children });
      0 === (b.mode & 1) && (d.lanes = c);
      d.return = b;
      d.sibling = null;
      null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
      b.child = d;
      b.memoizedState = null;
      return d;
    }
    function qj(a, b) {
      b = pj({ mode: "visible", children: b }, a.mode, 0, null);
      b.return = a;
      return a.child = b;
    }
    function sj(a, b, c, d) {
      null !== d && Jg(d);
      Ug(b, a.child, null, c);
      a = qj(b, b.pendingProps.children);
      a.flags |= 2;
      b.memoizedState = null;
      return a;
    }
    function rj(a, b, c, d, e, f, g) {
      if (c) {
        if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
        if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
        f = d.fallback;
        e = b.mode;
        d = pj({ mode: "visible", children: d.children }, e, 0, null);
        f = Tg(f, e, g, null);
        f.flags |= 2;
        d.return = b;
        f.return = b;
        d.sibling = f;
        b.child = d;
        0 !== (b.mode & 1) && Ug(b, a.child, null, g);
        b.child.memoizedState = nj(g);
        b.memoizedState = mj;
        return f;
      }
      if (0 === (b.mode & 1)) return sj(a, b, g, null);
      if ("$!" === e.data) {
        d = e.nextSibling && e.nextSibling.dataset;
        if (d) var h = d.dgst;
        d = h;
        f = Error(p(419));
        d = Ki(f, d, void 0);
        return sj(a, b, g, d);
      }
      h = 0 !== (g & a.childLanes);
      if (dh || h) {
        d = Q2;
        if (null !== d) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
          0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
        }
        tj();
        d = Ki(Error(p(421)));
        return sj(a, b, g, d);
      }
      if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
      a = f.treeContext;
      yg = Lf(e.nextSibling);
      xg = b;
      I = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
      b = qj(b, d.children);
      b.flags |= 4096;
      return b;
    }
    function vj(a, b, c) {
      a.lanes |= b;
      var d = a.alternate;
      null !== d && (d.lanes |= b);
      bh(a.return, b, c);
    }
    function wj(a, b, c, d, e) {
      var f = a.memoizedState;
      null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
    }
    function xj(a, b, c) {
      var d = b.pendingProps, e = d.revealOrder, f = d.tail;
      Xi(a, b, d.children, c);
      d = L2.current;
      if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
          if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
          else if (19 === a.tag) vj(a, c, b);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b) break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b) break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
        d &= 1;
      }
      G(L2, d);
      if (0 === (b.mode & 1)) b.memoizedState = null;
      else switch (e) {
        case "forwards":
          c = b.child;
          for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
          c = e;
          null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
          wj(b, false, e, c, f);
          break;
        case "backwards":
          c = null;
          e = b.child;
          for (b.child = null; null !== e; ) {
            a = e.alternate;
            if (null !== a && null === Ch(a)) {
              b.child = e;
              break;
            }
            a = e.sibling;
            e.sibling = c;
            c = e;
            e = a;
          }
          wj(b, true, c, null, f);
          break;
        case "together":
          wj(b, false, null, null, void 0);
          break;
        default:
          b.memoizedState = null;
      }
      return b.child;
    }
    function ij(a, b) {
      0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
    }
    function Zi(a, b, c) {
      null !== a && (b.dependencies = a.dependencies);
      rh |= b.lanes;
      if (0 === (c & b.childLanes)) return null;
      if (null !== a && b.child !== a.child) throw Error(p(153));
      if (null !== b.child) {
        a = b.child;
        c = Pg(a, a.pendingProps);
        b.child = c;
        for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
        c.sibling = null;
      }
      return b.child;
    }
    function yj(a, b, c) {
      switch (b.tag) {
        case 3:
          kj(b);
          Ig();
          break;
        case 5:
          Ah(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          yh(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d = b.type._context, e = b.memoizedProps.value;
          G(Wg, d._currentValue);
          d._currentValue = e;
          break;
        case 13:
          d = b.memoizedState;
          if (null !== d) {
            if (null !== d.dehydrated) return G(L2, L2.current & 1), b.flags |= 128, null;
            if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
            G(L2, L2.current & 1);
            a = Zi(a, b, c);
            return null !== a ? a.sibling : null;
          }
          G(L2, L2.current & 1);
          break;
        case 19:
          d = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d) return xj(a, b, c);
            b.flags |= 128;
          }
          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          G(L2, L2.current);
          if (d) break;
          else return null;
        case 22:
        case 23:
          return b.lanes = 0, dj(a, b, c);
      }
      return Zi(a, b, c);
    }
    var zj, Aj, Bj, Cj;
    zj = function(a, b) {
      for (var c = b.child; null !== c; ) {
        if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
        else if (4 !== c.tag && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b) break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b) return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    };
    Aj = function() {
    };
    Bj = function(a, b, c, d) {
      var e = a.memoizedProps;
      if (e !== d) {
        a = b.stateNode;
        xh(uh.current);
        var f = null;
        switch (c) {
          case "input":
            e = Ya(a, e);
            d = Ya(a, d);
            f = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 });
            d = A({}, d, { value: void 0 });
            f = [];
            break;
          case "textarea":
            e = gb(a, e);
            d = gb(a, d);
            f = [];
            break;
          default:
            "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
        }
        ub(c, d);
        var g;
        c = null;
        for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
          var h = e[l];
          for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
        for (l in d) {
          var k = d[l];
          h = null != e ? e[l] : void 0;
          if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
            for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          } else c || (f || (f = []), f.push(
            l,
            c
          )), c = k;
          else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
        }
        c && (f = f || []).push("style", c);
        var l = f;
        if (b.updateQueue = l) b.flags |= 4;
      }
    };
    Cj = function(a, b, c, d) {
      c !== d && (b.flags |= 4);
    };
    function Dj(a, b) {
      if (!I) switch (a.tailMode) {
        case "hidden":
          b = a.tail;
          for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
          null === c ? a.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = a.tail;
          for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
          null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
      }
    }
    function S(a) {
      var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
      if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
      else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
      a.subtreeFlags |= d;
      a.childLanes = c;
      return b;
    }
    function Ej(a, b, c) {
      var d = b.pendingProps;
      wg(b);
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          d = b.stateNode;
          zh();
          E(Wf);
          E(H);
          Eh();
          d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
          if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
          Aj(a, b);
          S(b);
          return null;
        case 5:
          Bh(b);
          var e = xh(wh.current);
          c = b.type;
          if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d) {
              if (null === b.stateNode) throw Error(p(166));
              S(b);
              return null;
            }
            a = xh(uh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c = b.type;
              var f = b.memoizedProps;
              d[Of] = b;
              d[Pf] = f;
              a = 0 !== (b.mode & 1);
              switch (c) {
                case "dialog":
                  D("cancel", d);
                  D("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], d);
                  break;
                case "source":
                  D("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d
                  );
                  D("load", d);
                  break;
                case "details":
                  D("toggle", d);
                  break;
                case "input":
                  Za(d, f);
                  D("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f.multiple };
                  D("invalid", d);
                  break;
                case "textarea":
                  hb(d, f), D("invalid", d);
              }
              ub(c, f);
              e = null;
              for (var g in f) if (f.hasOwnProperty(g)) {
                var h = f[g];
                "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                  d.textContent,
                  h,
                  a
                ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
              }
              switch (c) {
                case "input":
                  Va(d);
                  db(d, f, true);
                  break;
                case "textarea":
                  Va(d);
                  jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f.onClick && (d.onclick = Bf);
              }
              d = e;
              b.updateQueue = d;
              null !== d && (b.flags |= 4);
            } else {
              g = 9 === e.nodeType ? e : e.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
              a[Of] = b;
              a[Pf] = d;
              zj(a, b, false, false);
              b.stateNode = a;
              a: {
                g = vb(c, d);
                switch (c) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], a);
                    e = d;
                    break;
                  case "source":
                    D("error", a);
                    e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e = d;
                    break;
                  case "details":
                    D("toggle", a);
                    e = d;
                    break;
                  case "input":
                    Za(a, d);
                    e = Ya(a, d);
                    D("invalid", a);
                    break;
                  case "option":
                    e = d;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d.multiple };
                    e = A({}, d, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d);
                    e = gb(a, d);
                    D("invalid", a);
                    break;
                  default:
                    e = d;
                }
                ub(c, e);
                h = e;
                for (f in h) if (h.hasOwnProperty(f)) {
                  var k = h[f];
                  "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                }
                switch (c) {
                  case "input":
                    Va(a);
                    db(a, d, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d.value && a.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a.multiple = !!d.multiple;
                    f = d.value;
                    null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                      a,
                      !!d.multiple,
                      d.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e.onClick && (a.onclick = Bf);
                }
                switch (c) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d = !!d.autoFocus;
                    break a;
                  case "img":
                    d = true;
                    break a;
                  default:
                    d = false;
                }
              }
              d && (b.flags |= 4);
            }
            null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          }
          S(b);
          return null;
        case 6:
          if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
          else {
            if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
            c = xh(wh.current);
            xh(uh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c = b.memoizedProps;
              d[Of] = b;
              if (f = d.nodeValue !== c) {
                if (a = xg, null !== a) switch (a.tag) {
                  case 3:
                    Af(d.nodeValue, c, 0 !== (a.mode & 1));
                    break;
                  case 5:
                    true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                }
              }
              f && (b.flags |= 4);
            } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
          }
          S(b);
          return null;
        case 13:
          E(L2);
          d = b.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
            else if (f = Gg(b), null !== d && null !== d.dehydrated) {
              if (null === a) {
                if (!f) throw Error(p(318));
                f = b.memoizedState;
                f = null !== f ? f.dehydrated : null;
                if (!f) throw Error(p(317));
                f[Of] = b;
              } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b);
              f = false;
            } else null !== zg && (Fj(zg), zg = null), f = true;
            if (!f) return b.flags & 65536 ? b : null;
          }
          if (0 !== (b.flags & 128)) return b.lanes = c, b;
          d = null !== d;
          d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L2.current & 1) ? 0 === T && (T = 3) : tj()));
          null !== b.updateQueue && (b.flags |= 4);
          S(b);
          return null;
        case 4:
          return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
        case 10:
          return ah(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          E(L2);
          f = b.memoizedState;
          if (null === f) return S(b), null;
          d = 0 !== (b.flags & 128);
          g = f.rendering;
          if (null === g) if (d) Dj(f, false);
          else {
            if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
              g = Ch(a);
              if (null !== g) {
                b.flags |= 128;
                Dj(f, false);
                d = g.updateQueue;
                null !== d && (b.updateQueue = d, b.flags |= 4);
                b.subtreeFlags = 0;
                d = c;
                for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                G(L2, L2.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
            null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
          }
          else {
            if (!d) if (a = Ch(g), null !== a) {
              if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
            } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
            f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
          }
          if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L2.current, G(L2, d ? c & 1 | 2 : c & 1), b;
          S(b);
          return null;
        case 22:
        case 23:
          return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    function Ij(a, b) {
      wg(b);
      switch (b.tag) {
        case 1:
          return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 3:
          return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
        case 5:
          return Bh(b), null;
        case 13:
          E(L2);
          a = b.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b.alternate) throw Error(p(340));
            Ig();
          }
          a = b.flags;
          return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 19:
          return E(L2), null;
        case 4:
          return zh(), null;
        case 10:
          return ah(b.type._context), null;
        case 22:
        case 23:
          return Hj(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Lj(a, b) {
      var c = a.ref;
      if (null !== c) if ("function" === typeof c) try {
        c(null);
      } catch (d) {
        W(a, b, d);
      }
      else c.current = null;
    }
    function Mj(a, b, c) {
      try {
        c();
      } catch (d) {
        W(a, b, d);
      }
    }
    var Nj = false;
    function Oj(a, b) {
      Cf = dd;
      a = Me2();
      if (Ne2(a)) {
        if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
        else a: {
          c = (c = a.ownerDocument) && c.defaultView || window;
          var d = c.getSelection && c.getSelection();
          if (d && 0 !== d.rangeCount) {
            c = d.anchorNode;
            var e = d.anchorOffset, f = d.focusNode;
            d = d.focusOffset;
            try {
              c.nodeType, f.nodeType;
            } catch (F) {
              c = null;
              break a;
            }
            var g = 0, h = -1, k = -1, l = 0, m2 = 0, q = a, r2 = null;
            b: for (; ; ) {
              for (var y; ; ) {
                q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                3 === q.nodeType && (g += q.nodeValue.length);
                if (null === (y = q.firstChild)) break;
                r2 = q;
                q = y;
              }
              for (; ; ) {
                if (q === a) break b;
                r2 === c && ++l === e && (h = g);
                r2 === f && ++m2 === d && (k = g);
                if (null !== (y = q.nextSibling)) break;
                q = r2;
                r2 = q.parentNode;
              }
              q = y;
            }
            c = -1 === h || -1 === k ? null : { start: h, end: k };
          } else c = null;
        }
        c = c || { start: 0, end: 0 };
      } else c = null;
      Df = { focusedElem: a, selectionRange: c };
      dd = false;
      for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
      else for (; null !== V; ) {
        b = V;
        try {
          var n = b.alternate;
          if (0 !== (b.flags & 1024)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (null !== n) {
                var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                x.__reactInternalSnapshotBeforeUpdate = w;
              }
              break;
            case 3:
              var u = b.stateNode.containerInfo;
              1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(p(163));
          }
        } catch (F) {
          W(b, b.return, F);
        }
        a = b.sibling;
        if (null !== a) {
          a.return = b.return;
          V = a;
          break;
        }
        V = b.return;
      }
      n = Nj;
      Nj = false;
      return n;
    }
    function Pj(a, b, c) {
      var d = b.updateQueue;
      d = null !== d ? d.lastEffect : null;
      if (null !== d) {
        var e = d = d.next;
        do {
          if ((e.tag & a) === a) {
            var f = e.destroy;
            e.destroy = void 0;
            void 0 !== f && Mj(b, c, f);
          }
          e = e.next;
        } while (e !== d);
      }
    }
    function Qj(a, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d = c.create;
            c.destroy = d();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Rj(a) {
      var b = a.ref;
      if (null !== b) {
        var c = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c;
            break;
          default:
            a = c;
        }
        "function" === typeof b ? b(a) : b.current = a;
      }
    }
    function Sj(a) {
      var b = a.alternate;
      null !== b && (a.alternate = null, Sj(b));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Tj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Uj(a) {
      a: for (; ; ) {
        for (; null === a.sibling; ) {
          if (null === a.return || Tj(a.return)) return null;
          a = a.return;
        }
        a.sibling.return = a.return;
        for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
          if (a.flags & 2) continue a;
          if (null === a.child || 4 === a.tag) continue a;
          else a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2)) return a.stateNode;
      }
    }
    function Vj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
      else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
    }
    function Wj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
    }
    var X = null, Xj = false;
    function Yj(a, b, c) {
      for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
    }
    function Zj(a, b, c) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
        lc.onCommitFiberUnmount(kc, c);
      } catch (h) {
      }
      switch (c.tag) {
        case 5:
          U || Lj(c, b);
        case 6:
          var d = X, e = Xj;
          X = null;
          Yj(a, b, c);
          X = d;
          Xj = e;
          null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
          break;
        case 18:
          null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
          break;
        case 4:
          d = X;
          e = Xj;
          X = c.stateNode.containerInfo;
          Xj = true;
          Yj(a, b, c);
          X = d;
          Xj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
            e = d = d.next;
            do {
              var f = e, g = f.destroy;
              f = f.tag;
              void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
              e = e.next;
            } while (e !== d);
          }
          Yj(a, b, c);
          break;
        case 1:
          if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
            d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
          } catch (h) {
            W(c, b, h);
          }
          Yj(a, b, c);
          break;
        case 21:
          Yj(a, b, c);
          break;
        case 22:
          c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
          break;
        default:
          Yj(a, b, c);
      }
    }
    function ak(a) {
      var b = a.updateQueue;
      if (null !== b) {
        a.updateQueue = null;
        var c = a.stateNode;
        null === c && (c = a.stateNode = new Kj());
        b.forEach(function(b2) {
          var d = bk.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d, d));
        });
      }
    }
    function ck(a, b) {
      var c = b.deletions;
      if (null !== c) for (var d = 0; d < c.length; d++) {
        var e = c[d];
        try {
          var f = a, g = b, h = g;
          a: for (; null !== h; ) {
            switch (h.tag) {
              case 5:
                X = h.stateNode;
                Xj = false;
                break a;
              case 3:
                X = h.stateNode.containerInfo;
                Xj = true;
                break a;
              case 4:
                X = h.stateNode.containerInfo;
                Xj = true;
                break a;
            }
            h = h.return;
          }
          if (null === X) throw Error(p(160));
          Zj(f, g, e);
          X = null;
          Xj = false;
          var k = e.alternate;
          null !== k && (k.return = null);
          e.return = null;
        } catch (l) {
          W(e, b, l);
        }
      }
      if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
    }
    function dk(a, b) {
      var c = a.alternate, d = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ck(b, a);
          ek(a);
          if (d & 4) {
            try {
              Pj(3, a, a.return), Qj(3, a);
            } catch (t) {
              W(a, a.return, t);
            }
            try {
              Pj(5, a, a.return);
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 1:
          ck(b, a);
          ek(a);
          d & 512 && null !== c && Lj(c, c.return);
          break;
        case 5:
          ck(b, a);
          ek(a);
          d & 512 && null !== c && Lj(c, c.return);
          if (a.flags & 32) {
            var e = a.stateNode;
            try {
              ob(e, "");
            } catch (t) {
              W(a, a.return, t);
            }
          }
          if (d & 4 && (e = a.stateNode, null != e)) {
            var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
            a.updateQueue = null;
            if (null !== k) try {
              "input" === h && "radio" === f.type && null != f.name && ab(e, f);
              vb(h, g);
              var l = vb(h, f);
              for (g = 0; g < k.length; g += 2) {
                var m2 = k[g], q = k[g + 1];
                "style" === m2 ? sb(e, q) : "dangerouslySetInnerHTML" === m2 ? nb(e, q) : "children" === m2 ? ob(e, q) : ta(e, m2, q, l);
              }
              switch (h) {
                case "input":
                  bb(e, f);
                  break;
                case "textarea":
                  ib(e, f);
                  break;
                case "select":
                  var r2 = e._wrapperState.wasMultiple;
                  e._wrapperState.wasMultiple = !!f.multiple;
                  var y = f.value;
                  null != y ? fb(e, !!f.multiple, y, false) : r2 !== !!f.multiple && (null != f.defaultValue ? fb(
                    e,
                    !!f.multiple,
                    f.defaultValue,
                    true
                  ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
              }
              e[Pf] = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 6:
          ck(b, a);
          ek(a);
          if (d & 4) {
            if (null === a.stateNode) throw Error(p(162));
            e = a.stateNode;
            f = a.memoizedProps;
            try {
              e.nodeValue = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 3:
          ck(b, a);
          ek(a);
          if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
            bd(b.containerInfo);
          } catch (t) {
            W(a, a.return, t);
          }
          break;
        case 4:
          ck(b, a);
          ek(a);
          break;
        case 13:
          ck(b, a);
          ek(a);
          e = a.child;
          e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
          d & 4 && ak(a);
          break;
        case 22:
          m2 = null !== c && null !== c.memoizedState;
          a.mode & 1 ? (U = (l = U) || m2, ck(b, a), U = l) : ck(b, a);
          ek(a);
          if (d & 8192) {
            l = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l) && !m2 && 0 !== (a.mode & 1)) for (V = a, m2 = a.child; null !== m2; ) {
              for (q = V = m2; null !== V; ) {
                r2 = V;
                y = r2.child;
                switch (r2.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Pj(4, r2, r2.return);
                    break;
                  case 1:
                    Lj(r2, r2.return);
                    var n = r2.stateNode;
                    if ("function" === typeof n.componentWillUnmount) {
                      d = r2;
                      c = r2.return;
                      try {
                        b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                      } catch (t) {
                        W(d, c, t);
                      }
                    }
                    break;
                  case 5:
                    Lj(r2, r2.return);
                    break;
                  case 22:
                    if (null !== r2.memoizedState) {
                      gk(q);
                      continue;
                    }
                }
                null !== y ? (y.return = r2, V = y) : gk(q);
              }
              m2 = m2.sibling;
            }
            a: for (m2 = null, q = a; ; ) {
              if (5 === q.tag) {
                if (null === m2) {
                  m2 = q;
                  try {
                    e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                  } catch (t) {
                    W(a, a.return, t);
                  }
                }
              } else if (6 === q.tag) {
                if (null === m2) try {
                  q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                } catch (t) {
                  W(a, a.return, t);
                }
              } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                q.child.return = q;
                q = q.child;
                continue;
              }
              if (q === a) break a;
              for (; null === q.sibling; ) {
                if (null === q.return || q.return === a) break a;
                m2 === q && (m2 = null);
                q = q.return;
              }
              m2 === q && (m2 = null);
              q.sibling.return = q.return;
              q = q.sibling;
            }
          }
          break;
        case 19:
          ck(b, a);
          ek(a);
          d & 4 && ak(a);
          break;
        case 21:
          break;
        default:
          ck(
            b,
            a
          ), ek(a);
      }
    }
    function ek(a) {
      var b = a.flags;
      if (b & 2) {
        try {
          a: {
            for (var c = a.return; null !== c; ) {
              if (Tj(c)) {
                var d = c;
                break a;
              }
              c = c.return;
            }
            throw Error(p(160));
          }
          switch (d.tag) {
            case 5:
              var e = d.stateNode;
              d.flags & 32 && (ob(e, ""), d.flags &= -33);
              var f = Uj(a);
              Wj(a, f, e);
              break;
            case 3:
            case 4:
              var g = d.stateNode.containerInfo, h = Uj(a);
              Vj(a, h, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k) {
          W(a, a.return, k);
        }
        a.flags &= -3;
      }
      b & 4096 && (a.flags &= -4097);
    }
    function hk(a, b, c) {
      V = a;
      ik(a);
    }
    function ik(a, b, c) {
      for (var d = 0 !== (a.mode & 1); null !== V; ) {
        var e = V, f = e.child;
        if (22 === e.tag && d) {
          var g = null !== e.memoizedState || Jj;
          if (!g) {
            var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
            h = Jj;
            var l = U;
            Jj = g;
            if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
            for (; null !== f; ) V = f, ik(f), f = f.sibling;
            V = e;
            Jj = h;
            U = l;
          }
          kk(a);
        } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b = V;
        if (0 !== (b.flags & 8772)) {
          var c = b.alternate;
          try {
            if (0 !== (b.flags & 8772)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                U || Qj(5, b);
                break;
              case 1:
                var d = b.stateNode;
                if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
                else {
                  var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                  d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                }
                var f = b.updateQueue;
                null !== f && sh(b, f, d);
                break;
              case 3:
                var g = b.updateQueue;
                if (null !== g) {
                  c = null;
                  if (null !== b.child) switch (b.child.tag) {
                    case 5:
                      c = b.child.stateNode;
                      break;
                    case 1:
                      c = b.child.stateNode;
                  }
                  sh(b, g, c);
                }
                break;
              case 5:
                var h = b.stateNode;
                if (null === c && b.flags & 4) {
                  c = h;
                  var k = b.memoizedProps;
                  switch (b.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      k.autoFocus && c.focus();
                      break;
                    case "img":
                      k.src && (c.src = k.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (null === b.memoizedState) {
                  var l = b.alternate;
                  if (null !== l) {
                    var m2 = l.memoizedState;
                    if (null !== m2) {
                      var q = m2.dehydrated;
                      null !== q && bd(q);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(p(163));
            }
            U || b.flags & 512 && Rj(b);
          } catch (r2) {
            W(b, b.return, r2);
          }
        }
        if (b === a) {
          V = null;
          break;
        }
        c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function gk(a) {
      for (; null !== V; ) {
        var b = V;
        if (b === a) {
          V = null;
          break;
        }
        var c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function jk(a) {
      for (; null !== V; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c = b.return;
              try {
                Qj(4, b);
              } catch (k) {
                W(b, c, k);
              }
              break;
            case 1:
              var d = b.stateNode;
              if ("function" === typeof d.componentDidMount) {
                var e = b.return;
                try {
                  d.componentDidMount();
                } catch (k) {
                  W(b, e, k);
                }
              }
              var f = b.return;
              try {
                Rj(b);
              } catch (k) {
                W(b, f, k);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Rj(b);
              } catch (k) {
                W(b, g, k);
              }
          }
        } catch (k) {
          W(b, b.return, k);
        }
        if (b === a) {
          V = null;
          break;
        }
        var h = b.sibling;
        if (null !== h) {
          h.return = b.return;
          V = h;
          break;
        }
        V = b.return;
      }
    }
    var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok2 = ua.ReactCurrentBatchConfig, K = 0, Q2 = null, Y2 = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
    function R() {
      return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
    }
    function yi(a) {
      if (0 === (a.mode & 1)) return 1;
      if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
      if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
      a = C;
      if (0 !== a) return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    function gi(a, b, c, d) {
      if (50 < yk) throw yk = 0, zk = null, Error(p(185));
      Ac(a, c, d);
      if (0 === (K & 2) || a !== Q2) a === Q2 && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
    }
    function Dk(a, b) {
      var c = a.callbackNode;
      wc(a, b);
      var d = uc(a, a === Q2 ? Z : 0);
      if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
      else if (b = d & -d, a.callbackPriority !== b) {
        null != c && bc(c);
        if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
          0 === (K & 6) && jg();
        }), c = null;
        else {
          switch (Dc(d)) {
            case 1:
              c = fc;
              break;
            case 4:
              c = gc;
              break;
            case 16:
              c = hc;
              break;
            case 536870912:
              c = jc;
              break;
            default:
              c = hc;
          }
          c = Fk(c, Gk.bind(null, a));
        }
        a.callbackPriority = b;
        a.callbackNode = c;
      }
    }
    function Gk(a, b) {
      Ak = -1;
      Bk = 0;
      if (0 !== (K & 6)) throw Error(p(327));
      var c = a.callbackNode;
      if (Hk() && a.callbackNode !== c) return null;
      var d = uc(a, a === Q2 ? Z : 0);
      if (0 === d) return null;
      if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
      else {
        b = d;
        var e = K;
        K |= 2;
        var f = Jk();
        if (Q2 !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
        do
          try {
            Lk();
            break;
          } catch (h) {
            Mk(a, h);
          }
        while (1);
        $g();
        mk.current = f;
        K = e;
        null !== Y2 ? b = 0 : (Q2 = null, Z = 0, b = T);
      }
      if (0 !== b) {
        2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
        if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        if (6 === b) Ck(a, d);
        else {
          e = a.current.alternate;
          if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          a.finishedWork = e;
          a.finishedLanes = d;
          switch (b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Pk(a, tk, uk);
              break;
            case 3:
              Ck(a, d);
              if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                if (0 !== uc(a, 0)) break;
                e = a.suspendedLanes;
                if ((e & d) !== d) {
                  R();
                  a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                break;
              }
              Pk(a, tk, uk);
              break;
            case 4:
              Ck(a, d);
              if ((d & 4194240) === d) break;
              b = a.eventTimes;
              for (e = -1; 0 < d; ) {
                var g = 31 - oc(d);
                f = 1 << g;
                g = b[g];
                g > e && (e = g);
                d &= ~f;
              }
              d = e;
              d = B() - d;
              d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
              if (10 < d) {
                a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                break;
              }
              Pk(a, tk, uk);
              break;
            case 5:
              Pk(a, tk, uk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      Dk(a, B());
      return a.callbackNode === c ? Gk.bind(null, a) : null;
    }
    function Nk(a, b) {
      var c = sk;
      a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
      a = Ik(a, b);
      2 !== a && (b = tk, tk = c, null !== b && Fj(b));
      return a;
    }
    function Fj(a) {
      null === tk ? tk = a : tk.push.apply(tk, a);
    }
    function Ok(a) {
      for (var b = a; ; ) {
        if (b.flags & 16384) {
          var c = b.updateQueue;
          if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
            var e = c[d], f = e.getSnapshot;
            e = e.value;
            try {
              if (!He2(f(), e)) return false;
            } catch (g) {
              return false;
            }
          }
        }
        c = b.child;
        if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
        else {
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return true;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return true;
    }
    function Ck(a, b) {
      b &= ~rk;
      b &= ~qk;
      a.suspendedLanes |= b;
      a.pingedLanes &= ~b;
      for (a = a.expirationTimes; 0 < b; ) {
        var c = 31 - oc(b), d = 1 << c;
        a[c] = -1;
        b &= ~d;
      }
    }
    function Ek(a) {
      if (0 !== (K & 6)) throw Error(p(327));
      Hk();
      var b = uc(a, 0);
      if (0 === (b & 1)) return Dk(a, B()), null;
      var c = Ik(a, b);
      if (0 !== a.tag && 2 === c) {
        var d = xc(a);
        0 !== d && (b = d, c = Nk(a, d));
      }
      if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
      if (6 === c) throw Error(p(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b;
      Pk(a, tk, uk);
      Dk(a, B());
      return null;
    }
    function Qk(a, b) {
      var c = K;
      K |= 1;
      try {
        return a(b);
      } finally {
        K = c, 0 === K && (Gj = B() + 500, fg && jg());
      }
    }
    function Rk(a) {
      null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
      var b = K;
      K |= 1;
      var c = ok2.transition, d = C;
      try {
        if (ok2.transition = null, C = 1, a) return a();
      } finally {
        C = d, ok2.transition = c, K = b, 0 === (K & 6) && jg();
      }
    }
    function Hj() {
      fj = ej.current;
      E(ej);
    }
    function Kk(a, b) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c = a.timeoutHandle;
      -1 !== c && (a.timeoutHandle = -1, Gf(c));
      if (null !== Y2) for (c = Y2.return; null !== c; ) {
        var d = c;
        wg(d);
        switch (d.tag) {
          case 1:
            d = d.type.childContextTypes;
            null !== d && void 0 !== d && $f();
            break;
          case 3:
            zh();
            E(Wf);
            E(H);
            Eh();
            break;
          case 5:
            Bh(d);
            break;
          case 4:
            zh();
            break;
          case 13:
            E(L2);
            break;
          case 19:
            E(L2);
            break;
          case 10:
            ah(d.type._context);
            break;
          case 22:
          case 23:
            Hj();
        }
        c = c.return;
      }
      Q2 = a;
      Y2 = a = Pg(a.current, null);
      Z = fj = b;
      T = 0;
      pk = null;
      rk = qk = rh = 0;
      tk = sk = null;
      if (null !== fh) {
        for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
          c.interleaved = null;
          var e = d.next, f = c.pending;
          if (null !== f) {
            var g = f.next;
            f.next = e;
            d.next = g;
          }
          c.pending = d;
        }
        fh = null;
      }
      return a;
    }
    function Mk(a, b) {
      do {
        var c = Y2;
        try {
          $g();
          Fh.current = Rh;
          if (Ih) {
            for (var d = M.memoizedState; null !== d; ) {
              var e = d.queue;
              null !== e && (e.pending = null);
              d = d.next;
            }
            Ih = false;
          }
          Hh = 0;
          O = N = M = null;
          Jh = false;
          Kh = 0;
          nk.current = null;
          if (null === c || null === c.return) {
            T = 1;
            pk = b;
            Y2 = null;
            break;
          }
          a: {
            var f = a, g = c.return, h = c, k = b;
            b = Z;
            h.flags |= 32768;
            if (null !== k && "object" === typeof k && "function" === typeof k.then) {
              var l = k, m2 = h, q = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y = Ui(g);
              if (null !== y) {
                y.flags &= -257;
                Vi(y, g, h, f, b);
                y.mode & 1 && Si(f, l, b);
                b = y;
                k = l;
                var n = b.updateQueue;
                if (null === n) {
                  var t = /* @__PURE__ */ new Set();
                  t.add(k);
                  b.updateQueue = t;
                } else n.add(k);
                break a;
              } else {
                if (0 === (b & 1)) {
                  Si(f, l, b);
                  tj();
                  break a;
                }
                k = Error(p(426));
              }
            } else if (I && h.mode & 1) {
              var J = Ui(g);
              if (null !== J) {
                0 === (J.flags & 65536) && (J.flags |= 256);
                Vi(J, g, h, f, b);
                Jg(Ji(k, h));
                break a;
              }
            }
            f = k = Ji(k, h);
            4 !== T && (T = 2);
            null === sk ? sk = [f] : sk.push(f);
            f = g;
            do {
              switch (f.tag) {
                case 3:
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var x = Ni2(f, k, b);
                  ph(f, x);
                  break a;
                case 1:
                  h = k;
                  var w = f.type, u = f.stateNode;
                  if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var F = Qi(f, h, b);
                    ph(f, F);
                    break a;
                  }
              }
              f = f.return;
            } while (null !== f);
          }
          Sk(c);
        } catch (na) {
          b = na;
          Y2 === c && null !== c && (Y2 = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    function Jk() {
      var a = mk.current;
      mk.current = Rh;
      return null === a ? Rh : a;
    }
    function tj() {
      if (0 === T || 3 === T || 2 === T) T = 4;
      null === Q2 || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q2, Z);
    }
    function Ik(a, b) {
      var c = K;
      K |= 2;
      var d = Jk();
      if (Q2 !== a || Z !== b) uk = null, Kk(a, b);
      do
        try {
          Tk();
          break;
        } catch (e) {
          Mk(a, e);
        }
      while (1);
      $g();
      K = c;
      mk.current = d;
      if (null !== Y2) throw Error(p(261));
      Q2 = null;
      Z = 0;
      return T;
    }
    function Tk() {
      for (; null !== Y2; ) Uk(Y2);
    }
    function Lk() {
      for (; null !== Y2 && !cc(); ) Uk(Y2);
    }
    function Uk(a) {
      var b = Vk(a.alternate, a, fj);
      a.memoizedProps = a.pendingProps;
      null === b ? Sk(a) : Y2 = b;
      nk.current = null;
    }
    function Sk(a) {
      var b = a;
      do {
        var c = b.alternate;
        a = b.return;
        if (0 === (b.flags & 32768)) {
          if (c = Ej(c, b, fj), null !== c) {
            Y2 = c;
            return;
          }
        } else {
          c = Ij(c, b);
          if (null !== c) {
            c.flags &= 32767;
            Y2 = c;
            return;
          }
          if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6;
            Y2 = null;
            return;
          }
        }
        b = b.sibling;
        if (null !== b) {
          Y2 = b;
          return;
        }
        Y2 = b = a;
      } while (null !== b);
      0 === T && (T = 5);
    }
    function Pk(a, b, c) {
      var d = C, e = ok2.transition;
      try {
        ok2.transition = null, C = 1, Wk(a, b, c, d);
      } finally {
        ok2.transition = e, C = d;
      }
      return null;
    }
    function Wk(a, b, c, d) {
      do
        Hk();
      while (null !== wk);
      if (0 !== (K & 6)) throw Error(p(327));
      c = a.finishedWork;
      var e = a.finishedLanes;
      if (null === c) return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c === a.current) throw Error(p(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f = c.lanes | c.childLanes;
      Bc(a, f);
      a === Q2 && (Y2 = Q2 = null, Z = 0);
      0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
        Hk();
        return null;
      }));
      f = 0 !== (c.flags & 15990);
      if (0 !== (c.subtreeFlags & 15990) || f) {
        f = ok2.transition;
        ok2.transition = null;
        var g = C;
        C = 1;
        var h = K;
        K |= 4;
        nk.current = null;
        Oj(a, c);
        dk(c, a);
        Oe2(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c;
        hk(c);
        dc();
        K = h;
        C = g;
        ok2.transition = f;
      } else a.current = c;
      vk && (vk = false, wk = a, xk = e);
      f = a.pendingLanes;
      0 === f && (Ri = null);
      mc(c.stateNode);
      Dk(a, B());
      if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
      if (Oi) throw Oi = false, a = Pi, Pi = null, a;
      0 !== (xk & 1) && 0 !== a.tag && Hk();
      f = a.pendingLanes;
      0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
      jg();
      return null;
    }
    function Hk() {
      if (null !== wk) {
        var a = Dc(xk), b = ok2.transition, c = C;
        try {
          ok2.transition = null;
          C = 16 > a ? 16 : a;
          if (null === wk) var d = false;
          else {
            a = wk;
            wk = null;
            xk = 0;
            if (0 !== (K & 6)) throw Error(p(331));
            var e = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f = V, g = f.child;
              if (0 !== (V.flags & 16)) {
                var h = f.deletions;
                if (null !== h) {
                  for (var k = 0; k < h.length; k++) {
                    var l = h[k];
                    for (V = l; null !== V; ) {
                      var m2 = V;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(8, m2, f);
                      }
                      var q = m2.child;
                      if (null !== q) q.return = m2, V = q;
                      else for (; null !== V; ) {
                        m2 = V;
                        var r2 = m2.sibling, y = m2.return;
                        Sj(m2);
                        if (m2 === l) {
                          V = null;
                          break;
                        }
                        if (null !== r2) {
                          r2.return = y;
                          V = r2;
                          break;
                        }
                        V = y;
                      }
                    }
                  }
                  var n = f.alternate;
                  if (null !== n) {
                    var t = n.child;
                    if (null !== t) {
                      n.child = null;
                      do {
                        var J = t.sibling;
                        t.sibling = null;
                        t = J;
                      } while (null !== t);
                    }
                  }
                  V = f;
                }
              }
              if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
              else b: for (; null !== V; ) {
                f = V;
                if (0 !== (f.flags & 2048)) switch (f.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Pj(9, f, f.return);
                }
                var x = f.sibling;
                if (null !== x) {
                  x.return = f.return;
                  V = x;
                  break b;
                }
                V = f.return;
              }
            }
            var w = a.current;
            for (V = w; null !== V; ) {
              g = V;
              var u = g.child;
              if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
              else b: for (g = w; null !== V; ) {
                h = V;
                if (0 !== (h.flags & 2048)) try {
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, h);
                  }
                } catch (na) {
                  W(h, h.return, na);
                }
                if (h === g) {
                  V = null;
                  break b;
                }
                var F = h.sibling;
                if (null !== F) {
                  F.return = h.return;
                  V = F;
                  break b;
                }
                V = h.return;
              }
            }
            K = e;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
              lc.onPostCommitFiberRoot(kc, a);
            } catch (na) {
            }
            d = true;
          }
          return d;
        } finally {
          C = c, ok2.transition = b;
        }
      }
      return false;
    }
    function Xk(a, b, c) {
      b = Ji(c, b);
      b = Ni2(a, b, 1);
      a = nh(a, b, 1);
      b = R();
      null !== a && (Ac(a, 1, b), Dk(a, b));
    }
    function W(a, b, c) {
      if (3 === a.tag) Xk(a, a, c);
      else for (; null !== b; ) {
        if (3 === b.tag) {
          Xk(b, a, c);
          break;
        } else if (1 === b.tag) {
          var d = b.stateNode;
          if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
            a = Ji(c, a);
            a = Qi(b, a, 1);
            b = nh(b, a, 1);
            a = R();
            null !== b && (Ac(b, 1, a), Dk(b, a));
            break;
          }
        }
        b = b.return;
      }
    }
    function Ti(a, b, c) {
      var d = a.pingCache;
      null !== d && d.delete(b);
      b = R();
      a.pingedLanes |= a.suspendedLanes & c;
      Q2 === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
      Dk(a, b);
    }
    function Yk(a, b) {
      0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c = R();
      a = ih(a, b);
      null !== a && (Ac(a, b, c), Dk(a, c));
    }
    function uj(a) {
      var b = a.memoizedState, c = 0;
      null !== b && (c = b.retryLane);
      Yk(a, c);
    }
    function bk(a, b) {
      var c = 0;
      switch (a.tag) {
        case 13:
          var d = a.stateNode;
          var e = a.memoizedState;
          null !== e && (c = e.retryLane);
          break;
        case 19:
          d = a.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      null !== d && d.delete(b);
      Yk(a, c);
    }
    var Vk;
    Vk = function(a, b, c) {
      if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
      else {
        if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
        dh = 0 !== (a.flags & 131072) ? true : false;
      }
      else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          var d = b.type;
          ij(a, b);
          a = b.pendingProps;
          var e = Yf(b, H.current);
          ch(b, c);
          e = Nh(null, b, d, a, e, c);
          var f = Sh();
          b.flags |= 1;
          "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
          return b;
        case 16:
          d = b.elementType;
          a: {
            ij(a, b);
            a = b.pendingProps;
            e = d._init;
            d = e(d._payload);
            b.type = d;
            e = b.tag = Zk(d);
            a = Ci(d, a);
            switch (e) {
              case 0:
                b = cj(null, b, d, a, c);
                break a;
              case 1:
                b = hj(null, b, d, a, c);
                break a;
              case 11:
                b = Yi(null, b, d, a, c);
                break a;
              case 14:
                b = $i(null, b, d, Ci(d.type, a), c);
                break a;
            }
            throw Error(p(
              306,
              d,
              ""
            ));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
        case 3:
          a: {
            kj(b);
            if (null === a) throw Error(p(387));
            d = b.pendingProps;
            f = b.memoizedState;
            e = f.element;
            lh(a, b);
            qh(b, d, null, c);
            var g = b.memoizedState;
            d = g.element;
            if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
              e = Ji(Error(p(423)), b);
              b = lj(a, b, d, c, e);
              break a;
            } else if (d !== e) {
              e = Ji(Error(p(424)), b);
              b = lj(a, b, d, c, e);
              break a;
            } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
            else {
              Ig();
              if (d === e) {
                b = Zi(a, b, c);
                break a;
              }
              Xi(a, b, d, c);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
        case 6:
          return null === a && Eg(b), null;
        case 13:
          return oj(a, b, c);
        case 4:
          return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
        case 7:
          return Xi(a, b, b.pendingProps, c), b.child;
        case 8:
          return Xi(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return Xi(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            f = b.memoizedProps;
            g = e.value;
            G(Wg, d._currentValue);
            d._currentValue = g;
            if (null !== f) if (He2(f.value, g)) {
              if (f.children === e.children && !Wf.current) {
                b = Zi(a, b, c);
                break a;
              }
            } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
              var h = f.dependencies;
              if (null !== h) {
                g = f.child;
                for (var k = h.firstContext; null !== k; ) {
                  if (k.context === d) {
                    if (1 === f.tag) {
                      k = mh(-1, c & -c);
                      k.tag = 2;
                      var l = f.updateQueue;
                      if (null !== l) {
                        l = l.shared;
                        var m2 = l.pending;
                        null === m2 ? k.next = k : (k.next = m2.next, m2.next = k);
                        l.pending = k;
                      }
                    }
                    f.lanes |= c;
                    k = f.alternate;
                    null !== k && (k.lanes |= c);
                    bh(
                      f.return,
                      c,
                      b
                    );
                    h.lanes |= c;
                    break;
                  }
                  k = k.next;
                }
              } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
              else if (18 === f.tag) {
                g = f.return;
                if (null === g) throw Error(p(341));
                g.lanes |= c;
                h = g.alternate;
                null !== h && (h.lanes |= c);
                bh(g, c, b);
                g = f.sibling;
              } else g = f.child;
              if (null !== g) g.return = f;
              else for (g = f; null !== g; ) {
                if (g === b) {
                  g = null;
                  break;
                }
                f = g.sibling;
                if (null !== f) {
                  f.return = g.return;
                  g = f;
                  break;
                }
                g = g.return;
              }
              f = g;
            }
            Xi(a, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
        case 14:
          return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
        case 15:
          return bj(a, b, b.type, b.pendingProps, c);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
        case 19:
          return xj(a, b, c);
        case 22:
          return dj(a, b, c);
      }
      throw Error(p(156, b.tag));
    };
    function Fk(a, b) {
      return ac(a, b);
    }
    function $k(a, b, c, d) {
      this.tag = a;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a, b, c, d) {
      return new $k(a, b, c, d);
    }
    function aj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function Zk(a) {
      if ("function" === typeof a) return aj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da2) return 11;
        if (a === Ga2) return 14;
      }
      return 2;
    }
    function Pg(a, b) {
      var c = a.alternate;
      null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
      c.flags = a.flags & 14680064;
      c.childLanes = a.childLanes;
      c.lanes = a.lanes;
      c.child = a.child;
      c.memoizedProps = a.memoizedProps;
      c.memoizedState = a.memoizedState;
      c.updateQueue = a.updateQueue;
      b = a.dependencies;
      c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c.sibling = a.sibling;
      c.index = a.index;
      c.ref = a.ref;
      return c;
    }
    function Rg(a, b, c, d, e, f) {
      var g = 2;
      d = a;
      if ("function" === typeof a) aj(a) && (g = 1);
      else if ("string" === typeof a) g = 5;
      else a: switch (a) {
        case ya:
          return Tg(c.children, e, f, b);
        case za:
          g = 8;
          e |= 8;
          break;
        case Aa:
          return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
        case Ea:
          return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
        case Fa2:
          return a = Bg(19, c, b, e), a.elementType = Fa2, a.lanes = f, a;
        case Ia:
          return pj(c, e, f, b);
        default:
          if ("object" === typeof a && null !== a) switch (a.$$typeof) {
            case Ba2:
              g = 10;
              break a;
            case Ca:
              g = 9;
              break a;
            case Da2:
              g = 11;
              break a;
            case Ga2:
              g = 14;
              break a;
            case Ha:
              g = 16;
              d = null;
              break a;
          }
          throw Error(p(130, null == a ? a : typeof a, ""));
      }
      b = Bg(g, c, b, e);
      b.elementType = a;
      b.type = d;
      b.lanes = f;
      return b;
    }
    function Tg(a, b, c, d) {
      a = Bg(7, a, d, b);
      a.lanes = c;
      return a;
    }
    function pj(a, b, c, d) {
      a = Bg(22, a, d, b);
      a.elementType = Ia;
      a.lanes = c;
      a.stateNode = { isHidden: false };
      return a;
    }
    function Qg(a, b, c) {
      a = Bg(6, a, null, b);
      a.lanes = c;
      return a;
    }
    function Sg(a, b, c) {
      b = Bg(4, null !== a.children ? a.children : [], a.key, b);
      b.lanes = c;
      b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b;
    }
    function al(a, b, c, d, e) {
      this.tag = b;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d;
      this.onRecoverableError = e;
      this.mutableSourceEagerHydrationData = null;
    }
    function bl(a, b, c, d, e, f, g, h, k) {
      a = new al(a, b, c, h, k);
      1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
      f = Bg(3, null, null, b);
      a.current = f;
      f.stateNode = a;
      f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      kh(f);
      return a;
    }
    function cl2(a, b, c) {
      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
    }
    function dl2(a) {
      if (!a) return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
        var b = a;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (null !== b);
        throw Error(p(171));
      }
      if (1 === a.tag) {
        var c = a.type;
        if (Zf(c)) return bg(a, c, b);
      }
      return b;
    }
    function el(a, b, c, d, e, f, g, h, k) {
      a = bl(c, d, true, a, e, f, g, h, k);
      a.context = dl2(null);
      c = a.current;
      d = R();
      e = yi(c);
      f = mh(d, e);
      f.callback = void 0 !== b && null !== b ? b : null;
      nh(c, f, e);
      a.current.lanes = e;
      Ac(a, e, d);
      Dk(a, d);
      return a;
    }
    function fl(a, b, c, d) {
      var e = b.current, f = R(), g = yi(e);
      c = dl2(c);
      null === b.context ? b.context = c : b.pendingContext = c;
      b = mh(f, g);
      b.payload = { element: a };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      a = nh(e, b, g);
      null !== a && (gi(a, e, g, f), oh(a, e, g));
      return g;
    }
    function gl(a) {
      a = a.current;
      if (!a.child) return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function hl(a, b) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c = a.retryLane;
        a.retryLane = 0 !== c && c < b ? c : b;
      }
    }
    function il(a, b) {
      hl(a, b);
      (a = a.alternate) && hl(a, b);
    }
    function jl() {
      return null;
    }
    var kl = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ll(a) {
      this._internalRoot = a;
    }
    ml.prototype.render = ll.prototype.render = function(a) {
      var b = this._internalRoot;
      if (null === b) throw Error(p(409));
      fl(a, b, null, null);
    };
    ml.prototype.unmount = ll.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b = a.containerInfo;
        Rk(function() {
          fl(null, a, null, null);
        });
        b[uf] = null;
      }
    };
    function ml(a) {
      this._internalRoot = a;
    }
    ml.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b = Hc();
        a = { blockedOn: null, target: a, priority: b };
        for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
        Qc.splice(c, 0, a);
        0 === c && Vc(a);
      }
    };
    function nl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function pl() {
    }
    function ql(a, b, c, d, e) {
      if (e) {
        if ("function" === typeof d) {
          var f = d;
          d = function() {
            var a2 = gl(g);
            f.call(a2);
          };
        }
        var g = el(b, d, a, 0, null, false, false, "", pl);
        a._reactRootContainer = g;
        a[uf] = g.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Rk();
        return g;
      }
      for (; e = a.lastChild; ) a.removeChild(e);
      if ("function" === typeof d) {
        var h = d;
        d = function() {
          var a2 = gl(k);
          h.call(a2);
        };
      }
      var k = bl(a, 0, false, null, null, false, false, "", pl);
      a._reactRootContainer = k;
      a[uf] = k.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk(function() {
        fl(b, k, c, d);
      });
      return k;
    }
    function rl(a, b, c, d, e) {
      var f = c._reactRootContainer;
      if (f) {
        var g = f;
        if ("function" === typeof e) {
          var h = e;
          e = function() {
            var a2 = gl(g);
            h.call(a2);
          };
        }
        fl(b, g, a, e);
      } else g = ql(c, b, a, e, d);
      return gl(g);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c = tc(b.pendingLanes);
            0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
          }
          break;
        case 13:
          Rk(function() {
            var b2 = ih(a, 1);
            if (null !== b2) {
              var c2 = R();
              gi(b2, a, 1, c2);
            }
          }), il(a, 1);
      }
    };
    Fc = function(a) {
      if (13 === a.tag) {
        var b = ih(a, 134217728);
        if (null !== b) {
          var c = R();
          gi(b, a, 134217728, c);
        }
        il(a, 134217728);
      }
    };
    Gc = function(a) {
      if (13 === a.tag) {
        var b = yi(a), c = ih(a, b);
        if (null !== c) {
          var d = R();
          gi(c, a, b, d);
        }
        il(a, b);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a, b) {
      var c = C;
      try {
        return C = a, b();
      } finally {
        C = c;
      }
    };
    yb = function(a, b, c) {
      switch (b) {
        case "input":
          bb(a, c);
          b = c.name;
          if ("radio" === c.type && null != b) {
            for (c = a; c.parentNode; ) c = c.parentNode;
            c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a && d.form === a.form) {
                var e = Db(d);
                if (!e) throw Error(p(90));
                Wa2(d);
                bb(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c);
          break;
        case "select":
          b = c.value, null != b && fb(a, !!c.multiple, b, false);
      }
    };
    Gb = Qk;
    Hb = Rk;
    var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
    var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!vl.isDisabled && vl.supportsFiber) try {
        kc = vl.inject(ul), lc = vl;
      } catch (a) {
      }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
    reactDom_production_min.createPortal = function(a, b) {
      var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!nl(b)) throw Error(p(200));
      return cl2(a, b, null, c);
    };
    reactDom_production_min.createRoot = function(a, b) {
      if (!nl(a)) throw Error(p(299));
      var c = false, d = "", e = kl;
      null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
      b = bl(a, 1, false, null, null, c, false, d, e);
      a[uf] = b.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ll(b);
    };
    reactDom_production_min.findDOMNode = function(a) {
      if (null == a) return null;
      if (1 === a.nodeType) return a;
      var b = a._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a.render) throw Error(p(188));
        a = Object.keys(a).join(",");
        throw Error(p(268, a));
      }
      a = Zb(b);
      a = null === a ? null : a.stateNode;
      return a;
    };
    reactDom_production_min.flushSync = function(a) {
      return Rk(a);
    };
    reactDom_production_min.hydrate = function(a, b, c) {
      if (!ol(b)) throw Error(p(200));
      return rl(null, a, b, true, c);
    };
    reactDom_production_min.hydrateRoot = function(a, b, c) {
      if (!nl(a)) throw Error(p(405));
      var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
      null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
      b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
      a[uf] = b.current;
      sf(a);
      if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
        c,
        e
      );
      return new ml(b);
    };
    reactDom_production_min.render = function(a, b, c) {
      if (!ol(b)) throw Error(p(200));
      return rl(null, a, b, false, c);
    };
    reactDom_production_min.unmountComponentAtNode = function(a) {
      if (!ol(a)) throw Error(p(40));
      return a._reactRootContainer ? (Rk(function() {
        rl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Qk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
      if (!ol(c)) throw Error(p(200));
      if (null == a || void 0 === a._reactInternals) throw Error(p(38));
      return rl(a, b, c, false, d);
    };
    reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
    return reactDom_production_min;
  }
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  var reactDomExports = reactDom.exports;
  const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
  var NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
  ];
  var Primitive = NODES.reduce((primitive, node2) => {
    const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node2}`);
    const Node2 = reactExports.forwardRef((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? Slot2 : node2;
      if (typeof window !== "undefined") {
        window[Symbol.for("radix-ui")] = true;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
    });
    Node2.displayName = `Primitive.${node2}`;
    return { ...primitive, [node2]: Node2 };
  }, {});
  function dispatchDiscreteCustomEvent(target, event) {
    if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
  }
  function useCallbackRef$1(callback) {
    const callbackRef = reactExports.useRef(callback);
    reactExports.useEffect(() => {
      callbackRef.current = callback;
    });
    return reactExports.useMemo(() => (...args) => {
      var _a2;
      return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
    }, []);
  }
  var useInsertionEffect = React$1[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
  function useControllableState({
    prop,
    defaultProp,
    onChange = () => {
    },
    caller
  }) {
    const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value = isControlled ? prop : uncontrolledProp;
    {
      const isControlledRef = reactExports.useRef(prop !== void 0);
      reactExports.useEffect(() => {
        const wasControlled = isControlledRef.current;
        if (wasControlled !== isControlled) {
          const from = wasControlled ? "controlled" : "uncontrolled";
          const to = isControlled ? "controlled" : "uncontrolled";
          console.warn(
            `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
          );
        }
        isControlledRef.current = isControlled;
      }, [isControlled, caller]);
    }
    const setValue = reactExports.useCallback(
      (nextValue) => {
        var _a2;
        if (isControlled) {
          const value2 = isFunction$2(nextValue) ? nextValue(prop) : nextValue;
          if (value2 !== prop) {
            (_a2 = onChangeRef.current) == null ? void 0 : _a2.call(onChangeRef, value2);
          }
        } else {
          setUncontrolledProp(nextValue);
        }
      },
      [isControlled, prop, setUncontrolledProp, onChangeRef]
    );
    return [value, setValue];
  }
  function useUncontrolledState({
    defaultProp,
    onChange
  }) {
    const [value, setValue] = reactExports.useState(defaultProp);
    const prevValueRef = reactExports.useRef(value);
    const onChangeRef = reactExports.useRef(onChange);
    useInsertionEffect(() => {
      onChangeRef.current = onChange;
    }, [onChange]);
    reactExports.useEffect(() => {
      var _a2;
      if (prevValueRef.current !== value) {
        (_a2 = onChangeRef.current) == null ? void 0 : _a2.call(onChangeRef, value);
        prevValueRef.current = value;
      }
    }, [value, prevValueRef]);
    return [value, setValue, onChangeRef];
  }
  function isFunction$2(value) {
    return typeof value === "function";
  }
  var DirectionContext = reactExports.createContext(void 0);
  function useDirection(localDir) {
    const globalDir = reactExports.useContext(DirectionContext);
    return localDir || globalDir || "ltr";
  }
  var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
  var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
  var GROUP_NAME$3 = "RovingFocusGroup";
  var [Collection$3, useCollection$3, createCollectionScope$3] = createCollection(GROUP_NAME$3);
  var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
    GROUP_NAME$3,
    [createCollectionScope$3]
  );
  var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$3);
  var RovingFocusGroup = reactExports.forwardRef(
    (props, forwardedRef) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
    }
  );
  RovingFocusGroup.displayName = GROUP_NAME$3;
  var RovingFocusGroupImpl = reactExports.forwardRef((props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      orientation: orientation2,
      loop = false,
      dir,
      currentTabStopId: currentTabStopIdProp,
      defaultCurrentTabStopId,
      onCurrentTabStopIdChange,
      onEntryFocus,
      preventScrollOnEntryFocus = false,
      ...groupProps
    } = props;
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref);
    const direction = useDirection(dir);
    const [currentTabStopId, setCurrentTabStopId] = useControllableState({
      prop: currentTabStopIdProp,
      defaultProp: defaultCurrentTabStopId ?? null,
      onChange: onCurrentTabStopIdChange,
      caller: GROUP_NAME$3
    });
    const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
    const handleEntryFocus = useCallbackRef$1(onEntryFocus);
    const getItems = useCollection$3(__scopeRovingFocusGroup);
    const isClickFocusRef = reactExports.useRef(false);
    const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
    reactExports.useEffect(() => {
      const node2 = ref.current;
      if (node2) {
        node2.addEventListener(ENTRY_FOCUS, handleEntryFocus);
        return () => node2.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
      }
    }, [handleEntryFocus]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RovingFocusProvider,
      {
        scope: __scopeRovingFocusGroup,
        orientation: orientation2,
        dir: direction,
        loop,
        currentTabStopId,
        onItemFocus: reactExports.useCallback(
          (tabStopId) => setCurrentTabStopId(tabStopId),
          [setCurrentTabStopId]
        ),
        onItemShiftTab: reactExports.useCallback(() => setIsTabbingBackOut(true), []),
        onFocusableItemAdd: reactExports.useCallback(
          () => setFocusableItemsCount((prevCount) => prevCount + 1),
          []
        ),
        onFocusableItemRemove: reactExports.useCallback(
          () => setFocusableItemsCount((prevCount) => prevCount - 1),
          []
        ),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
            "data-orientation": orientation2,
            ...groupProps,
            ref: composedRefs,
            style: { outline: "none", ...props.style },
            onMouseDown: composeEventHandlers$1(props.onMouseDown, () => {
              isClickFocusRef.current = true;
            }),
            onFocus: composeEventHandlers$1(props.onFocus, (event) => {
              const isKeyboardFocus = !isClickFocusRef.current;
              if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
                const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS$1);
                event.currentTarget.dispatchEvent(entryFocusEvent);
                if (!entryFocusEvent.defaultPrevented) {
                  const items = getItems().filter((item) => item.focusable);
                  const activeItem = items.find((item) => item.active);
                  const currentItem = items.find((item) => item.id === currentTabStopId);
                  const candidateItems = [activeItem, currentItem, ...items].filter(
                    Boolean
                  );
                  const candidateNodes = candidateItems.map((item) => item.ref.current);
                  focusFirst$2(candidateNodes, preventScrollOnEntryFocus);
                }
              }
              isClickFocusRef.current = false;
            }),
            onBlur: composeEventHandlers$1(props.onBlur, () => setIsTabbingBackOut(false))
          }
        )
      }
    );
  });
  var ITEM_NAME$4 = "RovingFocusGroupItem";
  var RovingFocusGroupItem = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeRovingFocusGroup,
        focusable = true,
        active = false,
        tabStopId,
        children,
        ...itemProps
      } = props;
      const autoId = useId();
      const id2 = tabStopId || autoId;
      const context = useRovingFocusContext(ITEM_NAME$4, __scopeRovingFocusGroup);
      const isCurrentTabStop = context.currentTabStopId === id2;
      const getItems = useCollection$3(__scopeRovingFocusGroup);
      const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
      reactExports.useEffect(() => {
        if (focusable) {
          onFocusableItemAdd();
          return () => onFocusableItemRemove();
        }
      }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Collection$3.ItemSlot,
        {
          scope: __scopeRovingFocusGroup,
          id: id2,
          focusable,
          active,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.span,
            {
              tabIndex: isCurrentTabStop ? 0 : -1,
              "data-orientation": context.orientation,
              ...itemProps,
              ref: forwardedRef,
              onMouseDown: composeEventHandlers$1(props.onMouseDown, (event) => {
                if (!focusable) event.preventDefault();
                else context.onItemFocus(id2);
              }),
              onFocus: composeEventHandlers$1(props.onFocus, () => context.onItemFocus(id2)),
              onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
                if (event.key === "Tab" && event.shiftKey) {
                  context.onItemShiftTab();
                  return;
                }
                if (event.target !== event.currentTarget) return;
                const focusIntent = getFocusIntent(event, context.orientation, context.dir);
                if (focusIntent !== void 0) {
                  if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                  event.preventDefault();
                  const items = getItems().filter((item) => item.focusable);
                  let candidateNodes = items.map((item) => item.ref.current);
                  if (focusIntent === "last") candidateNodes.reverse();
                  else if (focusIntent === "prev" || focusIntent === "next") {
                    if (focusIntent === "prev") candidateNodes.reverse();
                    const currentIndex = candidateNodes.indexOf(event.currentTarget);
                    candidateNodes = context.loop ? wrapArray$2(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                  }
                  setTimeout(() => focusFirst$2(candidateNodes));
                }
              }),
              children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
            }
          )
        }
      );
    }
  );
  RovingFocusGroupItem.displayName = ITEM_NAME$4;
  var MAP_KEY_TO_FOCUS_INTENT = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function getDirectionAwareKey(key, dir) {
    if (dir !== "rtl") return key;
    return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
  }
  function getFocusIntent(event, orientation2, dir) {
    const key = getDirectionAwareKey(event.key, dir);
    if (orientation2 === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
    if (orientation2 === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
    return MAP_KEY_TO_FOCUS_INTENT[key];
  }
  function focusFirst$2(candidates, preventScroll = false) {
    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
    for (const candidate of candidates) {
      if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
      candidate.focus({ preventScroll });
      if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
    }
  }
  function wrapArray$2(array, startIndex) {
    return array.map((_, index2) => array[(startIndex + index2) % array.length]);
  }
  var Root$6 = RovingFocusGroup;
  var Item$1 = RovingFocusGroupItem;
  function useStateMachine(initialState, machine) {
    return reactExports.useReducer((state, event) => {
      const nextState = machine[state][event];
      return nextState ?? state;
    }, initialState);
  }
  var Presence = (props) => {
    const { present, children } = props;
    const presence = usePresence$1(present);
    const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
    const ref = useComposedRefs$1(presence.ref, getElementRef(child));
    const forceMount = typeof children === "function";
    return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
  };
  Presence.displayName = "Presence";
  function usePresence$1(present) {
    const [node2, setNode] = reactExports.useState();
    const stylesRef = reactExports.useRef(null);
    const prevPresentRef = reactExports.useRef(present);
    const prevAnimationNameRef = reactExports.useRef("none");
    const initialState = present ? "mounted" : "unmounted";
    const [state, send] = useStateMachine(initialState, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    reactExports.useEffect(() => {
      const currentAnimationName = getAnimationName(stylesRef.current);
      prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
    }, [state]);
    useLayoutEffect2(() => {
      const styles = stylesRef.current;
      const wasPresent = prevPresentRef.current;
      const hasPresentChanged = wasPresent !== present;
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.current;
        const currentAnimationName = getAnimationName(styles);
        if (present) {
          send("MOUNT");
        } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
          send("UNMOUNT");
        } else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (wasPresent && isAnimating) {
            send("ANIMATION_OUT");
          } else {
            send("UNMOUNT");
          }
        }
        prevPresentRef.current = present;
      }
    }, [present, send]);
    useLayoutEffect2(() => {
      if (node2) {
        let timeoutId;
        const ownerWindow = node2.ownerDocument.defaultView ?? window;
        const handleAnimationEnd = (event) => {
          const currentAnimationName = getAnimationName(stylesRef.current);
          const isCurrentAnimation = currentAnimationName.includes(event.animationName);
          if (event.target === node2 && isCurrentAnimation) {
            send("ANIMATION_END");
            if (!prevPresentRef.current) {
              const currentFillMode = node2.style.animationFillMode;
              node2.style.animationFillMode = "forwards";
              timeoutId = ownerWindow.setTimeout(() => {
                if (node2.style.animationFillMode === "forwards") {
                  node2.style.animationFillMode = currentFillMode;
                }
              });
            }
          }
        };
        const handleAnimationStart = (event) => {
          if (event.target === node2) {
            prevAnimationNameRef.current = getAnimationName(stylesRef.current);
          }
        };
        node2.addEventListener("animationstart", handleAnimationStart);
        node2.addEventListener("animationcancel", handleAnimationEnd);
        node2.addEventListener("animationend", handleAnimationEnd);
        return () => {
          ownerWindow.clearTimeout(timeoutId);
          node2.removeEventListener("animationstart", handleAnimationStart);
          node2.removeEventListener("animationcancel", handleAnimationEnd);
          node2.removeEventListener("animationend", handleAnimationEnd);
        };
      } else {
        send("ANIMATION_END");
      }
    }, [node2, send]);
    return {
      isPresent: ["mounted", "unmountSuspended"].includes(state),
      ref: reactExports.useCallback((node22) => {
        stylesRef.current = node22 ? getComputedStyle(node22) : null;
        setNode(node22);
      }, [])
    };
  }
  function getAnimationName(styles) {
    return (styles == null ? void 0 : styles.animationName) || "none";
  }
  function getElementRef(element2) {
    var _a2, _b2;
    let getter = (_a2 = Object.getOwnPropertyDescriptor(element2.props, "ref")) == null ? void 0 : _a2.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element2.ref;
    }
    getter = (_b2 = Object.getOwnPropertyDescriptor(element2, "ref")) == null ? void 0 : _b2.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element2.props.ref;
    }
    return element2.props.ref || element2.ref;
  }
  var TABS_NAME = "Tabs";
  var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
    createRovingFocusGroupScope
  ]);
  var useRovingFocusGroupScope$2 = createRovingFocusGroupScope();
  var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
  var Tabs = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeTabs,
        value: valueProp,
        onValueChange,
        defaultValue,
        orientation: orientation2 = "horizontal",
        dir,
        activationMode = "automatic",
        ...tabsProps
      } = props;
      const direction = useDirection(dir);
      const [value, setValue] = useControllableState({
        prop: valueProp,
        onChange: onValueChange,
        defaultProp: defaultValue ?? "",
        caller: TABS_NAME
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TabsProvider,
        {
          scope: __scopeTabs,
          baseId: useId(),
          value,
          onValueChange: setValue,
          orientation: orientation2,
          dir: direction,
          activationMode,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              dir: direction,
              "data-orientation": orientation2,
              ...tabsProps,
              ref: forwardedRef
            }
          )
        }
      );
    }
  );
  Tabs.displayName = TABS_NAME;
  var TAB_LIST_NAME = "TabsList";
  var TabsList$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeTabs, loop = true, ...listProps } = props;
      const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
      const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeTabs);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Root$6,
        {
          asChild: true,
          ...rovingFocusGroupScope,
          orientation: context.orientation,
          dir: context.dir,
          loop,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              role: "tablist",
              "aria-orientation": context.orientation,
              ...listProps,
              ref: forwardedRef
            }
          )
        }
      );
    }
  );
  TabsList$1.displayName = TAB_LIST_NAME;
  var TRIGGER_NAME$5 = "TabsTrigger";
  var TabsTrigger$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
      const context = useTabsContext(TRIGGER_NAME$5, __scopeTabs);
      const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeTabs);
      const triggerId = makeTriggerId(context.baseId, value);
      const contentId = makeContentId(context.baseId, value);
      const isSelected = value === context.value;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Item$1,
        {
          asChild: true,
          ...rovingFocusGroupScope,
          focusable: !disabled,
          active: isSelected,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.button,
            {
              type: "button",
              role: "tab",
              "aria-selected": isSelected,
              "aria-controls": contentId,
              "data-state": isSelected ? "active" : "inactive",
              "data-disabled": disabled ? "" : void 0,
              disabled,
              id: triggerId,
              ...triggerProps,
              ref: forwardedRef,
              onMouseDown: composeEventHandlers$1(props.onMouseDown, (event) => {
                if (!disabled && event.button === 0 && event.ctrlKey === false) {
                  context.onValueChange(value);
                } else {
                  event.preventDefault();
                }
              }),
              onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
                if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
              }),
              onFocus: composeEventHandlers$1(props.onFocus, () => {
                const isAutomaticActivation = context.activationMode !== "manual";
                if (!isSelected && !disabled && isAutomaticActivation) {
                  context.onValueChange(value);
                }
              })
            }
          )
        }
      );
    }
  );
  TabsTrigger$1.displayName = TRIGGER_NAME$5;
  var CONTENT_NAME$6 = "TabsContent";
  var TabsContent$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
      const context = useTabsContext(CONTENT_NAME$6, __scopeTabs);
      const triggerId = makeTriggerId(context.baseId, value);
      const contentId = makeContentId(context.baseId, value);
      const isSelected = value === context.value;
      const isMountAnimationPreventedRef = reactExports.useRef(isSelected);
      reactExports.useEffect(() => {
        const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
        return () => cancelAnimationFrame(rAF);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": isSelected ? "active" : "inactive",
          "data-orientation": context.orientation,
          role: "tabpanel",
          "aria-labelledby": triggerId,
          hidden: !present,
          id: contentId,
          tabIndex: 0,
          ...contentProps,
          ref: forwardedRef,
          style: {
            ...props.style,
            animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
          },
          children: present && children
        }
      ) });
    }
  );
  TabsContent$1.displayName = CONTENT_NAME$6;
  function makeTriggerId(baseId, value) {
    return `${baseId}-trigger-${value}`;
  }
  function makeContentId(baseId, value) {
    return `${baseId}-content-${value}`;
  }
  var List = TabsList$1;
  var Trigger$2 = TabsTrigger$1;
  var Content$2 = TabsContent$1;
  var Bt = Object.defineProperty, At$1 = Object.defineProperties;
  var kt$1 = Object.getOwnPropertyDescriptors;
  var Y = Object.getOwnPropertySymbols;
  var gt = Object.prototype.hasOwnProperty, Et = Object.prototype.propertyIsEnumerable;
  var vt$1 = (r2, s, e) => s in r2 ? Bt(r2, s, { enumerable: true, configurable: true, writable: true, value: e }) : r2[s] = e, St = (r2, s) => {
    for (var e in s || (s = {})) gt.call(s, e) && vt$1(r2, e, s[e]);
    if (Y) for (var e of Y(s)) Et.call(s, e) && vt$1(r2, e, s[e]);
    return r2;
  }, bt = (r2, s) => At$1(r2, kt$1(s));
  var Pt$1 = (r2, s) => {
    var e = {};
    for (var u in r2) gt.call(r2, u) && s.indexOf(u) < 0 && (e[u] = r2[u]);
    if (r2 != null && Y) for (var u of Y(r2)) s.indexOf(u) < 0 && Et.call(r2, u) && (e[u] = r2[u]);
    return e;
  };
  function ht(r2) {
    let s = setTimeout(r2, 0), e = setTimeout(r2, 10), u = setTimeout(r2, 50);
    return [s, e, u];
  }
  function _t(r2) {
    let s = reactExports.useRef();
    return reactExports.useEffect(() => {
      s.current = r2;
    }), s.current;
  }
  var Ot$1 = 18, wt = 40, Gt = `${wt}px`, xt = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");
  function Tt({ containerRef: r2, inputRef: s, pushPasswordManagerStrategy: e, isFocused: u }) {
    let [P, D] = reactExports.useState(false), [G, H] = reactExports.useState(false), [F, W] = reactExports.useState(false), Z = reactExports.useMemo(() => e === "none" ? false : (e === "increase-width" || e === "experimental-no-flickering") && P && G, [P, G, e]), T = reactExports.useCallback(() => {
      let f = r2.current, h = s.current;
      if (!f || !h || F || e === "none") return;
      let a = f, B = a.getBoundingClientRect().left + a.offsetWidth, A = a.getBoundingClientRect().top + a.offsetHeight / 2, z = B - Ot$1, q = A;
      document.querySelectorAll(xt).length === 0 && document.elementFromPoint(z, q) === f || (D(true), W(true));
    }, [r2, s, F, e]);
    return reactExports.useEffect(() => {
      let f = r2.current;
      if (!f || e === "none") return;
      function h() {
        let A = window.innerWidth - f.getBoundingClientRect().right;
        H(A >= wt);
      }
      h();
      let a = setInterval(h, 1e3);
      return () => {
        clearInterval(a);
      };
    }, [r2, e]), reactExports.useEffect(() => {
      let f = u || document.activeElement === s.current;
      if (e === "none" || !f) return;
      let h = setTimeout(T, 0), a = setTimeout(T, 2e3), B = setTimeout(T, 5e3), A = setTimeout(() => {
        W(true);
      }, 6e3);
      return () => {
        clearTimeout(h), clearTimeout(a), clearTimeout(B), clearTimeout(A);
      };
    }, [s, u, e, T]), { hasPWMBadge: P, willPushPWMBadge: Z, PWM_BADGE_SPACE_WIDTH: Gt };
  }
  var jt = reactExports.createContext({}), Lt$1 = reactExports.forwardRef((A, B) => {
    var z = A, { value: r2, onChange: s, maxLength: e, textAlign: u = "left", pattern: P, placeholder: D, inputMode: G = "numeric", onComplete: H, pushPasswordManagerStrategy: F = "increase-width", pasteTransformer: W, containerClassName: Z, noScriptCSSFallback: T = Nt$1, render: f, children: h } = z, a = Pt$1(z, ["value", "onChange", "maxLength", "textAlign", "pattern", "placeholder", "inputMode", "onComplete", "pushPasswordManagerStrategy", "pasteTransformer", "containerClassName", "noScriptCSSFallback", "render", "children"]);
    var X, lt2, ut2, dt2, ft;
    let [q, nt] = reactExports.useState(typeof a.defaultValue == "string" ? a.defaultValue : ""), i = r2 != null ? r2 : q, I = _t(i), x = reactExports.useCallback((t) => {
      s == null || s(t), nt(t);
    }, [s]), m2 = reactExports.useMemo(() => P ? typeof P == "string" ? new RegExp(P) : P : null, [P]), l = reactExports.useRef(null), K = reactExports.useRef(null), J = reactExports.useRef({ value: i, onChange: x, isIOS: typeof window != "undefined" && ((lt2 = (X = window == null ? void 0 : window.CSS) == null ? void 0 : X.supports) == null ? void 0 : lt2.call(X, "-webkit-touch-callout", "none")) }), V = reactExports.useRef({ prev: [(ut2 = l.current) == null ? void 0 : ut2.selectionStart, (dt2 = l.current) == null ? void 0 : dt2.selectionEnd, (ft = l.current) == null ? void 0 : ft.selectionDirection] });
    reactExports.useImperativeHandle(B, () => l.current, []), reactExports.useEffect(() => {
      let t = l.current, o = K.current;
      if (!t || !o) return;
      J.current.value !== t.value && J.current.onChange(t.value), V.current.prev = [t.selectionStart, t.selectionEnd, t.selectionDirection];
      function d() {
        if (document.activeElement !== t) {
          L2(null), N(null);
          return;
        }
        let c = t.selectionStart, b = t.selectionEnd, mt = t.selectionDirection, v = t.maxLength, C = t.value, _ = V.current.prev, g = -1, E = -1, w;
        if (C.length !== 0 && c !== null && b !== null) {
          let Dt = c === b, Ht2 = c === C.length && C.length < v;
          if (Dt && !Ht2) {
            let y = c;
            if (y === 0) g = 0, E = 1, w = "forward";
            else if (y === v) g = y - 1, E = y, w = "backward";
            else if (v > 1 && C.length > 1) {
              let et = 0;
              if (_[0] !== null && _[1] !== null) {
                w = y < _[1] ? "backward" : "forward";
                let Wt = _[0] === _[1] && _[0] < v;
                w === "backward" && !Wt && (et = -1);
              }
              g = et + y, E = et + y + 1;
            }
          }
          g !== -1 && E !== -1 && g !== E && l.current.setSelectionRange(g, E, w);
        }
        let pt = g !== -1 ? g : c, Rt = E !== -1 ? E : b, yt2 = w != null ? w : mt;
        L2(pt), N(Rt), V.current.prev = [pt, Rt, yt2];
      }
      if (document.addEventListener("selectionchange", d, { capture: true }), d(), document.activeElement === t && Q2(true), !document.getElementById("input-otp-style")) {
        let c = document.createElement("style");
        if (c.id = "input-otp-style", document.head.appendChild(c), c.sheet) {
          let b = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
          $$1(c.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), $$1(c.sheet, `[data-input-otp]:autofill { ${b} }`), $$1(c.sheet, `[data-input-otp]:-webkit-autofill { ${b} }`), $$1(c.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), $$1(c.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
        }
      }
      let R = () => {
        o && o.style.setProperty("--root-height", `${t.clientHeight}px`);
      };
      R();
      let p = new ResizeObserver(R);
      return p.observe(t), () => {
        document.removeEventListener("selectionchange", d, { capture: true }), p.disconnect();
      };
    }, []);
    let [ot2, rt2] = reactExports.useState(false), [j, Q2] = reactExports.useState(false), [M, L2] = reactExports.useState(null), [k, N] = reactExports.useState(null);
    reactExports.useEffect(() => {
      ht(() => {
        var R, p, c, b;
        (R = l.current) == null || R.dispatchEvent(new Event("input"));
        let t = (p = l.current) == null ? void 0 : p.selectionStart, o = (c = l.current) == null ? void 0 : c.selectionEnd, d = (b = l.current) == null ? void 0 : b.selectionDirection;
        t !== null && o !== null && (L2(t), N(o), V.current.prev = [t, o, d]);
      });
    }, [i, j]), reactExports.useEffect(() => {
      I !== void 0 && i !== I && I.length < e && i.length === e && (H == null || H(i));
    }, [e, H, I, i]);
    let O = Tt({ containerRef: K, inputRef: l, pushPasswordManagerStrategy: F, isFocused: j }), st = reactExports.useCallback((t) => {
      let o = t.currentTarget.value.slice(0, e);
      if (o.length > 0 && m2 && !m2.test(o)) {
        t.preventDefault();
        return;
      }
      typeof I == "string" && o.length < I.length && document.dispatchEvent(new Event("selectionchange")), x(o);
    }, [e, x, I, m2]), at2 = reactExports.useCallback(() => {
      var t;
      if (l.current) {
        let o = Math.min(l.current.value.length, e - 1), d = l.current.value.length;
        (t = l.current) == null || t.setSelectionRange(o, d), L2(o), N(d);
      }
      Q2(true);
    }, [e]), ct2 = reactExports.useCallback((t) => {
      var g, E;
      let o = l.current;
      if (!W && (!J.current.isIOS || !t.clipboardData || !o)) return;
      let d = t.clipboardData.getData("text/plain"), R = W ? W(d) : d;
      t.preventDefault();
      let p = (g = l.current) == null ? void 0 : g.selectionStart, c = (E = l.current) == null ? void 0 : E.selectionEnd, v = (p !== c ? i.slice(0, p) + R + i.slice(c) : i.slice(0, p) + R + i.slice(p)).slice(0, e);
      if (v.length > 0 && m2 && !m2.test(v)) return;
      o.value = v, x(v);
      let C = Math.min(v.length, e - 1), _ = v.length;
      o.setSelectionRange(C, _), L2(C), N(_);
    }, [e, x, m2, i]), It = reactExports.useMemo(() => ({ position: "relative", cursor: a.disabled ? "default" : "text", userSelect: "none", WebkitUserSelect: "none", pointerEvents: "none" }), [a.disabled]), it = reactExports.useMemo(() => ({ position: "absolute", inset: 0, width: O.willPushPWMBadge ? `calc(100% + ${O.PWM_BADGE_SPACE_WIDTH})` : "100%", clipPath: O.willPushPWMBadge ? `inset(0 ${O.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0, height: "100%", display: "flex", textAlign: u, opacity: "1", color: "transparent", pointerEvents: "all", background: "transparent", caretColor: "transparent", border: "0 solid transparent", outline: "0 solid transparent", boxShadow: "none", lineHeight: "1", letterSpacing: "-.5em", fontSize: "var(--root-height)", fontFamily: "monospace", fontVariantNumeric: "tabular-nums" }), [O.PWM_BADGE_SPACE_WIDTH, O.willPushPWMBadge, u]), Mt = reactExports.useMemo(() => reactExports.createElement("input", bt(St({ autoComplete: a.autoComplete || "one-time-code" }, a), { "data-input-otp": true, "data-input-otp-placeholder-shown": i.length === 0 || void 0, "data-input-otp-mss": M, "data-input-otp-mse": k, inputMode: G, pattern: m2 == null ? void 0 : m2.source, "aria-placeholder": D, style: it, maxLength: e, value: i, ref: l, onPaste: (t) => {
      var o;
      ct2(t), (o = a.onPaste) == null || o.call(a, t);
    }, onChange: st, onMouseOver: (t) => {
      var o;
      rt2(true), (o = a.onMouseOver) == null || o.call(a, t);
    }, onMouseLeave: (t) => {
      var o;
      rt2(false), (o = a.onMouseLeave) == null || o.call(a, t);
    }, onFocus: (t) => {
      var o;
      at2(), (o = a.onFocus) == null || o.call(a, t);
    }, onBlur: (t) => {
      var o;
      Q2(false), (o = a.onBlur) == null || o.call(a, t);
    } })), [st, at2, ct2, G, it, e, k, M, a, m2 == null ? void 0 : m2.source, i]), tt2 = reactExports.useMemo(() => ({ slots: Array.from({ length: e }).map((t, o) => {
      var c;
      let d = j && M !== null && k !== null && (M === k && o === M || o >= M && o < k), R = i[o] !== void 0 ? i[o] : null, p = i[0] !== void 0 ? null : (c = D == null ? void 0 : D[o]) != null ? c : null;
      return { char: R, placeholderChar: p, isActive: d, hasFakeCaret: d && R === null };
    }), isFocused: j, isHovering: !a.disabled && ot2 }), [j, ot2, e, k, M, a.disabled, i]), Ct2 = reactExports.useMemo(() => f ? f(tt2) : reactExports.createElement(jt.Provider, { value: tt2 }, h), [h, tt2, f]);
    return reactExports.createElement(reactExports.Fragment, null, T !== null && reactExports.createElement("noscript", null, reactExports.createElement("style", null, T)), reactExports.createElement("div", { ref: K, "data-input-otp-container": true, style: It, className: Z }, Ct2, reactExports.createElement("div", { style: { position: "absolute", inset: 0, pointerEvents: "none" } }, Mt)));
  });
  Lt$1.displayName = "Input";
  function $$1(r2, s) {
    try {
      r2.insertRule(s);
    } catch (e) {
      console.error("input-otp could not insert CSS rule:", s);
    }
  }
  var Nt$1 = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`;
  function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
    const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        if (event.key === "Escape") {
          onEscapeKeyDown(event);
        }
      };
      ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
      return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
    }, [onEscapeKeyDown, ownerDocument]);
  }
  var DISMISSABLE_LAYER_NAME = "DismissableLayer";
  var CONTEXT_UPDATE = "dismissableLayer.update";
  var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
  var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
  var originalBodyPointerEvents;
  var DismissableLayerContext = reactExports.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  var DismissableLayer = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        disableOutsidePointerEvents = false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        ...layerProps
      } = props;
      const context = reactExports.useContext(DismissableLayerContext);
      const [node2, setNode] = reactExports.useState(null);
      const ownerDocument = (node2 == null ? void 0 : node2.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
      const [, force] = reactExports.useState({});
      const composedRefs = useComposedRefs$1(forwardedRef, (node22) => setNode(node22));
      const layers = Array.from(context.layers);
      const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
      const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
      const index2 = node2 ? layers.indexOf(node2) : -1;
      const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
      const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
      const pointerDownOutside = usePointerDownOutside((event) => {
        const target = event.target;
        const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
        if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
        onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
        onInteractOutside == null ? void 0 : onInteractOutside(event);
        if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
      }, ownerDocument);
      const focusOutside = useFocusOutside((event) => {
        const target = event.target;
        const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
        if (isFocusInBranch) return;
        onFocusOutside == null ? void 0 : onFocusOutside(event);
        onInteractOutside == null ? void 0 : onInteractOutside(event);
        if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
      }, ownerDocument);
      useEscapeKeydown((event) => {
        const isHighestLayer = index2 === context.layers.size - 1;
        if (!isHighestLayer) return;
        onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
        if (!event.defaultPrevented && onDismiss) {
          event.preventDefault();
          onDismiss();
        }
      }, ownerDocument);
      reactExports.useEffect(() => {
        if (!node2) return;
        if (disableOutsidePointerEvents) {
          if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
            originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
            ownerDocument.body.style.pointerEvents = "none";
          }
          context.layersWithOutsidePointerEventsDisabled.add(node2);
        }
        context.layers.add(node2);
        dispatchUpdate();
        return () => {
          if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
            ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
          }
        };
      }, [node2, ownerDocument, disableOutsidePointerEvents, context]);
      reactExports.useEffect(() => {
        return () => {
          if (!node2) return;
          context.layers.delete(node2);
          context.layersWithOutsidePointerEventsDisabled.delete(node2);
          dispatchUpdate();
        };
      }, [node2, context]);
      reactExports.useEffect(() => {
        const handleUpdate = () => force({});
        document.addEventListener(CONTEXT_UPDATE, handleUpdate);
        return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          ...layerProps,
          ref: composedRefs,
          style: {
            pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
            ...props.style
          },
          onFocusCapture: composeEventHandlers$1(props.onFocusCapture, focusOutside.onFocusCapture),
          onBlurCapture: composeEventHandlers$1(props.onBlurCapture, focusOutside.onBlurCapture),
          onPointerDownCapture: composeEventHandlers$1(
            props.onPointerDownCapture,
            pointerDownOutside.onPointerDownCapture
          )
        }
      );
    }
  );
  DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
  var BRANCH_NAME = "DismissableLayerBranch";
  var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
    const context = reactExports.useContext(DismissableLayerContext);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref);
    reactExports.useEffect(() => {
      const node2 = ref.current;
      if (node2) {
        context.branches.add(node2);
        return () => {
          context.branches.delete(node2);
        };
      }
    }, [context.branches]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
  });
  DismissableLayerBranch.displayName = BRANCH_NAME;
  function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
    const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
    const isPointerInsideReactTreeRef = reactExports.useRef(false);
    const handleClickRef = reactExports.useRef(() => {
    });
    reactExports.useEffect(() => {
      const handlePointerDown = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent2 = function() {
            handleAndDispatchCustomEvent(
              POINTER_DOWN_OUTSIDE,
              handlePointerDownOutside,
              eventDetail,
              { discrete: true }
            );
          };
          const eventDetail = { originalEvent: event };
          if (event.pointerType === "touch") {
            ownerDocument.removeEventListener("click", handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
            ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
          } else {
            handleAndDispatchPointerDownOutsideEvent2();
          }
        } else {
          ownerDocument.removeEventListener("click", handleClickRef.current);
        }
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        ownerDocument.removeEventListener("pointerdown", handlePointerDown);
        ownerDocument.removeEventListener("click", handleClickRef.current);
      };
    }, [ownerDocument, handlePointerDownOutside]);
    return {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
    };
  }
  function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
    const handleFocusOutside = useCallbackRef$1(onFocusOutside);
    const isFocusInsideReactTreeRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = { originalEvent: event };
          handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
            discrete: false
          });
        }
      };
      ownerDocument.addEventListener("focusin", handleFocus);
      return () => ownerDocument.removeEventListener("focusin", handleFocus);
    }, [ownerDocument, handleFocusOutside]);
    return {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = false
    };
  }
  function dispatchUpdate() {
    const event = new CustomEvent(CONTEXT_UPDATE);
    document.dispatchEvent(event);
  }
  function handleAndDispatchCustomEvent(name2, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name2, { bubbles: false, cancelable: true, detail });
    if (handler) target.addEventListener(name2, handler, { once: true });
    if (discrete) {
      dispatchDiscreteCustomEvent(target, event);
    } else {
      target.dispatchEvent(event);
    }
  }
  const sides = ["top", "right", "bottom", "left"];
  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const floor = Math.floor;
  const createCoords = (v) => ({
    x: v,
    y: v
  });
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  const oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp$2(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
  function getSideAxis(placement) {
    return yAxisSides.has(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  const lrPlacement = ["left", "right"];
  const rlPlacement = ["right", "left"];
  const tbPlacement = ["top", "bottom"];
  const btPlacement = ["bottom", "top"];
  function getSideList(side, isStart, rtl) {
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rlPlacement : lrPlacement;
        return isStart ? lrPlacement : rlPlacement;
      case "left":
      case "right":
        return isStart ? tbPlacement : btPlacement;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list2 = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list2 = list2.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list2 = list2.concat(list2.map(getOppositeAlignmentPlacement));
      }
    }
    return list2;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x,
      y,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y,
      left: x,
      right: x + width,
      bottom: y + height,
      x,
      y
    };
  }
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  const computePosition$1 = async (reference, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x,
      y
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i = 0; i < validMiddleware.length; i++) {
      const {
        name: name2,
        fn
      } = validMiddleware[i];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn({
        x,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x = nextX != null ? nextX : x;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name2]: {
          ...middlewareData[name2],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x,
            y
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i = -1;
      }
    }
    return {
      x,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state, options2) {
    var _await$platform$isEle;
    if (options2 === void 0) {
      options2 = {};
    }
    const {
      x,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options2, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element2 = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  const arrow$3 = (options2) => ({
    name: "arrow",
    options: options2,
    async fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element: element2,
        padding = 0
      } = evaluate(options2, state) || {};
      if (element2 == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x,
        y
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform2.getDimensions(element2);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element2));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset2 = clamp$2(min$1, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset2,
          centerOffset: center - offset2 - alignmentOffset,
          ...shouldAddOffset && {
            alignmentOffset
          }
        },
        reset: shouldAddOffset
      };
    }
  });
  const flip$2 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "flip",
      options: options2,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options2, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
            if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
            // overflows the main axis.
            overflowsData.every((d) => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some((side) => overflow[side] >= 0);
  }
  const hide$2 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "hide",
      options: options2,
      async fn(state) {
        const {
          rects
        } = state;
        const {
          strategy = "referenceHidden",
          ...detectOverflowOptions
        } = evaluate(options2, state);
        switch (strategy) {
          case "referenceHidden": {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: "reference"
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
          case "escaped": {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
          default: {
            return {};
          }
        }
      }
    };
  };
  const originSides = /* @__PURE__ */ new Set(["left", "top"]);
  async function convertValueToCoords(state, options2) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = originSides.has(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options2, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  const offset$2 = function(options2) {
    if (options2 === void 0) {
      options2 = 0;
    }
    return {
      name: "offset",
      options: options2,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = await convertValueToCoords(state, options2);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  const shift$2 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "shift",
      options: options2,
      async fn(state) {
        const {
          x,
          y,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x2,
                y: y2
              } = _ref;
              return {
                x: x2,
                y: y2
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options2, state);
        const coords = {
          x,
          y
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp$2(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp$2(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  const limitShift$2 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      options: options2,
      fn(state) {
        const {
          x,
          y,
          placement,
          rects,
          middlewareData
        } = state;
        const {
          offset: offset2 = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true
        } = evaluate(options2, state);
        const coords = {
          x,
          y
        };
        const crossAxis = getSideAxis(placement);
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        const rawOffset = evaluate(offset2, state);
        const computedOffset = typeof rawOffset === "number" ? {
          mainAxis: rawOffset,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...rawOffset
        };
        if (checkMainAxis) {
          const len = mainAxis === "y" ? "height" : "width";
          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = mainAxis === "y" ? "width" : "height";
          const isOriginSide = originSides.has(getSide(placement));
          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        };
      }
    };
  };
  const size$2 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "size",
      options: options2,
      async fn(state) {
        var _state$middlewareData, _state$middlewareData2;
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state;
        const {
          apply = () => {
          },
          ...detectOverflowOptions
        } = evaluate(options2, state);
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
          availableWidth = maximumClippingWidth;
        }
        if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow.left, 0);
          const xMax = max(overflow.right, 0);
          const yMin = max(overflow.top, 0);
          const yMax = max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
          }
        }
        await apply({
          ...state,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node2) {
    if (isNode(node2)) {
      return (node2.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node2) {
    var _node$ownerDocument;
    return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node2) {
    var _ref;
    return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement$1(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
  function isOverflowElement(element2) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle$2(element2);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
  }
  const tableElements$1 = /* @__PURE__ */ new Set(["table", "td", "th"]);
  function isTableElement(element2) {
    return tableElements$1.has(getNodeName(element2));
  }
  const topLayerSelectors = [":popover-open", ":modal"];
  function isTopLayer(element2) {
    return topLayerSelectors.some((selector) => {
      try {
        return element2.matches(selector);
      } catch (_e3) {
        return false;
      }
    });
  }
  const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
  const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
  const containValues = ["paint", "layout", "strict", "content"];
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle$2(elementOrCss) : elementOrCss;
    return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
  }
  function getContainingBlock(element2) {
    let currentNode = getParentNode(element2);
    while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
  function isLastTraversableNode(node2) {
    return lastTraversableNodeNames.has(getNodeName(node2));
  }
  function getComputedStyle$2(element2) {
    return getWindow(element2).getComputedStyle(element2);
  }
  function getNodeScroll(element2) {
    if (isElement(element2)) {
      return {
        scrollLeft: element2.scrollLeft,
        scrollTop: element2.scrollTop
      };
    }
    return {
      scrollLeft: element2.scrollX,
      scrollTop: element2.scrollY
    };
  }
  function getParentNode(node2) {
    if (getNodeName(node2) === "html") {
      return node2;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node2.assignedSlot || // DOM Element detected.
      node2.parentNode || // ShadowRoot detected.
      isShadowRoot(node2) && node2.host || // Fallback.
      getDocumentElement(node2)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node2) {
    const parentNode = getParentNode(node2);
    if (isLastTraversableNode(parentNode)) {
      return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
    }
    if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node2, list2, traverseIframes) {
    var _node$ownerDocument2;
    if (list2 === void 0) {
      list2 = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node2);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }
  function getCssDimensions(element2) {
    const css = getComputedStyle$2(element2);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement$1(element2);
    const offsetWidth = hasOffset ? element2.offsetWidth : width;
    const offsetHeight = hasOffset ? element2.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element2) {
    return !isElement(element2) ? element2.contextElement : element2;
  }
  function getScale(element2) {
    const domElement = unwrapElement(element2);
    if (!isHTMLElement$1(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $: $2
    } = getCssDimensions(domElement);
    let x = ($2 ? round(rect.width) : rect.width) / width;
    let y = ($2 ? round(rect.height) : rect.height) / height;
    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y
    };
  }
  const noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element2) {
    const win = getWindow(element2);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element2.getBoundingClientRect();
    const domElement = unwrapElement(element2);
    let scale2 = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale2 = getScale(offsetParent);
        }
      } else {
        scale2 = getScale(element2);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x = (clientRect.left + visualOffsets.x) / scale2.x;
    let y = (clientRect.top + visualOffsets.y) / scale2.y;
    let width = clientRect.width / scale2.x;
    let height = clientRect.height / scale2.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle$2(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x += left;
        y += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x,
      y
    });
  }
  function getWindowScrollBarX(element2, rect) {
    const leftScroll = getNodeScroll(element2).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element2)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
      ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
      // RTL <body> scrollbar.
      getWindowScrollBarX(documentElement, htmlRect)
    ));
    const y = htmlRect.top + scroll.scrollTop;
    return {
      x,
      y
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale2 = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement$1(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale2 = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
    return {
      width: rect.width * scale2.x,
      height: rect.height * scale2.y,
      x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
      y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element2) {
    return Array.from(element2.getClientRects());
  }
  function getDocumentRect(element2) {
    const html2 = getDocumentElement(element2);
    const scroll = getNodeScroll(element2);
    const body = element2.ownerDocument.body;
    const width = max(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element2);
    const y = -scroll.scrollTop;
    if (getComputedStyle$2(body).direction === "rtl") {
      x += max(html2.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function getViewportRect(element2, strategy) {
    const win = getWindow(element2);
    const html2 = getDocumentElement(element2);
    const visualViewport = win.visualViewport;
    let width = html2.clientWidth;
    let height = html2.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
  function getInnerBoundingClientRect(element2, strategy) {
    const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
    const top = clientRect.top + element2.clientTop;
    const left = clientRect.left + element2.clientLeft;
    const scale2 = isHTMLElement$1(element2) ? getScale(element2) : createCoords(1);
    const width = element2.clientWidth * scale2.x;
    const height = element2.clientHeight * scale2.y;
    const x = left * scale2.x;
    const y = top * scale2.y;
    return {
      width,
      height,
      x,
      y
    };
  }
  function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element2, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element2));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element2);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element2, stopNode) {
    const parentNode = getParentNode(element2);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle$2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element2, cache) {
    const cachedResult = cache.get(element2);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element2, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle$2(element2).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element2) : element2;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle$2(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element2, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element: element2,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element2) ? [] : getClippingElementAncestors(element2, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element2) {
    const {
      width,
      height
    } = getCssDimensions(element2);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    function setLeftRTLScrollbarOffset() {
      offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        setLeftRTLScrollbarOffset();
      }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
      setLeftRTLScrollbarOffset();
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x,
      y,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element2) {
    return getComputedStyle$2(element2).position === "static";
  }
  function getTrueOffsetParent(element2, polyfill) {
    if (!isHTMLElement$1(element2) || getComputedStyle$2(element2).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element2);
    }
    let rawOffsetParent = element2.offsetParent;
    if (getDocumentElement(element2) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element2, polyfill) {
    const win = getWindow(element2);
    if (isTopLayer(element2)) {
      return win;
    }
    if (!isHTMLElement$1(element2)) {
      let svgOffsetParent = getParentNode(element2);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element2, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element2) || win;
  }
  const getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element2) {
    return getComputedStyle$2(element2).direction === "rtl";
  }
  const platform$2 = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  function rectsAreEqual(a, b) {
    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
  }
  function observeMove(element2, onMove) {
    let io = null;
    let timeoutId;
    const root2 = getDocumentElement(element2);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const elementRectForRootMargin = element2.getBoundingClientRect();
      const {
        left,
        top,
        width,
        height
      } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root2.clientWidth - (left + width));
      const insetBottom = floor(root2.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options2 = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element2.getBoundingClientRect())) {
          refresh();
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options2,
          // Handle <iframe>s
          root: root2.ownerDocument
        });
      } catch (_e3) {
        io = new IntersectionObserver(handleObserve, options2);
      }
      io.observe(element2);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference, floating, update, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options2;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  const offset$1 = offset$2;
  const shift$1 = shift$2;
  const flip$1 = flip$2;
  const size$1 = size$2;
  const hide$1 = hide$2;
  const arrow$2 = arrow$3;
  const limitShift$1 = limitShift$2;
  const computePosition = (reference, floating, options2) => {
    const cache = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform: platform$2,
      ...options2
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return computePosition$1(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };
  var isClient = typeof document !== "undefined";
  var noop$4 = function noop2() {
  };
  var index$1 = isClient ? reactExports.useLayoutEffect : noop$4;
  function deepEqual$1(a, b) {
    if (a === b) {
      return true;
    }
    if (typeof a !== typeof b) {
      return false;
    }
    if (typeof a === "function" && a.toString() === b.toString()) {
      return true;
    }
    let length;
    let i;
    let keys2;
    if (a && b && typeof a === "object") {
      if (Array.isArray(a)) {
        length = a.length;
        if (length !== b.length) return false;
        for (i = length; i-- !== 0; ) {
          if (!deepEqual$1(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      keys2 = Object.keys(a);
      length = keys2.length;
      if (length !== Object.keys(b).length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (!{}.hasOwnProperty.call(b, keys2[i])) {
          return false;
        }
      }
      for (i = length; i-- !== 0; ) {
        const key = keys2[i];
        if (key === "_owner" && a.$$typeof) {
          continue;
        }
        if (!deepEqual$1(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    return a !== a && b !== b;
  }
  function getDPR(element2) {
    if (typeof window === "undefined") {
      return 1;
    }
    const win = element2.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
  }
  function roundByDPR(element2, value) {
    const dpr = getDPR(element2);
    return Math.round(value * dpr) / dpr;
  }
  function useLatestRef(value) {
    const ref = reactExports.useRef(value);
    index$1(() => {
      ref.current = value;
    });
    return ref;
  }
  function useFloating(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2,
      elements: {
        reference: externalReference,
        floating: externalFloating
      } = {},
      transform = true,
      whileElementsMounted,
      open
    } = options2;
    const [data, setData] = reactExports.useState({
      x: 0,
      y: 0,
      strategy,
      placement,
      middlewareData: {},
      isPositioned: false
    });
    const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
    if (!deepEqual$1(latestMiddleware, middleware)) {
      setLatestMiddleware(middleware);
    }
    const [_reference, _setReference] = reactExports.useState(null);
    const [_floating, _setFloating] = reactExports.useState(null);
    const setReference = reactExports.useCallback((node2) => {
      if (node2 !== referenceRef.current) {
        referenceRef.current = node2;
        _setReference(node2);
      }
    }, []);
    const setFloating = reactExports.useCallback((node2) => {
      if (node2 !== floatingRef.current) {
        floatingRef.current = node2;
        _setFloating(node2);
      }
    }, []);
    const referenceEl = externalReference || _reference;
    const floatingEl = externalFloating || _floating;
    const referenceRef = reactExports.useRef(null);
    const floatingRef = reactExports.useRef(null);
    const dataRef = reactExports.useRef(data);
    const hasWhileElementsMounted = whileElementsMounted != null;
    const whileElementsMountedRef = useLatestRef(whileElementsMounted);
    const platformRef = useLatestRef(platform2);
    const openRef = useLatestRef(open);
    const update = reactExports.useCallback(() => {
      if (!referenceRef.current || !floatingRef.current) {
        return;
      }
      const config = {
        placement,
        strategy,
        middleware: latestMiddleware
      };
      if (platformRef.current) {
        config.platform = platformRef.current;
      }
      computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
        const fullData = {
          ...data2,
          // The floating element's position may be recomputed while it's closed
          // but still mounted (such as when transitioning out). To ensure
          // `isPositioned` will be `false` initially on the next open, avoid
          // setting it to `true` when `open === false` (must be specified).
          isPositioned: openRef.current !== false
        };
        if (isMountedRef.current && !deepEqual$1(dataRef.current, fullData)) {
          dataRef.current = fullData;
          reactDomExports.flushSync(() => {
            setData(fullData);
          });
        }
      });
    }, [latestMiddleware, placement, strategy, platformRef, openRef]);
    index$1(() => {
      if (open === false && dataRef.current.isPositioned) {
        dataRef.current.isPositioned = false;
        setData((data2) => ({
          ...data2,
          isPositioned: false
        }));
      }
    }, [open]);
    const isMountedRef = reactExports.useRef(false);
    index$1(() => {
      isMountedRef.current = true;
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    index$1(() => {
      if (referenceEl) referenceRef.current = referenceEl;
      if (floatingEl) floatingRef.current = floatingEl;
      if (referenceEl && floatingEl) {
        if (whileElementsMountedRef.current) {
          return whileElementsMountedRef.current(referenceEl, floatingEl, update);
        }
        update();
      }
    }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
    const refs = reactExports.useMemo(() => ({
      reference: referenceRef,
      floating: floatingRef,
      setReference,
      setFloating
    }), [setReference, setFloating]);
    const elements = reactExports.useMemo(() => ({
      reference: referenceEl,
      floating: floatingEl
    }), [referenceEl, floatingEl]);
    const floatingStyles = reactExports.useMemo(() => {
      const initialStyles = {
        position: strategy,
        left: 0,
        top: 0
      };
      if (!elements.floating) {
        return initialStyles;
      }
      const x = roundByDPR(elements.floating, data.x);
      const y = roundByDPR(elements.floating, data.y);
      if (transform) {
        return {
          ...initialStyles,
          transform: "translate(" + x + "px, " + y + "px)",
          ...getDPR(elements.floating) >= 1.5 && {
            willChange: "transform"
          }
        };
      }
      return {
        position: strategy,
        left: x,
        top: y
      };
    }, [strategy, transform, elements.floating, data.x, data.y]);
    return reactExports.useMemo(() => ({
      ...data,
      update,
      refs,
      elements,
      floatingStyles
    }), [data, update, refs, elements, floatingStyles]);
  }
  const arrow$1 = (options2) => {
    function isRef(value) {
      return {}.hasOwnProperty.call(value, "current");
    }
    return {
      name: "arrow",
      options: options2,
      fn(state) {
        const {
          element: element2,
          padding
        } = typeof options2 === "function" ? options2(state) : options2;
        if (element2 && isRef(element2)) {
          if (element2.current != null) {
            return arrow$2({
              element: element2.current,
              padding
            }).fn(state);
          }
          return {};
        }
        if (element2) {
          return arrow$2({
            element: element2,
            padding
          }).fn(state);
        }
        return {};
      }
    };
  };
  const offset = (options2, deps) => ({
    ...offset$1(options2),
    options: [options2, deps]
  });
  const shift = (options2, deps) => ({
    ...shift$1(options2),
    options: [options2, deps]
  });
  const limitShift = (options2, deps) => ({
    ...limitShift$1(options2),
    options: [options2, deps]
  });
  const flip = (options2, deps) => ({
    ...flip$1(options2),
    options: [options2, deps]
  });
  const size = (options2, deps) => ({
    ...size$1(options2),
    options: [options2, deps]
  });
  const hide = (options2, deps) => ({
    ...hide$1(options2),
    options: [options2, deps]
  });
  const arrow = (options2, deps) => ({
    ...arrow$1(options2),
    options: [options2, deps]
  });
  var NAME$2 = "Arrow";
  var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { children, width = 10, height = 5, ...arrowProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.svg,
      {
        ...arrowProps,
        ref: forwardedRef,
        width,
        height,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
      }
    );
  });
  Arrow$1.displayName = NAME$2;
  var Root$5 = Arrow$1;
  function useSize(element2) {
    const [size2, setSize] = reactExports.useState(void 0);
    useLayoutEffect2(() => {
      if (element2) {
        setSize({ width: element2.offsetWidth, height: element2.offsetHeight });
        const resizeObserver = new ResizeObserver((entries) => {
          if (!Array.isArray(entries)) {
            return;
          }
          if (!entries.length) {
            return;
          }
          const entry = entries[0];
          let width;
          let height;
          if ("borderBoxSize" in entry) {
            const borderSizeEntry = entry["borderBoxSize"];
            const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
            width = borderSize["inlineSize"];
            height = borderSize["blockSize"];
          } else {
            width = element2.offsetWidth;
            height = element2.offsetHeight;
          }
          setSize({ width, height });
        });
        resizeObserver.observe(element2, { box: "border-box" });
        return () => resizeObserver.unobserve(element2);
      } else {
        setSize(void 0);
      }
    }, [element2]);
    return size2;
  }
  var POPPER_NAME = "Popper";
  var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
  var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
  var Popper = (props) => {
    const { __scopePopper, children } = props;
    const [anchor, setAnchor] = reactExports.useState(null);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
  };
  Popper.displayName = POPPER_NAME;
  var ANCHOR_NAME$1 = "PopperAnchor";
  var PopperAnchor = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopePopper, virtualRef, ...anchorProps } = props;
      const context = usePopperContext(ANCHOR_NAME$1, __scopePopper);
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, ref);
      reactExports.useEffect(() => {
        context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
      });
      return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
    }
  );
  PopperAnchor.displayName = ANCHOR_NAME$1;
  var CONTENT_NAME$5 = "PopperContent";
  var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$5);
  var PopperContent = reactExports.forwardRef(
    (props, forwardedRef) => {
      var _a2, _b2, _c2, _d2, _e3, _f2;
      const {
        __scopePopper,
        side = "bottom",
        sideOffset = 0,
        align = "center",
        alignOffset = 0,
        arrowPadding = 0,
        avoidCollisions = true,
        collisionBoundary = [],
        collisionPadding: collisionPaddingProp = 0,
        sticky = "partial",
        hideWhenDetached = false,
        updatePositionStrategy = "optimized",
        onPlaced,
        ...contentProps
      } = props;
      const context = usePopperContext(CONTENT_NAME$5, __scopePopper);
      const [content2, setContent] = reactExports.useState(null);
      const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setContent(node2));
      const [arrow$12, setArrow] = reactExports.useState(null);
      const arrowSize = useSize(arrow$12);
      const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
      const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
      const desiredPlacement = side + (align !== "center" ? "-" + align : "");
      const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
      const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
      const hasExplicitBoundaries = boundary.length > 0;
      const detectOverflowOptions = {
        padding: collisionPadding,
        boundary: boundary.filter(isNotNull$2),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: hasExplicitBoundaries
      };
      const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
        // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
        strategy: "fixed",
        placement: desiredPlacement,
        whileElementsMounted: (...args) => {
          const cleanup = autoUpdate(...args, {
            animationFrame: updatePositionStrategy === "always"
          });
          return cleanup;
        },
        elements: {
          reference: context.anchor
        },
        middleware: [
          offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
          avoidCollisions && shift({
            mainAxis: true,
            crossAxis: false,
            limiter: sticky === "partial" ? limitShift() : void 0,
            ...detectOverflowOptions
          }),
          avoidCollisions && flip({ ...detectOverflowOptions }),
          size({
            ...detectOverflowOptions,
            apply: ({ elements, rects, availableWidth, availableHeight }) => {
              const { width: anchorWidth, height: anchorHeight } = rects.reference;
              const contentStyle = elements.floating.style;
              contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
              contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
              contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
              contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
            }
          }),
          arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
          transformOrigin({ arrowWidth, arrowHeight }),
          hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
        ]
      });
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const handlePlaced = useCallbackRef$1(onPlaced);
      useLayoutEffect2(() => {
        if (isPositioned) {
          handlePlaced == null ? void 0 : handlePlaced();
        }
      }, [isPositioned, handlePlaced]);
      const arrowX = (_a2 = middlewareData.arrow) == null ? void 0 : _a2.x;
      const arrowY = (_b2 = middlewareData.arrow) == null ? void 0 : _b2.y;
      const cannotCenterArrow = ((_c2 = middlewareData.arrow) == null ? void 0 : _c2.centerOffset) !== 0;
      const [contentZIndex, setContentZIndex] = reactExports.useState();
      useLayoutEffect2(() => {
        if (content2) setContentZIndex(window.getComputedStyle(content2).zIndex);
      }, [content2]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: refs.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
            ...floatingStyles,
            transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
            // keep off the page when measuring
            minWidth: "max-content",
            zIndex: contentZIndex,
            ["--radix-popper-transform-origin"]: [
              (_d2 = middlewareData.transformOrigin) == null ? void 0 : _d2.x,
              (_e3 = middlewareData.transformOrigin) == null ? void 0 : _e3.y
            ].join(" "),
            // hide the content if using the hide middleware and should be hidden
            // set visibility to hidden and disable pointer events so the UI behaves
            // as if the PopperContent isn't there at all
            ...((_f2 = middlewareData.hide) == null ? void 0 : _f2.referenceHidden) && {
              visibility: "hidden",
              pointerEvents: "none"
            }
          },
          dir: props.dir,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            PopperContentProvider,
            {
              scope: __scopePopper,
              placedSide,
              onArrowChange: setArrow,
              arrowX,
              arrowY,
              shouldHideArrow: cannotCenterArrow,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Primitive.div,
                {
                  "data-side": placedSide,
                  "data-align": placedAlign,
                  ...contentProps,
                  ref: composedRefs,
                  style: {
                    ...contentProps.style,
                    // if the PopperContent hasn't been placed yet (not all measurements done)
                    // we prevent animations so that users's animation don't kick in too early referring wrong sides
                    animation: !isPositioned ? "none" : void 0
                  }
                }
              )
            }
          )
        }
      );
    }
  );
  PopperContent.displayName = CONTENT_NAME$5;
  var ARROW_NAME$4 = "PopperArrow";
  var OPPOSITE_SIDE = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  };
  var PopperArrow = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
    const { __scopePopper, ...arrowProps } = props;
    const contentContext = useContentContext(ARROW_NAME$4, __scopePopper);
    const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
    return (
      // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
      // doesn't report size as we'd expect on SVG elements.
      // it reports their bounding box which is effectively the largest path inside the SVG.
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          ref: contentContext.onArrowChange,
          style: {
            position: "absolute",
            left: contentContext.arrowX,
            top: contentContext.arrowY,
            [baseSide]: 0,
            transformOrigin: {
              top: "",
              right: "0 0",
              bottom: "center 0",
              left: "100% 0"
            }[contentContext.placedSide],
            transform: {
              top: "translateY(100%)",
              right: "translateY(50%) rotate(90deg) translateX(-50%)",
              bottom: `rotate(180deg)`,
              left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[contentContext.placedSide],
            visibility: contentContext.shouldHideArrow ? "hidden" : void 0
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Root$5,
            {
              ...arrowProps,
              ref: forwardedRef,
              style: {
                ...arrowProps.style,
                // ensures the element can be measured correctly (mostly for if SVG)
                display: "block"
              }
            }
          )
        }
      )
    );
  });
  PopperArrow.displayName = ARROW_NAME$4;
  function isNotNull$2(value) {
    return value !== null;
  }
  var transformOrigin = (options2) => ({
    name: "transformOrigin",
    options: options2,
    fn(data) {
      var _a2, _b2, _c2;
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = ((_a2 = middlewareData.arrow) == null ? void 0 : _a2.centerOffset) !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options2.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options2.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (((_b2 = middlewareData.arrow) == null ? void 0 : _b2.x) ?? 0) + arrowWidth / 2;
      const arrowYCenter = (((_c2 = middlewareData.arrow) == null ? void 0 : _c2.y) ?? 0) + arrowHeight / 2;
      let x = "";
      let y = "";
      if (placedSide === "bottom") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x, y } };
    }
  });
  function getSideAndAlignFromPlacement(placement) {
    const [side, align = "center"] = placement.split("-");
    return [side, align];
  }
  var Root2$2 = Popper;
  var Anchor = PopperAnchor;
  var Content$1 = PopperContent;
  var Arrow = PopperArrow;
  var PORTAL_NAME$5 = "Portal";
  var Portal$4 = reactExports.forwardRef((props, forwardedRef) => {
    var _a2;
    const { container: containerProp, ...portalProps } = props;
    const [mounted, setMounted] = reactExports.useState(false);
    useLayoutEffect2(() => setMounted(true), []);
    const container = containerProp || mounted && ((_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body);
    return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
  });
  Portal$4.displayName = PORTAL_NAME$5;
  var VISUALLY_HIDDEN_STYLES = Object.freeze({
    // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  });
  var NAME$1 = "VisuallyHidden";
  var VisuallyHidden = reactExports.forwardRef(
    (props, forwardedRef) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          ...props,
          ref: forwardedRef,
          style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
        }
      );
    }
  );
  VisuallyHidden.displayName = NAME$1;
  var Root$4 = VisuallyHidden;
  var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
    createPopperScope
  ]);
  var usePopperScope$2 = createPopperScope();
  var PROVIDER_NAME = "TooltipProvider";
  var DEFAULT_DELAY_DURATION = 700;
  var TOOLTIP_OPEN = "tooltip.open";
  var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
  var TooltipProvider$1 = (props) => {
    const {
      __scopeTooltip,
      delayDuration = DEFAULT_DELAY_DURATION,
      skipDelayDuration = 300,
      disableHoverableContent = false,
      children
    } = props;
    const isOpenDelayedRef = reactExports.useRef(true);
    const isPointerInTransitRef = reactExports.useRef(false);
    const skipDelayTimerRef = reactExports.useRef(0);
    reactExports.useEffect(() => {
      const skipDelayTimer = skipDelayTimerRef.current;
      return () => window.clearTimeout(skipDelayTimer);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TooltipProviderContextProvider,
      {
        scope: __scopeTooltip,
        isOpenDelayedRef,
        delayDuration,
        onOpen: reactExports.useCallback(() => {
          window.clearTimeout(skipDelayTimerRef.current);
          isOpenDelayedRef.current = false;
        }, []),
        onClose: reactExports.useCallback(() => {
          window.clearTimeout(skipDelayTimerRef.current);
          skipDelayTimerRef.current = window.setTimeout(
            () => isOpenDelayedRef.current = true,
            skipDelayDuration
          );
        }, [skipDelayDuration]),
        isPointerInTransitRef,
        onPointerInTransitChange: reactExports.useCallback((inTransit) => {
          isPointerInTransitRef.current = inTransit;
        }, []),
        disableHoverableContent,
        children
      }
    );
  };
  TooltipProvider$1.displayName = PROVIDER_NAME;
  var TOOLTIP_NAME = "Tooltip";
  var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
  var TRIGGER_NAME$4 = "TooltipTrigger";
  var TooltipTrigger = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeTooltip, ...triggerProps } = props;
      const context = useTooltipContext(TRIGGER_NAME$4, __scopeTooltip);
      const providerContext = useTooltipProviderContext(TRIGGER_NAME$4, __scopeTooltip);
      const popperScope = usePopperScope$2(__scopeTooltip);
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, ref, context.onTriggerChange);
      const isPointerDownRef = reactExports.useRef(false);
      const hasPointerMoveOpenedRef = reactExports.useRef(false);
      const handlePointerUp = reactExports.useCallback(() => isPointerDownRef.current = false, []);
      reactExports.useEffect(() => {
        return () => document.removeEventListener("pointerup", handlePointerUp);
      }, [handlePointerUp]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          "aria-describedby": context.open ? context.contentId : void 0,
          "data-state": context.stateAttribute,
          ...triggerProps,
          ref: composedRefs,
          onPointerMove: composeEventHandlers$1(props.onPointerMove, (event) => {
            if (event.pointerType === "touch") return;
            if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
              context.onTriggerEnter();
              hasPointerMoveOpenedRef.current = true;
            }
          }),
          onPointerLeave: composeEventHandlers$1(props.onPointerLeave, () => {
            context.onTriggerLeave();
            hasPointerMoveOpenedRef.current = false;
          }),
          onPointerDown: composeEventHandlers$1(props.onPointerDown, () => {
            if (context.open) {
              context.onClose();
            }
            isPointerDownRef.current = true;
            document.addEventListener("pointerup", handlePointerUp, { once: true });
          }),
          onFocus: composeEventHandlers$1(props.onFocus, () => {
            if (!isPointerDownRef.current) context.onOpen();
          }),
          onBlur: composeEventHandlers$1(props.onBlur, context.onClose),
          onClick: composeEventHandlers$1(props.onClick, context.onClose)
        }
      ) });
    }
  );
  TooltipTrigger.displayName = TRIGGER_NAME$4;
  var PORTAL_NAME$4 = "TooltipPortal";
  var [PortalProvider$2, usePortalContext$2] = createTooltipContext(PORTAL_NAME$4, {
    forceMount: void 0
  });
  var TooltipPortal = (props) => {
    const { __scopeTooltip, forceMount, children, container } = props;
    const context = useTooltipContext(PORTAL_NAME$4, __scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$2, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$4, { asChild: true, container, children }) }) });
  };
  TooltipPortal.displayName = PORTAL_NAME$4;
  var CONTENT_NAME$4 = "TooltipContent";
  var TooltipContent$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext$2(CONTENT_NAME$4, props.__scopeTooltip);
      const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
      const context = useTooltipContext(CONTENT_NAME$4, props.__scopeTooltip);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
    }
  );
  var TooltipContentHoverable = reactExports.forwardRef((props, forwardedRef) => {
    const context = useTooltipContext(CONTENT_NAME$4, props.__scopeTooltip);
    const providerContext = useTooltipProviderContext(CONTENT_NAME$4, props.__scopeTooltip);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref);
    const [pointerGraceArea, setPointerGraceArea] = reactExports.useState(null);
    const { trigger, onClose } = context;
    const content2 = ref.current;
    const { onPointerInTransitChange } = providerContext;
    const handleRemoveGraceArea = reactExports.useCallback(() => {
      setPointerGraceArea(null);
      onPointerInTransitChange(false);
    }, [onPointerInTransitChange]);
    const handleCreateGraceArea = reactExports.useCallback(
      (event, hoverTarget) => {
        const currentTarget = event.currentTarget;
        const exitPoint = { x: event.clientX, y: event.clientY };
        const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
        const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
        const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
        const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
        setPointerGraceArea(graceArea);
        onPointerInTransitChange(true);
      },
      [onPointerInTransitChange]
    );
    reactExports.useEffect(() => {
      return () => handleRemoveGraceArea();
    }, [handleRemoveGraceArea]);
    reactExports.useEffect(() => {
      if (trigger && content2) {
        const handleTriggerLeave = (event) => handleCreateGraceArea(event, content2);
        const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
        trigger.addEventListener("pointerleave", handleTriggerLeave);
        content2.addEventListener("pointerleave", handleContentLeave);
        return () => {
          trigger.removeEventListener("pointerleave", handleTriggerLeave);
          content2.removeEventListener("pointerleave", handleContentLeave);
        };
      }
    }, [trigger, content2, handleCreateGraceArea, handleRemoveGraceArea]);
    reactExports.useEffect(() => {
      if (pointerGraceArea) {
        const handleTrackPointerGrace = (event) => {
          const target = event.target;
          const pointerPosition = { x: event.clientX, y: event.clientY };
          const hasEnteredTarget = (trigger == null ? void 0 : trigger.contains(target)) || (content2 == null ? void 0 : content2.contains(target));
          const isPointerOutsideGraceArea = !isPointInPolygon$1(pointerPosition, pointerGraceArea);
          if (hasEnteredTarget) {
            handleRemoveGraceArea();
          } else if (isPointerOutsideGraceArea) {
            handleRemoveGraceArea();
            onClose();
          }
        };
        document.addEventListener("pointermove", handleTrackPointerGrace);
        return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
      }
    }, [trigger, content2, pointerGraceArea, onClose, handleRemoveGraceArea]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
  });
  var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
  var Slottable = /* @__PURE__ */ createSlottable("TooltipContent");
  var TooltipContentImpl = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeTooltip,
        children,
        "aria-label": ariaLabel,
        onEscapeKeyDown,
        onPointerDownOutside,
        ...contentProps
      } = props;
      const context = useTooltipContext(CONTENT_NAME$4, __scopeTooltip);
      const popperScope = usePopperScope$2(__scopeTooltip);
      const { onClose } = context;
      reactExports.useEffect(() => {
        document.addEventListener(TOOLTIP_OPEN, onClose);
        return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
      }, [onClose]);
      reactExports.useEffect(() => {
        if (context.trigger) {
          const handleScroll2 = (event) => {
            const target = event.target;
            if (target == null ? void 0 : target.contains(context.trigger)) onClose();
          };
          window.addEventListener("scroll", handleScroll2, { capture: true });
          return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
        }
      }, [context.trigger, onClose]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        DismissableLayer,
        {
          asChild: true,
          disableOutsidePointerEvents: false,
          onEscapeKeyDown,
          onPointerDownOutside,
          onFocusOutside: (event) => event.preventDefault(),
          onDismiss: onClose,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Content$1,
            {
              "data-state": context.stateAttribute,
              ...popperScope,
              ...contentProps,
              ref: forwardedRef,
              style: {
                ...contentProps.style,
                // re-namespace exposed content custom properties
                ...{
                  "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
                }
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$4, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
              ]
            }
          )
        }
      );
    }
  );
  TooltipContent$1.displayName = CONTENT_NAME$4;
  var ARROW_NAME$3 = "TooltipArrow";
  var TooltipArrow$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeTooltip, ...arrowProps } = props;
      const popperScope = usePopperScope$2(__scopeTooltip);
      const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
        ARROW_NAME$3,
        __scopeTooltip
      );
      return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
    }
  );
  TooltipArrow$1.displayName = ARROW_NAME$3;
  function getExitSideFromRect(point2, rect) {
    const top = Math.abs(rect.top - point2.y);
    const bottom = Math.abs(rect.bottom - point2.y);
    const right = Math.abs(rect.right - point2.x);
    const left = Math.abs(rect.left - point2.x);
    switch (Math.min(top, bottom, right, left)) {
      case left:
        return "left";
      case right:
        return "right";
      case top:
        return "top";
      case bottom:
        return "bottom";
      default:
        throw new Error("unreachable");
    }
  }
  function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
    const paddedExitPoints = [];
    switch (exitSide) {
      case "top":
        paddedExitPoints.push(
          { x: exitPoint.x - padding, y: exitPoint.y + padding },
          { x: exitPoint.x + padding, y: exitPoint.y + padding }
        );
        break;
      case "bottom":
        paddedExitPoints.push(
          { x: exitPoint.x - padding, y: exitPoint.y - padding },
          { x: exitPoint.x + padding, y: exitPoint.y - padding }
        );
        break;
      case "left":
        paddedExitPoints.push(
          { x: exitPoint.x + padding, y: exitPoint.y - padding },
          { x: exitPoint.x + padding, y: exitPoint.y + padding }
        );
        break;
      case "right":
        paddedExitPoints.push(
          { x: exitPoint.x - padding, y: exitPoint.y - padding },
          { x: exitPoint.x - padding, y: exitPoint.y + padding }
        );
        break;
    }
    return paddedExitPoints;
  }
  function getPointsFromRect(rect) {
    const { top, right, bottom, left } = rect;
    return [
      { x: left, y: top },
      { x: right, y: top },
      { x: right, y: bottom },
      { x: left, y: bottom }
    ];
  }
  function isPointInPolygon$1(point2, polygon) {
    const { x, y } = point2;
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const ii = polygon[i];
      const jj = polygon[j];
      const xi = ii.x;
      const yi = ii.y;
      const xj = jj.x;
      const yj = jj.y;
      const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function getHull(points) {
    const newPoints = points.slice();
    newPoints.sort((a, b) => {
      if (a.x < b.x) return -1;
      else if (a.x > b.x) return 1;
      else if (a.y < b.y) return -1;
      else if (a.y > b.y) return 1;
      else return 0;
    });
    return getHullPresorted(newPoints);
  }
  function getHullPresorted(points) {
    if (points.length <= 1) return points.slice();
    const upperHull = [];
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      while (upperHull.length >= 2) {
        const q = upperHull[upperHull.length - 1];
        const r2 = upperHull[upperHull.length - 2];
        if ((q.x - r2.x) * (p.y - r2.y) >= (q.y - r2.y) * (p.x - r2.x)) upperHull.pop();
        else break;
      }
      upperHull.push(p);
    }
    upperHull.pop();
    const lowerHull = [];
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      while (lowerHull.length >= 2) {
        const q = lowerHull[lowerHull.length - 1];
        const r2 = lowerHull[lowerHull.length - 2];
        if ((q.x - r2.x) * (p.y - r2.y) >= (q.y - r2.y) * (p.x - r2.x)) lowerHull.pop();
        else break;
      }
      lowerHull.push(p);
    }
    lowerHull.pop();
    if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
      return upperHull;
    } else {
      return upperHull.concat(lowerHull);
    }
  }
  var Provider$1 = TooltipProvider$1;
  var Portal$3 = TooltipPortal;
  var Content2$3 = TooltipContent$1;
  var Arrow2$1 = TooltipArrow$1;
  function isObject$4(subject) {
    return Object.prototype.toString.call(subject) === "[object Object]";
  }
  function isRecord(subject) {
    return isObject$4(subject) || Array.isArray(subject);
  }
  function canUseDOM() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  function areOptionsEqual(optionsA, optionsB) {
    const optionsAKeys = Object.keys(optionsA);
    const optionsBKeys = Object.keys(optionsB);
    if (optionsAKeys.length !== optionsBKeys.length) return false;
    const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}));
    const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}));
    if (breakpointsA !== breakpointsB) return false;
    return optionsAKeys.every((key) => {
      const valueA = optionsA[key];
      const valueB = optionsB[key];
      if (typeof valueA === "function") return `${valueA}` === `${valueB}`;
      if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB;
      return areOptionsEqual(valueA, valueB);
    });
  }
  function sortAndMapPluginToOptions(plugins) {
    return plugins.concat().sort((a, b) => a.name > b.name ? 1 : -1).map((plugin) => plugin.options);
  }
  function arePluginsEqual(pluginsA, pluginsB) {
    if (pluginsA.length !== pluginsB.length) return false;
    const optionsA = sortAndMapPluginToOptions(pluginsA);
    const optionsB = sortAndMapPluginToOptions(pluginsB);
    return optionsA.every((optionA, index2) => {
      const optionB = optionsB[index2];
      return areOptionsEqual(optionA, optionB);
    });
  }
  function isNumber$1(subject) {
    return typeof subject === "number";
  }
  function isString$1(subject) {
    return typeof subject === "string";
  }
  function isBoolean$1(subject) {
    return typeof subject === "boolean";
  }
  function isObject$3(subject) {
    return Object.prototype.toString.call(subject) === "[object Object]";
  }
  function mathAbs(n) {
    return Math.abs(n);
  }
  function mathSign(n) {
    return Math.sign(n);
  }
  function deltaAbs(valueB, valueA) {
    return mathAbs(valueB - valueA);
  }
  function factorAbs(valueB, valueA) {
    if (valueB === 0 || valueA === 0) return 0;
    if (mathAbs(valueB) <= mathAbs(valueA)) return 0;
    const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));
    return mathAbs(diff / valueB);
  }
  function roundToTwoDecimals(num) {
    return Math.round(num * 100) / 100;
  }
  function arrayKeys(array) {
    return objectKeys(array).map(Number);
  }
  function arrayLast(array) {
    return array[arrayLastIndex(array)];
  }
  function arrayLastIndex(array) {
    return Math.max(0, array.length - 1);
  }
  function arrayIsLastIndex(array, index2) {
    return index2 === arrayLastIndex(array);
  }
  function arrayFromNumber(n, startAt = 0) {
    return Array.from(Array(n), (_, i) => startAt + i);
  }
  function objectKeys(object) {
    return Object.keys(object);
  }
  function objectsMergeDeep(objectA, objectB) {
    return [objectA, objectB].reduce((mergedObjects, currentObject) => {
      objectKeys(currentObject).forEach((key) => {
        const valueA = mergedObjects[key];
        const valueB = currentObject[key];
        const areObjects = isObject$3(valueA) && isObject$3(valueB);
        mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;
      });
      return mergedObjects;
    }, {});
  }
  function isMouseEvent(evt, ownerWindow) {
    return typeof ownerWindow.MouseEvent !== "undefined" && evt instanceof ownerWindow.MouseEvent;
  }
  function Alignment(align, viewSize) {
    const predefined = {
      start,
      center,
      end
    };
    function start() {
      return 0;
    }
    function center(n) {
      return end(n) / 2;
    }
    function end(n) {
      return viewSize - n;
    }
    function measure(n, index2) {
      if (isString$1(align)) return predefined[align](n);
      return align(viewSize, n, index2);
    }
    const self2 = {
      measure
    };
    return self2;
  }
  function EventStore() {
    let listeners = [];
    function add(node2, type, handler, options2 = {
      passive: true
    }) {
      let removeListener;
      if ("addEventListener" in node2) {
        node2.addEventListener(type, handler, options2);
        removeListener = () => node2.removeEventListener(type, handler, options2);
      } else {
        const legacyMediaQueryList = node2;
        legacyMediaQueryList.addListener(handler);
        removeListener = () => legacyMediaQueryList.removeListener(handler);
      }
      listeners.push(removeListener);
      return self2;
    }
    function clear() {
      listeners = listeners.filter((remove) => remove());
    }
    const self2 = {
      add,
      clear
    };
    return self2;
  }
  function Animations(ownerDocument, ownerWindow, update, render) {
    const documentVisibleHandler = EventStore();
    const fixedTimeStep = 1e3 / 60;
    let lastTimeStamp = null;
    let accumulatedTime = 0;
    let animationId = 0;
    function init() {
      documentVisibleHandler.add(ownerDocument, "visibilitychange", () => {
        if (ownerDocument.hidden) reset();
      });
    }
    function destroy() {
      stop();
      documentVisibleHandler.clear();
    }
    function animate(timeStamp) {
      if (!animationId) return;
      if (!lastTimeStamp) {
        lastTimeStamp = timeStamp;
        update();
        update();
      }
      const timeElapsed = timeStamp - lastTimeStamp;
      lastTimeStamp = timeStamp;
      accumulatedTime += timeElapsed;
      while (accumulatedTime >= fixedTimeStep) {
        update();
        accumulatedTime -= fixedTimeStep;
      }
      const alpha2 = accumulatedTime / fixedTimeStep;
      render(alpha2);
      if (animationId) {
        animationId = ownerWindow.requestAnimationFrame(animate);
      }
    }
    function start() {
      if (animationId) return;
      animationId = ownerWindow.requestAnimationFrame(animate);
    }
    function stop() {
      ownerWindow.cancelAnimationFrame(animationId);
      lastTimeStamp = null;
      accumulatedTime = 0;
      animationId = 0;
    }
    function reset() {
      lastTimeStamp = null;
      accumulatedTime = 0;
    }
    const self2 = {
      init,
      destroy,
      start,
      stop,
      update,
      render
    };
    return self2;
  }
  function Axis(axis, contentDirection) {
    const isRightToLeft = contentDirection === "rtl";
    const isVertical = axis === "y";
    const scroll = isVertical ? "y" : "x";
    const cross = isVertical ? "x" : "y";
    const sign = !isVertical && isRightToLeft ? -1 : 1;
    const startEdge = getStartEdge();
    const endEdge = getEndEdge();
    function measureSize(nodeRect) {
      const {
        height,
        width
      } = nodeRect;
      return isVertical ? height : width;
    }
    function getStartEdge() {
      if (isVertical) return "top";
      return isRightToLeft ? "right" : "left";
    }
    function getEndEdge() {
      if (isVertical) return "bottom";
      return isRightToLeft ? "left" : "right";
    }
    function direction(n) {
      return n * sign;
    }
    const self2 = {
      scroll,
      cross,
      startEdge,
      endEdge,
      measureSize,
      direction
    };
    return self2;
  }
  function Limit(min2 = 0, max2 = 0) {
    const length = mathAbs(min2 - max2);
    function reachedMin(n) {
      return n < min2;
    }
    function reachedMax(n) {
      return n > max2;
    }
    function reachedAny(n) {
      return reachedMin(n) || reachedMax(n);
    }
    function constrain(n) {
      if (!reachedAny(n)) return n;
      return reachedMin(n) ? min2 : max2;
    }
    function removeOffset(n) {
      if (!length) return n;
      return n - length * Math.ceil((n - max2) / length);
    }
    const self2 = {
      length,
      max: max2,
      min: min2,
      constrain,
      reachedAny,
      reachedMax,
      reachedMin,
      removeOffset
    };
    return self2;
  }
  function Counter(max2, start, loop) {
    const {
      constrain
    } = Limit(0, max2);
    const loopEnd = max2 + 1;
    let counter = withinLimit(start);
    function withinLimit(n) {
      return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);
    }
    function get() {
      return counter;
    }
    function set(n) {
      counter = withinLimit(n);
      return self2;
    }
    function add(n) {
      return clone().set(get() + n);
    }
    function clone() {
      return Counter(max2, get(), loop);
    }
    const self2 = {
      get,
      set,
      add,
      clone
    };
    return self2;
  }
  function DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location2, animation, scrollTo, scrollBody, scrollTarget, index2, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {
    const {
      cross: crossAxis,
      direction
    } = axis;
    const focusNodes = ["INPUT", "SELECT", "TEXTAREA"];
    const nonPassiveEvent = {
      passive: false
    };
    const initEvents = EventStore();
    const dragEvents = EventStore();
    const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));
    const snapForceBoost = {
      mouse: 300,
      touch: 400
    };
    const freeForceBoost = {
      mouse: 500,
      touch: 600
    };
    const baseSpeed = dragFree ? 43 : 25;
    let isMoving = false;
    let startScroll = 0;
    let startCross = 0;
    let pointerIsDown = false;
    let preventScroll = false;
    let preventClick = false;
    let isMouse = false;
    function init(emblaApi) {
      if (!watchDrag) return;
      function downIfAllowed(evt) {
        if (isBoolean$1(watchDrag) || watchDrag(emblaApi, evt)) down(evt);
      }
      const node2 = rootNode;
      initEvents.add(node2, "dragstart", (evt) => evt.preventDefault(), nonPassiveEvent).add(node2, "touchmove", () => void 0, nonPassiveEvent).add(node2, "touchend", () => void 0).add(node2, "touchstart", downIfAllowed).add(node2, "mousedown", downIfAllowed).add(node2, "touchcancel", up).add(node2, "contextmenu", up).add(node2, "click", click, true);
    }
    function destroy() {
      initEvents.clear();
      dragEvents.clear();
    }
    function addDragEvents() {
      const node2 = isMouse ? ownerDocument : rootNode;
      dragEvents.add(node2, "touchmove", move, nonPassiveEvent).add(node2, "touchend", up).add(node2, "mousemove", move, nonPassiveEvent).add(node2, "mouseup", up);
    }
    function isFocusNode(node2) {
      const nodeName = node2.nodeName || "";
      return focusNodes.includes(nodeName);
    }
    function forceBoost() {
      const boost = dragFree ? freeForceBoost : snapForceBoost;
      const type = isMouse ? "mouse" : "touch";
      return boost[type];
    }
    function allowedForce(force, targetChanged) {
      const next = index2.add(mathSign(force) * -1);
      const baseForce = scrollTarget.byDistance(force, !dragFree).distance;
      if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;
      if (skipSnaps && targetChanged) return baseForce * 0.5;
      return scrollTarget.byIndex(next.get(), 0).distance;
    }
    function down(evt) {
      const isMouseEvt = isMouseEvent(evt, ownerWindow);
      isMouse = isMouseEvt;
      preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;
      isMoving = deltaAbs(target.get(), location2.get()) >= 2;
      if (isMouseEvt && evt.button !== 0) return;
      if (isFocusNode(evt.target)) return;
      pointerIsDown = true;
      dragTracker.pointerDown(evt);
      scrollBody.useFriction(0).useDuration(0);
      target.set(location2);
      addDragEvents();
      startScroll = dragTracker.readPoint(evt);
      startCross = dragTracker.readPoint(evt, crossAxis);
      eventHandler.emit("pointerDown");
    }
    function move(evt) {
      const isTouchEvt = !isMouseEvent(evt, ownerWindow);
      if (isTouchEvt && evt.touches.length >= 2) return up(evt);
      const lastScroll = dragTracker.readPoint(evt);
      const lastCross = dragTracker.readPoint(evt, crossAxis);
      const diffScroll = deltaAbs(lastScroll, startScroll);
      const diffCross = deltaAbs(lastCross, startCross);
      if (!preventScroll && !isMouse) {
        if (!evt.cancelable) return up(evt);
        preventScroll = diffScroll > diffCross;
        if (!preventScroll) return up(evt);
      }
      const diff = dragTracker.pointerMove(evt);
      if (diffScroll > dragThreshold) preventClick = true;
      scrollBody.useFriction(0.3).useDuration(0.75);
      animation.start();
      target.add(direction(diff));
      evt.preventDefault();
    }
    function up(evt) {
      const currentLocation = scrollTarget.byDistance(0, false);
      const targetChanged = currentLocation.index !== index2.get();
      const rawForce = dragTracker.pointerUp(evt) * forceBoost();
      const force = allowedForce(direction(rawForce), targetChanged);
      const forceFactor = factorAbs(rawForce, force);
      const speed = baseSpeed - 10 * forceFactor;
      const friction = baseFriction + forceFactor / 50;
      preventScroll = false;
      pointerIsDown = false;
      dragEvents.clear();
      scrollBody.useDuration(speed).useFriction(friction);
      scrollTo.distance(force, !dragFree);
      isMouse = false;
      eventHandler.emit("pointerUp");
    }
    function click(evt) {
      if (preventClick) {
        evt.stopPropagation();
        evt.preventDefault();
        preventClick = false;
      }
    }
    function pointerDown() {
      return pointerIsDown;
    }
    const self2 = {
      init,
      destroy,
      pointerDown
    };
    return self2;
  }
  function DragTracker(axis, ownerWindow) {
    const logInterval = 170;
    let startEvent;
    let lastEvent;
    function readTime(evt) {
      return evt.timeStamp;
    }
    function readPoint(evt, evtAxis) {
      const property = evtAxis || axis.scroll;
      const coord = `client${property === "x" ? "X" : "Y"}`;
      return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];
    }
    function pointerDown(evt) {
      startEvent = evt;
      lastEvent = evt;
      return readPoint(evt);
    }
    function pointerMove(evt) {
      const diff = readPoint(evt) - readPoint(lastEvent);
      const expired = readTime(evt) - readTime(startEvent) > logInterval;
      lastEvent = evt;
      if (expired) startEvent = evt;
      return diff;
    }
    function pointerUp(evt) {
      if (!startEvent || !lastEvent) return 0;
      const diffDrag = readPoint(lastEvent) - readPoint(startEvent);
      const diffTime = readTime(evt) - readTime(startEvent);
      const expired = readTime(evt) - readTime(lastEvent) > logInterval;
      const force = diffDrag / diffTime;
      const isFlick = diffTime && !expired && mathAbs(force) > 0.1;
      return isFlick ? force : 0;
    }
    const self2 = {
      pointerDown,
      pointerMove,
      pointerUp,
      readPoint
    };
    return self2;
  }
  function NodeRects() {
    function measure(node2) {
      const {
        offsetTop,
        offsetLeft,
        offsetWidth,
        offsetHeight
      } = node2;
      const offset2 = {
        top: offsetTop,
        right: offsetLeft + offsetWidth,
        bottom: offsetTop + offsetHeight,
        left: offsetLeft,
        width: offsetWidth,
        height: offsetHeight
      };
      return offset2;
    }
    const self2 = {
      measure
    };
    return self2;
  }
  function PercentOfView(viewSize) {
    function measure(n) {
      return viewSize * (n / 100);
    }
    const self2 = {
      measure
    };
    return self2;
  }
  function ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {
    const observeNodes = [container].concat(slides);
    let resizeObserver;
    let containerSize;
    let slideSizes = [];
    let destroyed = false;
    function readSize(node2) {
      return axis.measureSize(nodeRects.measure(node2));
    }
    function init(emblaApi) {
      if (!watchResize) return;
      containerSize = readSize(container);
      slideSizes = slides.map(readSize);
      function defaultCallback(entries) {
        for (const entry of entries) {
          if (destroyed) return;
          const isContainer = entry.target === container;
          const slideIndex = slides.indexOf(entry.target);
          const lastSize = isContainer ? containerSize : slideSizes[slideIndex];
          const newSize = readSize(isContainer ? container : slides[slideIndex]);
          const diffSize = mathAbs(newSize - lastSize);
          if (diffSize >= 0.5) {
            emblaApi.reInit();
            eventHandler.emit("resize");
            break;
          }
        }
      }
      resizeObserver = new ResizeObserver((entries) => {
        if (isBoolean$1(watchResize) || watchResize(emblaApi, entries)) {
          defaultCallback(entries);
        }
      });
      ownerWindow.requestAnimationFrame(() => {
        observeNodes.forEach((node2) => resizeObserver.observe(node2));
      });
    }
    function destroy() {
      destroyed = true;
      if (resizeObserver) resizeObserver.disconnect();
    }
    const self2 = {
      init,
      destroy
    };
    return self2;
  }
  function ScrollBody(location2, offsetLocation, previousLocation, target, baseDuration, baseFriction) {
    let scrollVelocity = 0;
    let scrollDirection = 0;
    let scrollDuration = baseDuration;
    let scrollFriction = baseFriction;
    let rawLocation = location2.get();
    let rawLocationPrevious = 0;
    function seek() {
      const displacement = target.get() - location2.get();
      const isInstant = !scrollDuration;
      let scrollDistance = 0;
      if (isInstant) {
        scrollVelocity = 0;
        previousLocation.set(target);
        location2.set(target);
        scrollDistance = displacement;
      } else {
        previousLocation.set(location2);
        scrollVelocity += displacement / scrollDuration;
        scrollVelocity *= scrollFriction;
        rawLocation += scrollVelocity;
        location2.add(scrollVelocity);
        scrollDistance = rawLocation - rawLocationPrevious;
      }
      scrollDirection = mathSign(scrollDistance);
      rawLocationPrevious = rawLocation;
      return self2;
    }
    function settled() {
      const diff = target.get() - offsetLocation.get();
      return mathAbs(diff) < 1e-3;
    }
    function duration() {
      return scrollDuration;
    }
    function direction() {
      return scrollDirection;
    }
    function velocity() {
      return scrollVelocity;
    }
    function useBaseDuration() {
      return useDuration(baseDuration);
    }
    function useBaseFriction() {
      return useFriction(baseFriction);
    }
    function useDuration(n) {
      scrollDuration = n;
      return self2;
    }
    function useFriction(n) {
      scrollFriction = n;
      return self2;
    }
    const self2 = {
      direction,
      duration,
      velocity,
      seek,
      settled,
      useBaseFriction,
      useBaseDuration,
      useFriction,
      useDuration
    };
    return self2;
  }
  function ScrollBounds(limit, location2, target, scrollBody, percentOfView) {
    const pullBackThreshold = percentOfView.measure(10);
    const edgeOffsetTolerance = percentOfView.measure(50);
    const frictionLimit = Limit(0.1, 0.99);
    let disabled = false;
    function shouldConstrain() {
      if (disabled) return false;
      if (!limit.reachedAny(target.get())) return false;
      if (!limit.reachedAny(location2.get())) return false;
      return true;
    }
    function constrain(pointerDown) {
      if (!shouldConstrain()) return;
      const edge = limit.reachedMin(location2.get()) ? "min" : "max";
      const diffToEdge = mathAbs(limit[edge] - location2.get());
      const diffToTarget = target.get() - location2.get();
      const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);
      target.subtract(diffToTarget * friction);
      if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {
        target.set(limit.constrain(target.get()));
        scrollBody.useDuration(25).useBaseFriction();
      }
    }
    function toggleActive(active) {
      disabled = !active;
    }
    const self2 = {
      shouldConstrain,
      constrain,
      toggleActive
    };
    return self2;
  }
  function ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {
    const scrollBounds = Limit(-contentSize + viewSize, 0);
    const snapsBounded = measureBounded();
    const scrollContainLimit = findScrollContainLimit();
    const snapsContained = measureContained();
    function usePixelTolerance(bound, snap) {
      return deltaAbs(bound, snap) <= 1;
    }
    function findScrollContainLimit() {
      const startSnap = snapsBounded[0];
      const endSnap = arrayLast(snapsBounded);
      const min2 = snapsBounded.lastIndexOf(startSnap);
      const max2 = snapsBounded.indexOf(endSnap) + 1;
      return Limit(min2, max2);
    }
    function measureBounded() {
      return snapsAligned.map((snapAligned, index2) => {
        const {
          min: min2,
          max: max2
        } = scrollBounds;
        const snap = scrollBounds.constrain(snapAligned);
        const isFirst = !index2;
        const isLast = arrayIsLastIndex(snapsAligned, index2);
        if (isFirst) return max2;
        if (isLast) return min2;
        if (usePixelTolerance(min2, snap)) return min2;
        if (usePixelTolerance(max2, snap)) return max2;
        return snap;
      }).map((scrollBound) => parseFloat(scrollBound.toFixed(3)));
    }
    function measureContained() {
      if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max];
      if (containScroll === "keepSnaps") return snapsBounded;
      const {
        min: min2,
        max: max2
      } = scrollContainLimit;
      return snapsBounded.slice(min2, max2);
    }
    const self2 = {
      snapsContained,
      scrollContainLimit
    };
    return self2;
  }
  function ScrollLimit(contentSize, scrollSnaps, loop) {
    const max2 = scrollSnaps[0];
    const min2 = loop ? max2 - contentSize : arrayLast(scrollSnaps);
    const limit = Limit(min2, max2);
    const self2 = {
      limit
    };
    return self2;
  }
  function ScrollLooper(contentSize, limit, location2, vectors) {
    const jointSafety = 0.1;
    const min2 = limit.min + jointSafety;
    const max2 = limit.max + jointSafety;
    const {
      reachedMin,
      reachedMax
    } = Limit(min2, max2);
    function shouldLoop(direction) {
      if (direction === 1) return reachedMax(location2.get());
      if (direction === -1) return reachedMin(location2.get());
      return false;
    }
    function loop(direction) {
      if (!shouldLoop(direction)) return;
      const loopDistance = contentSize * (direction * -1);
      vectors.forEach((v) => v.add(loopDistance));
    }
    const self2 = {
      loop
    };
    return self2;
  }
  function ScrollProgress(limit) {
    const {
      max: max2,
      length
    } = limit;
    function get(n) {
      const currentLocation = n - max2;
      return length ? currentLocation / -length : 0;
    }
    const self2 = {
      get
    };
    return self2;
  }
  function ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {
    const {
      startEdge,
      endEdge
    } = axis;
    const {
      groupSlides
    } = slidesToScroll;
    const alignments = measureSizes().map(alignment.measure);
    const snaps = measureUnaligned();
    const snapsAligned = measureAligned();
    function measureSizes() {
      return groupSlides(slideRects).map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);
    }
    function measureUnaligned() {
      return slideRects.map((rect) => containerRect[startEdge] - rect[startEdge]).map((snap) => -mathAbs(snap));
    }
    function measureAligned() {
      return groupSlides(snaps).map((g) => g[0]).map((snap, index2) => snap + alignments[index2]);
    }
    const self2 = {
      snaps,
      snapsAligned
    };
    return self2;
  }
  function SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {
    const {
      groupSlides
    } = slidesToScroll;
    const {
      min: min2,
      max: max2
    } = scrollContainLimit;
    const slideRegistry = createSlideRegistry();
    function createSlideRegistry() {
      const groupedSlideIndexes = groupSlides(slideIndexes);
      const doNotContain = !containSnaps || containScroll === "keepSnaps";
      if (scrollSnaps.length === 1) return [slideIndexes];
      if (doNotContain) return groupedSlideIndexes;
      return groupedSlideIndexes.slice(min2, max2).map((group, index2, groups) => {
        const isFirst = !index2;
        const isLast = arrayIsLastIndex(groups, index2);
        if (isFirst) {
          const range = arrayLast(groups[0]) + 1;
          return arrayFromNumber(range);
        }
        if (isLast) {
          const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;
          return arrayFromNumber(range, arrayLast(groups)[0]);
        }
        return group;
      });
    }
    const self2 = {
      slideRegistry
    };
    return self2;
  }
  function ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {
    const {
      reachedAny,
      removeOffset,
      constrain
    } = limit;
    function minDistance(distances) {
      return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];
    }
    function findTargetSnap(target) {
      const distance2 = loop ? removeOffset(target) : constrain(target);
      const ascDiffsToSnaps = scrollSnaps.map((snap, index3) => ({
        diff: shortcut(snap - distance2, 0),
        index: index3
      })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));
      const {
        index: index2
      } = ascDiffsToSnaps[0];
      return {
        index: index2,
        distance: distance2
      };
    }
    function shortcut(target, direction) {
      const targets = [target, target + contentSize, target - contentSize];
      if (!loop) return target;
      if (!direction) return minDistance(targets);
      const matchingTargets = targets.filter((t) => mathSign(t) === direction);
      if (matchingTargets.length) return minDistance(matchingTargets);
      return arrayLast(targets) - contentSize;
    }
    function byIndex(index2, direction) {
      const diffToSnap = scrollSnaps[index2] - targetVector.get();
      const distance2 = shortcut(diffToSnap, direction);
      return {
        index: index2,
        distance: distance2
      };
    }
    function byDistance(distance2, snap) {
      const target = targetVector.get() + distance2;
      const {
        index: index2,
        distance: targetSnapDistance
      } = findTargetSnap(target);
      const reachedBound = !loop && reachedAny(target);
      if (!snap || reachedBound) return {
        index: index2,
        distance: distance2
      };
      const diffToSnap = scrollSnaps[index2] - targetSnapDistance;
      const snapDistance = distance2 + shortcut(diffToSnap, 0);
      return {
        index: index2,
        distance: snapDistance
      };
    }
    const self2 = {
      byDistance,
      byIndex,
      shortcut
    };
    return self2;
  }
  function ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {
    function scrollTo(target) {
      const distanceDiff = target.distance;
      const indexDiff = target.index !== indexCurrent.get();
      targetVector.add(distanceDiff);
      if (distanceDiff) {
        if (scrollBody.duration()) {
          animation.start();
        } else {
          animation.update();
          animation.render(1);
          animation.update();
        }
      }
      if (indexDiff) {
        indexPrevious.set(indexCurrent.get());
        indexCurrent.set(target.index);
        eventHandler.emit("select");
      }
    }
    function distance2(n, snap) {
      const target = scrollTarget.byDistance(n, snap);
      scrollTo(target);
    }
    function index2(n, direction) {
      const targetIndex = indexCurrent.clone().set(n);
      const target = scrollTarget.byIndex(targetIndex.get(), direction);
      scrollTo(target);
    }
    const self2 = {
      distance: distance2,
      index: index2
    };
    return self2;
  }
  function SlideFocus(root2, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {
    const focusListenerOptions = {
      passive: true,
      capture: true
    };
    let lastTabPressTime = 0;
    function init(emblaApi) {
      if (!watchFocus) return;
      function defaultCallback(index2) {
        const nowTime = (/* @__PURE__ */ new Date()).getTime();
        const diffTime = nowTime - lastTabPressTime;
        if (diffTime > 10) return;
        eventHandler.emit("slideFocusStart");
        root2.scrollLeft = 0;
        const group = slideRegistry.findIndex((group2) => group2.includes(index2));
        if (!isNumber$1(group)) return;
        scrollBody.useDuration(0);
        scrollTo.index(group, 0);
        eventHandler.emit("slideFocus");
      }
      eventStore.add(document, "keydown", registerTabPress, false);
      slides.forEach((slide, slideIndex) => {
        eventStore.add(slide, "focus", (evt) => {
          if (isBoolean$1(watchFocus) || watchFocus(emblaApi, evt)) {
            defaultCallback(slideIndex);
          }
        }, focusListenerOptions);
      });
    }
    function registerTabPress(event) {
      if (event.code === "Tab") lastTabPressTime = (/* @__PURE__ */ new Date()).getTime();
    }
    const self2 = {
      init
    };
    return self2;
  }
  function Vector1D(initialValue) {
    let value = initialValue;
    function get() {
      return value;
    }
    function set(n) {
      value = normalizeInput(n);
    }
    function add(n) {
      value += normalizeInput(n);
    }
    function subtract(n) {
      value -= normalizeInput(n);
    }
    function normalizeInput(n) {
      return isNumber$1(n) ? n : n.get();
    }
    const self2 = {
      get,
      set,
      add,
      subtract
    };
    return self2;
  }
  function Translate(axis, container) {
    const translate = axis.scroll === "x" ? x : y;
    const containerStyle = container.style;
    let previousTarget = null;
    let disabled = false;
    function x(n) {
      return `translate3d(${n}px,0px,0px)`;
    }
    function y(n) {
      return `translate3d(0px,${n}px,0px)`;
    }
    function to(target) {
      if (disabled) return;
      const newTarget = roundToTwoDecimals(axis.direction(target));
      if (newTarget === previousTarget) return;
      containerStyle.transform = translate(newTarget);
      previousTarget = newTarget;
    }
    function toggleActive(active) {
      disabled = !active;
    }
    function clear() {
      if (disabled) return;
      containerStyle.transform = "";
      if (!container.getAttribute("style")) container.removeAttribute("style");
    }
    const self2 = {
      clear,
      to,
      toggleActive
    };
    return self2;
  }
  function SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location2, slides) {
    const roundingSafety = 0.5;
    const ascItems = arrayKeys(slideSizesWithGaps);
    const descItems = arrayKeys(slideSizesWithGaps).reverse();
    const loopPoints = startPoints().concat(endPoints());
    function removeSlideSizes(indexes, from) {
      return indexes.reduce((a, i) => {
        return a - slideSizesWithGaps[i];
      }, from);
    }
    function slidesInGap(indexes, gap) {
      return indexes.reduce((a, i) => {
        const remainingGap = removeSlideSizes(a, gap);
        return remainingGap > 0 ? a.concat([i]) : a;
      }, []);
    }
    function findSlideBounds(offset2) {
      return snaps.map((snap, index2) => ({
        start: snap - slideSizes[index2] + roundingSafety + offset2,
        end: snap + viewSize - roundingSafety + offset2
      }));
    }
    function findLoopPoints(indexes, offset2, isEndEdge) {
      const slideBounds = findSlideBounds(offset2);
      return indexes.map((index2) => {
        const initial = isEndEdge ? 0 : -contentSize;
        const altered = isEndEdge ? contentSize : 0;
        const boundEdge = isEndEdge ? "end" : "start";
        const loopPoint = slideBounds[index2][boundEdge];
        return {
          index: index2,
          loopPoint,
          slideLocation: Vector1D(-1),
          translate: Translate(axis, slides[index2]),
          target: () => location2.get() > loopPoint ? initial : altered
        };
      });
    }
    function startPoints() {
      const gap = scrollSnaps[0];
      const indexes = slidesInGap(descItems, gap);
      return findLoopPoints(indexes, contentSize, false);
    }
    function endPoints() {
      const gap = viewSize - scrollSnaps[0] - 1;
      const indexes = slidesInGap(ascItems, gap);
      return findLoopPoints(indexes, -contentSize, true);
    }
    function canLoop() {
      return loopPoints.every(({
        index: index2
      }) => {
        const otherIndexes = ascItems.filter((i) => i !== index2);
        return removeSlideSizes(otherIndexes, viewSize) <= 0.1;
      });
    }
    function loop() {
      loopPoints.forEach((loopPoint) => {
        const {
          target,
          translate,
          slideLocation
        } = loopPoint;
        const shiftLocation = target();
        if (shiftLocation === slideLocation.get()) return;
        translate.to(shiftLocation);
        slideLocation.set(shiftLocation);
      });
    }
    function clear() {
      loopPoints.forEach((loopPoint) => loopPoint.translate.clear());
    }
    const self2 = {
      canLoop,
      clear,
      loop,
      loopPoints
    };
    return self2;
  }
  function SlidesHandler(container, eventHandler, watchSlides) {
    let mutationObserver;
    let destroyed = false;
    function init(emblaApi) {
      if (!watchSlides) return;
      function defaultCallback(mutations) {
        for (const mutation of mutations) {
          if (mutation.type === "childList") {
            emblaApi.reInit();
            eventHandler.emit("slidesChanged");
            break;
          }
        }
      }
      mutationObserver = new MutationObserver((mutations) => {
        if (destroyed) return;
        if (isBoolean$1(watchSlides) || watchSlides(emblaApi, mutations)) {
          defaultCallback(mutations);
        }
      });
      mutationObserver.observe(container, {
        childList: true
      });
    }
    function destroy() {
      if (mutationObserver) mutationObserver.disconnect();
      destroyed = true;
    }
    const self2 = {
      init,
      destroy
    };
    return self2;
  }
  function SlidesInView(container, slides, eventHandler, threshold) {
    const intersectionEntryMap = {};
    let inViewCache = null;
    let notInViewCache = null;
    let intersectionObserver;
    let destroyed = false;
    function init() {
      intersectionObserver = new IntersectionObserver((entries) => {
        if (destroyed) return;
        entries.forEach((entry) => {
          const index2 = slides.indexOf(entry.target);
          intersectionEntryMap[index2] = entry;
        });
        inViewCache = null;
        notInViewCache = null;
        eventHandler.emit("slidesInView");
      }, {
        root: container.parentElement,
        threshold
      });
      slides.forEach((slide) => intersectionObserver.observe(slide));
    }
    function destroy() {
      if (intersectionObserver) intersectionObserver.disconnect();
      destroyed = true;
    }
    function createInViewList(inView) {
      return objectKeys(intersectionEntryMap).reduce((list2, slideIndex) => {
        const index2 = parseInt(slideIndex);
        const {
          isIntersecting
        } = intersectionEntryMap[index2];
        const inViewMatch = inView && isIntersecting;
        const notInViewMatch = !inView && !isIntersecting;
        if (inViewMatch || notInViewMatch) list2.push(index2);
        return list2;
      }, []);
    }
    function get(inView = true) {
      if (inView && inViewCache) return inViewCache;
      if (!inView && notInViewCache) return notInViewCache;
      const slideIndexes = createInViewList(inView);
      if (inView) inViewCache = slideIndexes;
      if (!inView) notInViewCache = slideIndexes;
      return slideIndexes;
    }
    const self2 = {
      init,
      destroy,
      get
    };
    return self2;
  }
  function SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {
    const {
      measureSize,
      startEdge,
      endEdge
    } = axis;
    const withEdgeGap = slideRects[0] && readEdgeGap;
    const startGap = measureStartGap();
    const endGap = measureEndGap();
    const slideSizes = slideRects.map(measureSize);
    const slideSizesWithGaps = measureWithGaps();
    function measureStartGap() {
      if (!withEdgeGap) return 0;
      const slideRect = slideRects[0];
      return mathAbs(containerRect[startEdge] - slideRect[startEdge]);
    }
    function measureEndGap() {
      if (!withEdgeGap) return 0;
      const style = ownerWindow.getComputedStyle(arrayLast(slides));
      return parseFloat(style.getPropertyValue(`margin-${endEdge}`));
    }
    function measureWithGaps() {
      return slideRects.map((rect, index2, rects) => {
        const isFirst = !index2;
        const isLast = arrayIsLastIndex(rects, index2);
        if (isFirst) return slideSizes[index2] + startGap;
        if (isLast) return slideSizes[index2] + endGap;
        return rects[index2 + 1][startEdge] - rect[startEdge];
      }).map(mathAbs);
    }
    const self2 = {
      slideSizes,
      slideSizesWithGaps,
      startGap,
      endGap
    };
    return self2;
  }
  function SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {
    const {
      startEdge,
      endEdge,
      direction
    } = axis;
    const groupByNumber = isNumber$1(slidesToScroll);
    function byNumber(array, groupSize) {
      return arrayKeys(array).filter((i) => i % groupSize === 0).map((i) => array.slice(i, i + groupSize));
    }
    function bySize(array) {
      if (!array.length) return [];
      return arrayKeys(array).reduce((groups, rectB, index2) => {
        const rectA = arrayLast(groups) || 0;
        const isFirst = rectA === 0;
        const isLast = rectB === arrayLastIndex(array);
        const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];
        const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];
        const gapA = !loop && isFirst ? direction(startGap) : 0;
        const gapB = !loop && isLast ? direction(endGap) : 0;
        const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));
        if (index2 && chunkSize > viewSize + pixelTolerance) groups.push(rectB);
        if (isLast) groups.push(array.length);
        return groups;
      }, []).map((currentSize, index2, groups) => {
        const previousSize = Math.max(groups[index2 - 1] || 0);
        return array.slice(previousSize, currentSize);
      });
    }
    function groupSlides(array) {
      return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);
    }
    const self2 = {
      groupSlides
    };
    return self2;
  }
  function Engine(root2, container, slides, ownerDocument, ownerWindow, options2, eventHandler) {
    const {
      align,
      axis: scrollAxis,
      direction,
      startIndex,
      loop,
      duration,
      dragFree,
      dragThreshold,
      inViewThreshold,
      slidesToScroll: groupSlides,
      skipSnaps,
      containScroll,
      watchResize,
      watchSlides,
      watchDrag,
      watchFocus
    } = options2;
    const pixelTolerance = 2;
    const nodeRects = NodeRects();
    const containerRect = nodeRects.measure(container);
    const slideRects = slides.map(nodeRects.measure);
    const axis = Axis(scrollAxis, direction);
    const viewSize = axis.measureSize(containerRect);
    const percentOfView = PercentOfView(viewSize);
    const alignment = Alignment(align, viewSize);
    const containSnaps = !loop && !!containScroll;
    const readEdgeGap = loop || !!containScroll;
    const {
      slideSizes,
      slideSizesWithGaps,
      startGap,
      endGap
    } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);
    const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);
    const {
      snaps,
      snapsAligned
    } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);
    const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);
    const {
      snapsContained,
      scrollContainLimit
    } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);
    const scrollSnaps = containSnaps ? snapsContained : snapsAligned;
    const {
      limit
    } = ScrollLimit(contentSize, scrollSnaps, loop);
    const index2 = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);
    const indexPrevious = index2.clone();
    const slideIndexes = arrayKeys(slides);
    const update = ({
      dragHandler,
      scrollBody: scrollBody2,
      scrollBounds,
      options: {
        loop: loop2
      }
    }) => {
      if (!loop2) scrollBounds.constrain(dragHandler.pointerDown());
      scrollBody2.seek();
    };
    const render = ({
      scrollBody: scrollBody2,
      translate,
      location: location3,
      offsetLocation: offsetLocation2,
      previousLocation: previousLocation2,
      scrollLooper,
      slideLooper,
      dragHandler,
      animation: animation2,
      eventHandler: eventHandler2,
      scrollBounds,
      options: {
        loop: loop2
      }
    }, alpha2) => {
      const shouldSettle = scrollBody2.settled();
      const withinBounds = !scrollBounds.shouldConstrain();
      const hasSettled = loop2 ? shouldSettle : shouldSettle && withinBounds;
      const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown();
      if (hasSettledAndIdle) animation2.stop();
      const interpolatedLocation = location3.get() * alpha2 + previousLocation2.get() * (1 - alpha2);
      offsetLocation2.set(interpolatedLocation);
      if (loop2) {
        scrollLooper.loop(scrollBody2.direction());
        slideLooper.loop();
      }
      translate.to(offsetLocation2.get());
      if (hasSettledAndIdle) eventHandler2.emit("settle");
      if (!hasSettled) eventHandler2.emit("scroll");
    };
    const animation = Animations(ownerDocument, ownerWindow, () => update(engine), (alpha2) => render(engine, alpha2));
    const friction = 0.68;
    const startLocation = scrollSnaps[index2.get()];
    const location2 = Vector1D(startLocation);
    const previousLocation = Vector1D(startLocation);
    const offsetLocation = Vector1D(startLocation);
    const target = Vector1D(startLocation);
    const scrollBody = ScrollBody(location2, offsetLocation, previousLocation, target, duration, friction);
    const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);
    const scrollTo = ScrollTo(animation, index2, indexPrevious, scrollBody, scrollTarget, target, eventHandler);
    const scrollProgress = ScrollProgress(limit);
    const eventStore = EventStore();
    const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);
    const {
      slideRegistry
    } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);
    const slideFocus = SlideFocus(root2, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);
    const engine = {
      ownerDocument,
      ownerWindow,
      eventHandler,
      containerRect,
      slideRects,
      animation,
      axis,
      dragHandler: DragHandler(axis, root2, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location2, animation, scrollTo, scrollBody, scrollTarget, index2, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),
      eventStore,
      percentOfView,
      index: index2,
      indexPrevious,
      limit,
      location: location2,
      offsetLocation,
      previousLocation,
      options: options2,
      resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),
      scrollBody,
      scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),
      scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location2, offsetLocation, previousLocation, target]),
      scrollProgress,
      scrollSnapList: scrollSnaps.map(scrollProgress.get),
      scrollSnaps,
      scrollTarget,
      scrollTo,
      slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),
      slideFocus,
      slidesHandler: SlidesHandler(container, eventHandler, watchSlides),
      slidesInView,
      slideIndexes,
      slideRegistry,
      slidesToScroll,
      target,
      translate: Translate(axis, container)
    };
    return engine;
  }
  function EventHandler() {
    let listeners = {};
    let api;
    function init(emblaApi) {
      api = emblaApi;
    }
    function getListeners(evt) {
      return listeners[evt] || [];
    }
    function emit(evt) {
      getListeners(evt).forEach((e) => e(api, evt));
      return self2;
    }
    function on(evt, cb) {
      listeners[evt] = getListeners(evt).concat([cb]);
      return self2;
    }
    function off(evt, cb) {
      listeners[evt] = getListeners(evt).filter((e) => e !== cb);
      return self2;
    }
    function clear() {
      listeners = {};
    }
    const self2 = {
      init,
      emit,
      off,
      on,
      clear
    };
    return self2;
  }
  const defaultOptions = {
    align: "center",
    axis: "x",
    container: null,
    slides: null,
    containScroll: "trimSnaps",
    direction: "ltr",
    slidesToScroll: 1,
    inViewThreshold: 0,
    breakpoints: {},
    dragFree: false,
    dragThreshold: 10,
    loop: false,
    skipSnaps: false,
    duration: 25,
    startIndex: 0,
    active: true,
    watchDrag: true,
    watchResize: true,
    watchSlides: true,
    watchFocus: true
  };
  function OptionsHandler(ownerWindow) {
    function mergeOptions(optionsA, optionsB) {
      return objectsMergeDeep(optionsA, optionsB || {});
    }
    function optionsAtMedia(options2) {
      const optionsAtMedia2 = options2.breakpoints || {};
      const matchedMediaOptions = objectKeys(optionsAtMedia2).filter((media) => ownerWindow.matchMedia(media).matches).map((media) => optionsAtMedia2[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});
      return mergeOptions(options2, matchedMediaOptions);
    }
    function optionsMediaQueries(optionsList) {
      return optionsList.map((options2) => objectKeys(options2.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);
    }
    const self2 = {
      mergeOptions,
      optionsAtMedia,
      optionsMediaQueries
    };
    return self2;
  }
  function PluginsHandler(optionsHandler) {
    let activePlugins = [];
    function init(emblaApi, plugins) {
      activePlugins = plugins.filter(({
        options: options2
      }) => optionsHandler.optionsAtMedia(options2).active !== false);
      activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler));
      return plugins.reduce((map, plugin) => Object.assign(map, {
        [plugin.name]: plugin
      }), {});
    }
    function destroy() {
      activePlugins = activePlugins.filter((plugin) => plugin.destroy());
    }
    const self2 = {
      init,
      destroy
    };
    return self2;
  }
  function EmblaCarousel(root2, userOptions, userPlugins) {
    const ownerDocument = root2.ownerDocument;
    const ownerWindow = ownerDocument.defaultView;
    const optionsHandler = OptionsHandler(ownerWindow);
    const pluginsHandler = PluginsHandler(optionsHandler);
    const mediaHandlers = EventStore();
    const eventHandler = EventHandler();
    const {
      mergeOptions,
      optionsAtMedia,
      optionsMediaQueries
    } = optionsHandler;
    const {
      on,
      off,
      emit
    } = eventHandler;
    const reInit = reActivate;
    let destroyed = false;
    let engine;
    let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);
    let options2 = mergeOptions(optionsBase);
    let pluginList = [];
    let pluginApis;
    let container;
    let slides;
    function storeElements() {
      const {
        container: userContainer,
        slides: userSlides
      } = options2;
      const customContainer = isString$1(userContainer) ? root2.querySelector(userContainer) : userContainer;
      container = customContainer || root2.children[0];
      const customSlides = isString$1(userSlides) ? container.querySelectorAll(userSlides) : userSlides;
      slides = [].slice.call(customSlides || container.children);
    }
    function createEngine(options3) {
      const engine2 = Engine(root2, container, slides, ownerDocument, ownerWindow, options3, eventHandler);
      if (options3.loop && !engine2.slideLooper.canLoop()) {
        const optionsWithoutLoop = Object.assign({}, options3, {
          loop: false
        });
        return createEngine(optionsWithoutLoop);
      }
      return engine2;
    }
    function activate(withOptions, withPlugins) {
      if (destroyed) return;
      optionsBase = mergeOptions(optionsBase, withOptions);
      options2 = optionsAtMedia(optionsBase);
      pluginList = withPlugins || pluginList;
      storeElements();
      engine = createEngine(options2);
      optionsMediaQueries([optionsBase, ...pluginList.map(({
        options: options3
      }) => options3)]).forEach((query) => mediaHandlers.add(query, "change", reActivate));
      if (!options2.active) return;
      engine.translate.to(engine.location.get());
      engine.animation.init();
      engine.slidesInView.init();
      engine.slideFocus.init(self2);
      engine.eventHandler.init(self2);
      engine.resizeHandler.init(self2);
      engine.slidesHandler.init(self2);
      if (engine.options.loop) engine.slideLooper.loop();
      if (container.offsetParent && slides.length) engine.dragHandler.init(self2);
      pluginApis = pluginsHandler.init(self2, pluginList);
    }
    function reActivate(withOptions, withPlugins) {
      const startIndex = selectedScrollSnap();
      deActivate();
      activate(mergeOptions({
        startIndex
      }, withOptions), withPlugins);
      eventHandler.emit("reInit");
    }
    function deActivate() {
      engine.dragHandler.destroy();
      engine.eventStore.clear();
      engine.translate.clear();
      engine.slideLooper.clear();
      engine.resizeHandler.destroy();
      engine.slidesHandler.destroy();
      engine.slidesInView.destroy();
      engine.animation.destroy();
      pluginsHandler.destroy();
      mediaHandlers.clear();
    }
    function destroy() {
      if (destroyed) return;
      destroyed = true;
      mediaHandlers.clear();
      deActivate();
      eventHandler.emit("destroy");
      eventHandler.clear();
    }
    function scrollTo(index2, jump, direction) {
      if (!options2.active || destroyed) return;
      engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options2.duration);
      engine.scrollTo.index(index2, direction || 0);
    }
    function scrollNext(jump) {
      const next = engine.index.add(1).get();
      scrollTo(next, jump, -1);
    }
    function scrollPrev(jump) {
      const prev = engine.index.add(-1).get();
      scrollTo(prev, jump, 1);
    }
    function canScrollNext() {
      const next = engine.index.add(1).get();
      return next !== selectedScrollSnap();
    }
    function canScrollPrev() {
      const prev = engine.index.add(-1).get();
      return prev !== selectedScrollSnap();
    }
    function scrollSnapList() {
      return engine.scrollSnapList;
    }
    function scrollProgress() {
      return engine.scrollProgress.get(engine.offsetLocation.get());
    }
    function selectedScrollSnap() {
      return engine.index.get();
    }
    function previousScrollSnap() {
      return engine.indexPrevious.get();
    }
    function slidesInView() {
      return engine.slidesInView.get();
    }
    function slidesNotInView() {
      return engine.slidesInView.get(false);
    }
    function plugins() {
      return pluginApis;
    }
    function internalEngine() {
      return engine;
    }
    function rootNode() {
      return root2;
    }
    function containerNode() {
      return container;
    }
    function slideNodes() {
      return slides;
    }
    const self2 = {
      canScrollNext,
      canScrollPrev,
      containerNode,
      internalEngine,
      destroy,
      off,
      on,
      emit,
      plugins,
      previousScrollSnap,
      reInit,
      rootNode,
      scrollNext,
      scrollPrev,
      scrollProgress,
      scrollSnapList,
      scrollTo,
      selectedScrollSnap,
      slideNodes,
      slidesInView,
      slidesNotInView
    };
    activate(userOptions, userPlugins);
    setTimeout(() => eventHandler.emit("init"), 0);
    return self2;
  }
  EmblaCarousel.globalOptions = void 0;
  function useEmblaCarousel(options2 = {}, plugins = []) {
    const storedOptions = reactExports.useRef(options2);
    const storedPlugins = reactExports.useRef(plugins);
    const [emblaApi, setEmblaApi] = reactExports.useState();
    const [viewport, setViewport] = reactExports.useState();
    const reInit = reactExports.useCallback(() => {
      if (emblaApi) emblaApi.reInit(storedOptions.current, storedPlugins.current);
    }, [emblaApi]);
    reactExports.useEffect(() => {
      if (areOptionsEqual(storedOptions.current, options2)) return;
      storedOptions.current = options2;
      reInit();
    }, [options2, reInit]);
    reactExports.useEffect(() => {
      if (arePluginsEqual(storedPlugins.current, plugins)) return;
      storedPlugins.current = plugins;
      reInit();
    }, [plugins, reInit]);
    reactExports.useEffect(() => {
      if (canUseDOM() && viewport) {
        EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions;
        const newEmblaApi = EmblaCarousel(viewport, storedOptions.current, storedPlugins.current);
        setEmblaApi(newEmblaApi);
        return () => newEmblaApi.destroy();
      } else {
        setEmblaApi(void 0);
      }
    }, [viewport, setEmblaApi]);
    return [setViewport, emblaApi];
  }
  useEmblaCarousel.globalOptions = void 0;
  var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
  var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
  var EVENT_OPTIONS = { bubbles: false, cancelable: true };
  var FOCUS_SCOPE_NAME = "FocusScope";
  var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
    const {
      loop = false,
      trapped = false,
      onMountAutoFocus: onMountAutoFocusProp,
      onUnmountAutoFocus: onUnmountAutoFocusProp,
      ...scopeProps
    } = props;
    const [container, setContainer] = reactExports.useState(null);
    const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
    const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
    const lastFocusedElementRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setContainer(node2));
    const focusScope = reactExports.useRef({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    reactExports.useEffect(() => {
      if (trapped) {
        let handleFocusIn2 = function(event) {
          if (focusScope.paused || !container) return;
          const target = event.target;
          if (container.contains(target)) {
            lastFocusedElementRef.current = target;
          } else {
            focus(lastFocusedElementRef.current, { select: true });
          }
        }, handleFocusOut2 = function(event) {
          if (focusScope.paused || !container) return;
          const relatedTarget = event.relatedTarget;
          if (relatedTarget === null) return;
          if (!container.contains(relatedTarget)) {
            focus(lastFocusedElementRef.current, { select: true });
          }
        }, handleMutations2 = function(mutations) {
          const focusedElement = document.activeElement;
          if (focusedElement !== document.body) return;
          for (const mutation of mutations) {
            if (mutation.removedNodes.length > 0) focus(container);
          }
        };
        document.addEventListener("focusin", handleFocusIn2);
        document.addEventListener("focusout", handleFocusOut2);
        const mutationObserver = new MutationObserver(handleMutations2);
        if (container) mutationObserver.observe(container, { childList: true, subtree: true });
        return () => {
          document.removeEventListener("focusin", handleFocusIn2);
          document.removeEventListener("focusout", handleFocusOut2);
          mutationObserver.disconnect();
        };
      }
    }, [trapped, container, focusScope.paused]);
    reactExports.useEffect(() => {
      if (container) {
        focusScopesStack.add(focusScope);
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = container.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          container.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            focusFirst$1(removeLinks(getTabbableCandidates(container)), { select: true });
            if (document.activeElement === previouslyFocusedElement) {
              focus(container);
            }
          }
        }
        return () => {
          container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          setTimeout(() => {
            const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
            container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            container.dispatchEvent(unmountEvent);
            if (!unmountEvent.defaultPrevented) {
              focus(previouslyFocusedElement ?? document.body, { select: true });
            }
            container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            focusScopesStack.remove(focusScope);
          }, 0);
        };
      }
    }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
    const handleKeyDown = reactExports.useCallback(
      (event) => {
        if (!loop && !trapped) return;
        if (focusScope.paused) return;
        const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
          const container2 = event.currentTarget;
          const [first, last] = getTabbableEdges(container2);
          const hasTabbableElementsInside = first && last;
          if (!hasTabbableElementsInside) {
            if (focusedElement === container2) event.preventDefault();
          } else {
            if (!event.shiftKey && focusedElement === last) {
              event.preventDefault();
              if (loop) focus(first, { select: true });
            } else if (event.shiftKey && focusedElement === first) {
              event.preventDefault();
              if (loop) focus(last, { select: true });
            }
          }
        }
      },
      [loop, trapped, focusScope.paused]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
  });
  FocusScope.displayName = FOCUS_SCOPE_NAME;
  function focusFirst$1(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      focus(candidate, { select });
      if (document.activeElement !== previouslyFocusedElement) return;
    }
  }
  function getTabbableEdges(container) {
    const candidates = getTabbableCandidates(container);
    const first = findVisible(candidates, container);
    const last = findVisible(candidates.reverse(), container);
    return [first, last];
  }
  function getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node2) => {
        const isHiddenInput = node2.tagName === "INPUT" && node2.type === "hidden";
        if (node2.disabled || node2.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
        return node2.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode()) nodes.push(walker.currentNode);
    return nodes;
  }
  function findVisible(elements, container) {
    for (const element2 of elements) {
      if (!isHidden(element2, { upTo: container })) return element2;
    }
  }
  function isHidden(node2, { upTo }) {
    if (getComputedStyle(node2).visibility === "hidden") return true;
    while (node2) {
      if (upTo !== void 0 && node2 === upTo) return false;
      if (getComputedStyle(node2).display === "none") return true;
      node2 = node2.parentElement;
    }
    return false;
  }
  function isSelectableInput(element2) {
    return element2 instanceof HTMLInputElement && "select" in element2;
  }
  function focus(element2, { select = false } = {}) {
    if (element2 && element2.focus) {
      const previouslyFocusedElement = document.activeElement;
      element2.focus({ preventScroll: true });
      if (element2 !== previouslyFocusedElement && isSelectableInput(element2) && select)
        element2.select();
    }
  }
  var focusScopesStack = createFocusScopesStack();
  function createFocusScopesStack() {
    let stack = [];
    return {
      add(focusScope) {
        const activeFocusScope = stack[0];
        if (focusScope !== activeFocusScope) {
          activeFocusScope == null ? void 0 : activeFocusScope.pause();
        }
        stack = arrayRemove(stack, focusScope);
        stack.unshift(focusScope);
      },
      remove(focusScope) {
        var _a2;
        stack = arrayRemove(stack, focusScope);
        (_a2 = stack[0]) == null ? void 0 : _a2.resume();
      }
    };
  }
  function arrayRemove(array, item) {
    const updatedArray = [...array];
    const index2 = updatedArray.indexOf(item);
    if (index2 !== -1) {
      updatedArray.splice(index2, 1);
    }
    return updatedArray;
  }
  function removeLinks(items) {
    return items.filter((item) => item.tagName !== "A");
  }
  var count = 0;
  function useFocusGuards() {
    reactExports.useEffect(() => {
      const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
      document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
      document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
      count++;
      return () => {
        if (count === 1) {
          document.querySelectorAll("[data-radix-focus-guard]").forEach((node2) => node2.remove());
        }
        count--;
      };
    }, []);
  }
  function createFocusGuard() {
    const element2 = document.createElement("span");
    element2.setAttribute("data-radix-focus-guard", "");
    element2.tabIndex = 0;
    element2.style.outline = "none";
    element2.style.opacity = "0";
    element2.style.position = "fixed";
    element2.style.pointerEvents = "none";
    return element2;
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  var zeroRightClassName = "right-scroll-bar-position";
  var fullWidthClassName = "width-before-scroll-bar";
  var noScrollbarsClassName = "with-scroll-bars-hidden";
  var removedBarSizeVariable = "--removed-body-scroll-bar-size";
  function assignRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
    return ref;
  }
  function useCallbackRef(initialValue, callback) {
    var ref = reactExports.useState(function() {
      return {
        // value
        value: initialValue,
        // last callback
        callback,
        // "memoized" public interface
        facade: {
          get current() {
            return ref.value;
          },
          set current(value) {
            var last = ref.value;
            if (last !== value) {
              ref.value = value;
              ref.callback(value, last);
            }
          }
        }
      };
    })[0];
    ref.callback = callback;
    return ref.facade;
  }
  var useIsomorphicLayoutEffect$2 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  var currentValues = /* @__PURE__ */ new WeakMap();
  function useMergeRefs(refs, defaultValue) {
    var callbackRef = useCallbackRef(null, function(newValue) {
      return refs.forEach(function(ref) {
        return assignRef(ref, newValue);
      });
    });
    useIsomorphicLayoutEffect$2(function() {
      var oldValue = currentValues.get(callbackRef);
      if (oldValue) {
        var prevRefs_1 = new Set(oldValue);
        var nextRefs_1 = new Set(refs);
        var current_1 = callbackRef.current;
        prevRefs_1.forEach(function(ref) {
          if (!nextRefs_1.has(ref)) {
            assignRef(ref, null);
          }
        });
        nextRefs_1.forEach(function(ref) {
          if (!prevRefs_1.has(ref)) {
            assignRef(ref, current_1);
          }
        });
      }
      currentValues.set(callbackRef, refs);
    }, [refs]);
    return callbackRef;
  }
  function ItoI(a) {
    return a;
  }
  function innerCreateMedium(defaults2, middleware) {
    if (middleware === void 0) {
      middleware = ItoI;
    }
    var buffer = [];
    var assigned = false;
    var medium = {
      read: function() {
        if (assigned) {
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        }
        if (buffer.length) {
          return buffer[buffer.length - 1];
        }
        return defaults2;
      },
      useMedium: function(data) {
        var item = middleware(data, assigned);
        buffer.push(item);
        return function() {
          buffer = buffer.filter(function(x) {
            return x !== item;
          });
        };
      },
      assignSyncMedium: function(cb) {
        assigned = true;
        while (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
        }
        buffer = {
          push: function(x) {
            return cb(x);
          },
          filter: function() {
            return buffer;
          }
        };
      },
      assignMedium: function(cb) {
        assigned = true;
        var pendingQueue = [];
        if (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
          pendingQueue = buffer;
        }
        var executeQueue = function() {
          var cbs2 = pendingQueue;
          pendingQueue = [];
          cbs2.forEach(cb);
        };
        var cycle = function() {
          return Promise.resolve().then(executeQueue);
        };
        cycle();
        buffer = {
          push: function(x) {
            pendingQueue.push(x);
            cycle();
          },
          filter: function(filter2) {
            pendingQueue = pendingQueue.filter(filter2);
            return buffer;
          }
        };
      }
    };
    return medium;
  }
  function createSidecarMedium(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options2);
    return medium;
  }
  var SideCar$1 = function(_a2) {
    var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
    if (!sideCar) {
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    }
    var Target = sideCar.read();
    if (!Target) {
      throw new Error("Sidecar medium not found");
    }
    return reactExports.createElement(Target, __assign({}, rest));
  };
  SideCar$1.isSideCarExport = true;
  function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar$1;
  }
  var effectCar = createSidecarMedium();
  var nothing = function() {
    return;
  };
  var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
    var ref = reactExports.useRef(null);
    var _a2 = reactExports.useState({
      onScrollCapture: nothing,
      onWheelCapture: nothing,
      onTouchMoveCapture: nothing
    }), callbacks = _a2[0], setCallbacks = _a2[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
    var SideCar2 = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return reactExports.createElement(
      reactExports.Fragment,
      null,
      enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
      forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
    );
  });
  RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
  };
  RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };
  var getNonce = function() {
    if (typeof __webpack_nonce__ !== "undefined") {
      return __webpack_nonce__;
    }
    return void 0;
  };
  function makeStyleTag() {
    if (!document)
      return null;
    var tag = document.createElement("style");
    tag.type = "text/css";
    var nonce = getNonce();
    if (nonce) {
      tag.setAttribute("nonce", nonce);
    }
    return tag;
  }
  function injectStyles(tag, css) {
    if (tag.styleSheet) {
      tag.styleSheet.cssText = css;
    } else {
      tag.appendChild(document.createTextNode(css));
    }
  }
  function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(tag);
  }
  var stylesheetSingleton = function() {
    var counter = 0;
    var stylesheet = null;
    return {
      add: function(style) {
        if (counter == 0) {
          if (stylesheet = makeStyleTag()) {
            injectStyles(stylesheet, style);
            insertStyleTag(stylesheet);
          }
        }
        counter++;
      },
      remove: function() {
        counter--;
        if (!counter && stylesheet) {
          stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
          stylesheet = null;
        }
      }
    };
  };
  var styleHookSingleton = function() {
    var sheet = stylesheetSingleton();
    return function(styles, isDynamic) {
      reactExports.useEffect(function() {
        sheet.add(styles);
        return function() {
          sheet.remove();
        };
      }, [styles && isDynamic]);
    };
  };
  var styleSingleton = function() {
    var useStyle2 = styleHookSingleton();
    var Sheet = function(_a2) {
      var styles = _a2.styles, dynamic = _a2.dynamic;
      useStyle2(styles, dynamic);
      return null;
    };
    return Sheet;
  };
  var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  };
  var parse$1 = function(x) {
    return parseInt(x || "", 10) || 0;
  };
  var getOffset = function(gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
    var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
    var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
    return [parse$1(left), parse$1(top), parse$1(right)];
  };
  var getGapWidth = function(gapMode) {
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    if (typeof window === "undefined") {
      return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
    };
  };
  var Style = styleSingleton();
  var lockAttribute = "data-scroll-locked";
  var getStyles = function(_a2, allowRelative, gapMode, important) {
    var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
      allowRelative && "position: relative ".concat(important, ";"),
      gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
      gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
    ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
  };
  var getCurrentUseCounter = function() {
    var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
    return isFinite(counter) ? counter : 0;
  };
  var useLockAttribute = function() {
    reactExports.useEffect(function() {
      document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
      return function() {
        var newCounter = getCurrentUseCounter() - 1;
        if (newCounter <= 0) {
          document.body.removeAttribute(lockAttribute);
        } else {
          document.body.setAttribute(lockAttribute, newCounter.toString());
        }
      };
    }, []);
  };
  var RemoveScrollBar = function(_a2) {
    var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b2 = _a2.gapMode, gapMode = _b2 === void 0 ? "margin" : _b2;
    useLockAttribute();
    var gap = reactExports.useMemo(function() {
      return getGapWidth(gapMode);
    }, [gapMode]);
    return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
  };
  var passiveSupported = false;
  if (typeof window !== "undefined") {
    try {
      var options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
          return true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }
  var nonPassive = passiveSupported ? { passive: false } : false;
  var alwaysContainsScroll = function(node2) {
    return node2.tagName === "TEXTAREA";
  };
  var elementCanBeScrolled = function(node2, overflow) {
    if (!(node2 instanceof Element)) {
      return false;
    }
    var styles = window.getComputedStyle(node2);
    return (
      // not-not-scrollable
      styles[overflow] !== "hidden" && // contains scroll inside self
      !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node2) && styles[overflow] === "visible")
    );
  };
  var elementCouldBeVScrolled = function(node2) {
    return elementCanBeScrolled(node2, "overflowY");
  };
  var elementCouldBeHScrolled = function(node2) {
    return elementCanBeScrolled(node2, "overflowX");
  };
  var locationCouldBeScrolled = function(axis, node2) {
    var ownerDocument = node2.ownerDocument;
    var current = node2;
    do {
      if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
        current = current.host;
      }
      var isScrollable = elementCouldBeScrolled(axis, current);
      if (isScrollable) {
        var _a2 = getScrollVariables(axis, current), scrollHeight = _a2[1], clientHeight = _a2[2];
        if (scrollHeight > clientHeight) {
          return true;
        }
      }
      current = current.parentNode;
    } while (current && current !== ownerDocument.body);
    return false;
  };
  var getVScrollVariables = function(_a2) {
    var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
    return [
      scrollTop,
      scrollHeight,
      clientHeight
    ];
  };
  var getHScrollVariables = function(_a2) {
    var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
    return [
      scrollLeft,
      scrollWidth,
      clientWidth
    ];
  };
  var elementCouldBeScrolled = function(axis, node2) {
    return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
  };
  var getScrollVariables = function(axis, node2) {
    return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
  };
  var getDirectionFactor = function(axis, direction) {
    return axis === "h" && direction === "rtl" ? -1 : 1;
  };
  var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
      if (!target) {
        break;
      }
      var _a2 = getScrollVariables(axis, target), position2 = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
      var elementScroll = scroll_1 - capacity - directionFactor * position2;
      if (position2 || elementScroll) {
        if (elementCouldBeScrolled(axis, target)) {
          availableScroll += elementScroll;
          availableScrollTop += position2;
        }
      }
      var parent_1 = target.parentNode;
      target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
    } while (
      // portaled content
      !targetInLock && target !== document.body || // self content
      targetInLock && (endTarget.contains(target) || endTarget === target)
    );
    if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
      shouldCancelScroll = true;
    } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
      shouldCancelScroll = true;
    }
    return shouldCancelScroll;
  };
  var getTouchXY = function(event) {
    return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
  };
  var getDeltaXY = function(event) {
    return [event.deltaX, event.deltaY];
  };
  var extractRef = function(ref) {
    return ref && "current" in ref ? ref.current : ref;
  };
  var deltaCompare = function(x, y) {
    return x[0] === y[0] && x[1] === y[1];
  };
  var generateStyle = function(id2) {
    return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
  };
  var idCounter = 0;
  var lockStack = [];
  function RemoveScrollSideCar(props) {
    var shouldPreventQueue = reactExports.useRef([]);
    var touchStartRef = reactExports.useRef([0, 0]);
    var activeAxis = reactExports.useRef();
    var id2 = reactExports.useState(idCounter++)[0];
    var Style2 = reactExports.useState(styleSingleton)[0];
    var lastProps = reactExports.useRef(props);
    reactExports.useEffect(function() {
      lastProps.current = props;
    }, [props]);
    reactExports.useEffect(function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-".concat(id2));
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
        allow_1.forEach(function(el) {
          return el.classList.add("allow-interactivity-".concat(id2));
        });
        return function() {
          document.body.classList.remove("block-interactivity-".concat(id2));
          allow_1.forEach(function(el) {
            return el.classList.remove("allow-interactivity-".concat(id2));
          });
        };
      }
      return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
      if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
        return !lastProps.current.allowPinchZoom;
      }
      var touch = getTouchXY(event);
      var touchStart = touchStartRef.current;
      var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
      var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
      var currentAxis;
      var target = event.target;
      var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
      if ("touches" in event && moveDirection === "h" && target.type === "range") {
        return false;
      }
      var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      if (!canBeScrolledInMainDirection) {
        return true;
      }
      if (canBeScrolledInMainDirection) {
        currentAxis = moveDirection;
      } else {
        currentAxis = moveDirection === "v" ? "h" : "v";
        canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      }
      if (!canBeScrolledInMainDirection) {
        return false;
      }
      if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
        activeAxis.current = currentAxis;
      }
      if (!currentAxis) {
        return true;
      }
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
    }, []);
    var shouldPrevent = reactExports.useCallback(function(_event) {
      var event = _event;
      if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
        return;
      }
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
      var sourceEvent = shouldPreventQueue.current.filter(function(e) {
        return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
      })[0];
      if (sourceEvent && sourceEvent.should) {
        if (event.cancelable) {
          event.preventDefault();
        }
        return;
      }
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
          return node2.contains(event.target);
        });
        var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        if (shouldStop) {
          if (event.cancelable) {
            event.preventDefault();
          }
        }
      }
    }, []);
    var shouldCancel = reactExports.useCallback(function(name2, delta, target, should) {
      var event = { name: name2, delta, target, should, shadowParent: getOutermostShadowParent(target) };
      shouldPreventQueue.current.push(event);
      setTimeout(function() {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
          return e !== event;
        });
      }, 1);
    }, []);
    var scrollTouchStart = reactExports.useCallback(function(event) {
      touchStartRef.current = getTouchXY(event);
      activeAxis.current = void 0;
    }, []);
    var scrollWheel = reactExports.useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = reactExports.useCallback(function(event) {
      shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    reactExports.useEffect(function() {
      lockStack.push(Style2);
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove
      });
      document.addEventListener("wheel", shouldPrevent, nonPassive);
      document.addEventListener("touchmove", shouldPrevent, nonPassive);
      document.addEventListener("touchstart", scrollTouchStart, nonPassive);
      return function() {
        lockStack = lockStack.filter(function(inst) {
          return inst !== Style2;
        });
        document.removeEventListener("wheel", shouldPrevent, nonPassive);
        document.removeEventListener("touchmove", shouldPrevent, nonPassive);
        document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return reactExports.createElement(
      reactExports.Fragment,
      null,
      inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
      removeScrollBar ? reactExports.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
    );
  }
  function getOutermostShadowParent(node2) {
    var shadowParent = null;
    while (node2 !== null) {
      if (node2 instanceof ShadowRoot) {
        shadowParent = node2.host;
        node2 = node2.host;
      }
      node2 = node2.parentNode;
    }
    return shadowParent;
  }
  const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
  var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
    return reactExports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
  });
  ReactRemoveScroll.classNames = RemoveScroll.classNames;
  var getDefaultParent = function(originalTarget) {
    if (typeof document === "undefined") {
      return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
  };
  var counterMap = /* @__PURE__ */ new WeakMap();
  var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
  var markerMap = {};
  var lockCount = 0;
  var unwrapHost = function(node2) {
    return node2 && (node2.host || unwrapHost(node2.parentNode));
  };
  var correctTargets = function(parent, targets) {
    return targets.map(function(target) {
      if (parent.contains(target)) {
        return target;
      }
      var correctedTarget = unwrapHost(target);
      if (correctedTarget && parent.contains(correctedTarget)) {
        return correctedTarget;
      }
      console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
      return null;
    }).filter(function(x) {
      return Boolean(x);
    });
  };
  var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    if (!markerMap[markerName]) {
      markerMap[markerName] = /* @__PURE__ */ new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = /* @__PURE__ */ new Set();
    var elementsToStop = new Set(targets);
    var keep = function(el) {
      if (!el || elementsToKeep.has(el)) {
        return;
      }
      elementsToKeep.add(el);
      keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function(parent) {
      if (!parent || elementsToStop.has(parent)) {
        return;
      }
      Array.prototype.forEach.call(parent.children, function(node2) {
        if (elementsToKeep.has(node2)) {
          deep(node2);
        } else {
          try {
            var attr = node2.getAttribute(controlAttribute);
            var alreadyHidden = attr !== null && attr !== "false";
            var counterValue = (counterMap.get(node2) || 0) + 1;
            var markerValue = (markerCounter.get(node2) || 0) + 1;
            counterMap.set(node2, counterValue);
            markerCounter.set(node2, markerValue);
            hiddenNodes.push(node2);
            if (counterValue === 1 && alreadyHidden) {
              uncontrolledNodes.set(node2, true);
            }
            if (markerValue === 1) {
              node2.setAttribute(markerName, "true");
            }
            if (!alreadyHidden) {
              node2.setAttribute(controlAttribute, "true");
            }
          } catch (e) {
            console.error("aria-hidden: cannot operate on ", node2, e);
          }
        }
      });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function() {
      hiddenNodes.forEach(function(node2) {
        var counterValue = counterMap.get(node2) - 1;
        var markerValue = markerCounter.get(node2) - 1;
        counterMap.set(node2, counterValue);
        markerCounter.set(node2, markerValue);
        if (!counterValue) {
          if (!uncontrolledNodes.has(node2)) {
            node2.removeAttribute(controlAttribute);
          }
          uncontrolledNodes.delete(node2);
        }
        if (!markerValue) {
          node2.removeAttribute(markerName);
        }
      });
      lockCount--;
      if (!lockCount) {
        counterMap = /* @__PURE__ */ new WeakMap();
        counterMap = /* @__PURE__ */ new WeakMap();
        uncontrolledNodes = /* @__PURE__ */ new WeakMap();
        markerMap = {};
      }
    };
  };
  var hideOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = "data-aria-hidden";
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = getDefaultParent(originalTarget);
    if (!activeParentNode) {
      return function() {
        return null;
      };
    }
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
    return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
  };
  var DIALOG_NAME = "Dialog";
  var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
  var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
  var Dialog$1 = (props) => {
    const {
      __scopeDialog,
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      modal = true
    } = props;
    const triggerRef = reactExports.useRef(null);
    const contentRef = reactExports.useRef(null);
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? false,
      onChange: onOpenChange,
      caller: DIALOG_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogProvider,
      {
        scope: __scopeDialog,
        triggerRef,
        contentRef,
        contentId: useId(),
        titleId: useId(),
        descriptionId: useId(),
        open,
        onOpenChange: setOpen,
        onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        modal,
        children
      }
    );
  };
  Dialog$1.displayName = DIALOG_NAME;
  var TRIGGER_NAME$3 = "DialogTrigger";
  var DialogTrigger = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...triggerProps } = props;
      const context = useDialogContext(TRIGGER_NAME$3, __scopeDialog);
      const composedTriggerRef = useComposedRefs$1(forwardedRef, context.triggerRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": context.open,
          "aria-controls": context.contentId,
          "data-state": getState$3(context.open),
          ...triggerProps,
          ref: composedTriggerRef,
          onClick: composeEventHandlers$1(props.onClick, context.onOpenToggle)
        }
      );
    }
  );
  DialogTrigger.displayName = TRIGGER_NAME$3;
  var PORTAL_NAME$3 = "DialogPortal";
  var [PortalProvider$1, usePortalContext$1] = createDialogContext(PORTAL_NAME$3, {
    forceMount: void 0
  });
  var DialogPortal$1 = (props) => {
    const { __scopeDialog, forceMount, children, container } = props;
    const context = useDialogContext(PORTAL_NAME$3, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$1, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$4, { asChild: true, container, children: child }) })) });
  };
  DialogPortal$1.displayName = PORTAL_NAME$3;
  var OVERLAY_NAME = "DialogOverlay";
  var DialogOverlay$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext$1(OVERLAY_NAME, props.__scopeDialog);
      const { forceMount = portalContext.forceMount, ...overlayProps } = props;
      const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
      return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
    }
  );
  DialogOverlay$1.displayName = OVERLAY_NAME;
  var Slot$2 = /* @__PURE__ */ createSlot("DialogOverlay.RemoveScroll");
  var DialogOverlayImpl = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...overlayProps } = props;
      const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
      return (
        // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
        // ie. when `Overlay` and `Content` are siblings
        /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot$2, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            "data-state": getState$3(context.open),
            ...overlayProps,
            ref: forwardedRef,
            style: { pointerEvents: "auto", ...overlayProps.style }
          }
        ) })
      );
    }
  );
  var CONTENT_NAME$3 = "DialogContent";
  var DialogContent$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext$1(CONTENT_NAME$3, props.__scopeDialog);
      const { forceMount = portalContext.forceMount, ...contentProps } = props;
      const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
    }
  );
  DialogContent$1.displayName = CONTENT_NAME$3;
  var DialogContentModal = reactExports.forwardRef(
    (props, forwardedRef) => {
      const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
      const contentRef = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, context.contentRef, contentRef);
      reactExports.useEffect(() => {
        const content2 = contentRef.current;
        if (content2) return hideOthers(content2);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogContentImpl,
        {
          ...props,
          ref: composedRefs,
          trapFocus: context.open,
          disableOutsidePointerEvents: true,
          onCloseAutoFocus: composeEventHandlers$1(props.onCloseAutoFocus, (event) => {
            var _a2;
            event.preventDefault();
            (_a2 = context.triggerRef.current) == null ? void 0 : _a2.focus();
          }),
          onPointerDownOutside: composeEventHandlers$1(props.onPointerDownOutside, (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            if (isRightClick) event.preventDefault();
          }),
          onFocusOutside: composeEventHandlers$1(
            props.onFocusOutside,
            (event) => event.preventDefault()
          )
        }
      );
    }
  );
  var DialogContentNonModal = reactExports.forwardRef(
    (props, forwardedRef) => {
      const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
      const hasInteractedOutsideRef = reactExports.useRef(false);
      const hasPointerDownOutsideRef = reactExports.useRef(false);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogContentImpl,
        {
          ...props,
          ref: forwardedRef,
          trapFocus: false,
          disableOutsidePointerEvents: false,
          onCloseAutoFocus: (event) => {
            var _a2, _b2;
            (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
            if (!event.defaultPrevented) {
              if (!hasInteractedOutsideRef.current) (_b2 = context.triggerRef.current) == null ? void 0 : _b2.focus();
              event.preventDefault();
            }
            hasInteractedOutsideRef.current = false;
            hasPointerDownOutsideRef.current = false;
          },
          onInteractOutside: (event) => {
            var _a2, _b2;
            (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
            if (!event.defaultPrevented) {
              hasInteractedOutsideRef.current = true;
              if (event.detail.originalEvent.type === "pointerdown") {
                hasPointerDownOutsideRef.current = true;
              }
            }
            const target = event.target;
            const targetIsTrigger = (_b2 = context.triggerRef.current) == null ? void 0 : _b2.contains(target);
            if (targetIsTrigger) event.preventDefault();
            if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
              event.preventDefault();
            }
          }
        }
      );
    }
  );
  var DialogContentImpl = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
      const context = useDialogContext(CONTENT_NAME$3, __scopeDialog);
      const contentRef = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, contentRef);
      useFocusGuards();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            loop: true,
            trapped: trapFocus,
            onMountAutoFocus: onOpenAutoFocus,
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                role: "dialog",
                id: context.contentId,
                "aria-describedby": context.descriptionId,
                "aria-labelledby": context.titleId,
                "data-state": getState$3(context.open),
                ...contentProps,
                ref: composedRefs,
                onDismiss: () => context.onOpenChange(false)
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
        ] })
      ] });
    }
  );
  var TITLE_NAME = "DialogTitle";
  var DialogTitle$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...titleProps } = props;
      const context = useDialogContext(TITLE_NAME, __scopeDialog);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
    }
  );
  DialogTitle$1.displayName = TITLE_NAME;
  var DESCRIPTION_NAME = "DialogDescription";
  var DialogDescription$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...descriptionProps } = props;
      const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
    }
  );
  DialogDescription$1.displayName = DESCRIPTION_NAME;
  var CLOSE_NAME = "DialogClose";
  var DialogClose = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...closeProps } = props;
      const context = useDialogContext(CLOSE_NAME, __scopeDialog);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          ...closeProps,
          ref: forwardedRef,
          onClick: composeEventHandlers$1(props.onClick, () => context.onOpenChange(false))
        }
      );
    }
  );
  DialogClose.displayName = CLOSE_NAME;
  function getState$3(open) {
    return open ? "open" : "closed";
  }
  var TITLE_WARNING_NAME = "DialogTitleWarning";
  var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
    contentName: CONTENT_NAME$3,
    titleName: TITLE_NAME,
    docsSlug: "dialog"
  });
  var TitleWarning = ({ titleId }) => {
    const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
    const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
    reactExports.useEffect(() => {
      if (titleId) {
        const hasTitle = document.getElementById(titleId);
        if (!hasTitle) console.error(MESSAGE);
      }
    }, [MESSAGE, titleId]);
    return null;
  };
  var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
  var DescriptionWarning = ({ contentRef, descriptionId }) => {
    const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
    const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
    reactExports.useEffect(() => {
      var _a2;
      const describedById = (_a2 = contentRef.current) == null ? void 0 : _a2.getAttribute("aria-describedby");
      if (descriptionId && describedById) {
        const hasDescription = document.getElementById(descriptionId);
        if (!hasDescription) console.warn(MESSAGE);
      }
    }, [MESSAGE, contentRef, descriptionId]);
    return null;
  };
  var Root$3 = Dialog$1;
  var Portal$2 = DialogPortal$1;
  var Overlay = DialogOverlay$1;
  var Content = DialogContent$1;
  var Title = DialogTitle$1;
  var Description = DialogDescription$1;
  var Close = DialogClose;
  var SELECTION_KEYS$1 = ["Enter", " "];
  var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
  var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
  var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
  var SUB_OPEN_KEYS = {
    ltr: [...SELECTION_KEYS$1, "ArrowRight"],
    rtl: [...SELECTION_KEYS$1, "ArrowLeft"]
  };
  var SUB_CLOSE_KEYS = {
    ltr: ["ArrowLeft"],
    rtl: ["ArrowRight"]
  };
  var MENU_NAME = "Menu";
  var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection(MENU_NAME);
  var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
    createCollectionScope$2,
    createPopperScope,
    createRovingFocusGroupScope
  ]);
  var usePopperScope$1 = createPopperScope();
  var useRovingFocusGroupScope$1 = createRovingFocusGroupScope();
  var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
  var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
  var Menu = (props) => {
    const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
    const popperScope = usePopperScope$1(__scopeMenu);
    const [content2, setContent] = reactExports.useState(null);
    const isUsingKeyboardRef = reactExports.useRef(false);
    const handleOpenChange = useCallbackRef$1(onOpenChange);
    const direction = useDirection(dir);
    reactExports.useEffect(() => {
      const handleKeyDown = () => {
        isUsingKeyboardRef.current = true;
        document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
        document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
      };
      const handlePointer = () => isUsingKeyboardRef.current = false;
      document.addEventListener("keydown", handleKeyDown, { capture: true });
      return () => {
        document.removeEventListener("keydown", handleKeyDown, { capture: true });
        document.removeEventListener("pointerdown", handlePointer, { capture: true });
        document.removeEventListener("pointermove", handlePointer, { capture: true });
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$2, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuProvider,
      {
        scope: __scopeMenu,
        open,
        onOpenChange: handleOpenChange,
        content: content2,
        onContentChange: setContent,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          MenuRootProvider,
          {
            scope: __scopeMenu,
            onClose: reactExports.useCallback(() => handleOpenChange(false), [handleOpenChange]),
            isUsingKeyboardRef,
            dir: direction,
            modal,
            children
          }
        )
      }
    ) });
  };
  Menu.displayName = MENU_NAME;
  var ANCHOR_NAME = "MenuAnchor";
  var MenuAnchor = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeMenu, ...anchorProps } = props;
      const popperScope = usePopperScope$1(__scopeMenu);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
    }
  );
  MenuAnchor.displayName = ANCHOR_NAME;
  var PORTAL_NAME$2 = "MenuPortal";
  var [PortalProvider, usePortalContext] = createMenuContext(PORTAL_NAME$2, {
    forceMount: void 0
  });
  var MenuPortal = (props) => {
    const { __scopeMenu, forceMount, children, container } = props;
    const context = useMenuContext(PORTAL_NAME$2, __scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$4, { asChild: true, container, children }) }) });
  };
  MenuPortal.displayName = PORTAL_NAME$2;
  var CONTENT_NAME$2 = "MenuContent";
  var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME$2);
  var MenuContent = reactExports.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext(CONTENT_NAME$2, props.__scopeMenu);
      const { forceMount = portalContext.forceMount, ...contentProps } = props;
      const context = useMenuContext(CONTENT_NAME$2, props.__scopeMenu);
      const rootContext = useMenuRootContext(CONTENT_NAME$2, props.__scopeMenu);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
    }
  );
  var MenuRootContentModal = reactExports.forwardRef(
    (props, forwardedRef) => {
      const context = useMenuContext(CONTENT_NAME$2, props.__scopeMenu);
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, ref);
      reactExports.useEffect(() => {
        const content2 = ref.current;
        if (content2) return hideOthers(content2);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuContentImpl,
        {
          ...props,
          ref: composedRefs,
          trapFocus: context.open,
          disableOutsidePointerEvents: context.open,
          disableOutsideScroll: true,
          onFocusOutside: composeEventHandlers$1(
            props.onFocusOutside,
            (event) => event.preventDefault(),
            { checkForDefaultPrevented: false }
          ),
          onDismiss: () => context.onOpenChange(false)
        }
      );
    }
  );
  var MenuRootContentNonModal = reactExports.forwardRef((props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME$2, props.__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        onDismiss: () => context.onOpenChange(false)
      }
    );
  });
  var Slot$1 = /* @__PURE__ */ createSlot("MenuContent.ScrollLock");
  var MenuContentImpl = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeMenu,
        loop = false,
        trapFocus,
        onOpenAutoFocus,
        onCloseAutoFocus,
        disableOutsidePointerEvents,
        onEntryFocus,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        disableOutsideScroll,
        ...contentProps
      } = props;
      const context = useMenuContext(CONTENT_NAME$2, __scopeMenu);
      const rootContext = useMenuRootContext(CONTENT_NAME$2, __scopeMenu);
      const popperScope = usePopperScope$1(__scopeMenu);
      const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeMenu);
      const getItems = useCollection$2(__scopeMenu);
      const [currentItemId, setCurrentItemId] = reactExports.useState(null);
      const contentRef = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, contentRef, context.onContentChange);
      const timerRef = reactExports.useRef(0);
      const searchRef = reactExports.useRef("");
      const pointerGraceTimerRef = reactExports.useRef(0);
      const pointerGraceIntentRef = reactExports.useRef(null);
      const pointerDirRef = reactExports.useRef("right");
      const lastPointerXRef = reactExports.useRef(0);
      const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll : reactExports.Fragment;
      const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot$1, allowPinchZoom: true } : void 0;
      const handleTypeaheadSearch = (key) => {
        var _a2, _b2;
        const search2 = searchRef.current + key;
        const items = getItems().filter((item) => !item.disabled);
        const currentItem = document.activeElement;
        const currentMatch = (_a2 = items.find((item) => item.ref.current === currentItem)) == null ? void 0 : _a2.textValue;
        const values = items.map((item) => item.textValue);
        const nextMatch = getNextMatch(values, search2, currentMatch);
        const newItem = (_b2 = items.find((item) => item.textValue === nextMatch)) == null ? void 0 : _b2.ref.current;
        (function updateSearch(value) {
          searchRef.current = value;
          window.clearTimeout(timerRef.current);
          if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
        })(search2);
        if (newItem) {
          setTimeout(() => newItem.focus());
        }
      };
      reactExports.useEffect(() => {
        return () => window.clearTimeout(timerRef.current);
      }, []);
      useFocusGuards();
      const isPointerMovingToSubmenu = reactExports.useCallback((event) => {
        var _a2, _b2;
        const isMovingTowards = pointerDirRef.current === ((_a2 = pointerGraceIntentRef.current) == null ? void 0 : _a2.side);
        return isMovingTowards && isPointerInGraceArea(event, (_b2 = pointerGraceIntentRef.current) == null ? void 0 : _b2.area);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuContentProvider,
        {
          scope: __scopeMenu,
          searchRef,
          onItemEnter: reactExports.useCallback(
            (event) => {
              if (isPointerMovingToSubmenu(event)) event.preventDefault();
            },
            [isPointerMovingToSubmenu]
          ),
          onItemLeave: reactExports.useCallback(
            (event) => {
              var _a2;
              if (isPointerMovingToSubmenu(event)) return;
              (_a2 = contentRef.current) == null ? void 0 : _a2.focus();
              setCurrentItemId(null);
            },
            [isPointerMovingToSubmenu]
          ),
          onTriggerLeave: reactExports.useCallback(
            (event) => {
              if (isPointerMovingToSubmenu(event)) event.preventDefault();
            },
            [isPointerMovingToSubmenu]
          ),
          pointerGraceTimerRef,
          onPointerGraceIntentChange: reactExports.useCallback((intent) => {
            pointerGraceIntentRef.current = intent;
          }, []),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusScope,
            {
              asChild: true,
              trapped: trapFocus,
              onMountAutoFocus: composeEventHandlers$1(onOpenAutoFocus, (event) => {
                var _a2;
                event.preventDefault();
                (_a2 = contentRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });
              }),
              onUnmountAutoFocus: onCloseAutoFocus,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                DismissableLayer,
                {
                  asChild: true,
                  disableOutsidePointerEvents,
                  onEscapeKeyDown,
                  onPointerDownOutside,
                  onFocusOutside,
                  onInteractOutside,
                  onDismiss,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Root$6,
                    {
                      asChild: true,
                      ...rovingFocusGroupScope,
                      dir: rootContext.dir,
                      orientation: "vertical",
                      loop,
                      currentTabStopId: currentItemId,
                      onCurrentTabStopIdChange: setCurrentItemId,
                      onEntryFocus: composeEventHandlers$1(onEntryFocus, (event) => {
                        if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                      }),
                      preventScrollOnEntryFocus: true,
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Content$1,
                        {
                          role: "menu",
                          "aria-orientation": "vertical",
                          "data-state": getOpenState(context.open),
                          "data-radix-menu-content": "",
                          dir: rootContext.dir,
                          ...popperScope,
                          ...contentProps,
                          ref: composedRefs,
                          style: { outline: "none", ...contentProps.style },
                          onKeyDown: composeEventHandlers$1(contentProps.onKeyDown, (event) => {
                            const target = event.target;
                            const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                            const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                            const isCharacterKey = event.key.length === 1;
                            if (isKeyDownInside) {
                              if (event.key === "Tab") event.preventDefault();
                              if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                            }
                            const content2 = contentRef.current;
                            if (event.target !== content2) return;
                            if (!FIRST_LAST_KEYS.includes(event.key)) return;
                            event.preventDefault();
                            const items = getItems().filter((item) => !item.disabled);
                            const candidateNodes = items.map((item) => item.ref.current);
                            if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                            focusFirst(candidateNodes);
                          }),
                          onBlur: composeEventHandlers$1(props.onBlur, (event) => {
                            if (!event.currentTarget.contains(event.target)) {
                              window.clearTimeout(timerRef.current);
                              searchRef.current = "";
                            }
                          }),
                          onPointerMove: composeEventHandlers$1(
                            props.onPointerMove,
                            whenMouse((event) => {
                              const target = event.target;
                              const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                              if (event.currentTarget.contains(target) && pointerXHasChanged) {
                                const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                                pointerDirRef.current = newDir;
                                lastPointerXRef.current = event.clientX;
                              }
                            })
                          )
                        }
                      )
                    }
                  )
                }
              )
            }
          ) })
        }
      );
    }
  );
  MenuContent.displayName = CONTENT_NAME$2;
  var GROUP_NAME$2 = "MenuGroup";
  var MenuGroup = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeMenu, ...groupProps } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
    }
  );
  MenuGroup.displayName = GROUP_NAME$2;
  var LABEL_NAME$2 = "MenuLabel";
  var MenuLabel = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeMenu, ...labelProps } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...labelProps, ref: forwardedRef });
    }
  );
  MenuLabel.displayName = LABEL_NAME$2;
  var ITEM_NAME$3 = "MenuItem";
  var ITEM_SELECT = "menu.itemSelect";
  var MenuItem = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { disabled = false, onSelect, ...itemProps } = props;
      const ref = reactExports.useRef(null);
      const rootContext = useMenuRootContext(ITEM_NAME$3, props.__scopeMenu);
      const contentContext = useMenuContentContext(ITEM_NAME$3, props.__scopeMenu);
      const composedRefs = useComposedRefs$1(forwardedRef, ref);
      const isPointerDownRef = reactExports.useRef(false);
      const handleSelect = () => {
        const menuItem = ref.current;
        if (!disabled && menuItem) {
          const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
          menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
          dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
          if (itemSelectEvent.defaultPrevented) {
            isPointerDownRef.current = false;
          } else {
            rootContext.onClose();
          }
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuItemImpl,
        {
          ...itemProps,
          ref: composedRefs,
          disabled,
          onClick: composeEventHandlers$1(props.onClick, handleSelect),
          onPointerDown: (event) => {
            var _a2;
            (_a2 = props.onPointerDown) == null ? void 0 : _a2.call(props, event);
            isPointerDownRef.current = true;
          },
          onPointerUp: composeEventHandlers$1(props.onPointerUp, (event) => {
            var _a2;
            if (!isPointerDownRef.current) (_a2 = event.currentTarget) == null ? void 0 : _a2.click();
          }),
          onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
            const isTypingAhead = contentContext.searchRef.current !== "";
            if (disabled || isTypingAhead && event.key === " ") return;
            if (SELECTION_KEYS$1.includes(event.key)) {
              event.currentTarget.click();
              event.preventDefault();
            }
          })
        }
      );
    }
  );
  MenuItem.displayName = ITEM_NAME$3;
  var MenuItemImpl = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
      const contentContext = useMenuContentContext(ITEM_NAME$3, __scopeMenu);
      const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeMenu);
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, ref);
      const [isFocused, setIsFocused] = reactExports.useState(false);
      const [textContent, setTextContent] = reactExports.useState("");
      reactExports.useEffect(() => {
        const menuItem = ref.current;
        if (menuItem) {
          setTextContent((menuItem.textContent ?? "").trim());
        }
      }, [itemProps.children]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Collection$2.ItemSlot,
        {
          scope: __scopeMenu,
          disabled,
          textValue: textValue ?? textContent,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              role: "menuitem",
              "data-highlighted": isFocused ? "" : void 0,
              "aria-disabled": disabled || void 0,
              "data-disabled": disabled ? "" : void 0,
              ...itemProps,
              ref: composedRefs,
              onPointerMove: composeEventHandlers$1(
                props.onPointerMove,
                whenMouse((event) => {
                  if (disabled) {
                    contentContext.onItemLeave(event);
                  } else {
                    contentContext.onItemEnter(event);
                    if (!event.defaultPrevented) {
                      const item = event.currentTarget;
                      item.focus({ preventScroll: true });
                    }
                  }
                })
              ),
              onPointerLeave: composeEventHandlers$1(
                props.onPointerLeave,
                whenMouse((event) => contentContext.onItemLeave(event))
              ),
              onFocus: composeEventHandlers$1(props.onFocus, () => setIsFocused(true)),
              onBlur: composeEventHandlers$1(props.onBlur, () => setIsFocused(false))
            }
          ) })
        }
      );
    }
  );
  var CHECKBOX_ITEM_NAME$1 = "MenuCheckboxItem";
  var MenuCheckboxItem = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuItem,
        {
          role: "menuitemcheckbox",
          "aria-checked": isIndeterminate$1(checked) ? "mixed" : checked,
          ...checkboxItemProps,
          ref: forwardedRef,
          "data-state": getCheckedState(checked),
          onSelect: composeEventHandlers$1(
            checkboxItemProps.onSelect,
            () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate$1(checked) ? true : !checked),
            { checkForDefaultPrevented: false }
          )
        }
      ) });
    }
  );
  MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
  var RADIO_GROUP_NAME$2 = "MenuRadioGroup";
  var [RadioGroupProvider$1, useRadioGroupContext$1] = createMenuContext(
    RADIO_GROUP_NAME$2,
    { value: void 0, onValueChange: () => {
    } }
  );
  var MenuRadioGroup = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { value, onValueChange, ...groupProps } = props;
      const handleValueChange = useCallbackRef$1(onValueChange);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupProvider$1, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
    }
  );
  MenuRadioGroup.displayName = RADIO_GROUP_NAME$2;
  var RADIO_ITEM_NAME$1 = "MenuRadioItem";
  var MenuRadioItem = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { value, ...radioItemProps } = props;
      const context = useRadioGroupContext$1(RADIO_ITEM_NAME$1, props.__scopeMenu);
      const checked = value === context.value;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuItem,
        {
          role: "menuitemradio",
          "aria-checked": checked,
          ...radioItemProps,
          ref: forwardedRef,
          "data-state": getCheckedState(checked),
          onSelect: composeEventHandlers$1(
            radioItemProps.onSelect,
            () => {
              var _a2;
              return (_a2 = context.onValueChange) == null ? void 0 : _a2.call(context, value);
            },
            { checkForDefaultPrevented: false }
          )
        }
      ) });
    }
  );
  MenuRadioItem.displayName = RADIO_ITEM_NAME$1;
  var ITEM_INDICATOR_NAME$1 = "MenuItemIndicator";
  var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
    ITEM_INDICATOR_NAME$1,
    { checked: false }
  );
  var MenuItemIndicator = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
      const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME$1, __scopeMenu);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Presence,
        {
          present: forceMount || isIndeterminate$1(indicatorContext.checked) || indicatorContext.checked === true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.span,
            {
              ...itemIndicatorProps,
              ref: forwardedRef,
              "data-state": getCheckedState(indicatorContext.checked)
            }
          )
        }
      );
    }
  );
  MenuItemIndicator.displayName = ITEM_INDICATOR_NAME$1;
  var SEPARATOR_NAME$2 = "MenuSeparator";
  var MenuSeparator = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeMenu, ...separatorProps } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          role: "separator",
          "aria-orientation": "horizontal",
          ...separatorProps,
          ref: forwardedRef
        }
      );
    }
  );
  MenuSeparator.displayName = SEPARATOR_NAME$2;
  var ARROW_NAME$2 = "MenuArrow";
  var MenuArrow = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeMenu, ...arrowProps } = props;
      const popperScope = usePopperScope$1(__scopeMenu);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
    }
  );
  MenuArrow.displayName = ARROW_NAME$2;
  var SUB_NAME = "MenuSub";
  var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
  var SUB_TRIGGER_NAME$1 = "MenuSubTrigger";
  var MenuSubTrigger = reactExports.forwardRef(
    (props, forwardedRef) => {
      const context = useMenuContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
      const rootContext = useMenuRootContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
      const subContext = useMenuSubContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
      const contentContext = useMenuContentContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
      const openTimerRef = reactExports.useRef(null);
      const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
      const scope = { __scopeMenu: props.__scopeMenu };
      const clearOpenTimer = reactExports.useCallback(() => {
        if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
        openTimerRef.current = null;
      }, []);
      reactExports.useEffect(() => clearOpenTimer, [clearOpenTimer]);
      reactExports.useEffect(() => {
        const pointerGraceTimer = pointerGraceTimerRef.current;
        return () => {
          window.clearTimeout(pointerGraceTimer);
          onPointerGraceIntentChange(null);
        };
      }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuItemImpl,
        {
          id: subContext.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": context.open,
          "aria-controls": subContext.contentId,
          "data-state": getOpenState(context.open),
          ...props,
          ref: composeRefs$1(forwardedRef, subContext.onTriggerChange),
          onClick: (event) => {
            var _a2;
            (_a2 = props.onClick) == null ? void 0 : _a2.call(props, event);
            if (props.disabled || event.defaultPrevented) return;
            event.currentTarget.focus();
            if (!context.open) context.onOpenChange(true);
          },
          onPointerMove: composeEventHandlers$1(
            props.onPointerMove,
            whenMouse((event) => {
              contentContext.onItemEnter(event);
              if (event.defaultPrevented) return;
              if (!props.disabled && !context.open && !openTimerRef.current) {
                contentContext.onPointerGraceIntentChange(null);
                openTimerRef.current = window.setTimeout(() => {
                  context.onOpenChange(true);
                  clearOpenTimer();
                }, 100);
              }
            })
          ),
          onPointerLeave: composeEventHandlers$1(
            props.onPointerLeave,
            whenMouse((event) => {
              var _a2, _b2;
              clearOpenTimer();
              const contentRect = (_a2 = context.content) == null ? void 0 : _a2.getBoundingClientRect();
              if (contentRect) {
                const side = (_b2 = context.content) == null ? void 0 : _b2.dataset.side;
                const rightSide = side === "right";
                const bleed = rightSide ? -5 : 5;
                const contentNearEdge = contentRect[rightSide ? "left" : "right"];
                const contentFarEdge = contentRect[rightSide ? "right" : "left"];
                contentContext.onPointerGraceIntentChange({
                  area: [
                    // Apply a bleed on clientX to ensure that our exit point is
                    // consistently within polygon bounds
                    { x: event.clientX + bleed, y: event.clientY },
                    { x: contentNearEdge, y: contentRect.top },
                    { x: contentFarEdge, y: contentRect.top },
                    { x: contentFarEdge, y: contentRect.bottom },
                    { x: contentNearEdge, y: contentRect.bottom }
                  ],
                  side
                });
                window.clearTimeout(pointerGraceTimerRef.current);
                pointerGraceTimerRef.current = window.setTimeout(
                  () => contentContext.onPointerGraceIntentChange(null),
                  300
                );
              } else {
                contentContext.onTriggerLeave(event);
                if (event.defaultPrevented) return;
                contentContext.onPointerGraceIntentChange(null);
              }
            })
          ),
          onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
            var _a2;
            const isTypingAhead = contentContext.searchRef.current !== "";
            if (props.disabled || isTypingAhead && event.key === " ") return;
            if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
              context.onOpenChange(true);
              (_a2 = context.content) == null ? void 0 : _a2.focus();
              event.preventDefault();
            }
          })
        }
      ) });
    }
  );
  MenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
  var SUB_CONTENT_NAME$1 = "MenuSubContent";
  var MenuSubContent = reactExports.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext(CONTENT_NAME$2, props.__scopeMenu);
      const { forceMount = portalContext.forceMount, ...subContentProps } = props;
      const context = useMenuContext(CONTENT_NAME$2, props.__scopeMenu);
      const rootContext = useMenuRootContext(CONTENT_NAME$2, props.__scopeMenu);
      const subContext = useMenuSubContext(SUB_CONTENT_NAME$1, props.__scopeMenu);
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, ref);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuContentImpl,
        {
          id: subContext.contentId,
          "aria-labelledby": subContext.triggerId,
          ...subContentProps,
          ref: composedRefs,
          align: "start",
          side: rootContext.dir === "rtl" ? "left" : "right",
          disableOutsidePointerEvents: false,
          disableOutsideScroll: false,
          trapFocus: false,
          onOpenAutoFocus: (event) => {
            var _a2;
            if (rootContext.isUsingKeyboardRef.current) (_a2 = ref.current) == null ? void 0 : _a2.focus();
            event.preventDefault();
          },
          onCloseAutoFocus: (event) => event.preventDefault(),
          onFocusOutside: composeEventHandlers$1(props.onFocusOutside, (event) => {
            if (event.target !== subContext.trigger) context.onOpenChange(false);
          }),
          onEscapeKeyDown: composeEventHandlers$1(props.onEscapeKeyDown, (event) => {
            rootContext.onClose();
            event.preventDefault();
          }),
          onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
            var _a2;
            const isKeyDownInside = event.currentTarget.contains(event.target);
            const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
            if (isKeyDownInside && isCloseKey) {
              context.onOpenChange(false);
              (_a2 = subContext.trigger) == null ? void 0 : _a2.focus();
              event.preventDefault();
            }
          })
        }
      ) }) }) });
    }
  );
  MenuSubContent.displayName = SUB_CONTENT_NAME$1;
  function getOpenState(open) {
    return open ? "open" : "closed";
  }
  function isIndeterminate$1(checked) {
    return checked === "indeterminate";
  }
  function getCheckedState(checked) {
    return isIndeterminate$1(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
  }
  function focusFirst(candidates) {
    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
    for (const candidate of candidates) {
      if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
      candidate.focus();
      if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
    }
  }
  function wrapArray$1(array, startIndex) {
    return array.map((_, index2) => array[(startIndex + index2) % array.length]);
  }
  function getNextMatch(values, search2, currentMatch) {
    const isRepeated = search2.length > 1 && Array.from(search2).every((char) => char === search2[0]);
    const normalizedSearch = isRepeated ? search2[0] : search2;
    const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
    let wrappedValues = wrapArray$1(values, Math.max(currentMatchIndex, 0));
    const excludeCurrentMatch = normalizedSearch.length === 1;
    if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
    const nextMatch = wrappedValues.find(
      (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
    );
    return nextMatch !== currentMatch ? nextMatch : void 0;
  }
  function isPointInPolygon(point2, polygon) {
    const { x, y } = point2;
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const ii = polygon[i];
      const jj = polygon[j];
      const xi = ii.x;
      const yi = ii.y;
      const xj = jj.x;
      const yj = jj.y;
      const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function isPointerInGraceArea(event, area) {
    if (!area) return false;
    const cursorPos = { x: event.clientX, y: event.clientY };
    return isPointInPolygon(cursorPos, area);
  }
  function whenMouse(handler) {
    return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
  }
  var Root3 = Menu;
  var Anchor2 = MenuAnchor;
  var Portal$1 = MenuPortal;
  var Content2$2 = MenuContent;
  var Group = MenuGroup;
  var Label$2 = MenuLabel;
  var Item2$2 = MenuItem;
  var CheckboxItem = MenuCheckboxItem;
  var RadioGroup$1 = MenuRadioGroup;
  var RadioItem = MenuRadioItem;
  var ItemIndicator$1 = MenuItemIndicator;
  var Separator$1 = MenuSeparator;
  var Arrow2 = MenuArrow;
  var SubTrigger = MenuSubTrigger;
  var SubContent = MenuSubContent;
  var DROPDOWN_MENU_NAME = "DropdownMenu";
  var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
    DROPDOWN_MENU_NAME,
    [createMenuScope]
  );
  var useMenuScope = createMenuScope();
  var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
  var DropdownMenu = (props) => {
    const {
      __scopeDropdownMenu,
      children,
      dir,
      open: openProp,
      defaultOpen,
      onOpenChange,
      modal = true
    } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const triggerRef = reactExports.useRef(null);
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? false,
      onChange: onOpenChange,
      caller: DROPDOWN_MENU_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DropdownMenuProvider,
      {
        scope: __scopeDropdownMenu,
        triggerId: useId(),
        triggerRef,
        contentId: useId(),
        open,
        onOpenChange: setOpen,
        onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        modal,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root3, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
      }
    );
  };
  DropdownMenu.displayName = DROPDOWN_MENU_NAME;
  var TRIGGER_NAME$2 = "DropdownMenuTrigger";
  var DropdownMenuTrigger = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
      const context = useDropdownMenuContext(TRIGGER_NAME$2, __scopeDropdownMenu);
      const menuScope = useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          id: context.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": context.open,
          "aria-controls": context.open ? context.contentId : void 0,
          "data-state": context.open ? "open" : "closed",
          "data-disabled": disabled ? "" : void 0,
          disabled,
          ...triggerProps,
          ref: composeRefs$1(forwardedRef, context.triggerRef),
          onPointerDown: composeEventHandlers$1(props.onPointerDown, (event) => {
            if (!disabled && event.button === 0 && event.ctrlKey === false) {
              context.onOpenToggle();
              if (!context.open) event.preventDefault();
            }
          }),
          onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
            if (disabled) return;
            if (["Enter", " "].includes(event.key)) context.onOpenToggle();
            if (event.key === "ArrowDown") context.onOpenChange(true);
            if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
          })
        }
      ) });
    }
  );
  DropdownMenuTrigger.displayName = TRIGGER_NAME$2;
  var PORTAL_NAME$1 = "DropdownMenuPortal";
  var DropdownMenuPortal = (props) => {
    const { __scopeDropdownMenu, ...portalProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { ...menuScope, ...portalProps });
  };
  DropdownMenuPortal.displayName = PORTAL_NAME$1;
  var CONTENT_NAME$1 = "DropdownMenuContent";
  var DropdownMenuContent$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDropdownMenu, ...contentProps } = props;
      const context = useDropdownMenuContext(CONTENT_NAME$1, __scopeDropdownMenu);
      const menuScope = useMenuScope(__scopeDropdownMenu);
      const hasInteractedOutsideRef = reactExports.useRef(false);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Content2$2,
        {
          id: context.contentId,
          "aria-labelledby": context.triggerId,
          ...menuScope,
          ...contentProps,
          ref: forwardedRef,
          onCloseAutoFocus: composeEventHandlers$1(props.onCloseAutoFocus, (event) => {
            var _a2;
            if (!hasInteractedOutsideRef.current) (_a2 = context.triggerRef.current) == null ? void 0 : _a2.focus();
            hasInteractedOutsideRef.current = false;
            event.preventDefault();
          }),
          onInteractOutside: composeEventHandlers$1(props.onInteractOutside, (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
          }),
          style: {
            ...props.style,
            // re-namespace exposed content custom properties
            ...{
              "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
              "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
              "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
            }
          }
        }
      );
    }
  );
  DropdownMenuContent$1.displayName = CONTENT_NAME$1;
  var GROUP_NAME$1 = "DropdownMenuGroup";
  var DropdownMenuGroup = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDropdownMenu, ...groupProps } = props;
      const menuScope = useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
    }
  );
  DropdownMenuGroup.displayName = GROUP_NAME$1;
  var LABEL_NAME$1 = "DropdownMenuLabel";
  var DropdownMenuLabel$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDropdownMenu, ...labelProps } = props;
      const menuScope = useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Label$2, { ...menuScope, ...labelProps, ref: forwardedRef });
    }
  );
  DropdownMenuLabel$1.displayName = LABEL_NAME$1;
  var ITEM_NAME$2 = "DropdownMenuItem";
  var DropdownMenuItem$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDropdownMenu, ...itemProps } = props;
      const menuScope = useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$2, { ...menuScope, ...itemProps, ref: forwardedRef });
    }
  );
  DropdownMenuItem$1.displayName = ITEM_NAME$2;
  var CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem";
  var DropdownMenuCheckboxItem$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeDropdownMenu, ...checkboxItemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
  });
  DropdownMenuCheckboxItem$1.displayName = CHECKBOX_ITEM_NAME;
  var RADIO_GROUP_NAME$1 = "DropdownMenuRadioGroup";
  var DropdownMenuRadioGroup = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeDropdownMenu, ...radioGroupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup$1, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
  });
  DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME$1;
  var RADIO_ITEM_NAME = "DropdownMenuRadioItem";
  var DropdownMenuRadioItem$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeDropdownMenu, ...radioItemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
  });
  DropdownMenuRadioItem$1.displayName = RADIO_ITEM_NAME;
  var INDICATOR_NAME$2 = "DropdownMenuItemIndicator";
  var DropdownMenuItemIndicator = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator$1, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
  });
  DropdownMenuItemIndicator.displayName = INDICATOR_NAME$2;
  var SEPARATOR_NAME$1 = "DropdownMenuSeparator";
  var DropdownMenuSeparator$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeDropdownMenu, ...separatorProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator$1, { ...menuScope, ...separatorProps, ref: forwardedRef });
  });
  DropdownMenuSeparator$1.displayName = SEPARATOR_NAME$1;
  var ARROW_NAME$1 = "DropdownMenuArrow";
  var DropdownMenuArrow = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDropdownMenu, ...arrowProps } = props;
      const menuScope = useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { ...menuScope, ...arrowProps, ref: forwardedRef });
    }
  );
  DropdownMenuArrow.displayName = ARROW_NAME$1;
  var SUB_TRIGGER_NAME = "DropdownMenuSubTrigger";
  var DropdownMenuSubTrigger$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeDropdownMenu, ...subTriggerProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
  });
  DropdownMenuSubTrigger$1.displayName = SUB_TRIGGER_NAME;
  var SUB_CONTENT_NAME = "DropdownMenuSubContent";
  var DropdownMenuSubContent$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeDropdownMenu, ...subContentProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SubContent,
      {
        ...menuScope,
        ...subContentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  });
  DropdownMenuSubContent$1.displayName = SUB_CONTENT_NAME;
  var Root2$1 = DropdownMenu;
  var Trigger$1 = DropdownMenuTrigger;
  var Portal2 = DropdownMenuPortal;
  var Content2$1 = DropdownMenuContent$1;
  var Label2 = DropdownMenuLabel$1;
  var Item2$1 = DropdownMenuItem$1;
  var CheckboxItem2 = DropdownMenuCheckboxItem$1;
  var RadioItem2 = DropdownMenuRadioItem$1;
  var ItemIndicator2 = DropdownMenuItemIndicator;
  var Separator2 = DropdownMenuSeparator$1;
  var SubTrigger2 = DropdownMenuSubTrigger$1;
  var SubContent2 = DropdownMenuSubContent$1;
  function clamp$1(value, [min2, max2]) {
    return Math.min(max2, Math.max(min2, value));
  }
  function usePrevious(value) {
    const ref = reactExports.useRef({ value, previous: value });
    return reactExports.useMemo(() => {
      if (ref.current.value !== value) {
        ref.current.previous = ref.current.value;
        ref.current.value = value;
      }
      return ref.current.previous;
    }, [value]);
  }
  var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
  var SELECTION_KEYS = [" ", "Enter"];
  var SELECT_NAME = "Select";
  var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(SELECT_NAME);
  var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
    createCollectionScope$1,
    createPopperScope
  ]);
  var usePopperScope = createPopperScope();
  var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
  var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
  var TRIGGER_NAME$1 = "SelectTrigger";
  var SelectTrigger$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, disabled = false, ...triggerProps } = props;
      const popperScope = usePopperScope(__scopeSelect);
      const context = useSelectContext(TRIGGER_NAME$1, __scopeSelect);
      const isDisabled = context.disabled || disabled;
      const composedRefs = useComposedRefs$1(forwardedRef, context.onTriggerChange);
      const getItems = useCollection$1(__scopeSelect);
      const pointerTypeRef = reactExports.useRef("touch");
      const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search2) => {
        const enabledItems = getItems().filter((item) => !item.disabled);
        const currentItem = enabledItems.find((item) => item.value === context.value);
        const nextItem = findNextItem(enabledItems, search2, currentItem);
        if (nextItem !== void 0) {
          context.onValueChange(nextItem.value);
        }
      });
      const handleOpen = (pointerEvent) => {
        if (!isDisabled) {
          context.onOpenChange(true);
          resetTypeahead();
        }
        if (pointerEvent) {
          context.triggerPointerDownPosRef.current = {
            x: Math.round(pointerEvent.pageX),
            y: Math.round(pointerEvent.pageY)
          };
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "combobox",
          "aria-controls": context.contentId,
          "aria-expanded": context.open,
          "aria-required": context.required,
          "aria-autocomplete": "none",
          dir: context.dir,
          "data-state": context.open ? "open" : "closed",
          disabled: isDisabled,
          "data-disabled": isDisabled ? "" : void 0,
          "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
          ...triggerProps,
          ref: composedRefs,
          onClick: composeEventHandlers$1(triggerProps.onClick, (event) => {
            event.currentTarget.focus();
            if (pointerTypeRef.current !== "mouse") {
              handleOpen(event);
            }
          }),
          onPointerDown: composeEventHandlers$1(triggerProps.onPointerDown, (event) => {
            pointerTypeRef.current = event.pointerType;
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) {
              target.releasePointerCapture(event.pointerId);
            }
            if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
              handleOpen(event);
              event.preventDefault();
            }
          }),
          onKeyDown: composeEventHandlers$1(triggerProps.onKeyDown, (event) => {
            const isTypingAhead = searchRef.current !== "";
            const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
            if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
            if (isTypingAhead && event.key === " ") return;
            if (OPEN_KEYS.includes(event.key)) {
              handleOpen();
              event.preventDefault();
            }
          })
        }
      ) });
    }
  );
  SelectTrigger$1.displayName = TRIGGER_NAME$1;
  var VALUE_NAME = "SelectValue";
  var SelectValue = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
      const context = useSelectContext(VALUE_NAME, __scopeSelect);
      const { onValueNodeHasChildrenChange } = context;
      const hasChildren = children !== void 0;
      const composedRefs = useComposedRefs$1(forwardedRef, context.onValueNodeChange);
      useLayoutEffect2(() => {
        onValueNodeHasChildrenChange(hasChildren);
      }, [onValueNodeHasChildrenChange, hasChildren]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          ...valueProps,
          ref: composedRefs,
          style: { pointerEvents: "none" },
          children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
        }
      );
    }
  );
  SelectValue.displayName = VALUE_NAME;
  var ICON_NAME = "SelectIcon";
  var SelectIcon = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, children, ...iconProps } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "" });
    }
  );
  SelectIcon.displayName = ICON_NAME;
  var PORTAL_NAME = "SelectPortal";
  var SelectPortal = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$4, { asChild: true, ...props });
  };
  SelectPortal.displayName = PORTAL_NAME;
  var CONTENT_NAME = "SelectContent";
  var SelectContent$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const context = useSelectContext(CONTENT_NAME, props.__scopeSelect);
      const [fragment, setFragment] = reactExports.useState();
      useLayoutEffect2(() => {
        setFragment(new DocumentFragment());
      }, []);
      if (!context.open) {
        const frag = fragment;
        return frag ? reactDomExports.createPortal(
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
          frag
        ) : null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
    }
  );
  SelectContent$1.displayName = CONTENT_NAME;
  var CONTENT_MARGIN = 10;
  var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME);
  var CONTENT_IMPL_NAME = "SelectContentImpl";
  var Slot = /* @__PURE__ */ createSlot("SelectContent.RemoveScroll");
  var SelectContentImpl = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeSelect,
        position: position2 = "item-aligned",
        onCloseAutoFocus,
        onEscapeKeyDown,
        onPointerDownOutside,
        //
        // PopperContent props
        side,
        sideOffset,
        align,
        alignOffset,
        arrowPadding,
        collisionBoundary,
        collisionPadding,
        sticky,
        hideWhenDetached,
        avoidCollisions,
        //
        ...contentProps
      } = props;
      const context = useSelectContext(CONTENT_NAME, __scopeSelect);
      const [content2, setContent] = reactExports.useState(null);
      const [viewport, setViewport] = reactExports.useState(null);
      const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setContent(node2));
      const [selectedItem, setSelectedItem] = reactExports.useState(null);
      const [selectedItemText, setSelectedItemText] = reactExports.useState(
        null
      );
      const getItems = useCollection$1(__scopeSelect);
      const [isPositioned, setIsPositioned] = reactExports.useState(false);
      const firstValidItemFoundRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        if (content2) return hideOthers(content2);
      }, [content2]);
      useFocusGuards();
      const focusFirst2 = reactExports.useCallback(
        (candidates) => {
          const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
          const [lastItem] = restItems.slice(-1);
          const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
          for (const candidate of candidates) {
            if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
            candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
            if (candidate === firstItem && viewport) viewport.scrollTop = 0;
            if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
            candidate == null ? void 0 : candidate.focus();
            if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
          }
        },
        [getItems, viewport]
      );
      const focusSelectedItem = reactExports.useCallback(
        () => focusFirst2([selectedItem, content2]),
        [focusFirst2, selectedItem, content2]
      );
      reactExports.useEffect(() => {
        if (isPositioned) {
          focusSelectedItem();
        }
      }, [isPositioned, focusSelectedItem]);
      const { onOpenChange, triggerPointerDownPosRef } = context;
      reactExports.useEffect(() => {
        if (content2) {
          let pointerMoveDelta = { x: 0, y: 0 };
          const handlePointerMove = (event) => {
            var _a2, _b2;
            pointerMoveDelta = {
              x: Math.abs(Math.round(event.pageX) - (((_a2 = triggerPointerDownPosRef.current) == null ? void 0 : _a2.x) ?? 0)),
              y: Math.abs(Math.round(event.pageY) - (((_b2 = triggerPointerDownPosRef.current) == null ? void 0 : _b2.y) ?? 0))
            };
          };
          const handlePointerUp = (event) => {
            if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
              event.preventDefault();
            } else {
              if (!content2.contains(event.target)) {
                onOpenChange(false);
              }
            }
            document.removeEventListener("pointermove", handlePointerMove);
            triggerPointerDownPosRef.current = null;
          };
          if (triggerPointerDownPosRef.current !== null) {
            document.addEventListener("pointermove", handlePointerMove);
            document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
          }
          return () => {
            document.removeEventListener("pointermove", handlePointerMove);
            document.removeEventListener("pointerup", handlePointerUp, { capture: true });
          };
        }
      }, [content2, onOpenChange, triggerPointerDownPosRef]);
      reactExports.useEffect(() => {
        const close = () => onOpenChange(false);
        window.addEventListener("blur", close);
        window.addEventListener("resize", close);
        return () => {
          window.removeEventListener("blur", close);
          window.removeEventListener("resize", close);
        };
      }, [onOpenChange]);
      const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search2) => {
        const enabledItems = getItems().filter((item) => !item.disabled);
        const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
        const nextItem = findNextItem(enabledItems, search2, currentItem);
        if (nextItem) {
          setTimeout(() => nextItem.ref.current.focus());
        }
      });
      const itemRefCallback = reactExports.useCallback(
        (node2, value, disabled) => {
          const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
          const isSelectedItem = context.value !== void 0 && context.value === value;
          if (isSelectedItem || isFirstValidItem) {
            setSelectedItem(node2);
            if (isFirstValidItem) firstValidItemFoundRef.current = true;
          }
        },
        [context.value]
      );
      const handleItemLeave = reactExports.useCallback(() => content2 == null ? void 0 : content2.focus(), [content2]);
      const itemTextRefCallback = reactExports.useCallback(
        (node2, value, disabled) => {
          const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
          const isSelectedItem = context.value !== void 0 && context.value === value;
          if (isSelectedItem || isFirstValidItem) {
            setSelectedItemText(node2);
          }
        },
        [context.value]
      );
      const SelectPosition = position2 === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
      const popperContentProps = SelectPosition === SelectPopperPosition ? {
        side,
        sideOffset,
        align,
        alignOffset,
        arrowPadding,
        collisionBoundary,
        collisionPadding,
        sticky,
        hideWhenDetached,
        avoidCollisions
      } : {};
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectContentProvider,
        {
          scope: __scopeSelect,
          content: content2,
          viewport,
          onViewportChange: setViewport,
          itemRefCallback,
          selectedItem,
          onItemLeave: handleItemLeave,
          itemTextRefCallback,
          focusSelectedItem,
          selectedItemText,
          position: position2,
          isPositioned,
          searchRef,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusScope,
            {
              asChild: true,
              trapped: context.open,
              onMountAutoFocus: (event) => {
                event.preventDefault();
              },
              onUnmountAutoFocus: composeEventHandlers$1(onCloseAutoFocus, (event) => {
                var _a2;
                (_a2 = context.trigger) == null ? void 0 : _a2.focus({ preventScroll: true });
                event.preventDefault();
              }),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                DismissableLayer,
                {
                  asChild: true,
                  disableOutsidePointerEvents: true,
                  onEscapeKeyDown,
                  onPointerDownOutside,
                  onFocusOutside: (event) => event.preventDefault(),
                  onDismiss: () => context.onOpenChange(false),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    SelectPosition,
                    {
                      role: "listbox",
                      id: context.contentId,
                      "data-state": context.open ? "open" : "closed",
                      dir: context.dir,
                      onContextMenu: (event) => event.preventDefault(),
                      ...contentProps,
                      ...popperContentProps,
                      onPlaced: () => setIsPositioned(true),
                      ref: composedRefs,
                      style: {
                        // flex layout so we can place the scroll buttons properly
                        display: "flex",
                        flexDirection: "column",
                        // reset the outline by default as the content MAY get focused
                        outline: "none",
                        ...contentProps.style
                      },
                      onKeyDown: composeEventHandlers$1(contentProps.onKeyDown, (event) => {
                        const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                        if (event.key === "Tab") event.preventDefault();
                        if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                        if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                          const items = getItems().filter((item) => !item.disabled);
                          let candidateNodes = items.map((item) => item.ref.current);
                          if (["ArrowUp", "End"].includes(event.key)) {
                            candidateNodes = candidateNodes.slice().reverse();
                          }
                          if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                            const currentElement = event.target;
                            const currentIndex = candidateNodes.indexOf(currentElement);
                            candidateNodes = candidateNodes.slice(currentIndex + 1);
                          }
                          setTimeout(() => focusFirst2(candidateNodes));
                          event.preventDefault();
                        }
                      })
                    }
                  )
                }
              )
            }
          ) })
        }
      );
    }
  );
  SelectContentImpl.displayName = CONTENT_IMPL_NAME;
  var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
  var SelectItemAlignedPosition = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, onPlaced, ...popperProps } = props;
    const context = useSelectContext(CONTENT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(CONTENT_NAME, __scopeSelect);
    const [contentWrapper, setContentWrapper] = reactExports.useState(null);
    const [content2, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setContent(node2));
    const getItems = useCollection$1(__scopeSelect);
    const shouldExpandOnScrollRef = reactExports.useRef(false);
    const shouldRepositionRef = reactExports.useRef(true);
    const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
    const position2 = reactExports.useCallback(() => {
      if (context.trigger && context.valueNode && contentWrapper && content2 && viewport && selectedItem && selectedItemText) {
        const triggerRect = context.trigger.getBoundingClientRect();
        const contentRect = content2.getBoundingClientRect();
        const valueNodeRect = context.valueNode.getBoundingClientRect();
        const itemTextRect = selectedItemText.getBoundingClientRect();
        if (context.dir !== "rtl") {
          const itemTextOffset = itemTextRect.left - contentRect.left;
          const left = valueNodeRect.left - itemTextOffset;
          const leftDelta = triggerRect.left - left;
          const minContentWidth = triggerRect.width + leftDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const rightEdge = window.innerWidth - CONTENT_MARGIN;
          const clampedLeft = clamp$1(left, [
            CONTENT_MARGIN,
            // Prevents the content from going off the starting edge of the
            // viewport. It may still go off the ending edge, but this can be
            // controlled by the user since they may want to manage overflow in a
            // specific way.
            // https://github.com/radix-ui/primitives/issues/2049
            Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
          ]);
          contentWrapper.style.minWidth = minContentWidth + "px";
          contentWrapper.style.left = clampedLeft + "px";
        } else {
          const itemTextOffset = contentRect.right - itemTextRect.right;
          const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
          const rightDelta = window.innerWidth - triggerRect.right - right;
          const minContentWidth = triggerRect.width + rightDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const leftEdge = window.innerWidth - CONTENT_MARGIN;
          const clampedRight = clamp$1(right, [
            CONTENT_MARGIN,
            Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
          ]);
          contentWrapper.style.minWidth = minContentWidth + "px";
          contentWrapper.style.right = clampedRight + "px";
        }
        const items = getItems();
        const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
        const itemsHeight = viewport.scrollHeight;
        const contentStyles = window.getComputedStyle(content2);
        const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
        const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
        const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
        const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
        const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
        const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
        const viewportStyles = window.getComputedStyle(viewport);
        const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
        const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
        const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
        const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
        const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
        const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
        const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
        const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
        const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
        if (willAlignWithoutTopOverflow) {
          const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
          contentWrapper.style.bottom = "0px";
          const viewportOffsetBottom = content2.clientHeight - viewport.offsetTop - viewport.offsetHeight;
          const clampedTriggerMiddleToBottomEdge = Math.max(
            triggerMiddleToBottomEdge,
            selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
            (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
          );
          const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
          contentWrapper.style.height = height + "px";
        } else {
          const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
          contentWrapper.style.top = "0px";
          const clampedTopEdgeToTriggerMiddle = Math.max(
            topEdgeToTriggerMiddle,
            contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
            (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
          );
          const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
          contentWrapper.style.height = height + "px";
          viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
        }
        contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
        contentWrapper.style.minHeight = minContentHeight + "px";
        contentWrapper.style.maxHeight = availableHeight + "px";
        onPlaced == null ? void 0 : onPlaced();
        requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
      }
    }, [
      getItems,
      context.trigger,
      context.valueNode,
      contentWrapper,
      content2,
      viewport,
      selectedItem,
      selectedItemText,
      context.dir,
      onPlaced
    ]);
    useLayoutEffect2(() => position2(), [position2]);
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content2) setContentZIndex(window.getComputedStyle(content2).zIndex);
    }, [content2]);
    const handleScrollButtonChange = reactExports.useCallback(
      (node2) => {
        if (node2 && shouldRepositionRef.current === true) {
          position2();
          focusSelectedItem == null ? void 0 : focusSelectedItem();
          shouldRepositionRef.current = false;
        }
      },
      [position2, focusSelectedItem]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectViewportProvider,
      {
        scope: __scopeSelect,
        contentWrapper,
        shouldExpandOnScrollRef,
        onScrollButtonChange: handleScrollButtonChange,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            ref: setContentWrapper,
            style: {
              display: "flex",
              flexDirection: "column",
              position: "fixed",
              zIndex: contentZIndex
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                ...popperProps,
                ref: composedRefs,
                style: {
                  // When we get the height of the content, it includes borders. If we were to set
                  // the height without having `boxSizing: 'border-box'` it would be too big.
                  boxSizing: "border-box",
                  // We need to ensure the content doesn't get taller than the wrapper
                  maxHeight: "100%",
                  ...popperProps.style
                }
              }
            )
          }
        )
      }
    );
  });
  SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
  var POPPER_POSITION_NAME = "SelectPopperPosition";
  var SelectPopperPosition = reactExports.forwardRef((props, forwardedRef) => {
    const {
      __scopeSelect,
      align = "start",
      collisionPadding = CONTENT_MARGIN,
      ...popperProps
    } = props;
    const popperScope = usePopperScope(__scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content$1,
      {
        ...popperScope,
        ...popperProps,
        ref: forwardedRef,
        align,
        collisionPadding,
        style: {
          // Ensure border-box for floating-ui calculations
          boxSizing: "border-box",
          ...popperProps.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-select-content-available-width": "var(--radix-popper-available-width)",
            "--radix-select-content-available-height": "var(--radix-popper-available-height)",
            "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  });
  SelectPopperPosition.displayName = POPPER_POSITION_NAME;
  var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME, {});
  var VIEWPORT_NAME = "SelectViewport";
  var SelectViewport = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, nonce, ...viewportProps } = props;
      const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
      const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
      const composedRefs = useComposedRefs$1(forwardedRef, contentContext.onViewportChange);
      const prevScrollTopRef = reactExports.useRef(0);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "style",
          {
            dangerouslySetInnerHTML: {
              __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
            },
            nonce
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            "data-radix-select-viewport": "",
            role: "presentation",
            ...viewportProps,
            ref: composedRefs,
            style: {
              // we use position: 'relative' here on the `viewport` so that when we call
              // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
              // (independent of the scrollUpButton).
              position: "relative",
              flex: 1,
              // Viewport should only be scrollable in the vertical direction.
              // This won't work in vertical writing modes, so we'll need to
              // revisit this if/when that is supported
              // https://developer.chrome.com/blog/vertical-form-controls
              overflow: "hidden auto",
              ...viewportProps.style
            },
            onScroll: composeEventHandlers$1(viewportProps.onScroll, (event) => {
              const viewport = event.currentTarget;
              const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
              if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
                const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
                if (scrolledBy > 0) {
                  const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                  const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                  const cssHeight = parseFloat(contentWrapper.style.height);
                  const prevHeight = Math.max(cssMinHeight, cssHeight);
                  if (prevHeight < availableHeight) {
                    const nextHeight = prevHeight + scrolledBy;
                    const clampedNextHeight = Math.min(availableHeight, nextHeight);
                    const heightDiff = nextHeight - clampedNextHeight;
                    contentWrapper.style.height = clampedNextHeight + "px";
                    if (contentWrapper.style.bottom === "0px") {
                      viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                      contentWrapper.style.justifyContent = "flex-end";
                    }
                  }
                }
              }
              prevScrollTopRef.current = viewport.scrollTop;
            })
          }
        ) })
      ] });
    }
  );
  SelectViewport.displayName = VIEWPORT_NAME;
  var GROUP_NAME = "SelectGroup";
  var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
  var SelectGroup = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, ...groupProps } = props;
      const groupId = useId();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
    }
  );
  SelectGroup.displayName = GROUP_NAME;
  var LABEL_NAME = "SelectLabel";
  var SelectLabel$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, ...labelProps } = props;
      const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
    }
  );
  SelectLabel$1.displayName = LABEL_NAME;
  var ITEM_NAME$1 = "SelectItem";
  var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME$1);
  var SelectItem$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeSelect,
        value,
        disabled = false,
        textValue: textValueProp,
        ...itemProps
      } = props;
      const context = useSelectContext(ITEM_NAME$1, __scopeSelect);
      const contentContext = useSelectContentContext(ITEM_NAME$1, __scopeSelect);
      const isSelected = context.value === value;
      const [textValue, setTextValue] = reactExports.useState(textValueProp ?? "");
      const [isFocused, setIsFocused] = reactExports.useState(false);
      const composedRefs = useComposedRefs$1(
        forwardedRef,
        (node2) => {
          var _a2;
          return (_a2 = contentContext.itemRefCallback) == null ? void 0 : _a2.call(contentContext, node2, value, disabled);
        }
      );
      const textId = useId();
      const pointerTypeRef = reactExports.useRef("touch");
      const handleSelect = () => {
        if (!disabled) {
          context.onValueChange(value);
          context.onOpenChange(false);
        }
      };
      if (value === "") {
        throw new Error(
          "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectItemContextProvider,
        {
          scope: __scopeSelect,
          value,
          disabled,
          textId,
          isSelected,
          onItemTextChange: reactExports.useCallback((node2) => {
            setTextValue((prevTextValue) => prevTextValue || ((node2 == null ? void 0 : node2.textContent) ?? "").trim());
          }, []),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Collection$1.ItemSlot,
            {
              scope: __scopeSelect,
              value,
              disabled,
              textValue,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Primitive.div,
                {
                  role: "option",
                  "aria-labelledby": textId,
                  "data-highlighted": isFocused ? "" : void 0,
                  "aria-selected": isSelected && isFocused,
                  "data-state": isSelected ? "checked" : "unchecked",
                  "aria-disabled": disabled || void 0,
                  "data-disabled": disabled ? "" : void 0,
                  tabIndex: disabled ? void 0 : -1,
                  ...itemProps,
                  ref: composedRefs,
                  onFocus: composeEventHandlers$1(itemProps.onFocus, () => setIsFocused(true)),
                  onBlur: composeEventHandlers$1(itemProps.onBlur, () => setIsFocused(false)),
                  onClick: composeEventHandlers$1(itemProps.onClick, () => {
                    if (pointerTypeRef.current !== "mouse") handleSelect();
                  }),
                  onPointerUp: composeEventHandlers$1(itemProps.onPointerUp, () => {
                    if (pointerTypeRef.current === "mouse") handleSelect();
                  }),
                  onPointerDown: composeEventHandlers$1(itemProps.onPointerDown, (event) => {
                    pointerTypeRef.current = event.pointerType;
                  }),
                  onPointerMove: composeEventHandlers$1(itemProps.onPointerMove, (event) => {
                    var _a2;
                    pointerTypeRef.current = event.pointerType;
                    if (disabled) {
                      (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
                    } else if (pointerTypeRef.current === "mouse") {
                      event.currentTarget.focus({ preventScroll: true });
                    }
                  }),
                  onPointerLeave: composeEventHandlers$1(itemProps.onPointerLeave, (event) => {
                    var _a2;
                    if (event.currentTarget === document.activeElement) {
                      (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
                    }
                  }),
                  onKeyDown: composeEventHandlers$1(itemProps.onKeyDown, (event) => {
                    var _a2;
                    const isTypingAhead = ((_a2 = contentContext.searchRef) == null ? void 0 : _a2.current) !== "";
                    if (isTypingAhead && event.key === " ") return;
                    if (SELECTION_KEYS.includes(event.key)) handleSelect();
                    if (event.key === " ") event.preventDefault();
                  })
                }
              )
            }
          )
        }
      );
    }
  );
  SelectItem$1.displayName = ITEM_NAME$1;
  var ITEM_TEXT_NAME = "SelectItemText";
  var SelectItemText = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, className, style, ...itemTextProps } = props;
      const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
      const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
      const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
      const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
      const [itemTextNode, setItemTextNode] = reactExports.useState(null);
      const composedRefs = useComposedRefs$1(
        forwardedRef,
        (node2) => setItemTextNode(node2),
        itemContext.onItemTextChange,
        (node2) => {
          var _a2;
          return (_a2 = contentContext.itemTextRefCallback) == null ? void 0 : _a2.call(contentContext, node2, itemContext.value, itemContext.disabled);
        }
      );
      const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
      const nativeOption = reactExports.useMemo(
        () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
        [itemContext.disabled, itemContext.value, textContent]
      );
      const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
      useLayoutEffect2(() => {
        onNativeOptionAdd(nativeOption);
        return () => onNativeOptionRemove(nativeOption);
      }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
        itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? reactDomExports.createPortal(itemTextProps.children, context.valueNode) : null
      ] });
    }
  );
  SelectItemText.displayName = ITEM_TEXT_NAME;
  var ITEM_INDICATOR_NAME = "SelectItemIndicator";
  var SelectItemIndicator = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, ...itemIndicatorProps } = props;
      const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
      return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
    }
  );
  SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
  var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
  var SelectScrollUpButton$1 = reactExports.forwardRef((props, forwardedRef) => {
    const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
    const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
    const [canScrollUp, setCanScrollUp] = reactExports.useState(false);
    const composedRefs = useComposedRefs$1(forwardedRef, viewportContext.onScrollButtonChange);
    useLayoutEffect2(() => {
      if (contentContext.viewport && contentContext.isPositioned) {
        let handleScroll2 = function() {
          const canScrollUp2 = viewport.scrollTop > 0;
          setCanScrollUp(canScrollUp2);
        };
        const viewport = contentContext.viewport;
        handleScroll2();
        viewport.addEventListener("scroll", handleScroll2);
        return () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [contentContext.viewport, contentContext.isPositioned]);
    return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectScrollButtonImpl,
      {
        ...props,
        ref: composedRefs,
        onAutoScroll: () => {
          const { viewport, selectedItem } = contentContext;
          if (viewport && selectedItem) {
            viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
          }
        }
      }
    ) : null;
  });
  SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
  var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
  var SelectScrollDownButton$1 = reactExports.forwardRef((props, forwardedRef) => {
    const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
    const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
    const [canScrollDown, setCanScrollDown] = reactExports.useState(false);
    const composedRefs = useComposedRefs$1(forwardedRef, viewportContext.onScrollButtonChange);
    useLayoutEffect2(() => {
      if (contentContext.viewport && contentContext.isPositioned) {
        let handleScroll2 = function() {
          const maxScroll = viewport.scrollHeight - viewport.clientHeight;
          const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
          setCanScrollDown(canScrollDown2);
        };
        const viewport = contentContext.viewport;
        handleScroll2();
        viewport.addEventListener("scroll", handleScroll2);
        return () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [contentContext.viewport, contentContext.isPositioned]);
    return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectScrollButtonImpl,
      {
        ...props,
        ref: composedRefs,
        onAutoScroll: () => {
          const { viewport, selectedItem } = contentContext;
          if (viewport && selectedItem) {
            viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
          }
        }
      }
    ) : null;
  });
  SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
  var SelectScrollButtonImpl = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
    const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
    const autoScrollTimerRef = reactExports.useRef(null);
    const getItems = useCollection$1(__scopeSelect);
    const clearAutoScrollTimer = reactExports.useCallback(() => {
      if (autoScrollTimerRef.current !== null) {
        window.clearInterval(autoScrollTimerRef.current);
        autoScrollTimerRef.current = null;
      }
    }, []);
    reactExports.useEffect(() => {
      return () => clearAutoScrollTimer();
    }, [clearAutoScrollTimer]);
    useLayoutEffect2(() => {
      var _a2;
      const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
      (_a2 = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a2.scrollIntoView({ block: "nearest" });
    }, [getItems]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "aria-hidden": true,
        ...scrollIndicatorProps,
        ref: forwardedRef,
        style: { flexShrink: 0, ...scrollIndicatorProps.style },
        onPointerDown: composeEventHandlers$1(scrollIndicatorProps.onPointerDown, () => {
          if (autoScrollTimerRef.current === null) {
            autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
          }
        }),
        onPointerMove: composeEventHandlers$1(scrollIndicatorProps.onPointerMove, () => {
          var _a2;
          (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
          if (autoScrollTimerRef.current === null) {
            autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
          }
        }),
        onPointerLeave: composeEventHandlers$1(scrollIndicatorProps.onPointerLeave, () => {
          clearAutoScrollTimer();
        })
      }
    );
  });
  var SEPARATOR_NAME = "SelectSeparator";
  var SelectSeparator$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, ...separatorProps } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
    }
  );
  SelectSeparator$1.displayName = SEPARATOR_NAME;
  var ARROW_NAME = "SelectArrow";
  var SelectArrow = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, ...arrowProps } = props;
      const popperScope = usePopperScope(__scopeSelect);
      const context = useSelectContext(ARROW_NAME, __scopeSelect);
      const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);
      return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
    }
  );
  SelectArrow.displayName = ARROW_NAME;
  var BUBBLE_INPUT_NAME$4 = "SelectBubbleInput";
  var SelectBubbleInput = reactExports.forwardRef(
    ({ __scopeSelect, value, ...props }, forwardedRef) => {
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, ref);
      const prevValue = usePrevious(value);
      reactExports.useEffect(() => {
        const select = ref.current;
        if (!select) return;
        const selectProto = window.HTMLSelectElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(
          selectProto,
          "value"
        );
        const setValue = descriptor.set;
        if (prevValue !== value && setValue) {
          const event = new Event("change", { bubbles: true });
          setValue.call(select, value);
          select.dispatchEvent(event);
        }
      }, [prevValue, value]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.select,
        {
          ...props,
          style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
          ref: composedRefs,
          defaultValue: value
        }
      );
    }
  );
  SelectBubbleInput.displayName = BUBBLE_INPUT_NAME$4;
  function shouldShowPlaceholder(value) {
    return value === "" || value === void 0;
  }
  function useTypeaheadSearch(onSearchChange) {
    const handleSearchChange = useCallbackRef$1(onSearchChange);
    const searchRef = reactExports.useRef("");
    const timerRef = reactExports.useRef(0);
    const handleTypeaheadSearch = reactExports.useCallback(
      (key) => {
        const search2 = searchRef.current + key;
        handleSearchChange(search2);
        (function updateSearch(value) {
          searchRef.current = value;
          window.clearTimeout(timerRef.current);
          if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
        })(search2);
      },
      [handleSearchChange]
    );
    const resetTypeahead = reactExports.useCallback(() => {
      searchRef.current = "";
      window.clearTimeout(timerRef.current);
    }, []);
    reactExports.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    return [searchRef, handleTypeaheadSearch, resetTypeahead];
  }
  function findNextItem(items, search2, currentItem) {
    const isRepeated = search2.length > 1 && Array.from(search2).every((char) => char === search2[0]);
    const normalizedSearch = isRepeated ? search2[0] : search2;
    const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizedSearch.length === 1;
    if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
    const nextItem = wrappedItems.find(
      (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
    );
    return nextItem !== currentItem ? nextItem : void 0;
  }
  function wrapArray(array, startIndex) {
    return array.map((_, index2) => array[(startIndex + index2) % array.length]);
  }
  var Trigger = SelectTrigger$1;
  var Icon = SelectIcon;
  var Portal = SelectPortal;
  var Content2 = SelectContent$1;
  var Viewport = SelectViewport;
  var Label$1 = SelectLabel$1;
  var Item = SelectItem$1;
  var ItemText = SelectItemText;
  var ItemIndicator = SelectItemIndicator;
  var ScrollUpButton = SelectScrollUpButton$1;
  var ScrollDownButton = SelectScrollDownButton$1;
  var Separator = SelectSeparator$1;
  var NAME = "Label";
  var Label = reactExports.forwardRef((props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.label,
      {
        ...props,
        ref: forwardedRef,
        onMouseDown: (event) => {
          var _a2;
          const target = event.target;
          if (target.closest("button, input, select, textarea")) return;
          (_a2 = props.onMouseDown) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
        }
      }
    );
  });
  Label.displayName = NAME;
  var Root$2 = Label;
  function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler == null ? void 0 : originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented) {
        return ourEventHandler == null ? void 0 : ourEventHandler(event);
      }
    };
  }
  var SWITCH_NAME = "Switch";
  var [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);
  var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
  var Switch$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeSwitch,
        name: name2,
        checked: checkedProp,
        defaultChecked,
        required,
        disabled,
        value = "on",
        onCheckedChange,
        form,
        ...switchProps
      } = props;
      const [button, setButton] = reactExports.useState(null);
      const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setButton(node2));
      const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
      const isFormControl = button ? form || !!button.closest("form") : true;
      const [checked, setChecked] = useControllableState({
        prop: checkedProp,
        defaultProp: defaultChecked ?? false,
        onChange: onCheckedChange,
        caller: SWITCH_NAME
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "switch",
            "aria-checked": checked,
            "aria-required": required,
            "data-state": getState$2(checked),
            "data-disabled": disabled ? "" : void 0,
            disabled,
            value,
            ...switchProps,
            ref: composedRefs,
            onClick: composeEventHandlers(props.onClick, (event) => {
              setChecked((prevChecked) => !prevChecked);
              if (isFormControl) {
                hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
                if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
              }
            })
          }
        ),
        isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
          SwitchBubbleInput,
          {
            control: button,
            bubbles: !hasConsumerStoppedPropagationRef.current,
            name: name2,
            value,
            checked,
            required,
            disabled,
            form,
            style: { transform: "translateX(-100%)" }
          }
        )
      ] });
    }
  );
  Switch$1.displayName = SWITCH_NAME;
  var THUMB_NAME$1 = "SwitchThumb";
  var SwitchThumb = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSwitch, ...thumbProps } = props;
      const context = useSwitchContext(THUMB_NAME$1, __scopeSwitch);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          "data-state": getState$2(context.checked),
          "data-disabled": context.disabled ? "" : void 0,
          ...thumbProps,
          ref: forwardedRef
        }
      );
    }
  );
  SwitchThumb.displayName = THUMB_NAME$1;
  var BUBBLE_INPUT_NAME$3 = "SwitchBubbleInput";
  var SwitchBubbleInput = reactExports.forwardRef(
    ({
      __scopeSwitch,
      control,
      checked,
      bubbles = true,
      ...props
    }, forwardedRef) => {
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(ref, forwardedRef);
      const prevChecked = usePrevious(checked);
      const controlSize = useSize(control);
      reactExports.useEffect(() => {
        const input = ref.current;
        if (!input) return;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(
          inputProto,
          "checked"
        );
        const setChecked = descriptor.set;
        if (prevChecked !== checked && setChecked) {
          const event = new Event("click", { bubbles });
          setChecked.call(input, checked);
          input.dispatchEvent(event);
        }
      }, [prevChecked, checked, bubbles]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "checkbox",
          "aria-hidden": true,
          defaultChecked: checked,
          ...props,
          tabIndex: -1,
          ref: composedRefs,
          style: {
            ...props.style,
            ...controlSize,
            position: "absolute",
            pointerEvents: "none",
            opacity: 0,
            margin: 0
          }
        }
      );
    }
  );
  SwitchBubbleInput.displayName = BUBBLE_INPUT_NAME$3;
  function getState$2(checked) {
    return checked ? "checked" : "unchecked";
  }
  var Root$1 = Switch$1;
  var Thumb$1 = SwitchThumb;
  var RADIO_NAME = "Radio";
  var [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);
  var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
  var Radio = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeRadio,
        name: name2,
        checked = false,
        required,
        disabled,
        value = "on",
        onCheck,
        form,
        ...radioProps
      } = props;
      const [button, setButton] = reactExports.useState(null);
      const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setButton(node2));
      const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
      const isFormControl = button ? form || !!button.closest("form") : true;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "radio",
            "aria-checked": checked,
            "data-state": getState$1(checked),
            "data-disabled": disabled ? "" : void 0,
            disabled,
            value,
            ...radioProps,
            ref: composedRefs,
            onClick: composeEventHandlers$1(props.onClick, (event) => {
              if (!checked) onCheck == null ? void 0 : onCheck();
              if (isFormControl) {
                hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
                if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
              }
            })
          }
        ),
        isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
          RadioBubbleInput,
          {
            control: button,
            bubbles: !hasConsumerStoppedPropagationRef.current,
            name: name2,
            value,
            checked,
            required,
            disabled,
            form,
            style: { transform: "translateX(-100%)" }
          }
        )
      ] });
    }
  );
  Radio.displayName = RADIO_NAME;
  var INDICATOR_NAME$1 = "RadioIndicator";
  var RadioIndicator = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeRadio, forceMount, ...indicatorProps } = props;
      const context = useRadioContext(INDICATOR_NAME$1, __scopeRadio);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          "data-state": getState$1(context.checked),
          "data-disabled": context.disabled ? "" : void 0,
          ...indicatorProps,
          ref: forwardedRef
        }
      ) });
    }
  );
  RadioIndicator.displayName = INDICATOR_NAME$1;
  var BUBBLE_INPUT_NAME$2 = "RadioBubbleInput";
  var RadioBubbleInput = reactExports.forwardRef(
    ({
      __scopeRadio,
      control,
      checked,
      bubbles = true,
      ...props
    }, forwardedRef) => {
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(ref, forwardedRef);
      const prevChecked = usePrevious(checked);
      const controlSize = useSize(control);
      reactExports.useEffect(() => {
        const input = ref.current;
        if (!input) return;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(
          inputProto,
          "checked"
        );
        const setChecked = descriptor.set;
        if (prevChecked !== checked && setChecked) {
          const event = new Event("click", { bubbles });
          setChecked.call(input, checked);
          input.dispatchEvent(event);
        }
      }, [prevChecked, checked, bubbles]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.input,
        {
          type: "radio",
          "aria-hidden": true,
          defaultChecked: checked,
          ...props,
          tabIndex: -1,
          ref: composedRefs,
          style: {
            ...props.style,
            ...controlSize,
            position: "absolute",
            pointerEvents: "none",
            opacity: 0,
            margin: 0
          }
        }
      );
    }
  );
  RadioBubbleInput.displayName = BUBBLE_INPUT_NAME$2;
  function getState$1(checked) {
    return checked ? "checked" : "unchecked";
  }
  var ARROW_KEYS$1 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
  var RADIO_GROUP_NAME = "RadioGroup";
  var [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME, [
    createRovingFocusGroupScope,
    createRadioScope
  ]);
  var useRovingFocusGroupScope = createRovingFocusGroupScope();
  var useRadioScope = createRadioScope();
  var [RadioGroupProvider, useRadioGroupContext] = createRadioGroupContext(RADIO_GROUP_NAME);
  var RadioGroup = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeRadioGroup,
        name: name2,
        defaultValue,
        value: valueProp,
        required = false,
        disabled = false,
        orientation: orientation2,
        dir,
        loop = true,
        onValueChange,
        ...groupProps
      } = props;
      const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeRadioGroup);
      const direction = useDirection(dir);
      const [value, setValue] = useControllableState({
        prop: valueProp,
        defaultProp: defaultValue ?? null,
        onChange: onValueChange,
        caller: RADIO_GROUP_NAME
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        RadioGroupProvider,
        {
          scope: __scopeRadioGroup,
          name: name2,
          required,
          disabled,
          value,
          onValueChange: setValue,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Root$6,
            {
              asChild: true,
              ...rovingFocusGroupScope,
              orientation: orientation2,
              dir: direction,
              loop,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Primitive.div,
                {
                  role: "radiogroup",
                  "aria-required": required,
                  "aria-orientation": orientation2,
                  "data-disabled": disabled ? "" : void 0,
                  dir: direction,
                  ...groupProps,
                  ref: forwardedRef
                }
              )
            }
          )
        }
      );
    }
  );
  RadioGroup.displayName = RADIO_GROUP_NAME;
  var ITEM_NAME = "RadioGroupItem";
  var RadioGroupItem$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeRadioGroup, disabled, ...itemProps } = props;
      const context = useRadioGroupContext(ITEM_NAME, __scopeRadioGroup);
      const isDisabled = context.disabled || disabled;
      const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeRadioGroup);
      const radioScope = useRadioScope(__scopeRadioGroup);
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, ref);
      const checked = context.value === itemProps.value;
      const isArrowKeyPressedRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        const handleKeyDown = (event) => {
          if (ARROW_KEYS$1.includes(event.key)) {
            isArrowKeyPressedRef.current = true;
          }
        };
        const handleKeyUp = () => isArrowKeyPressedRef.current = false;
        document.addEventListener("keydown", handleKeyDown);
        document.addEventListener("keyup", handleKeyUp);
        return () => {
          document.removeEventListener("keydown", handleKeyDown);
          document.removeEventListener("keyup", handleKeyUp);
        };
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Item$1,
        {
          asChild: true,
          ...rovingFocusGroupScope,
          focusable: !isDisabled,
          active: checked,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Radio,
            {
              disabled: isDisabled,
              required: context.required,
              checked,
              ...radioScope,
              ...itemProps,
              name: context.name,
              ref: composedRefs,
              onCheck: () => context.onValueChange(itemProps.value),
              onKeyDown: composeEventHandlers$1((event) => {
                if (event.key === "Enter") event.preventDefault();
              }),
              onFocus: composeEventHandlers$1(itemProps.onFocus, () => {
                var _a2;
                if (isArrowKeyPressedRef.current) (_a2 = ref.current) == null ? void 0 : _a2.click();
              })
            }
          )
        }
      );
    }
  );
  RadioGroupItem$1.displayName = ITEM_NAME;
  var INDICATOR_NAME2 = "RadioGroupIndicator";
  var RadioGroupIndicator = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeRadioGroup, ...indicatorProps } = props;
      const radioScope = useRadioScope(__scopeRadioGroup);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioIndicator, { ...radioScope, ...indicatorProps, ref: forwardedRef });
    }
  );
  RadioGroupIndicator.displayName = INDICATOR_NAME2;
  var Root2 = RadioGroup;
  var Item2 = RadioGroupItem$1;
  var Indicator = RadioGroupIndicator;
  var CHECKBOX_NAME = "Checkbox";
  var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
  var [CheckboxProviderImpl, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
  function CheckboxProvider(props) {
    const {
      __scopeCheckbox,
      checked: checkedProp,
      children,
      defaultChecked,
      disabled,
      form,
      name: name2,
      onCheckedChange,
      required,
      value = "on",
      // @ts-expect-error
      internal_do_not_use_render
    } = props;
    const [checked, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked ?? false,
      onChange: onCheckedChange,
      caller: CHECKBOX_NAME
    });
    const [control, setControl] = reactExports.useState(null);
    const [bubbleInput, setBubbleInput] = reactExports.useState(null);
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = control ? !!form || !!control.closest("form") : (
      // We set this to true by default so that events bubble to forms without JS (SSR)
      true
    );
    const context = {
      checked,
      disabled,
      setChecked,
      control,
      setControl,
      name: name2,
      form,
      value,
      hasConsumerStoppedPropagationRef,
      required,
      defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked,
      isFormControl,
      bubbleInput,
      setBubbleInput
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CheckboxProviderImpl,
      {
        scope: __scopeCheckbox,
        ...context,
        children: isFunction$1(internal_do_not_use_render) ? internal_do_not_use_render(context) : children
      }
    );
  }
  var TRIGGER_NAME = "CheckboxTrigger";
  var CheckboxTrigger = reactExports.forwardRef(
    ({ __scopeCheckbox, onKeyDown, onClick, ...checkboxProps }, forwardedRef) => {
      const {
        control,
        value,
        disabled,
        checked,
        required,
        setControl,
        setChecked,
        hasConsumerStoppedPropagationRef,
        isFormControl,
        bubbleInput
      } = useCheckboxContext(TRIGGER_NAME, __scopeCheckbox);
      const composedRefs = useComposedRefs$1(forwardedRef, setControl);
      const initialCheckedStateRef = reactExports.useRef(checked);
      reactExports.useEffect(() => {
        const form = control == null ? void 0 : control.form;
        if (form) {
          const reset = () => setChecked(initialCheckedStateRef.current);
          form.addEventListener("reset", reset);
          return () => form.removeEventListener("reset", reset);
        }
      }, [control, setChecked]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "checkbox",
          "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
          "aria-required": required,
          "data-state": getState(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...checkboxProps,
          ref: composedRefs,
          onKeyDown: composeEventHandlers$1(onKeyDown, (event) => {
            if (event.key === "Enter") event.preventDefault();
          }),
          onClick: composeEventHandlers$1(onClick, (event) => {
            setChecked((prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked);
            if (bubbleInput && isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      );
    }
  );
  CheckboxTrigger.displayName = TRIGGER_NAME;
  var Checkbox$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeCheckbox,
        name: name2,
        checked,
        defaultChecked,
        required,
        disabled,
        value,
        onCheckedChange,
        form,
        ...checkboxProps
      } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CheckboxProvider,
        {
          __scopeCheckbox,
          checked,
          defaultChecked,
          disabled,
          required,
          onCheckedChange,
          name: name2,
          form,
          value,
          internal_do_not_use_render: ({ isFormControl }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CheckboxTrigger,
              {
                ...checkboxProps,
                ref: forwardedRef,
                __scopeCheckbox
              }
            ),
            isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
              CheckboxBubbleInput,
              {
                __scopeCheckbox
              }
            )
          ] })
        }
      );
    }
  );
  Checkbox$1.displayName = CHECKBOX_NAME;
  var INDICATOR_NAME = "CheckboxIndicator";
  var CheckboxIndicator = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
      const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Presence,
        {
          present: forceMount || isIndeterminate(context.checked) || context.checked === true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.span,
            {
              "data-state": getState(context.checked),
              "data-disabled": context.disabled ? "" : void 0,
              ...indicatorProps,
              ref: forwardedRef,
              style: { pointerEvents: "none", ...props.style }
            }
          )
        }
      );
    }
  );
  CheckboxIndicator.displayName = INDICATOR_NAME;
  var BUBBLE_INPUT_NAME$1 = "CheckboxBubbleInput";
  var CheckboxBubbleInput = reactExports.forwardRef(
    ({ __scopeCheckbox, ...props }, forwardedRef) => {
      const {
        control,
        hasConsumerStoppedPropagationRef,
        checked,
        defaultChecked,
        required,
        disabled,
        name: name2,
        value,
        form,
        bubbleInput,
        setBubbleInput
      } = useCheckboxContext(BUBBLE_INPUT_NAME$1, __scopeCheckbox);
      const composedRefs = useComposedRefs$1(forwardedRef, setBubbleInput);
      const prevChecked = usePrevious(checked);
      const controlSize = useSize(control);
      reactExports.useEffect(() => {
        const input = bubbleInput;
        if (!input) return;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(
          inputProto,
          "checked"
        );
        const setChecked = descriptor.set;
        const bubbles = !hasConsumerStoppedPropagationRef.current;
        if (prevChecked !== checked && setChecked) {
          const event = new Event("click", { bubbles });
          input.indeterminate = isIndeterminate(checked);
          setChecked.call(input, isIndeterminate(checked) ? false : checked);
          input.dispatchEvent(event);
        }
      }, [bubbleInput, prevChecked, checked, hasConsumerStoppedPropagationRef]);
      const defaultCheckedRef = reactExports.useRef(isIndeterminate(checked) ? false : checked);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.input,
        {
          type: "checkbox",
          "aria-hidden": true,
          defaultChecked: defaultChecked ?? defaultCheckedRef.current,
          required,
          disabled,
          name: name2,
          value,
          form,
          ...props,
          tabIndex: -1,
          ref: composedRefs,
          style: {
            ...props.style,
            ...controlSize,
            position: "absolute",
            pointerEvents: "none",
            opacity: 0,
            margin: 0,
            // We transform because the input is absolutely positioned but we have
            // rendered it **after** the button. This pulls it back to sit on top
            // of the button.
            transform: "translateX(-100%)"
          }
        }
      );
    }
  );
  CheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME$1;
  function isFunction$1(value) {
    return typeof value === "function";
  }
  function isIndeterminate(checked) {
    return checked === "indeterminate";
  }
  function getState(checked) {
    return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
  }
  var PAGE_KEYS = ["PageUp", "PageDown"];
  var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
  var BACK_KEYS = {
    "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
    "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
  };
  var SLIDER_NAME = "Slider";
  var [Collection, useCollection, createCollectionScope] = createCollection(SLIDER_NAME);
  var [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [
    createCollectionScope
  ]);
  var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
  var Slider$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        name: name2,
        min: min2 = 0,
        max: max2 = 100,
        step = 1,
        orientation: orientation2 = "horizontal",
        disabled = false,
        minStepsBetweenThumbs = 0,
        defaultValue = [min2],
        value,
        onValueChange = () => {
        },
        onValueCommit = () => {
        },
        inverted = false,
        form,
        ...sliderProps
      } = props;
      const thumbRefs = reactExports.useRef(/* @__PURE__ */ new Set());
      const valueIndexToChangeRef = reactExports.useRef(0);
      const isHorizontal = orientation2 === "horizontal";
      const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
      const [values = [], setValues] = useControllableState({
        prop: value,
        defaultProp: defaultValue,
        onChange: (value2) => {
          var _a2;
          const thumbs = [...thumbRefs.current];
          (_a2 = thumbs[valueIndexToChangeRef.current]) == null ? void 0 : _a2.focus();
          onValueChange(value2);
        }
      });
      const valuesBeforeSlideStartRef = reactExports.useRef(values);
      function handleSlideStart(value2) {
        const closestIndex = getClosestValueIndex(values, value2);
        updateValues(value2, closestIndex);
      }
      function handleSlideMove(value2) {
        updateValues(value2, valueIndexToChangeRef.current);
      }
      function handleSlideEnd() {
        const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
        const nextValue = values[valueIndexToChangeRef.current];
        const hasChanged = nextValue !== prevValue;
        if (hasChanged) onValueCommit(values);
      }
      function updateValues(value2, atIndex, { commit } = { commit: false }) {
        const decimalCount = getDecimalCount(step);
        const snapToStep = roundValue(Math.round((value2 - min2) / step) * step + min2, decimalCount);
        const nextValue = clamp$1(snapToStep, [min2, max2]);
        setValues((prevValues = []) => {
          const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
          if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
            valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
            const hasChanged = String(nextValues) !== String(prevValues);
            if (hasChanged && commit) onValueCommit(nextValues);
            return hasChanged ? nextValues : prevValues;
          } else {
            return prevValues;
          }
        });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SliderProvider,
        {
          scope: props.__scopeSlider,
          name: name2,
          disabled,
          min: min2,
          max: max2,
          valueIndexToChangeRef,
          thumbs: thumbRefs.current,
          values,
          orientation: orientation2,
          form,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderOrientation,
            {
              "aria-disabled": disabled,
              "data-disabled": disabled ? "" : void 0,
              ...sliderProps,
              ref: forwardedRef,
              onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
                if (!disabled) valuesBeforeSlideStartRef.current = values;
              }),
              min: min2,
              max: max2,
              inverted,
              onSlideStart: disabled ? void 0 : handleSlideStart,
              onSlideMove: disabled ? void 0 : handleSlideMove,
              onSlideEnd: disabled ? void 0 : handleSlideEnd,
              onHomeKeyDown: () => !disabled && updateValues(min2, 0, { commit: true }),
              onEndKeyDown: () => !disabled && updateValues(max2, values.length - 1, { commit: true }),
              onStepKeyDown: ({ event, direction: stepDirection }) => {
                if (!disabled) {
                  const isPageKey = PAGE_KEYS.includes(event.key);
                  const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
                  const multiplier = isSkipKey ? 10 : 1;
                  const atIndex = valueIndexToChangeRef.current;
                  const value2 = values[atIndex];
                  const stepInDirection = step * multiplier * stepDirection;
                  updateValues(value2 + stepInDirection, atIndex, { commit: true });
                }
              }
            }
          ) }) })
        }
      );
    }
  );
  Slider$1.displayName = SLIDER_NAME;
  var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1
  });
  var SliderHorizontal = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        min: min2,
        max: max2,
        dir,
        inverted,
        onSlideStart,
        onSlideMove,
        onSlideEnd,
        onStepKeyDown,
        ...sliderProps
      } = props;
      const [slider, setSlider] = reactExports.useState(null);
      const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setSlider(node2));
      const rectRef = reactExports.useRef(void 0);
      const direction = useDirection(dir);
      const isDirectionLTR = direction === "ltr";
      const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
      function getValueFromPointer(pointerPosition) {
        const rect = rectRef.current || slider.getBoundingClientRect();
        const input = [0, rect.width];
        const output = isSlidingFromLeft ? [min2, max2] : [max2, min2];
        const value = linearScale(input, output);
        rectRef.current = rect;
        return value(pointerPosition - rect.left);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SliderOrientationProvider,
        {
          scope: props.__scopeSlider,
          startEdge: isSlidingFromLeft ? "left" : "right",
          endEdge: isSlidingFromLeft ? "right" : "left",
          direction: isSlidingFromLeft ? 1 : -1,
          size: "width",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderImpl,
            {
              dir: direction,
              "data-orientation": "horizontal",
              ...sliderProps,
              ref: composedRefs,
              style: {
                ...sliderProps.style,
                ["--radix-slider-thumb-transform"]: "translateX(-50%)"
              },
              onSlideStart: (event) => {
                const value = getValueFromPointer(event.clientX);
                onSlideStart == null ? void 0 : onSlideStart(value);
              },
              onSlideMove: (event) => {
                const value = getValueFromPointer(event.clientX);
                onSlideMove == null ? void 0 : onSlideMove(value);
              },
              onSlideEnd: () => {
                rectRef.current = void 0;
                onSlideEnd == null ? void 0 : onSlideEnd();
              },
              onStepKeyDown: (event) => {
                const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
                const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
                onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
              }
            }
          )
        }
      );
    }
  );
  var SliderVertical = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        min: min2,
        max: max2,
        inverted,
        onSlideStart,
        onSlideMove,
        onSlideEnd,
        onStepKeyDown,
        ...sliderProps
      } = props;
      const sliderRef = reactExports.useRef(null);
      const ref = useComposedRefs$1(forwardedRef, sliderRef);
      const rectRef = reactExports.useRef(void 0);
      const isSlidingFromBottom = !inverted;
      function getValueFromPointer(pointerPosition) {
        const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
        const input = [0, rect.height];
        const output = isSlidingFromBottom ? [max2, min2] : [min2, max2];
        const value = linearScale(input, output);
        rectRef.current = rect;
        return value(pointerPosition - rect.top);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SliderOrientationProvider,
        {
          scope: props.__scopeSlider,
          startEdge: isSlidingFromBottom ? "bottom" : "top",
          endEdge: isSlidingFromBottom ? "top" : "bottom",
          size: "height",
          direction: isSlidingFromBottom ? 1 : -1,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderImpl,
            {
              "data-orientation": "vertical",
              ...sliderProps,
              ref,
              style: {
                ...sliderProps.style,
                ["--radix-slider-thumb-transform"]: "translateY(50%)"
              },
              onSlideStart: (event) => {
                const value = getValueFromPointer(event.clientY);
                onSlideStart == null ? void 0 : onSlideStart(value);
              },
              onSlideMove: (event) => {
                const value = getValueFromPointer(event.clientY);
                onSlideMove == null ? void 0 : onSlideMove(value);
              },
              onSlideEnd: () => {
                rectRef.current = void 0;
                onSlideEnd == null ? void 0 : onSlideEnd();
              },
              onStepKeyDown: (event) => {
                const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
                const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
                onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
              }
            }
          )
        }
      );
    }
  );
  var SliderImpl = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeSlider,
        onSlideStart,
        onSlideMove,
        onSlideEnd,
        onHomeKeyDown,
        onEndKeyDown,
        onStepKeyDown,
        ...sliderProps
      } = props;
      const context = useSliderContext(SLIDER_NAME, __scopeSlider);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          ...sliderProps,
          ref: forwardedRef,
          onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
            if (event.key === "Home") {
              onHomeKeyDown(event);
              event.preventDefault();
            } else if (event.key === "End") {
              onEndKeyDown(event);
              event.preventDefault();
            } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
              onStepKeyDown(event);
              event.preventDefault();
            }
          }),
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            const target = event.target;
            target.setPointerCapture(event.pointerId);
            event.preventDefault();
            if (context.thumbs.has(target)) {
              target.focus();
            } else {
              onSlideStart(event);
            }
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);
          }),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) {
              target.releasePointerCapture(event.pointerId);
              onSlideEnd(event);
            }
          })
        }
      );
    }
  );
  var TRACK_NAME = "SliderTrack";
  var SliderTrack = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSlider, ...trackProps } = props;
      const context = useSliderContext(TRACK_NAME, __scopeSlider);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          "data-disabled": context.disabled ? "" : void 0,
          "data-orientation": context.orientation,
          ...trackProps,
          ref: forwardedRef
        }
      );
    }
  );
  SliderTrack.displayName = TRACK_NAME;
  var RANGE_NAME = "SliderRange";
  var SliderRange = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSlider, ...rangeProps } = props;
      const context = useSliderContext(RANGE_NAME, __scopeSlider);
      const orientation2 = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, ref);
      const valuesCount = context.values.length;
      const percentages = context.values.map(
        (value) => convertValueToPercentage(value, context.min, context.max)
      );
      const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
      const offsetEnd = 100 - Math.max(...percentages);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          "data-orientation": context.orientation,
          "data-disabled": context.disabled ? "" : void 0,
          ...rangeProps,
          ref: composedRefs,
          style: {
            ...props.style,
            [orientation2.startEdge]: offsetStart + "%",
            [orientation2.endEdge]: offsetEnd + "%"
          }
        }
      );
    }
  );
  SliderRange.displayName = RANGE_NAME;
  var THUMB_NAME = "SliderThumb";
  var SliderThumb = reactExports.forwardRef(
    (props, forwardedRef) => {
      const getItems = useCollection(props.__scopeSlider);
      const [thumb, setThumb] = reactExports.useState(null);
      const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setThumb(node2));
      const index2 = reactExports.useMemo(
        () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
        [getItems, thumb]
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderThumbImpl, { ...props, ref: composedRefs, index: index2 });
    }
  );
  var SliderThumbImpl = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSlider, index: index2, name: name2, ...thumbProps } = props;
      const context = useSliderContext(THUMB_NAME, __scopeSlider);
      const orientation2 = useSliderOrientationContext(THUMB_NAME, __scopeSlider);
      const [thumb, setThumb] = reactExports.useState(null);
      const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setThumb(node2));
      const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
      const size2 = useSize(thumb);
      const value = context.values[index2];
      const percent2 = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
      const label = getLabel(index2, context.values.length);
      const orientationSize = size2 == null ? void 0 : size2[orientation2.size];
      const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent2, orientation2.direction) : 0;
      reactExports.useEffect(() => {
        if (thumb) {
          context.thumbs.add(thumb);
          return () => {
            context.thumbs.delete(thumb);
          };
        }
      }, [thumb, context.thumbs]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "span",
        {
          style: {
            transform: "var(--radix-slider-thumb-transform)",
            position: "absolute",
            [orientation2.startEdge]: `calc(${percent2}% + ${thumbInBoundsOffset}px)`
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.span,
              {
                role: "slider",
                "aria-label": props["aria-label"] || label,
                "aria-valuemin": context.min,
                "aria-valuenow": value,
                "aria-valuemax": context.max,
                "aria-orientation": context.orientation,
                "data-orientation": context.orientation,
                "data-disabled": context.disabled ? "" : void 0,
                tabIndex: context.disabled ? void 0 : 0,
                ...thumbProps,
                ref: composedRefs,
                style: value === void 0 ? { display: "none" } : props.style,
                onFocus: composeEventHandlers(props.onFocus, () => {
                  context.valueIndexToChangeRef.current = index2;
                })
              }
            ) }),
            isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
              SliderBubbleInput,
              {
                name: name2 ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
                form: context.form,
                value
              },
              index2
            )
          ]
        }
      );
    }
  );
  SliderThumb.displayName = THUMB_NAME;
  var BUBBLE_INPUT_NAME = "RadioBubbleInput";
  var SliderBubbleInput = reactExports.forwardRef(
    ({ __scopeSlider, value, ...props }, forwardedRef) => {
      const ref = reactExports.useRef(null);
      const composedRefs = useComposedRefs$1(ref, forwardedRef);
      const prevValue = usePrevious(value);
      reactExports.useEffect(() => {
        const input = ref.current;
        if (!input) return;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
        const setValue = descriptor.set;
        if (prevValue !== value && setValue) {
          const event = new Event("input", { bubbles: true });
          setValue.call(input, value);
          input.dispatchEvent(event);
        }
      }, [prevValue, value]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.input,
        {
          style: { display: "none" },
          ...props,
          ref: composedRefs,
          defaultValue: value
        }
      );
    }
  );
  SliderBubbleInput.displayName = BUBBLE_INPUT_NAME;
  function getNextSortedValues(prevValues = [], nextValue, atIndex) {
    const nextValues = [...prevValues];
    nextValues[atIndex] = nextValue;
    return nextValues.sort((a, b) => a - b);
  }
  function convertValueToPercentage(value, min2, max2) {
    const maxSteps = max2 - min2;
    const percentPerStep = 100 / maxSteps;
    const percentage = percentPerStep * (value - min2);
    return clamp$1(percentage, [0, 100]);
  }
  function getLabel(index2, totalValues) {
    if (totalValues > 2) {
      return `Value ${index2 + 1} of ${totalValues}`;
    } else if (totalValues === 2) {
      return ["Minimum", "Maximum"][index2];
    } else {
      return void 0;
    }
  }
  function getClosestValueIndex(values, nextValue) {
    if (values.length === 1) return 0;
    const distances = values.map((value) => Math.abs(value - nextValue));
    const closestDistance = Math.min(...distances);
    return distances.indexOf(closestDistance);
  }
  function getThumbInBoundsOffset(width, left, direction) {
    const halfWidth = width / 2;
    const halfPercent = 50;
    const offset2 = linearScale([0, halfPercent], [0, halfWidth]);
    return (halfWidth - offset2(left) * direction) * direction;
  }
  function getStepsBetweenValues(values) {
    return values.slice(0, -1).map((value, index2) => values[index2 + 1] - value);
  }
  function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
    if (minStepsBetweenValues > 0) {
      const stepsBetweenValues = getStepsBetweenValues(values);
      const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
      return actualMinStepsBetweenValues >= minStepsBetweenValues;
    }
    return true;
  }
  function linearScale(input, output) {
    return (value) => {
      if (input[0] === input[1] || output[0] === output[1]) return output[0];
      const ratio = (output[1] - output[0]) / (input[1] - input[0]);
      return output[0] + ratio * (value - input[0]);
    };
  }
  function getDecimalCount(value) {
    return (String(value).split(".")[1] || "").length;
  }
  function roundValue(value, decimalCount) {
    const rounder = Math.pow(10, decimalCount);
    return Math.round(value * rounder) / rounder;
  }
  var Root = Slider$1;
  var Track = SliderTrack;
  var Range = SliderRange;
  var Thumb = SliderThumb;
  var __defProp$1 = Object.defineProperty;
  var __export$1 = (target, all2) => {
    for (var name2 in all2)
      __defProp$1(target, name2, { get: all2[name2], enumerable: true });
  };
  function cn$1(...inputs) {
    return twMerge(clsx(inputs));
  }
  var LogoSpinner = ({
    className = "",
    size: size2 = 16
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size2,
        height: size2,
        viewBox: "0 0 48 48",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        className: `lua:animate-spin ${className}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M28.7982 6.91902C28.7982 3.9217 26.7444 1.40402 23.9671 0.696624C24.9104 0.236792 25.9463 -0.00148259 26.9957 6.94086e-06C30.8169 6.94086e-06 33.9147 3.09779 33.9147 6.91902C33.9147 10.7403 30.8169 13.838 26.9957 13.838C25.9463 13.8395 24.9104 13.6013 23.9671 13.1414C26.7441 12.434 28.7982 9.91634 28.7982 6.91902Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M19.615 6.80833C18.1155 4.21259 15.0786 3.05934 12.3198 3.8351C12.9068 2.96525 13.6847 2.24098 14.5943 1.7176C17.9035 -0.192048 22.1352 0.94074 24.0459 4.25024C25.9567 7.55974 24.8225 11.7911 21.5133 13.7016C20.6053 14.2276 19.5891 14.5392 18.5422 14.6127C20.5936 12.6114 21.1136 9.40407 19.615 6.80833Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.6065 11.3049C9.0105 9.80594 5.8034 10.326 3.80186 12.3776C3.87528 11.3307 4.1869 10.3144 4.71296 9.40629C6.62261 6.09707 10.8551 4.96318 14.1643 6.87393C17.4736 8.78469 18.6075 13.0161 16.697 16.3253C16.1735 17.2348 15.4491 18.0128 14.5792 18.5997C15.3555 15.8404 14.2023 12.803 11.6065 11.3049Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M6.91903 19.202C3.92143 19.202 1.40401 21.2558 0.696614 24.0331C0.236781 23.0898 -0.0014826 22.0539 6.94119e-06 21.0045C6.94119e-06 17.1833 3.09779 14.0855 6.91903 14.0855C10.7403 14.0855 13.838 17.1833 13.838 21.0045C13.8394 22.0539 13.6011 23.0898 13.1414 24.0331C12.434 21.2558 9.91634 19.202 6.91903 19.202Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M6.80835 28.3851C4.21234 29.8838 3.05963 32.9215 3.83456 35.6803C2.9647 35.0933 2.24044 34.3154 1.71706 33.4059C-0.193141 30.0969 0.940748 25.865 4.2497 23.9542C7.55865 22.0434 11.7906 23.1773 13.7011 26.4868C14.2271 27.3949 14.5387 28.4111 14.6122 29.4579C12.6115 27.4065 9.40409 26.8865 6.80835 28.3851Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.3041 36.3935C9.80545 38.9895 10.3255 42.1966 12.3768 44.1981C11.33 44.1246 10.3138 43.813 9.4058 43.287C6.09657 41.3774 4.96269 37.1449 6.87317 33.8356C8.78364 30.5264 13.0156 29.3925 16.3248 31.303C17.2343 31.8264 18.0123 32.5506 18.5992 33.4205C15.8405 32.6445 12.803 33.7977 11.3041 36.3935Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M19.2016 41.081C19.2016 44.0786 21.2558 46.596 24.0331 47.3034C23.0897 47.7632 22.0539 48.0014 21.0045 48C17.1832 48 14.0854 44.9022 14.0854 41.081C14.0854 37.2598 17.1832 34.162 21.0045 34.162C22.0539 34.1607 23.0897 34.3989 24.0331 34.8586C21.2558 35.566 19.2016 38.0837 19.2016 41.081Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M28.3851 41.1916C29.8837 43.7874 32.9215 44.9407 35.6802 44.1649C35.0932 45.0347 34.3153 45.7589 33.4058 46.2824C30.0963 48.192 25.8649 47.0592 23.9541 43.7497C22.0434 40.4402 23.1773 36.2089 26.4868 34.2984C27.3948 33.7724 28.411 33.4607 29.4578 33.3873C27.4065 35.3885 26.8864 38.5959 28.3851 41.1916Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M36.3936 36.696C38.9893 38.1946 42.1967 37.6746 44.1982 35.623C44.1246 36.6696 43.8129 37.6856 43.2869 38.5934C41.3772 41.9027 37.1447 43.0365 33.8355 41.1261C30.5263 39.2156 29.3921 34.9845 31.3028 31.6744C31.8262 30.7649 32.5505 29.987 33.4203 29.4C32.6454 32.1596 33.7978 35.197 36.3936 36.696Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M41.081 28.798C44.0783 28.798 46.596 26.7442 47.3034 23.9669C47.7632 24.9102 48.0015 25.9461 48 26.9955C48 30.8167 44.9022 33.9145 41.081 33.9145C37.2597 33.9145 34.1619 30.8167 34.1619 26.9955C34.1607 25.946 34.3993 24.9101 34.8594 23.9669C35.566 26.7442 38.0836 28.798 41.081 28.798Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M41.1917 19.6148C43.7875 18.1162 44.9407 15.0785 44.1647 12.3197C45.0346 12.9067 45.7589 13.6846 46.2824 14.5941C48.1921 17.9036 47.0593 22.135 43.7498 24.0458C40.4403 25.9565 36.2089 24.8227 34.2984 21.5132C33.7724 20.6051 33.4608 19.5889 33.3873 18.5421C35.3886 20.5935 38.5957 21.1135 41.1917 19.6148Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M36.6957 11.6065C38.1946 9.01077 37.6746 5.80339 35.623 3.80186C36.6704 3.87515 37.6872 4.18689 38.5957 4.71324C41.9049 6.62289 43.0388 10.8554 41.128 14.1646C39.2173 17.4738 34.9859 18.608 31.6767 16.6972C30.7671 16.1738 29.9891 15.4496 29.402 14.5797C32.1596 15.3555 35.1971 14.2022 36.6957 11.6065Z",
              fill: "currentColor"
            }
          )
        ]
      }
    );
  };
  var buttonVariants = cva(
    [
      "lua:flex lua:items-center lua:justify-center lua:rounded-full lua:font-onest lua:font-semibold lua:leading-5 lua:transition-all lua:focus-visible:outline-hidden lua:gap-2 lua:cursor-pointer",
      "lua:disabled:pointer-events-none lua:disabled:bg-black/4 lua:disabled:text-black/16 lua:disabled:border-transparent",
      "lua:focus-visible:ring-2 lua:focus-visible:ring-offset-2 lua:focus-visible:ring-offset-white"
    ].join(" "),
    {
      variants: {
        variant: {
          default: [
            "lua:bg-black lua:text-white",
            "lua:hover:bg-black-hover",
            "lua:active:bg-black-hover",
            "lua:focus-visible:bg-black lua:focus-visible:ring-black"
          ].join(" "),
          primary: [
            "lua:bg-blue-600 lua:text-white",
            "lua:hover:bg-blue-700",
            "lua:active:bg-blue-800",
            "lua:focus-visible:bg-blue-600 lua:focus-visible:ring-blue-600"
          ].join(" "),
          outline: [
            "lua:border lua:border-blue-600 lua:bg-white lua:text-blue-600",
            "lua:hover:bg-blue-600 lua:hover:text-white",
            "lua:active:bg-blue-600 lua:active:text-white",
            "lua:focus-visible:ring-blue-600"
          ].join(" "),
          tertiary: [
            "lua:bg-white lua:border lua:border-neutral-400 lua:text-gray-900",
            "lua:hover:bg-neutral-200",
            "lua:active:bg-neutral-300",
            "lua:focus-visible:bg-neutral-100 lua:focus-visible:border-neutral-500 lua:focus-visible:ring-black"
          ].join(" "),
          secondary: [
            "lua:bg-gray-100 lua:text-gray-900",
            "lua:hover:bg-gray-200",
            "lua:active:bg-gray-300",
            "lua:focus-visible:bg-gray-100 lua:focus-visible:ring-black"
          ].join(" "),
          muted: [
            "lua:bg-transparent lua:text-gray-700",
            "lua:hover:bg-neutral-200",
            "lua:active:bg-neutral-600",
            "lua:focus-visible:bg-white lua:focus-visible:ring-black"
          ].join(" "),
          destructive: [
            "lua:bg-red-600 lua:text-white",
            "lua:hover:bg-red-700",
            "lua:active:bg-red-800",
            "lua:focus-visible:bg-red-600 lua:focus-visible:ring-red-600"
          ].join(" ")
        },
        size: {
          small: "lua:h-6 lua:px-3 lua:text-xs sm:lua:text-sm",
          // 12px mobile, 14px larger screens
          default: "lua:h-8 lua:px-3 lua:text-sm sm:lua:text-base",
          // 14px mobile, 16px larger screens
          large: "lua:h-10 lua:px-4 lua:text-base sm:lua:text-lg"
          // 16px mobile, 18px larger screens
        },
        hasStartAdornment: {
          true: "lua:pl-2"
        },
        hasEndAdornment: {
          true: "lua:pr-2"
        }
      },
      defaultVariants: {
        variant: "default",
        size: "default"
      }
    }
  );
  var iconStyles = "lua:w-4 lua:h-4 lua:flex lua:items-center lua:justify-center";
  var Button = reactExports.forwardRef(
    ({
      className,
      variant,
      size: size2,
      asChild = false,
      startAdornment,
      endAdornment,
      children,
      loading = false,
      disabled,
      "aria-label": ariaLabel,
      "aria-describedby": ariaDescribedby,
      ...props
    }, ref) => {
      const Comp = asChild ? Slot$3 : "button";
      const hasStartAdornment = !!startAdornment;
      const hasEndAdornment = !!endAdornment;
      reactExports.Children.toArray(children).some(
        (child) => typeof child === "string" && child.trim().length > 0
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Comp,
        {
          className: cn$1(
            buttonVariants({
              variant,
              size: size2,
              hasStartAdornment,
              hasEndAdornment,
              className
            })
          ),
          ref,
          disabled: disabled || loading,
          "aria-label": ariaLabel,
          "aria-describedby": ariaDescribedby,
          "aria-busy": loading,
          "aria-disabled": disabled || loading,
          ...props,
          children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:items-center lua:gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              LogoSpinner,
              {
                size: 20,
                className: "lua:text-current",
                "aria-hidden": "true"
              }
            ),
            children && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "aria-hidden": "true", children })
          ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            startAdornment && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: iconStyles, "aria-hidden": "true", children: startAdornment }),
            children,
            endAdornment && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: iconStyles, "aria-hidden": "true", children: endAdornment })
          ] })
        }
      ) });
    }
  );
  Button.displayName = "Button";
  var iconButtonVariants = {
    size: {
      small: "lua:p-2 lua:size-7",
      default: "lua:p-2 lua:size-10",
      large: "lua:p-3 lua:size-12"
    }
  };
  var IconButton = reactExports.forwardRef(
    ({
      className,
      variant,
      size: size2 = "default",
      asChild = false,
      children,
      loading = false,
      disabled,
      "aria-label": ariaLabel,
      "aria-describedby": ariaDescribedBy,
      ...props
    }, ref) => {
      const Comp = asChild ? Slot$3 : "button";
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Comp,
        {
          className: cn$1(
            buttonVariants({ variant, className }),
            iconButtonVariants.size[size2],
            "lua:inline-flex lua:items-center lua:justify-center"
          ),
          ref,
          disabled: disabled || loading,
          "aria-label": ariaLabel,
          "aria-describedby": ariaDescribedBy,
          "aria-busy": loading,
          "aria-disabled": disabled || loading,
          ...props,
          children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            LogoSpinner,
            {
              size: size2 === "small" ? 16 : size2 === "large" ? 24 : 20,
              className: "lua:text-current",
              "aria-hidden": "true"
            }
          ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: reactExports.cloneElement(children, {
            "aria-hidden": "true"
          }) })
        }
      ) });
    }
  );
  IconButton.displayName = "IconButton";
  var Input = reactExports.forwardRef(
    ({
      className,
      type = "text",
      label,
      description,
      error,
      success,
      startAdornment,
      endAdornment,
      id: id2,
      "aria-describedby": ariaDescribedby,
      "aria-invalid": ariaInvalid,
      disabled,
      ...props
    }, ref) => {
      const generatedId = reactExports.useId();
      const inputId = id2 || generatedId;
      const descriptionId = description ? `${inputId}-description` : void 0;
      const errorId = error ? `${inputId}-error` : void 0;
      const successId = success ? `${inputId}-success` : void 0;
      const describedBy = [ariaDescribedby, descriptionId, errorId, successId].filter(Boolean).join(" ") || void 0;
      const hasError = !!error;
      const hasSuccess = !!success && !hasError;
      const hasStartAdornment = !!startAdornment;
      const hasEndAdornment = !!endAdornment;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:w-full", children: [
        label && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            htmlFor: inputId,
            className: cn$1(
              "lua:block lua:text-sm lua:font-medium lua:mb-2 lua:text-gray-900",
              disabled && "lua:text-gray-600 lua:cursor-not-allowed"
            ),
            children: label
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:relative", children: [
          hasStartAdornment && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:absolute lua:left-3 lua:top-1/2 lua:-translate-y-1/2 lua:flex lua:items-center lua:pointer-events-none lua:text-gray-500", children: startAdornment }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type,
              id: inputId,
              className: cn$1(
                // Base styles
                "lua:flex lua:h-10 lua:w-full lua:rounded-md lua:border lua:bg-transparent lua:px-3 lua:py-2 lua:text-base lua:transition-all lua:duration-200",
                "file:lua:border-0 file:lua:bg-transparent file:lua:text-sm file:lua:font-medium file:lua:text-gray-900",
                "placeholder:lua:text-gray-500",
                "focus-visible:lua:outline-hidden focus-visible:lua:ring-2 focus-visible:lua:ring-offset-2 focus-visible:lua:ring-offset-white",
                // Default state
                "lua:border-gray-300 lua:text-gray-900",
                "focus-visible:lua:ring-blue-600",
                // Error state
                hasError && [
                  "lua:border-red-600",
                  "focus-visible:lua:ring-red-600",
                  "lua:text-gray-900"
                ],
                // Success state
                hasSuccess && [
                  "lua:border-green-500",
                  "focus-visible:lua:ring-green-500"
                ],
                // Disabled state
                disabled && [
                  "lua:cursor-not-allowed lua:opacity-50",
                  "lua:bg-gray-100",
                  "lua:text-gray-600",
                  "placeholder:lua:text-gray-400"
                ],
                // Padding adjustments for adornments
                hasStartAdornment && "lua:pl-10",
                hasEndAdornment && "lua:pr-10",
                // Responsive text size
                "md:lua:text-sm",
                className
              ),
              ref,
              disabled,
              "aria-describedby": describedBy,
              "aria-invalid": ariaInvalid || hasError,
              ...props
            }
          ),
          hasEndAdornment && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:absolute lua:right-3 lua:top-1/2 lua:-translate-y-1/2 lua:flex lua:items-center lua:pointer-events-none lua:text-gray-500", children: endAdornment })
        ] }),
        description && !error && !success && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            id: descriptionId,
            className: "lua:mt-2 lua:text-sm lua:text-gray-600",
            children: description
          }
        ),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            id: errorId,
            className: "lua:mt-2 lua:text-sm lua:text-red-600",
            role: "alert",
            "aria-live": "polite",
            children: error
          }
        ),
        success && !error && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            id: successId,
            className: "lua:mt-2 lua:text-sm lua:text-green-600",
            role: "status",
            "aria-live": "polite",
            children: success
          }
        )
      ] });
    }
  );
  Input.displayName = "Input";
  var badgeVariants = cva(
    [
      "lua:inline-flex lua:items-center lua:justify-center lua:rounded-md lua:border lua:px-2 lua:py-1 lua:text-xs lua:font-medium",
      "lua:w-fit lua:whitespace-nowrap lua:shrink-0 [&>svg]:lua:size-3 lua:gap-1 [&>svg]:lua:pointer-events-none",
      "lua:focus-visible:border-blue-600 lua:focus-visible:ring-blue-600/50 lua:focus-visible:ring-2",
      "aria-invalid:lua:ring-red-600/20",
      "aria-invalid:lua:border-red-600 lua:transition-[color,box-shadow] lua:overflow-hidden"
    ].join(" "),
    {
      variants: {
        variant: {
          default: [
            "lua:border-transparent lua:bg-blue-600 lua:text-white",
            "[a&]:lua:hover:bg-blue-700"
          ].join(" "),
          secondary: [
            "lua:border-transparent lua:bg-gray-100 lua:text-gray-900",
            "[a&]:lua:hover:bg-gray-200"
          ].join(" "),
          destructive: [
            "lua:border-transparent lua:bg-red-600 lua:text-white",
            "[a&]:lua:hover:bg-red-700",
            "lua:focus-visible:ring-red-600/20"
          ].join(" "),
          outline: [
            "lua:text-gray-900 lua:border-gray-300",
            "[a&]:lua:hover:bg-gray-100 [a&]:lua:hover:text-gray-900"
          ].join(" "),
          success: [
            "lua:border-transparent lua:bg-green-600 lua:text-white",
            "[a&]:lua:hover:bg-green-700"
          ].join(" "),
          warning: [
            "lua:border-transparent lua:bg-yellow-600 lua:text-white",
            "[a&]:lua:hover:bg-yellow-700"
          ].join(" ")
        }
      },
      defaultVariants: {
        variant: "default"
      }
    }
  );
  var Badge = reactExports.forwardRef(
    ({ className, variant, asChild = false, ...props }, ref) => {
      const Comp = asChild ? Slot$3 : "span";
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Comp,
        {
          ref,
          "data-slot": "badge",
          className: cn$1(badgeVariants({ variant }), className),
          ...props
        }
      );
    }
  );
  Badge.displayName = "Badge";
  var Textarea = reactExports.forwardRef(
    ({
      className,
      description,
      error,
      success,
      resize = "vertical",
      id: id2,
      "aria-describedby": ariaDescribedby,
      "aria-invalid": ariaInvalid,
      disabled,
      ...props
    }, ref) => {
      const generatedId = reactExports.useId();
      const textareaId = id2 || generatedId;
      const descriptionId = description ? `${textareaId}-description` : void 0;
      const errorId = error ? `${textareaId}-error` : void 0;
      const successId = success ? `${textareaId}-success` : void 0;
      const describedBy = [ariaDescribedby, descriptionId, errorId, successId].filter(Boolean).join(" ") || void 0;
      const hasError = !!error;
      const hasSuccess = !!success && !hasError;
      const resizeClasses = {
        none: "lua:resize-none",
        vertical: "lua:resize-y",
        horizontal: "lua:resize-x",
        both: "lua:resize"
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            id: textareaId,
            "data-slot": "textarea",
            className: cn$1(
              // Base styles
              "lua:flex lua:min-h-16 lua:w-full lua:rounded-md lua:border lua:bg-transparent lua:px-3 lua:py-2 lua:text-base lua:transition-all lua:duration-200",
              "lua:placeholder:text-gray-500",
              "lua:focus-visible:outline-hidden lua:focus-visible:ring-2 lua:focus-visible:ring-offset-2 lua:focus-visible:ring-offset-white",
              // Default state
              "lua:border-gray-300 lua:text-gray-900",
              "lua:focus-visible:ring-blue-600",
              // Error state
              hasError && [
                "lua:border-red-600",
                "lua:focus-visible:ring-red-600",
                "lua:text-gray-900"
              ],
              // Success state
              hasSuccess && [
                "lua:border-green-500",
                "lua:focus-visible:ring-green-500"
              ],
              // Disabled state
              disabled && [
                "lua:cursor-not-allowed lua:opacity-50",
                "lua:bg-gray-100",
                "lua:text-gray-600",
                "lua:placeholder:text-gray-400"
              ],
              // Resize behavior
              resizeClasses[resize],
              // Responsive text size
              "lua:md:text-sm",
              className
            ),
            ref,
            disabled,
            "aria-describedby": describedBy,
            "aria-invalid": ariaInvalid || hasError,
            ...props
          }
        ),
        description && !error && !success && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            id: descriptionId,
            className: "lua:mt-2 lua:text-sm lua:text-gray-600",
            children: description
          }
        ),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            id: errorId,
            className: "lua:mt-2 lua:text-sm lua:text-red-600",
            role: "alert",
            "aria-live": "polite",
            children: error
          }
        ),
        success && !error && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            id: successId,
            className: "lua:mt-2 lua:text-sm lua:text-green-600",
            role: "status",
            "aria-live": "polite",
            children: success
          }
        )
      ] });
    }
  );
  Textarea.displayName = "Textarea";
  var tabsListVariants = cva([
    "lua:inline-flex lua:items-center lua:justify-start lua:border-b lua:border-gray-200 lua:text-gray-600"
  ].join(" "));
  var TabsList = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    List,
    {
      ref,
      className: cn$1(tabsListVariants(), className),
      ...props
    }
  ));
  TabsList.displayName = List.displayName;
  var tabsTriggerVariants = cva([
    "lua:inline-flex lua:items-center lua:justify-center lua:whitespace-nowrap lua:px-2 lua:py-2 lua:text-sm lua:font-medium",
    "lua:relative lua:transition-all lua:focus-visible:outline-hidden lua:focus-visible:ring-2",
    "lua:focus-visible:ring-blue-600 lua:focus-visible:ring-offset-2 lua:disabled:pointer-events-none lua:disabled:opacity-50",
    "lua:data-[state=active]:text-blue-600 lua:data-[state=active]:border-b-2 lua:data-[state=active]:border-blue-600 lua:data-[state=active]:-mb-px",
    "lua:hover:text-gray-900 lua:text-gray-600"
  ].join(" "));
  var TabsTrigger = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Trigger$2,
    {
      ref,
      className: cn$1(tabsTriggerVariants(), className),
      ...props
    }
  ));
  TabsTrigger.displayName = Trigger$2.displayName;
  var tabsContentVariants = cva([
    "lua:mt-4 lua:ring-offset-white lua:focus-visible:outline-hidden lua:focus-visible:ring-2",
    "lua:focus-visible:ring-blue-600 lua:focus-visible:ring-offset-2"
  ].join(" "));
  var TabsContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content$2,
    {
      ref,
      className: cn$1(tabsContentVariants(), className),
      ...props
    }
  ));
  TabsContent.displayName = Content$2.displayName;
  var InputOTP = reactExports.forwardRef(({ className, containerClassName, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Lt$1,
    {
      ref,
      containerClassName: cn$1(
        "lua:flex lua:items-center lua:gap-2 has-disabled:lua:opacity-50",
        containerClassName
      ),
      className: cn$1("lua:disabled:cursor-not-allowed", className),
      ...props
    }
  ));
  InputOTP.displayName = "InputOTP";
  var InputOTPGroup = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: cn$1("lua:flex lua:items-center", className), ...props }));
  InputOTPGroup.displayName = "InputOTPGroup";
  var InputOTPSlot = reactExports.forwardRef(({ index: index2, className, ...props }, ref) => {
    const inputOTPContext = reactExports.useContext(jt);
    const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index2];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref,
        className: cn$1(
          "lua:relative lua:flex lua:h-10 lua:w-10 lua:items-center lua:justify-center lua:border lua:border-gray-300 lua:bg-white lua:text-sm lua:transition-all lua:first:rounded-l-md lua:last:rounded-r-md lua:focus-within:z-10 lua:focus-within:ring-2 lua:focus-within:ring-blue-600 lua:focus-within:ring-offset-2 lua:disabled:cursor-not-allowed lua:disabled:opacity-50",
          isActive && "lua:z-10 lua:ring-2 lua:ring-blue-600 lua:ring-offset-2",
          className
        ),
        ...props,
        children: [
          char,
          hasFakeCaret && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:pointer-events-none lua:absolute lua:inset-0 lua:flex lua:items-center lua:justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:h-4 lua:w-px lua:animate-caret-blink lua:bg-gray-900 lua:duration-1000" }) })
        ]
      }
    );
  });
  InputOTPSlot.displayName = "InputOTPSlot";
  var InputOTPSeparator = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      role: "separator",
      className: cn$1("lua:flex lua:items-center lua:justify-center", className),
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:h-px lua:w-3 lua:bg-gray-300" })
    }
  ));
  InputOTPSeparator.displayName = "InputOTPSeparator";
  var TooltipProvider = Provider$1;
  var TooltipArrow = reactExports.forwardRef(({ className, style, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Arrow2$1,
    {
      ref,
      className: cn$1("", className),
      width: 8,
      height: 4,
      style: {
        fill: "#ffffff",
        stroke: "#d1d5db",
        strokeWidth: "1px",
        ...style
      },
      ...props
    }
  ));
  TooltipArrow.displayName = Arrow2$1.displayName;
  var TooltipContent = reactExports.forwardRef(({ className, sideOffset = 4, style, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content2$3,
    {
      ref,
      sideOffset,
      className: cn$1(
        "lua:z-50 lua:overflow-hidden lua:px-3 lua:py-2 lua:text-xs lua:transition-all lua:duration-200",
        "lua:shadow-lg lua:border lua:rounded-lg",
        "lua:bg-white lua:text-gray-900 lua:border-gray-300",
        className
      ),
      style: {
        color: "#111827",
        // gray-900 
        backgroundColor: "#ffffff",
        // white
        borderColor: "#d1d5db",
        // gray-300
        ...style
      },
      ...props
    }
  ) }));
  TooltipContent.displayName = Content2$3.displayName;
  var Card = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: cn$1(
        "lua:rounded-xl lua:border lua:border-gray-200 lua:bg-white lua:text-gray-900 lua:shadow-sm",
        className
      ),
      ...props
    }
  ));
  Card.displayName = "Card";
  var CardHeader = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: cn$1("lua:flex lua:flex-col lua:space-y-2 lua:p-6", className),
      ...props
    }
  ));
  CardHeader.displayName = "CardHeader";
  var CardTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: cn$1("lua:font-semibold lua:leading-none lua:tracking-tight", className),
      ...props
    }
  ));
  CardTitle.displayName = "CardTitle";
  var CardDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: cn$1("lua:text-sm lua:text-gray-600", className),
      ...props
    }
  ));
  CardDescription.displayName = "CardDescription";
  var CardContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: cn$1("lua:p-6 lua:pt-0", className), ...props }));
  CardContent.displayName = "CardContent";
  var CardFooter = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: cn$1("lua:flex lua:items-center lua:p-6 lua:pt-0", className),
      ...props
    }
  ));
  CardFooter.displayName = "CardFooter";
  function getDefaultAriaLabel(componentName) {
    const specialCases = {
      XIcon: "Close",
      UserIcon: "User",
      ImageIcon: "Image",
      RecordIcon: "Record",
      Logo: "Lua logo",
      ChatsCircle: "Chats circle",
      DotsThree: "More options",
      DotsThreeVertical: "More options vertical",
      CaretDown: "Expand",
      CaretRight: "Expand right",
      MagnifyingGlass: "Search",
      SidebarSimple: "Sidebar",
      PaperPlane: "Send",
      PaperPlaneTilt: "Send message",
      PencilSimple: "PencilSimple",
      PlugsRegular: "Plugs regular",
      SignOut: "Sign out",
      VideoCamera: "Video camera",
      CurrencyCircleDollar: "Dollar",
      LockSimple: "Lock",
      UserCircle: "User profile",
      CopySimpleIcon: "Copy simple",
      CreditCard: "Credit card",
      ChartBar: "Chart",
      GitCommit: "Git commit",
      Users: "Users",
      WarningOctagon: "Warning octagon",
      WarningTriangle: "Warning triangle",
      Waveform: "Waveform"
    };
    if (specialCases[componentName]) {
      return specialCases[componentName];
    }
    return componentName.replace(/([A-Z])/g, " $1").trim().toLowerCase().replace(/^\w/, (c) => c.toUpperCase());
  }
  function getAccessibilityProps(props, componentName) {
    const {
      "aria-label": ariaLabel,
      "aria-hidden": ariaHidden,
      "aria-describedby": ariaDescribedBy,
      role,
      title,
      ...restProps
    } = props;
    const finalAriaLabel = ariaLabel || (componentName ? getDefaultAriaLabel(componentName) : void 0);
    const isDecorative = !finalAriaLabel;
    const finalAriaHidden = ariaHidden ?? isDecorative;
    const finalRole = role ?? (finalAriaLabel ? "img" : void 0);
    return {
      accessibilityProps: {
        "aria-label": finalAriaLabel,
        "aria-hidden": finalAriaHidden,
        "aria-describedby": ariaDescribedBy,
        role: finalRole,
        focusable: "false"
      },
      title,
      restProps
    };
  }
  var ArrowLeft$1 = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props, "ArrowLeft");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M21 12C21 12.1989 20.921 12.3897 20.7803 12.5303C20.6397 12.671 20.4489 12.75 20.25 12.75H5.56029L11.0306 18.2194C11.1003 18.289 11.1556 18.3718 11.1933 18.4628C11.231 18.5539 11.2504 18.6514 11.2504 18.75C11.2504 18.8485 11.231 18.9461 11.1933 19.0372C11.1556 19.1282 11.1003 19.2109 11.0306 19.2806C10.9609 19.3503 10.8782 19.4056 10.7872 19.4433C10.6961 19.481 10.5985 19.5004 10.5 19.5004C10.4014 19.5004 10.3039 19.481 10.2128 19.4433C10.1218 19.4056 10.039 19.3503 9.96935 19.2806L3.21935 12.5306C3.14962 12.461 3.0943 12.3782 3.05656 12.2872C3.01882 12.1961 2.99939 12.0986 2.99939 12C2.99939 11.9014 3.01882 11.8038 3.05656 11.7128C3.0943 11.6217 3.14962 11.539 3.21935 11.4694L9.96935 4.71936C10.1101 4.57863 10.301 4.49957 10.5 4.49957C10.699 4.49957 10.8899 4.57863 11.0306 4.71936C11.1713 4.8601 11.2504 5.05097 11.2504 5.24999C11.2504 5.44901 11.1713 5.63988 11.0306 5.78061L5.56029 11.25H20.25C20.4489 11.25 20.6397 11.329 20.7803 11.4697C20.921 11.6103 21 11.8011 21 12Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  ArrowLeft$1.displayName = "ArrowLeft";
  var ArrowRight = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.7806 12.5306L14.0306 19.2806C13.8899 19.4213 13.699 19.5004 13.5 19.5004C13.301 19.5004 13.1101 19.4213 12.9694 19.2806C12.8286 19.1399 12.7496 18.949 12.7496 18.75C12.7496 18.551 12.8286 18.3601 12.9694 18.2194L18.4397 12.75H3.75C3.55109 12.75 3.36032 12.671 3.21967 12.5303C3.07902 12.3897 3 12.1989 3 12C3 11.8011 3.07902 11.6103 3.21967 11.4697C3.36032 11.329 3.55109 11.25 3.75 11.25H18.4397L12.9694 5.78061C12.8286 5.63988 12.7496 5.44901 12.7496 5.24999C12.7496 5.05097 12.8286 4.8601 12.9694 4.71936C13.1101 4.57863 13.301 4.49957 13.5 4.49957C13.699 4.49957 13.8899 4.57863 14.0306 4.71936L20.7806 11.4694C20.8504 11.539 20.9057 11.6217 20.9434 11.7128C20.9812 11.8038 21.0006 11.9014 21.0006 12C21.0006 12.0986 20.9812 12.1961 20.9434 12.2872C20.9057 12.3782 20.8504 12.461 20.7806 12.5306Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  ArrowRight.displayName = "ArrowRight";
  var ArrowClockwiseIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M22.5 5.25001V9.75001C22.5 9.94892 22.421 10.1397 22.2803 10.2803C22.1397 10.421 21.9489 10.5 21.75 10.5H17.25C17.0511 10.5 16.8603 10.421 16.7197 10.2803C16.579 10.1397 16.5 9.94892 16.5 9.75001C16.5 9.5511 16.579 9.36033 16.7197 9.21968C16.8603 9.07903 17.0511 9.00001 17.25 9.00001H19.8188L17.3259 6.71626L17.3025 6.69376C16.2601 5.65172 14.9337 4.93994 13.4891 4.64734C12.0445 4.35473 10.5457 4.49428 9.17991 5.04854C7.81414 5.60281 6.64197 6.54721 5.80982 7.76379C4.97768 8.98036 4.52245 10.4152 4.501 11.889C4.47956 13.3627 4.89286 14.8102 5.68926 16.0505C6.48566 17.2907 7.62986 18.2688 8.97892 18.8626C10.328 19.4564 11.8221 19.6395 13.2746 19.389C14.7271 19.1386 16.0736 18.4657 17.1459 17.4544C17.2905 17.3176 17.4835 17.2439 17.6825 17.2495C17.8814 17.255 18.07 17.3393 18.2067 17.4839C18.3435 17.6285 18.4172 17.8215 18.4117 18.0204C18.4061 18.2194 18.3218 18.4079 18.1772 18.5447C16.5098 20.126 14.298 21.0052 12 21H11.8763C10.4023 20.9798 8.95579 20.5979 7.66398 19.8878C6.37216 19.1776 5.27455 18.161 4.46762 16.9274C3.6607 15.6937 3.16915 14.2807 3.0362 12.8126C2.90324 11.3445 3.13294 9.86616 3.70511 8.5076C4.27728 7.14903 5.1744 5.95181 6.31762 5.02116C7.46085 4.09051 8.81517 3.45492 10.2616 3.17026C11.7079 2.88559 13.2021 2.96057 14.6127 3.38859C16.0234 3.81662 17.3073 4.58459 18.3516 5.62501L21 8.04376V5.25001C21 5.0511 21.079 4.86033 21.2197 4.71968C21.3603 4.57903 21.5511 4.50001 21.75 4.50001C21.9489 4.50001 22.1397 4.57903 22.2803 4.71968C22.421 4.86033 22.5 5.0511 22.5 5.25001Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  ArrowClockwiseIcon.displayName = "ArrowClockwiseIcon";
  var ArrowsClockwiseIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21 4.50001V9.00001C21 9.19892 20.921 9.38969 20.7803 9.53034C20.6397 9.67099 20.4489 9.75001 20.25 9.75001H15.75C15.5511 9.75001 15.3603 9.67099 15.2197 9.53034C15.079 9.38969 15 9.19892 15 9.00001C15 8.8011 15.079 8.61033 15.2197 8.46968C15.3603 8.32903 15.5511 8.25001 15.75 8.25001H18.4397L17.0681 6.87845C15.6742 5.4782 13.7817 4.68821 11.8059 4.68188H11.7638C9.80454 4.67729 7.92227 5.44414 6.52406 6.81657C6.38083 6.95028 6.19096 7.02262 5.99507 7.01813C5.79918 7.01364 5.61283 6.93266 5.47588 6.79253C5.33893 6.65239 5.26226 6.46423 5.26227 6.26829C5.26228 6.07235 5.33897 5.88419 5.47594 5.74407C7.1705 4.08788 9.44983 3.16677 11.8193 3.18064C14.1887 3.1945 16.4571 4.14222 18.1322 5.81813L19.5 7.1897V4.50001C19.5 4.3011 19.579 4.11033 19.7197 3.96968C19.8603 3.82903 20.0511 3.75001 20.25 3.75001C20.4489 3.75001 20.6397 3.82903 20.7803 3.96968C20.921 4.11033 21 4.3011 21 4.50001ZM17.4759 17.1834C16.0639 18.5627 14.1651 19.3298 12.1912 19.3182C10.2173 19.3066 8.32762 18.5173 6.93188 17.1216L5.56031 15.75H8.25C8.44891 15.75 8.63968 15.671 8.78033 15.5303C8.92098 15.3897 9 15.1989 9 15C9 14.8011 8.92098 14.6103 8.78033 14.4697C8.63968 14.329 8.44891 14.25 8.25 14.25H3.75C3.55109 14.25 3.36032 14.329 3.21967 14.4697C3.07902 14.6103 3 14.8011 3 15V19.5C3 19.6989 3.07902 19.8897 3.21967 20.0303C3.36032 20.171 3.55109 20.25 3.75 20.25C3.94891 20.25 4.13968 20.171 4.28033 20.0303C4.42098 19.8897 4.5 19.6989 4.5 19.5V16.8103L5.87156 18.1819C7.54426 19.863 9.816 20.8112 12.1875 20.8181H12.2372C14.5885 20.8242 16.8476 19.9037 18.525 18.2559C18.662 18.1158 18.7387 17.9277 18.7387 17.7317C18.7387 17.5358 18.662 17.3476 18.5251 17.2075C18.3881 17.0674 18.2018 16.9864 18.0059 16.9819C17.81 16.9774 17.6201 17.0497 17.4769 17.1834H17.4759Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  ArrowsClockwiseIcon.displayName = "ArrowsClockwiseIcon";
  var ArrowSquareOut = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props, "ArrowSquareOut");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M21 9.75C21 9.94891 20.921 10.1397 20.7803 10.2803C20.6397 10.421 20.4489 10.5 20.25 10.5C20.0511 10.5 19.8603 10.421 19.7197 10.2803C19.579 10.1397 19.5 9.94891 19.5 9.75V5.56125L13.2816 11.7806C13.1408 11.9214 12.95 12.0004 12.7509 12.0004C12.5519 12.0004 12.361 11.9214 12.2203 11.7806C12.0796 11.6399 12.0005 11.449 12.0005 11.25C12.0005 11.051 12.0796 10.8601 12.2203 10.7194L18.4387 4.5H14.25C14.0511 4.5 13.8603 4.42098 13.7197 4.28033C13.579 4.13968 13.5 3.94891 13.5 3.75C13.5 3.55109 13.579 3.36032 13.7197 3.21967C13.8603 3.07902 14.0511 3 14.25 3H20.25C20.4489 3 20.6397 3.07902 20.7803 3.21967C20.921 3.36032 21 3.55109 21 3.75V9.75ZM17.25 12C17.0511 12 16.8603 12.079 16.7197 12.2197C16.579 12.3603 16.5 12.5511 16.5 12.75V19.5H4.5V7.5H11.25C11.4489 7.5 11.6397 7.42098 11.7803 7.28033C11.921 7.13968 12 6.94891 12 6.75C12 6.55109 11.921 6.36032 11.7803 6.21967C11.6397 6.07902 11.4489 6 11.25 6H4.5C4.10218 6 3.72064 6.15804 3.43934 6.43934C3.15804 6.72064 3 7.10218 3 7.5V19.5C3 19.8978 3.15804 20.2794 3.43934 20.5607C3.72064 20.842 4.10218 21 4.5 21H16.5C16.8978 21 17.2794 20.842 17.5607 20.5607C17.842 20.2794 18 19.8978 18 19.5V12.75C18 12.5511 17.921 12.3603 17.7803 12.2197C17.6397 12.079 17.4489 12 17.25 12Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  ArrowSquareOut.displayName = "ArrowSquareOut";
  var ArrowUp$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fill: props.color || "currentColor",
            d: "M19.2806 11.0306C19.211 11.1003 19.1282 11.1557 19.0372 11.1934C18.9461 11.2311 18.8486 11.2506 18.75 11.2506C18.6514 11.2506 18.5538 11.2311 18.4628 11.1934C18.3717 11.1557 18.289 11.1003 18.2194 11.0306L12.75 5.56029V20.25C12.75 20.4489 12.671 20.6397 12.5303 20.7803C12.3897 20.921 12.1989 21 12 21C11.8011 21 11.6103 20.921 11.4697 20.7803C11.329 20.6397 11.25 20.4489 11.25 20.25V5.56029L5.78061 11.0306C5.63988 11.1713 5.44901 11.2504 5.24999 11.2504C5.05097 11.2504 4.8601 11.1713 4.71936 11.0306C4.57863 10.8899 4.49957 10.699 4.49957 10.5C4.49957 10.301 4.57863 10.1101 4.71936 9.96935L11.4694 3.21935C11.539 3.14962 11.6217 3.0943 11.7128 3.05656C11.8038 3.01882 11.9014 2.99939 12 2.99939C12.0986 2.99939 12.1961 3.01882 12.2872 3.05656C12.3782 3.0943 12.461 3.14962 12.5306 3.21935L19.2806 9.96935C19.3503 10.039 19.4057 10.1217 19.4434 10.2128C19.4812 10.3038 19.5006 10.4014 19.5006 10.5C19.5006 10.5985 19.4812 10.6961 19.4434 10.7872C19.4057 10.8782 19.3503 10.961 19.2806 11.0306Z"
          }
        )
      }
    )
  );
  ArrowUp$1.displayName = "ArrowUp";
  var BooksIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.7172 18.2391L18.6056 3.44537C18.5654 3.25191 18.4873 3.06831 18.3759 2.90511C18.2645 2.74191 18.1219 2.60233 17.9564 2.4944C17.7909 2.38646 17.6057 2.3123 17.4114 2.27616C17.2171 2.24002 17.0176 2.24262 16.8244 2.28381L12.4359 3.22693C12.0478 3.31193 11.7089 3.54675 11.4929 3.88032C11.277 4.21389 11.2015 4.61923 11.2828 5.00818L14.3944 19.8019C14.4637 20.1395 14.6471 20.4428 14.9138 20.661C15.1805 20.8792 15.5142 20.9989 15.8588 21.0001C15.9653 20.9999 16.0715 20.9886 16.1756 20.9663L20.5641 20.0232C20.9527 19.938 21.292 19.7027 21.5079 19.3686C21.7239 19.0344 21.7991 18.6285 21.7172 18.2391ZM12.75 4.70162C12.75 4.696 12.75 4.69318 12.75 4.69318L17.1375 3.75568L17.4497 5.24349L13.0622 6.18756L12.75 4.70162ZM13.3706 7.65193L17.76 6.70974L18.0731 8.20037L13.6875 9.14349L13.3706 7.65193ZM13.9931 10.6116L18.3825 9.66849L19.6294 15.5972L15.24 16.5404L13.9931 10.6116ZM20.25 18.5569L15.8625 19.4944L15.5503 18.0066L19.9378 17.0626L20.25 18.5485C20.25 18.5541 20.25 18.5569 20.25 18.5569ZM9.75 3.00006H5.25C4.85218 3.00006 4.47064 3.15809 4.18934 3.4394C3.90804 3.7207 3.75 4.10223 3.75 4.50006V19.5001C3.75 19.8979 3.90804 20.2794 4.18934 20.5607C4.47064 20.842 4.85218 21.0001 5.25 21.0001H9.75C10.1478 21.0001 10.5294 20.842 10.8107 20.5607C11.092 20.2794 11.25 19.8979 11.25 19.5001V4.50006C11.25 4.10223 11.092 3.7207 10.8107 3.4394C10.5294 3.15809 10.1478 3.00006 9.75 3.00006ZM5.25 4.50006H9.75V6.00006H5.25V4.50006ZM5.25 7.50006H9.75V16.5001H5.25V7.50006ZM9.75 19.5001H5.25V18.0001H9.75V19.5001Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  BooksIcon.displayName = "BooksIcon";
  var Camera$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M19.5 5.25H16.9012L15.6234 3.33375C15.555 3.23114 15.4623 3.147 15.3535 3.08879C15.2448 3.03057 15.1233 3.00007 15 3H9C8.87665 3.00007 8.75522 3.03057 8.64648 3.08879C8.53773 3.147 8.44502 3.23114 8.37656 3.33375L7.09781 5.25H4.5C3.90326 5.25 3.33097 5.48705 2.90901 5.90901C2.48705 6.33097 2.25 6.90326 2.25 7.5V18C2.25 18.5967 2.48705 19.169 2.90901 19.591C3.33097 20.0129 3.90326 20.25 4.5 20.25H19.5C20.0967 20.25 20.669 20.0129 21.091 19.591C21.5129 19.169 21.75 18.5967 21.75 18V7.5C21.75 6.90326 21.5129 6.33097 21.091 5.90901C20.669 5.48705 20.0967 5.25 19.5 5.25ZM20.25 18C20.25 18.1989 20.171 18.3897 20.0303 18.5303C19.8897 18.671 19.6989 18.75 19.5 18.75H4.5C4.30109 18.75 4.11032 18.671 3.96967 18.5303C3.82902 18.3897 3.75 18.1989 3.75 18V7.5C3.75 7.30109 3.82902 7.11032 3.96967 6.96967C4.11032 6.82902 4.30109 6.75 4.5 6.75H7.5C7.62351 6.75008 7.74512 6.71966 7.85405 6.66143C7.96297 6.60321 8.05583 6.51899 8.12438 6.41625L9.40125 4.5H14.5978L15.8756 6.41625C15.9442 6.51899 16.037 6.60321 16.146 6.66143C16.2549 6.71966 16.3765 6.75008 16.5 6.75H19.5C19.6989 6.75 19.8897 6.82902 20.0303 6.96967C20.171 7.11032 20.25 7.30109 20.25 7.5V18ZM12 8.25C11.1842 8.25 10.3866 8.49193 9.70827 8.94519C9.02992 9.39845 8.50121 10.0427 8.189 10.7964C7.87679 11.5502 7.7951 12.3796 7.95426 13.1797C8.11343 13.9799 8.50629 14.7149 9.08318 15.2918C9.66008 15.8687 10.3951 16.2616 11.1953 16.4207C11.9954 16.5799 12.8248 16.4982 13.5786 16.186C14.3323 15.8738 14.9766 15.3451 15.4298 14.6667C15.8831 13.9884 16.125 13.1908 16.125 12.375C16.1238 11.2814 15.6888 10.2329 14.9154 9.45955C14.1421 8.68624 13.0936 8.25124 12 8.25ZM12 15C11.4808 15 10.9733 14.846 10.5416 14.5576C10.1099 14.2692 9.7735 13.8592 9.57482 13.3795C9.37614 12.8999 9.32415 12.3721 9.42544 11.8629C9.52672 11.3537 9.77673 10.886 10.1438 10.5188C10.511 10.1517 10.9787 9.90172 11.4879 9.80044C11.9971 9.69915 12.5249 9.75114 13.0045 9.94982C13.4842 10.1485 13.8942 10.4849 14.1826 10.9166C14.471 11.3483 14.625 11.8558 14.625 12.375C14.625 13.0712 14.3484 13.7389 13.8562 14.2312C13.3639 14.7234 12.6962 15 12 15Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Camera$1.displayName = "Camera";
  var CaretDown = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.0306 9.53068L12.5306 17.0307C12.461 17.1004 12.3782 17.1557 12.2872 17.1935C12.1961 17.2312 12.0986 17.2506 12 17.2506C11.9014 17.2506 11.8038 17.2312 11.7128 17.1935C11.6217 17.1557 11.539 17.1004 11.4694 17.0307L3.96936 9.53068C3.82863 9.38995 3.74957 9.19907 3.74957 9.00005C3.74957 8.80103 3.82863 8.61016 3.96936 8.46943C4.1101 8.32869 4.30097 8.24963 4.49999 8.24963C4.69901 8.24963 4.88988 8.32869 5.03061 8.46943L12 15.4397L18.9694 8.46943C19.039 8.39974 19.1218 8.34447 19.2128 8.30676C19.3039 8.26904 19.4014 8.24963 19.5 8.24963C19.5985 8.24963 19.6961 8.26904 19.7872 8.30676C19.8782 8.34447 19.9609 8.39974 20.0306 8.46943C20.1003 8.53911 20.1556 8.62183 20.1933 8.71288C20.231 8.80392 20.2504 8.9015 20.2504 9.00005C20.2504 9.0986 20.231 9.19618 20.1933 9.28722C20.1556 9.37827 20.1003 9.46099 20.0306 9.53068Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  CaretDown.displayName = "CaretDown";
  var CaretRight = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M17.0306 12.5307L9.53062 20.0307C9.46093 20.1004 9.37821 20.1556 9.28716 20.1933C9.19612 20.2311 9.09854 20.2505 8.99999 20.2505C8.90144 20.2505 8.80386 20.2311 8.71282 20.1933C8.62177 20.1556 8.53905 20.1004 8.46936 20.0307C8.39968 19.961 8.34441 19.8783 8.30669 19.7872C8.26898 19.6962 8.24957 19.5986 8.24957 19.5001C8.24957 19.4015 8.26898 19.3039 8.30669 19.2129C8.34441 19.1218 8.39968 19.0391 8.46936 18.9694L15.4397 12.0001L8.46936 5.03068C8.32863 4.88995 8.24957 4.69907 8.24957 4.50005C8.24957 4.30103 8.32863 4.11016 8.46936 3.96943C8.61009 3.8287 8.80097 3.74963 8.99999 3.74963C9.19901 3.74963 9.38988 3.8287 9.53062 3.96943L17.0306 11.4694C17.1003 11.5391 17.1557 11.6218 17.1934 11.7128C17.2312 11.8039 17.2506 11.9015 17.2506 12.0001C17.2506 12.0986 17.2312 12.1962 17.1934 12.2873C17.1557 12.3783 17.1003 12.461 17.0306 12.5307Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  CaretRight.displayName = "CaretRight";
  var CaretUpIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.0306 15.5306C19.961 15.6003 19.8782 15.6557 19.7872 15.6934C19.6961 15.7311 19.5986 15.7506 19.5 15.7506C19.4014 15.7506 19.3038 15.7311 19.2128 15.6934C19.1217 15.6557 19.039 15.6003 18.9694 15.5306L12 8.56029L5.03061 15.5306C4.88988 15.6713 4.69901 15.7504 4.49999 15.7504C4.30097 15.7504 4.1101 15.6713 3.96936 15.5306C3.82863 15.3899 3.74957 15.199 3.74957 15C3.74957 14.801 3.82863 14.6101 3.96936 14.4694L11.4694 6.96935C11.539 6.89962 11.6217 6.8443 11.7128 6.80656C11.8038 6.76882 11.9014 6.74939 12 6.74939C12.0986 6.74939 12.1961 6.76882 12.2872 6.80656C12.3782 6.8443 12.461 6.89962 12.5306 6.96935L20.0306 14.4694C20.1003 14.539 20.1557 14.6217 20.1934 14.7128C20.2312 14.8038 20.2506 14.9014 20.2506 15C20.2506 15.0985 20.2312 15.1961 20.1934 15.2872C20.1557 15.3782 20.1003 15.4609 20.0306 15.5306Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  CaretUpIcon.displayName = "CaretUpIcon";
  var ChartBar = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21 18.75H20.25V3.75C20.25 3.55109 20.171 3.36032 20.0303 3.21967C19.8897 3.07902 19.6989 3 19.5 3H14.25C14.0511 3 13.8603 3.07902 13.7197 3.21967C13.579 3.36032 13.5 3.55109 13.5 3.75V7.5H9C8.80109 7.5 8.61032 7.57902 8.46967 7.71967C8.32902 7.86032 8.25 8.05109 8.25 8.25V12H4.5C4.30109 12 4.11032 12.079 3.96967 12.2197C3.82902 12.3603 3.75 12.5511 3.75 12.75V18.75H3C2.80109 18.75 2.61032 18.829 2.46967 18.9697C2.32902 19.1103 2.25 19.3011 2.25 19.5C2.25 19.6989 2.32902 19.8897 2.46967 20.0303C2.61032 20.171 2.80109 20.25 3 20.25H21C21.1989 20.25 21.3897 20.171 21.5303 20.0303C21.671 19.8897 21.75 19.6989 21.75 19.5C21.75 19.3011 21.671 19.1103 21.5303 18.9697C21.3897 18.829 21.1989 18.75 21 18.75ZM15 4.5H18.75V18.75H15V4.5ZM9.75 9H13.5V18.75H9.75V9ZM5.25 13.5H8.25V18.75H5.25V13.5Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  ChartBar.displayName = "ChartBar";
  var Chat$1 = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props, "Chat");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M20.25 4.5H3.75C3.35217 4.5 2.97064 4.65804 2.68934 4.93934C2.40803 5.22064 2.25 5.60218 2.25 6V21C2.24827 21.286 2.32918 21.5665 2.48302 21.8076C2.63686 22.0488 2.85707 22.2404 3.11718 22.3594C3.3154 22.4517 3.53135 22.4997 3.75 22.5C4.10213 22.4992 4.44257 22.3736 4.71093 22.1456L4.71937 22.1391L7.78125 19.5H20.25C20.6478 19.5 21.0294 19.342 21.3107 19.0607C21.592 18.7794 21.75 18.3978 21.75 18V6C21.75 5.60218 21.592 5.22064 21.3107 4.93934C21.0294 4.65804 20.6478 4.5 20.25 4.5ZM20.25 18H7.5C7.31991 18.0001 7.14587 18.065 7.00968 18.1828L3.75 21V6H20.25V18Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  Chat$1.displayName = "Chat";
  var ChatsCircle = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.7566 17.5087C22.2748 16.4338 22.5291 15.2508 22.4983 14.058C22.4675 12.8651 22.1525 11.6968 21.5795 10.6501C21.0066 9.60341 20.1921 8.70854 19.2038 8.03984C18.2155 7.37113 17.0819 6.94789 15.8972 6.80527C15.503 5.88873 14.9299 5.06007 14.2115 4.36779C13.493 3.67551 12.6436 3.13353 11.7131 2.7736C10.7826 2.41367 9.7896 2.24302 8.7923 2.27164C7.795 2.30026 6.81344 2.52758 5.90509 2.94028C4.99673 3.35298 4.17985 3.94277 3.50228 4.67511C2.82471 5.40745 2.30007 6.26762 1.95908 7.20525C1.61809 8.14288 1.4676 9.13912 1.51643 10.1356C1.56526 11.1321 1.81243 12.1089 2.24346 13.0087L1.5619 15.3253C1.48569 15.5839 1.4806 15.8582 1.54715 16.1195C1.6137 16.3808 1.74943 16.6193 1.94007 16.8099C2.13071 17.0005 2.36921 17.1363 2.63047 17.2028C2.89173 17.2694 3.1661 17.2643 3.42471 17.1881L5.74127 16.5065C6.48512 16.8639 7.28261 17.0967 8.1019 17.1956C8.49994 18.1282 9.08297 18.9704 9.81575 19.6713C10.5485 20.3723 11.4158 20.9173 12.3652 21.2735C13.3146 21.6297 14.3264 21.7897 15.3393 21.7438C16.3523 21.698 17.3455 21.4471 18.2588 21.0065L20.5753 21.6881C20.8339 21.7642 21.1081 21.7693 21.3692 21.7027C21.6304 21.6362 21.8688 21.5006 22.0594 21.3101C22.25 21.1196 22.3858 20.8812 22.4524 20.6201C22.5191 20.359 22.5141 20.0848 22.4381 19.8262L21.7566 17.5087ZM5.81252 14.9531C5.74085 14.9532 5.66955 14.9633 5.60065 14.9831L3.00002 15.75L3.76596 13.1475C3.82044 12.9594 3.79924 12.7576 3.7069 12.585C3.02844 11.3161 2.82853 9.84573 3.14362 8.44182C3.4587 7.03792 4.2678 5.79398 5.42341 4.93678C6.57902 4.07958 8.0042 3.66619 9.43914 3.77198C10.8741 3.87778 12.2232 4.4957 13.2406 5.5131C14.258 6.53051 14.876 7.87965 14.9817 9.31459C15.0875 10.7495 14.6742 12.1747 13.8169 13.3303C12.9597 14.4859 11.7158 15.295 10.3119 15.6101C8.90799 15.9252 7.4376 15.7253 6.16877 15.0468C6.05966 14.9864 5.93722 14.9542 5.81252 14.9531ZM20.2303 17.6465L21 20.25L18.3975 19.484C18.2095 19.4295 18.0076 19.4507 17.835 19.5431C16.4539 20.2805 14.8394 20.4494 13.3356 20.0137C11.8318 19.578 10.5576 18.5721 9.78471 17.2106C10.8116 17.1034 11.8053 16.7852 12.7034 16.2758C13.6016 15.7665 14.3847 15.077 15.0038 14.2507C15.6229 13.4244 16.0645 12.4791 16.301 11.4741C16.5375 10.469 16.5638 9.42593 16.3781 8.41027C17.2729 8.62117 18.1072 9.03485 18.8167 9.61936C19.5262 10.2039 20.0919 10.9436 20.4701 11.7814C20.8484 12.6193 21.029 13.5328 20.9982 14.4516C20.9673 15.3703 20.7258 16.2697 20.2922 17.0803C20.1989 17.2539 20.1776 17.4573 20.2332 17.6465H20.2303Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  ChatsCircle.displayName = "ChatsCircle";
  var Check = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.5306 7.28068L9.53061 19.2807C9.46096 19.3504 9.37824 19.4057 9.2872 19.4435C9.19615 19.4812 9.09855 19.5006 8.99999 19.5006C8.90143 19.5006 8.80383 19.4812 8.71278 19.4435C8.62174 19.4057 8.53902 19.3504 8.46936 19.2807L3.21936 14.0307C3.07863 13.8899 2.99957 13.6991 2.99957 13.5001C2.99957 13.301 3.07863 13.1102 3.21936 12.9694C3.3601 12.8287 3.55097 12.7496 3.74999 12.7496C3.94901 12.7496 4.13988 12.8287 4.28061 12.9694L8.99999 17.6897L20.4694 6.21943C20.6101 6.07869 20.801 5.99963 21 5.99963C21.199 5.99963 21.3899 6.07869 21.5306 6.21943C21.6713 6.36016 21.7504 6.55103 21.7504 6.75005C21.7504 6.94907 21.6713 7.13995 21.5306 7.28068Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Check.displayName = "Check";
  var CheckSquareIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M16.2806 9.21937C16.3504 9.28903 16.4057 9.37175 16.4434 9.46279C16.4812 9.55384 16.5006 9.65144 16.5006 9.75C16.5006 9.84856 16.4812 9.94616 16.4434 10.0372C16.4057 10.1283 16.3504 10.211 16.2806 10.2806L11.0306 15.5306C10.961 15.6004 10.8783 15.6557 10.7872 15.6934C10.6962 15.7312 10.5986 15.7506 10.5 15.7506C10.4014 15.7506 10.3038 15.7312 10.2128 15.6934C10.1217 15.6557 10.039 15.6004 9.96937 15.5306L7.71937 13.2806C7.57864 13.1399 7.49958 12.949 7.49958 12.75C7.49958 12.551 7.57864 12.3601 7.71937 12.2194C7.86011 12.0786 8.05098 11.9996 8.25 11.9996C8.44902 11.9996 8.63989 12.0786 8.78063 12.2194L10.5 13.9397L15.2194 9.21937C15.289 9.14964 15.3717 9.09432 15.4628 9.05658C15.5538 9.01884 15.6514 8.99941 15.75 8.99941C15.8486 8.99941 15.9462 9.01884 16.0372 9.05658C16.1283 9.09432 16.211 9.14964 16.2806 9.21937ZM21 4.5V19.5C21 19.8978 20.842 20.2794 20.5607 20.5607C20.2794 20.842 19.8978 21 19.5 21H4.5C4.10218 21 3.72064 20.842 3.43934 20.5607C3.15804 20.2794 3 19.8978 3 19.5V4.5C3 4.10218 3.15804 3.72064 3.43934 3.43934C3.72064 3.15804 4.10218 3 4.5 3H19.5C19.8978 3 20.2794 3.15804 20.5607 3.43934C20.842 3.72064 21 4.10218 21 4.5ZM19.5 19.5V4.5H4.5V19.5H19.5Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  CheckSquareIcon.displayName = "CheckSquareIcon";
  var Circle = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 2.25C10.0716 2.25 8.18657 2.82183 6.58319 3.89317C4.97982 4.96451 3.73013 6.48726 2.99218 8.26884C2.25422 10.0504 2.06114 12.0108 2.43735 13.9021C2.81355 15.7934 3.74215 17.5307 5.10571 18.8943C6.46928 20.2579 8.20656 21.1865 10.0979 21.5627C11.9892 21.9389 13.9496 21.7458 15.7312 21.0078C17.5127 20.2699 19.0355 19.0202 20.1068 17.4168C21.1782 15.8134 21.75 13.9284 21.75 12C21.7473 9.41498 20.7192 6.93661 18.8913 5.10872C17.0634 3.28084 14.585 2.25273 12 2.25ZM12 20.25C10.3683 20.25 8.77326 19.7661 7.41655 18.8596C6.05984 17.9531 5.00242 16.6646 4.378 15.1571C3.75358 13.6496 3.5902 11.9908 3.90853 10.3905C4.22685 8.79016 5.01259 7.32015 6.16637 6.16637C7.32016 5.01259 8.79017 4.22685 10.3905 3.90852C11.9909 3.59019 13.6497 3.75357 15.1571 4.37799C16.6646 5.00242 17.9531 6.05984 18.8596 7.41655C19.7661 8.77325 20.25 10.3683 20.25 12C20.2475 14.1873 19.3775 16.2843 17.8309 17.8309C16.2843 19.3775 14.1873 20.2475 12 20.25Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Circle.displayName = "Circle";
  var ClipboardTextIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M15.75 14.25C15.75 14.4489 15.671 14.6397 15.5303 14.7803C15.3897 14.921 15.1989 15 15 15H9C8.80109 15 8.61032 14.921 8.46967 14.7803C8.32902 14.6397 8.25 14.4489 8.25 14.25C8.25 14.0511 8.32902 13.8603 8.46967 13.7197C8.61032 13.579 8.80109 13.5 9 13.5H15C15.1989 13.5 15.3897 13.579 15.5303 13.7197C15.671 13.8603 15.75 14.0511 15.75 14.25ZM15 10.5H9C8.80109 10.5 8.61032 10.579 8.46967 10.7197C8.32902 10.8603 8.25 11.0511 8.25 11.25C8.25 11.4489 8.32902 11.6397 8.46967 11.7803C8.61032 11.921 8.80109 12 9 12H15C15.1989 12 15.3897 11.921 15.5303 11.7803C15.671 11.6397 15.75 11.4489 15.75 11.25C15.75 11.0511 15.671 10.8603 15.5303 10.7197C15.3897 10.579 15.1989 10.5 15 10.5ZM20.25 4.49999V20.25C20.25 20.6478 20.092 21.0293 19.8107 21.3106C19.5294 21.592 19.1478 21.75 18.75 21.75H5.25C4.85218 21.75 4.47064 21.592 4.18934 21.3106C3.90804 21.0293 3.75 20.6478 3.75 20.25V4.49999C3.75 4.10216 3.90804 3.72063 4.18934 3.43933C4.47064 3.15802 4.85218 2.99999 5.25 2.99999H8.64937C9.07079 2.52817 9.58709 2.15066 10.1645 1.8922C10.7419 1.63373 11.3674 1.50012 12 1.50012C12.6326 1.50012 13.2581 1.63373 13.8355 1.8922C14.4129 2.15066 14.9292 2.52817 15.3506 2.99999H18.75C19.1478 2.99999 19.5294 3.15802 19.8107 3.43933C20.092 3.72063 20.25 4.10216 20.25 4.49999ZM9 5.99999H15C15 5.20434 14.6839 4.44127 14.1213 3.87867C13.5587 3.31606 12.7956 2.99999 12 2.99999C11.2044 2.99999 10.4413 3.31606 9.87868 3.87867C9.31607 4.44127 9 5.20434 9 5.99999ZM18.75 4.49999H16.2422C16.4128 4.98169 16.5 5.48896 16.5 5.99999V6.74999C16.5 6.9489 16.421 7.13966 16.2803 7.28032C16.1397 7.42097 15.9489 7.49999 15.75 7.49999H8.25C8.05109 7.49999 7.86032 7.42097 7.71967 7.28032C7.57902 7.13966 7.5 6.9489 7.5 6.74999V5.99999C7.50002 5.48896 7.58721 4.98169 7.75781 4.49999H5.25V20.25H18.75V4.49999Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  ClipboardTextIcon.displayName = "ClipboardTextIcon";
  var Clock = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 2.25C10.0716 2.25 8.18657 2.82183 6.58319 3.89317C4.97982 4.96451 3.73013 6.48726 2.99218 8.26884C2.25422 10.0504 2.06114 12.0108 2.43735 13.9021C2.81355 15.7934 3.74215 17.5307 5.10571 18.8943C6.46928 20.2579 8.20656 21.1865 10.0979 21.5627C11.9892 21.9389 13.9496 21.7458 15.7312 21.0078C17.5127 20.2699 19.0355 19.0202 20.1068 17.4168C21.1782 15.8134 21.75 13.9284 21.75 12C21.7473 9.41498 20.7192 6.93661 18.8913 5.10872C17.0634 3.28084 14.585 2.25273 12 2.25ZM12 20.25C10.3683 20.25 8.77326 19.7661 7.41655 18.8596C6.05984 17.9531 5.00242 16.6646 4.378 15.1571C3.75358 13.6496 3.5902 11.9908 3.90853 10.3905C4.22685 8.79016 5.01259 7.32015 6.16637 6.16637C7.32016 5.01259 8.79017 4.22685 10.3905 3.90852C11.9909 3.59019 13.6497 3.75357 15.1571 4.37799C16.6646 5.00242 17.9531 6.05984 18.8596 7.41655C19.7661 8.77325 20.25 10.3683 20.25 12C20.2475 14.1873 19.3775 16.2843 17.8309 17.8309C16.2843 19.3775 14.1873 20.2475 12 20.25ZM18 12C18 12.1989 17.921 12.3897 17.7803 12.5303C17.6397 12.671 17.4489 12.75 17.25 12.75H12C11.8011 12.75 11.6103 12.671 11.4697 12.5303C11.329 12.3897 11.25 12.1989 11.25 12V6.75C11.25 6.55109 11.329 6.36032 11.4697 6.21967C11.6103 6.07902 11.8011 6 12 6C12.1989 6 12.3897 6.07902 12.5303 6.21967C12.671 6.36032 12.75 6.55109 12.75 6.75V11.25H17.25C17.4489 11.25 17.6397 11.329 17.7803 11.4697C17.921 11.6103 18 11.8011 18 12Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Clock.displayName = "Clock";
  var CopySimpleIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M17.25 6H3.75C3.55109 6 3.36032 6.07902 3.21967 6.21967C3.07902 6.36032 3 6.55109 3 6.75V20.25C3 20.4489 3.07902 20.6397 3.21967 20.7803C3.36032 20.921 3.55109 21 3.75 21H17.25C17.4489 21 17.6397 20.921 17.7803 20.7803C17.921 20.6397 18 20.4489 18 20.25V6.75C18 6.55109 17.921 6.36032 17.7803 6.21967C17.6397 6.07902 17.4489 6 17.25 6ZM16.5 19.5H4.5V7.5H16.5V19.5ZM21 3.75V17.25C21 17.4489 20.921 17.6397 20.7803 17.7803C20.6397 17.921 20.4489 18 20.25 18C20.0511 18 19.8603 17.921 19.7197 17.7803C19.579 17.6397 19.5 17.4489 19.5 17.25V4.5H6.75C6.55109 4.5 6.36032 4.42098 6.21967 4.28033C6.07902 4.13968 6 3.94891 6 3.75C6 3.55109 6.07902 3.36032 6.21967 3.21967C6.36032 3.07902 6.55109 3 6.75 3H20.25C20.4489 3 20.6397 3.07902 20.7803 3.21967C20.921 3.36032 21 3.55109 21 3.75Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  CopySimpleIcon.displayName = "CopySimpleIcon";
  var CreditCard = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21 4.5H3C2.60218 4.5 2.22064 4.65804 1.93934 4.93934C1.65804 5.22064 1.5 5.60218 1.5 6V18C1.5 18.3978 1.65804 18.7794 1.93934 19.0607C2.22064 19.342 2.60218 19.5 3 19.5H21C21.3978 19.5 21.7794 19.342 22.0607 19.0607C22.342 18.7794 22.5 18.3978 22.5 18V6C22.5 5.60218 22.342 5.22064 22.0607 4.93934C21.7794 4.65804 21.3978 4.5 21 4.5ZM21 6V8.25H3V6H21ZM21 18H3V9.75H21V18ZM19.5 15.75C19.5 15.9489 19.421 16.1397 19.2803 16.2803C19.1397 16.421 18.9489 16.5 18.75 16.5H15.75C15.5511 16.5 15.3603 16.421 15.2197 16.2803C15.079 16.1397 15 15.9489 15 15.75C15 15.5511 15.079 15.3603 15.2197 15.2197C15.3603 15.079 15.5511 15 15.75 15H18.75C18.9489 15 19.1397 15.079 19.2803 15.2197C19.421 15.3603 19.5 15.5511 19.5 15.75ZM13.5 15.75C13.5 15.9489 13.421 16.1397 13.2803 16.2803C13.1397 16.421 12.9489 16.5 12.75 16.5H11.25C11.0511 16.5 10.8603 16.421 10.7197 16.2803C10.579 16.1397 10.5 15.9489 10.5 15.75C10.5 15.5511 10.579 15.3603 10.7197 15.2197C10.8603 15.079 11.0511 15 11.25 15H12.75C12.9489 15 13.1397 15.079 13.2803 15.2197C13.421 15.3603 13.5 15.5511 13.5 15.75Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  CreditCard.displayName = "CreditCard";
  var CurrencyCircleDollar = React.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 2.25C10.0716 2.25 8.18657 2.82183 6.58319 3.89317C4.97982 4.96451 3.73013 6.48726 2.99218 8.26884C2.25422 10.0504 2.06114 12.0108 2.43735 13.9021C2.81355 15.7934 3.74215 17.5307 5.10571 18.8943C6.46928 20.2579 8.20656 21.1865 10.0979 21.5627C11.9892 21.9389 13.9496 21.7458 15.7312 21.0078C17.5127 20.2699 19.0355 19.0202 20.1068 17.4168C21.1782 15.8134 21.75 13.9284 21.75 12C21.7473 9.41498 20.7192 6.93661 18.8913 5.10872C17.0634 3.28084 14.585 2.25273 12 2.25ZM12 20.25C10.3683 20.25 8.77326 19.7661 7.41655 18.8596C6.05984 17.9531 5.00242 16.6646 4.378 15.1571C3.75358 13.6496 3.5902 11.9908 3.90853 10.3905C4.22685 8.79016 5.01259 7.32015 6.16637 6.16637C7.32016 5.01259 8.79017 4.22685 10.3905 3.90852C11.9909 3.59019 13.6497 3.75357 15.1571 4.37799C16.6646 5.00242 17.9531 6.05984 18.8596 7.41655C19.7661 8.77325 20.25 10.3683 20.25 12C20.2475 14.1873 19.3775 16.2843 17.8309 17.8309C16.2843 19.3775 14.1873 20.2475 12 20.25ZM15.75 13.875C15.75 14.5712 15.4734 15.2389 14.9812 15.7312C14.4889 16.2234 13.8212 16.5 13.125 16.5H12.75V17.25C12.75 17.4489 12.671 17.6397 12.5303 17.7803C12.3897 17.921 12.1989 18 12 18C11.8011 18 11.6103 17.921 11.4697 17.7803C11.329 17.6397 11.25 17.4489 11.25 17.25V16.5H9.75C9.55109 16.5 9.36033 16.421 9.21967 16.2803C9.07902 16.1397 9 15.9489 9 15.75C9 15.5511 9.07902 15.3603 9.21967 15.2197C9.36033 15.079 9.55109 15 9.75 15H13.125C13.4234 15 13.7095 14.8815 13.9205 14.6705C14.1315 14.4595 14.25 14.1734 14.25 13.875C14.25 13.5766 14.1315 13.2905 13.9205 13.0795C13.7095 12.8685 13.4234 12.75 13.125 12.75H10.875C10.1788 12.75 9.51113 12.4734 9.01885 11.9812C8.52657 11.4889 8.25 10.8212 8.25 10.125C8.25 9.42881 8.52657 8.76113 9.01885 8.26884C9.51113 7.77656 10.1788 7.5 10.875 7.5H11.25V6.75C11.25 6.55109 11.329 6.36032 11.4697 6.21967C11.6103 6.07902 11.8011 6 12 6C12.1989 6 12.3897 6.07902 12.5303 6.21967C12.671 6.36032 12.75 6.55109 12.75 6.75V7.5H14.25C14.4489 7.5 14.6397 7.57902 14.7803 7.71967C14.921 7.86032 15 8.05109 15 8.25C15 8.44891 14.921 8.63968 14.7803 8.78033C14.6397 8.92098 14.4489 9 14.25 9H10.875C10.5766 9 10.2905 9.11853 10.0795 9.3295C9.86853 9.54048 9.75 9.82663 9.75 10.125C9.75 10.4234 9.86853 10.7095 10.0795 10.9205C10.2905 11.1315 10.5766 11.25 10.875 11.25H13.125C13.8212 11.25 14.4889 11.5266 14.9812 12.0188C15.4734 12.5111 15.75 13.1788 15.75 13.875Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  CurrencyCircleDollar.displayName = "CurrencyCircleDollar";
  var DotsSixVerticalIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M9.75 5.625C9.75 5.8475 9.68402 6.06501 9.5604 6.25002C9.43679 6.43502 9.26109 6.57922 9.05552 6.66437C8.84995 6.74951 8.62375 6.77179 8.40552 6.72838C8.1873 6.68498 7.98684 6.57783 7.82951 6.4205C7.67217 6.26316 7.56503 6.06271 7.52162 5.84448C7.47821 5.62625 7.50049 5.40005 7.58564 5.19448C7.67078 4.98891 7.81498 4.81321 7.99998 4.6896C8.18499 4.56598 8.4025 4.5 8.625 4.5C8.92337 4.5 9.20952 4.61853 9.4205 4.82951C9.63147 5.04048 9.75 5.32663 9.75 5.625ZM15.375 6.75C15.5975 6.75 15.815 6.68402 16 6.5604C16.185 6.43679 16.3292 6.26109 16.4144 6.05552C16.4995 5.84995 16.5218 5.62375 16.4784 5.40552C16.435 5.1873 16.3278 4.98684 16.1705 4.82951C16.0132 4.67217 15.8127 4.56503 15.5945 4.52162C15.3762 4.47821 15.15 4.50049 14.9445 4.58564C14.7389 4.67078 14.5632 4.81498 14.4396 4.99998C14.316 5.18499 14.25 5.4025 14.25 5.625C14.25 5.92337 14.3685 6.20952 14.5795 6.4205C14.7905 6.63147 15.0766 6.75 15.375 6.75ZM8.625 10.875C8.4025 10.875 8.18499 10.941 7.99998 11.0646C7.81498 11.1882 7.67078 11.3639 7.58564 11.5695C7.50049 11.775 7.47821 12.0012 7.52162 12.2195C7.56503 12.4377 7.67217 12.6382 7.82951 12.7955C7.98684 12.9528 8.1873 13.06 8.40552 13.1034C8.62375 13.1468 8.84995 13.1245 9.05552 13.0394C9.26109 12.9542 9.43679 12.81 9.5604 12.625C9.68402 12.44 9.75 12.2225 9.75 12C9.75 11.7016 9.63147 11.4155 9.4205 11.2045C9.20952 10.9935 8.92337 10.875 8.625 10.875ZM15.375 10.875C15.1525 10.875 14.935 10.941 14.75 11.0646C14.565 11.1882 14.4208 11.3639 14.3356 11.5695C14.2505 11.775 14.2282 12.0012 14.2716 12.2195C14.315 12.4377 14.4222 12.6382 14.5795 12.7955C14.7368 12.9528 14.9373 13.06 15.1555 13.1034C15.3738 13.1468 15.6 13.1245 15.8055 13.0394C16.0111 12.9542 16.1868 12.81 16.3104 12.625C16.434 12.44 16.5 12.2225 16.5 12C16.5 11.7016 16.3815 11.4155 16.1705 11.2045C15.9595 10.9935 15.6734 10.875 15.375 10.875ZM8.625 17.25C8.4025 17.25 8.18499 17.316 7.99998 17.4396C7.81498 17.5632 7.67078 17.7389 7.58564 17.9445C7.50049 18.15 7.47821 18.3762 7.52162 18.5945C7.56503 18.8127 7.67217 19.0132 7.82951 19.1705C7.98684 19.3278 8.1873 19.435 8.40552 19.4784C8.62375 19.5218 8.84995 19.4995 9.05552 19.4144C9.26109 19.3292 9.43679 19.185 9.5604 19C9.68402 18.815 9.75 18.5975 9.75 18.375C9.75 18.0766 9.63147 17.7905 9.4205 17.5795C9.20952 17.3685 8.92337 17.25 8.625 17.25ZM15.375 17.25C15.1525 17.25 14.935 17.316 14.75 17.4396C14.565 17.5632 14.4208 17.7389 14.3356 17.9445C14.2505 18.15 14.2282 18.3762 14.2716 18.5945C14.315 18.8127 14.4222 19.0132 14.5795 19.1705C14.7368 19.3278 14.9373 19.435 15.1555 19.4784C15.3738 19.5218 15.6 19.4995 15.8055 19.4144C16.0111 19.3292 16.1868 19.185 16.3104 19C16.434 18.815 16.5 18.5975 16.5 18.375C16.5 18.0766 16.3815 17.7905 16.1705 17.5795C15.9595 17.3685 15.6734 17.25 15.375 17.25Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  DotsSixVerticalIcon.displayName = "DotsSixVerticalIcon";
  var DotsThree = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M13.125 12C13.125 12.2225 13.059 12.44 12.9354 12.625C12.8118 12.81 12.6361 12.9542 12.4305 13.0394C12.225 13.1245 11.9988 13.1468 11.7805 13.1034C11.5623 13.06 11.3618 12.9528 11.2045 12.7955C11.0472 12.6382 10.94 12.4377 10.8966 12.2195C10.8532 12.0012 10.8755 11.775 10.9606 11.5695C11.0458 11.3639 11.19 11.1882 11.375 11.0646C11.56 10.941 11.7775 10.875 12 10.875C12.2984 10.875 12.5845 10.9935 12.7955 11.2045C13.0065 11.4155 13.125 11.7016 13.125 12ZM18.375 10.875C18.1525 10.875 17.935 10.941 17.75 11.0646C17.565 11.1882 17.4208 11.3639 17.3356 11.5695C17.2505 11.775 17.2282 12.0012 17.2716 12.2195C17.315 12.4377 17.4222 12.6382 17.5795 12.7955C17.7368 12.9528 17.9373 13.06 18.1555 13.1034C18.3738 13.1468 18.6 13.1245 18.8055 13.0394C19.0111 12.9542 19.1868 12.81 19.3104 12.625C19.434 12.44 19.5 12.2225 19.5 12C19.5 11.7016 19.3815 11.4155 19.1705 11.2045C18.9595 10.9935 18.6734 10.875 18.375 10.875ZM5.625 10.875C5.4025 10.875 5.18499 10.941 4.99998 11.0646C4.81498 11.1882 4.67078 11.3639 4.58564 11.5695C4.50049 11.775 4.47821 12.0012 4.52162 12.2195C4.56503 12.4377 4.67217 12.6382 4.82951 12.7955C4.98684 12.9528 5.1873 13.06 5.40552 13.1034C5.62375 13.1468 5.84995 13.1245 6.05552 13.0394C6.26109 12.9542 6.43679 12.81 6.5604 12.625C6.68402 12.44 6.75 12.2225 6.75 12C6.75 11.7016 6.63147 11.4155 6.4205 11.2045C6.20952 10.9935 5.92337 10.875 5.625 10.875Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  DotsThree.displayName = "DotsThree";
  var DotsThreeVertical = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M13.125 12C13.125 12.2225 13.059 12.44 12.9354 12.625C12.8118 12.81 12.6361 12.9542 12.4305 13.0394C12.225 13.1245 11.9988 13.1468 11.7805 13.1034C11.5623 13.06 11.3618 12.9528 11.2045 12.7955C11.0472 12.6382 10.94 12.4377 10.8966 12.2195C10.8532 12.0012 10.8755 11.775 10.9606 11.5695C11.0458 11.3639 11.19 11.1882 11.375 11.0646C11.56 10.941 11.7775 10.875 12 10.875C12.2984 10.875 12.5845 10.9935 12.7955 11.2045C13.0065 11.4155 13.125 11.7016 13.125 12ZM12 6.75C12.2225 6.75 12.44 6.68402 12.625 6.5604C12.81 6.43679 12.9542 6.26109 13.0394 6.05552C13.1245 5.84995 13.1468 5.62375 13.1034 5.40552C13.06 5.1873 12.9528 4.98684 12.7955 4.82951C12.6382 4.67217 12.4377 4.56503 12.2195 4.52162C12.0012 4.47821 11.775 4.50049 11.5695 4.58564C11.3639 4.67078 11.1882 4.81498 11.0646 4.99998C10.941 5.18499 10.875 5.4025 10.875 5.625C10.875 5.92337 10.9935 6.20952 11.2045 6.4205C11.4155 6.63147 11.7016 6.75 12 6.75ZM12 17.25C11.7775 17.25 11.56 17.316 11.375 17.4396C11.19 17.5632 11.0458 17.7389 10.9606 17.9445C10.8755 18.15 10.8532 18.3762 10.8966 18.5945C10.94 18.8127 11.0472 19.0132 11.2045 19.1705C11.3618 19.3278 11.5623 19.435 11.7805 19.4784C11.9988 19.5218 12.225 19.4995 12.4305 19.4144C12.6361 19.3292 12.8118 19.185 12.9354 19C13.059 18.815 13.125 18.5975 13.125 18.375C13.125 18.0766 13.0065 17.7905 12.7955 17.5795C12.5845 17.3685 12.2984 17.25 12 17.25Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  DotsThreeVertical.displayName = "DotsThreeVertical";
  var FacebookLogo = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props, "FacebookLogo");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M12 2.25C10.0716 2.25 8.18657 2.82183 6.58319 3.89317C4.97982 4.96451 3.73013 6.48726 2.99218 8.26884C2.25422 10.0504 2.06114 12.0108 2.43735 13.9021C2.81355 15.7934 3.74215 17.5307 5.10571 18.8943C6.46928 20.2579 8.20656 21.1865 10.0979 21.5627C11.9892 21.9389 13.9496 21.7458 15.7312 21.0078C17.5127 20.2699 19.0355 19.0202 20.1068 17.4168C21.1782 15.8134 21.75 13.9284 21.75 12C21.7473 9.41498 20.7192 6.93661 18.8913 5.10872C17.0634 3.28084 14.585 2.25273 12 2.25ZM12.75 20.2153V14.25H15C15.1989 14.25 15.3897 14.171 15.5303 14.0303C15.671 13.8897 15.75 13.6989 15.75 13.5C15.75 13.3011 15.671 13.1103 15.5303 12.9697C15.3897 12.829 15.1989 12.75 15 12.75H12.75V10.5C12.75 10.1022 12.908 9.72064 13.1893 9.43934C13.4706 9.15804 13.8522 9 14.25 9H15.75C15.9489 9 16.1397 8.92098 16.2803 8.78033C16.421 8.63968 16.5 8.44891 16.5 8.25C16.5 8.05109 16.421 7.86032 16.2803 7.71967C16.1397 7.57902 15.9489 7.5 15.75 7.5H14.25C13.4544 7.5 12.6913 7.81607 12.1287 8.37868C11.5661 8.94129 11.25 9.70435 11.25 10.5V12.75H9C8.80109 12.75 8.61033 12.829 8.46967 12.9697C8.32902 13.1103 8.25 13.3011 8.25 13.5C8.25 13.6989 8.32902 13.8897 8.46967 14.0303C8.61033 14.171 8.80109 14.25 9 14.25H11.25V20.2153C9.13575 20.0223 7.17728 19.0217 5.78198 17.4215C4.38667 15.8214 3.66195 13.7449 3.75855 11.6241C3.85515 9.50324 4.76564 7.50127 6.30064 6.0346C7.83563 4.56793 9.87696 3.74947 12 3.74947C14.1231 3.74947 16.1644 4.56793 17.6994 6.0346C19.2344 7.50127 20.1449 9.50324 20.2415 11.6241C20.3381 13.7449 19.6133 15.8214 18.218 17.4215C16.8227 19.0217 14.8643 20.0223 12.75 20.2153Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  FacebookLogo.displayName = "FacebookLogo";
  var FolderIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.25 6.75001H12.3103L9.75 4.18969C9.61122 4.0498 9.44601 3.93889 9.26398 3.86341C9.08196 3.78792 8.88674 3.74938 8.68969 3.75001H3.75C3.35218 3.75001 2.97064 3.90804 2.68934 4.18935C2.40804 4.47065 2.25 4.85218 2.25 5.25001V18.8081C2.2505 19.1904 2.40257 19.5568 2.67286 19.8271C2.94316 20.0974 3.30962 20.2495 3.69188 20.25H20.3334C20.709 20.2495 21.069 20.1001 21.3346 19.8346C21.6001 19.569 21.7495 19.209 21.75 18.8334V8.25001C21.75 7.85218 21.592 7.47065 21.3107 7.18935C21.0294 6.90804 20.6478 6.75001 20.25 6.75001ZM3.75 5.25001H8.68969L10.1897 6.75001H3.75V5.25001ZM20.25 18.75H3.75V8.25001H20.25V18.75Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  FolderIcon.displayName = "FolderIcon";
  var FolderSimpleLockIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.75 8.25V9.75C21.75 9.94891 21.671 10.1397 21.5303 10.2803C21.3897 10.421 21.1989 10.5 21 10.5C20.8011 10.5 20.6103 10.421 20.4697 10.2803C20.329 10.1397 20.25 9.94891 20.25 9.75V8.25H12.2503C11.9259 8.2492 11.6103 8.14401 11.3503 7.95L8.74969 6H3.75V18.75H10.5C10.6989 18.75 10.8897 18.829 11.0303 18.9697C11.171 19.1103 11.25 19.3011 11.25 19.5C11.25 19.6989 11.171 19.8897 11.0303 20.0303C10.8897 20.171 10.6989 20.25 10.5 20.25H3.75C3.35218 20.25 2.97064 20.092 2.68934 19.8107C2.40804 19.5294 2.25 19.1478 2.25 18.75V6C2.25 5.60218 2.40804 5.22064 2.68934 4.93934C2.97064 4.65804 3.35218 4.5 3.75 4.5H8.74969C9.07411 4.5008 9.38967 4.60599 9.64969 4.8L12.2503 6.75H20.25C20.6478 6.75 21.0294 6.90804 21.3107 7.18934C21.592 7.47064 21.75 7.85218 21.75 8.25ZM21.75 15.75V19.5C21.75 19.6989 21.671 19.8897 21.5303 20.0303C21.3897 20.171 21.1989 20.25 21 20.25H14.25C14.0511 20.25 13.8603 20.171 13.7197 20.0303C13.579 19.8897 13.5 19.6989 13.5 19.5V15.75C13.5 15.5511 13.579 15.3603 13.7197 15.2197C13.8603 15.079 14.0511 15 14.25 15H15V14.625C15 13.9288 15.2766 13.2611 15.7688 12.7688C16.2611 12.2766 16.9288 12 17.625 12C18.3212 12 18.9889 12.2766 19.4812 12.7688C19.9734 13.2611 20.25 13.9288 20.25 14.625V15H21C21.1989 15 21.3897 15.079 21.5303 15.2197C21.671 15.3603 21.75 15.5511 21.75 15.75ZM16.5 15H18.75V14.625C18.75 14.3266 18.6315 14.0405 18.4205 13.8295C18.2095 13.6185 17.9234 13.5 17.625 13.5C17.3266 13.5 17.0405 13.6185 16.8295 13.8295C16.6185 14.0405 16.5 14.3266 16.5 14.625V15ZM20.25 16.5H15V18.75H20.25V16.5Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  FolderSimpleLockIcon.displayName = "FolderSimpleLockIcon";
  var Gear = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 7.50004C11.11 7.50004 10.2399 7.76396 9.49992 8.25843C8.75989 8.7529 8.18312 9.4557 7.84252 10.278C7.50193 11.1002 7.41282 12.005 7.58645 12.8779C7.76008 13.7509 8.18867 14.5527 8.818 15.182C9.44734 15.8114 10.2492 16.2399 11.1221 16.4136C11.995 16.5872 12.8998 16.4981 13.7221 16.1575C14.5443 15.8169 15.2471 15.2401 15.7416 14.5001C16.2361 13.7601 16.5 12.8901 16.5 12C16.4987 10.807 16.0242 9.66308 15.1806 8.81943C14.3369 7.97579 13.1931 7.50128 12 7.50004ZM12 15C11.4066 15 10.8266 14.8241 10.3333 14.4945C9.83992 14.1648 9.45541 13.6963 9.22834 13.1481C9.00128 12.5999 8.94187 11.9967 9.05763 11.4148C9.17338 10.8328 9.4591 10.2983 9.87866 9.87872C10.2982 9.45917 10.8328 9.17344 11.4147 9.05769C11.9967 8.94193 12.5999 9.00134 13.148 9.2284C13.6962 9.45547 14.1647 9.83999 14.4944 10.3333C14.824 10.8267 15 11.4067 15 12C15 12.7957 14.6839 13.5588 14.1213 14.1214C13.5587 14.684 12.7956 15 12 15ZM20.25 12.2025C20.2537 12.0675 20.2537 11.9325 20.25 11.7975L21.6487 10.05C21.7221 9.95829 21.7728 9.8506 21.7969 9.73563C21.821 9.62067 21.8178 9.50165 21.7875 9.38817C21.5582 8.52623 21.2152 7.69865 20.7675 6.92723C20.7089 6.82628 20.6275 6.7404 20.5298 6.67644C20.4322 6.61248 20.3209 6.57219 20.205 6.55879L17.9812 6.31129C17.8887 6.21379 17.795 6.12004 17.7 6.03004L17.4375 3.80067C17.424 3.68462 17.3836 3.57333 17.3194 3.47567C17.2553 3.37801 17.1692 3.29668 17.0681 3.23817C16.2964 2.79131 15.4689 2.44864 14.6072 2.21911C14.4936 2.18891 14.3746 2.18583 14.2596 2.21009C14.1446 2.23435 14.037 2.28529 13.9453 2.35879L12.2025 3.75004C12.0675 3.75004 11.9325 3.75004 11.7975 3.75004L10.05 2.35411C9.95823 2.28076 9.85053 2.23 9.73557 2.2059C9.62061 2.1818 9.50159 2.18504 9.38811 2.21536C8.52631 2.44507 7.69878 2.78806 6.92717 3.23536C6.82622 3.29397 6.74034 3.37535 6.67638 3.473C6.61242 3.57065 6.57213 3.68189 6.55873 3.79786L6.31123 6.02536C6.21373 6.11848 6.11998 6.21223 6.02998 6.30661L3.80061 6.56254C3.68456 6.57605 3.57326 6.61647 3.4756 6.6806C3.37794 6.74473 3.29662 6.83079 3.23811 6.93192C2.79124 7.70363 2.44858 8.53114 2.21904 9.39286C2.18885 9.50641 2.18577 9.62547 2.21003 9.74044C2.23429 9.8554 2.28523 9.96306 2.35873 10.0547L3.74998 11.7975C3.74998 11.9325 3.74998 12.0675 3.74998 12.2025L2.35404 13.95C2.2807 14.0418 2.22994 14.1495 2.20584 14.2645C2.18174 14.3794 2.18498 14.4984 2.21529 14.6119C2.4446 15.4739 2.78761 16.3014 3.23529 17.0729C3.29391 17.1738 3.37529 17.2597 3.47294 17.3236C3.57059 17.3876 3.68183 17.4279 3.79779 17.4413L6.02154 17.6888C6.11467 17.7863 6.20842 17.88 6.30279 17.97L6.56248 20.1994C6.57598 20.3155 6.61641 20.4268 6.68054 20.5244C6.74467 20.6221 6.83073 20.7034 6.93186 20.7619C7.70357 21.2088 8.53108 21.5515 9.3928 21.781C9.50635 21.8112 9.62541 21.8143 9.74038 21.79C9.85534 21.7657 9.963 21.7148 10.0547 21.6413L11.7975 20.25C11.9325 20.2538 12.0675 20.2538 12.2025 20.25L13.95 21.6488C14.0417 21.7221 14.1494 21.7729 14.2644 21.797C14.3794 21.8211 14.4984 21.8179 14.6119 21.7875C15.4738 21.5582 16.3014 21.2152 17.0728 20.7675C17.1737 20.7089 17.2596 20.6276 17.3236 20.5299C17.3875 20.4322 17.4278 20.321 17.4412 20.205L17.6887 17.9813C17.7862 17.8888 17.88 17.795 17.97 17.7L20.1994 17.4375C20.3154 17.424 20.4267 17.3836 20.5244 17.3195C20.622 17.2554 20.7033 17.1693 20.7619 17.0682C21.2087 16.2965 21.5514 15.4689 21.7809 14.6072C21.8111 14.4937 21.8142 14.3746 21.7899 14.2597C21.7657 14.1447 21.7147 14.037 21.6412 13.9454L20.25 12.2025ZM18.7406 11.5932C18.7565 11.8642 18.7565 12.1359 18.7406 12.4069C18.7294 12.5925 18.7876 12.7756 18.9037 12.9207L20.234 14.5829C20.0814 15.068 19.8859 15.5386 19.65 15.9891L17.5312 16.2291C17.3467 16.2496 17.1764 16.3378 17.0531 16.4766C16.8726 16.6796 16.6804 16.8718 16.4775 17.0522C16.3387 17.1755 16.2505 17.3458 16.23 17.5304L15.9947 19.6472C15.5442 19.8833 15.0736 20.0788 14.5884 20.2313L12.9253 18.901C12.7922 18.7946 12.6269 18.7368 12.4565 18.7369H12.4115C12.1405 18.7529 11.8688 18.7529 11.5978 18.7369C11.4122 18.7257 11.2292 18.7839 11.084 18.9L9.41717 20.2313C8.93204 20.0786 8.46144 19.8832 8.01092 19.6472L7.77092 17.5313C7.75044 17.3468 7.66225 17.1764 7.52342 17.0532C7.32046 16.8727 7.12825 16.6805 6.94779 16.4775C6.82454 16.3387 6.65418 16.2505 6.46967 16.23L4.35279 15.9938C4.11672 15.5433 3.92126 15.0727 3.76873 14.5875L5.09904 12.9244C5.21521 12.7793 5.27334 12.5962 5.26217 12.4107C5.24623 12.1397 5.24623 11.8679 5.26217 11.5969C5.27334 11.4114 5.21521 11.2283 5.09904 11.0832L3.76873 9.41723C3.92138 8.93211 4.11684 8.4615 4.35279 8.01098L6.46873 7.77098C6.65325 7.7505 6.82361 7.66231 6.94686 7.52348C7.12732 7.32052 7.31952 7.12832 7.52248 6.94786C7.66187 6.82452 7.75042 6.65377 7.77092 6.46879L8.00623 4.35286C8.4567 4.11679 8.92731 3.92132 9.41248 3.76879L11.0756 5.09911C11.2207 5.21527 11.4038 5.2734 11.5894 5.26223C11.8604 5.24629 12.1321 5.24629 12.4031 5.26223C12.5887 5.2734 12.7717 5.21527 12.9169 5.09911L14.5828 3.76879C15.0679 3.92144 15.5385 4.1169 15.989 4.35286L16.229 6.46879C16.2495 6.65331 16.3377 6.82367 16.4765 6.94692C16.6795 7.12738 16.8717 7.31958 17.0522 7.52254C17.1754 7.66138 17.3458 7.74956 17.5303 7.77004L19.6472 8.00536C19.8832 8.45583 20.0787 8.92644 20.2312 9.41161L18.9009 11.0747C18.7836 11.2211 18.7254 11.406 18.7378 11.5932H18.7406Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Gear.displayName = "Gear";
  var GearSix = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 7.49998C11.11 7.49998 10.24 7.7639 9.49993 8.25837C8.75991 8.75284 8.18313 9.45564 7.84254 10.2779C7.50194 11.1002 7.41283 12.005 7.58646 12.8779C7.7601 13.7508 8.18868 14.5526 8.81801 15.182C9.44735 15.8113 10.2492 16.2399 11.1221 16.4135C11.995 16.5871 12.8998 16.498 13.7221 16.1574C14.5443 15.8168 15.2471 15.2401 15.7416 14.5C16.2361 13.76 16.5 12.89 16.5 12C16.4988 10.8069 16.0243 9.66302 15.1806 8.81937C14.337 7.97573 13.1931 7.50122 12 7.49998ZM12 15C11.4067 15 10.8266 14.824 10.3333 14.4944C9.83994 14.1647 9.45542 13.6962 9.22836 13.148C9.00129 12.5999 8.94188 11.9967 9.05764 11.4147C9.17339 10.8328 9.45912 10.2982 9.87867 9.87866C10.2982 9.4591 10.8328 9.17338 11.4147 9.05763C11.9967 8.94187 12.5999 9.00128 13.148 9.22834C13.6962 9.45541 14.1648 9.83992 14.4944 10.3333C14.824 10.8266 15 11.4066 15 12C15 12.7956 14.6839 13.5587 14.1213 14.1213C13.5587 14.6839 12.7956 15 12 15ZM22.3069 10.0509C22.286 9.94531 22.2426 9.84543 22.1797 9.75807C22.1167 9.67072 22.0357 9.59793 21.9422 9.54467L19.1456 7.95092L19.1344 4.79904C19.134 4.6905 19.1101 4.58331 19.0643 4.4849C19.0185 4.38649 18.9519 4.29919 18.8691 4.22904C17.8546 3.37095 16.6864 2.71336 15.4266 2.29123C15.3273 2.25765 15.2222 2.24522 15.1179 2.25475C15.0136 2.26428 14.9124 2.29555 14.8209 2.34654L12 3.92342L9.17624 2.34373C9.0847 2.29245 8.98341 2.26094 8.87893 2.25125C8.77445 2.24156 8.6691 2.2539 8.56968 2.28748C7.31076 2.71269 6.14389 3.37279 5.13093 4.23279C5.04822 4.30284 4.98166 4.38999 4.93586 4.48823C4.89006 4.58647 4.8661 4.69347 4.86562 4.80186L4.85156 7.95654L2.055 9.55029C1.96143 9.60356 1.88044 9.67634 1.81751 9.7637C1.75458 9.85105 1.7112 9.95093 1.69031 10.0565C1.43437 11.3427 1.43437 12.6667 1.69031 13.9528C1.7112 14.0584 1.75458 14.1583 1.81751 14.2456C1.88044 14.333 1.96143 14.4058 2.055 14.459L4.85156 16.0528L4.86281 19.2047C4.86315 19.3132 4.88705 19.4204 4.93285 19.5188C4.97866 19.6172 5.04528 19.7045 5.12812 19.7747C6.14256 20.6328 7.31077 21.2904 8.57062 21.7125C8.66983 21.7461 8.77498 21.7585 8.87929 21.749C8.9836 21.7394 9.08476 21.7082 9.17624 21.6572L12 20.0765L14.8237 21.6562C14.9355 21.7185 15.0615 21.7508 15.1894 21.75C15.2713 21.75 15.3526 21.7367 15.4303 21.7106C16.6891 21.286 17.8559 20.6265 18.8691 19.7672C18.9518 19.6971 19.0183 19.61 19.0641 19.5117C19.1099 19.4135 19.1339 19.3065 19.1344 19.1981L19.1484 16.0434L21.945 14.4497C22.0386 14.3964 22.1196 14.3236 22.1825 14.2363C22.2454 14.1489 22.2888 14.049 22.3097 13.9434C22.5642 12.6583 22.5632 11.3357 22.3069 10.0509ZM20.9006 13.3237L18.2222 14.8472C18.1048 14.9139 18.0077 15.0111 17.9409 15.1284C17.8866 15.2222 17.8294 15.3215 17.7712 15.4153C17.6968 15.5335 17.6572 15.6703 17.6569 15.81L17.6428 18.8334C16.9229 19.3988 16.1208 19.8509 15.2644 20.174L12.5625 18.6684C12.4503 18.6064 12.3241 18.5741 12.1959 18.5747H12.1781C12.0647 18.5747 11.9503 18.5747 11.8369 18.5747C11.7027 18.5713 11.5701 18.6037 11.4525 18.6684L8.74874 20.1778C7.89047 19.8571 7.0862 19.4072 6.36375 18.8437L6.35343 15.825C6.35297 15.685 6.31335 15.548 6.23906 15.4294C6.18093 15.3356 6.12375 15.2419 6.07031 15.1425C6.00405 15.0233 5.90689 14.9242 5.78906 14.8556L3.10781 13.3284C2.96906 12.4507 2.96906 11.5567 3.10781 10.679L5.78156 9.15279C5.89891 9.08607 5.99608 8.9889 6.06281 8.87154C6.11718 8.77779 6.17437 8.67842 6.2325 8.58467C6.3069 8.46644 6.34653 8.32967 6.34687 8.18998L6.36093 5.16654C7.08087 4.60118 7.88293 4.14909 8.73937 3.82592L11.4375 5.33154C11.5549 5.39663 11.6877 5.42901 11.8219 5.42529C11.9353 5.42529 12.0497 5.42529 12.1631 5.42529C12.2973 5.42865 12.4299 5.39629 12.5475 5.33154L15.2512 3.82217C16.1095 4.14286 16.9138 4.59274 17.6362 5.15623L17.6466 8.17498C17.647 8.31495 17.6866 8.45199 17.7609 8.57061C17.8191 8.66436 17.8762 8.75811 17.9297 8.85748C17.9959 8.97665 18.0931 9.07575 18.2109 9.14436L20.8922 10.6715C21.0328 11.5499 21.0344 12.4449 20.8969 13.3237H20.9006Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  GearSix.displayName = "GearSix";
  var GitCommit = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M23.25 11.25H17.1956C17.0145 10.0013 16.3897 8.85954 15.4355 8.03383C14.4814 7.20812 13.2618 6.75366 12 6.75366C10.7382 6.75366 9.51859 7.20812 8.56446 8.03383C7.61033 8.85954 6.98551 10.0013 6.80438 11.25H0.75C0.551088 11.25 0.360322 11.329 0.21967 11.4697C0.0790176 11.6103 0 11.8011 0 12C0 12.1989 0.0790176 12.3897 0.21967 12.5303C0.360322 12.671 0.551088 12.75 0.75 12.75H6.80438C6.98551 13.9988 7.61033 15.1405 8.56446 15.9662C9.51859 16.7919 10.7382 17.2464 12 17.2464C13.2618 17.2464 14.4814 16.7919 15.4355 15.9662C16.3897 15.1405 17.0145 13.9988 17.1956 12.75H23.25C23.4489 12.75 23.6397 12.671 23.7803 12.5303C23.921 12.3897 24 12.1989 24 12C24 11.8011 23.921 11.6103 23.7803 11.4697C23.6397 11.329 23.4489 11.25 23.25 11.25ZM12 15.75C11.2583 15.75 10.5333 15.5301 9.91661 15.118C9.29993 14.706 8.81928 14.1203 8.53545 13.4351C8.25162 12.7499 8.17736 11.9959 8.32205 11.2684C8.46675 10.541 8.8239 9.87281 9.34835 9.34837C9.8728 8.82392 10.541 8.46677 11.2684 8.32207C11.9958 8.17738 12.7498 8.25164 13.4351 8.53547C14.1203 8.8193 14.706 9.29994 15.118 9.91663C15.5301 10.5333 15.75 11.2583 15.75 12C15.75 12.9946 15.3549 13.9484 14.6517 14.6517C13.9484 15.3549 12.9946 15.75 12 15.75Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  GitCommit.displayName = "GitCommit";
  var Headset = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M18.9272 5.12437C18.03 4.21817 16.9629 3.49783 15.7869 3.0046C14.611 2.51137 13.3493 2.25494 12.0741 2.25H12C9.41414 2.25 6.93419 3.27723 5.10571 5.10571C3.27723 6.93419 2.25 9.41414 2.25 12V17.25C2.25 17.8467 2.48705 18.419 2.90901 18.841C3.33097 19.2629 3.90326 19.5 4.5 19.5H6C6.59674 19.5 7.16903 19.2629 7.59099 18.841C8.01295 18.419 8.25 17.8467 8.25 17.25V13.5C8.25 12.9033 8.01295 12.331 7.59099 11.909C7.16903 11.4871 6.59674 11.25 6 11.25H3.78375C3.92839 9.68619 4.51578 8.196 5.47709 6.9541C6.43839 5.71219 7.73377 4.77003 9.21141 4.23803C10.689 3.70603 12.2877 3.60624 13.82 3.95035C15.3524 4.29446 16.7548 5.06822 17.8631 6.18094C19.2177 7.54247 20.0509 9.33662 20.2172 11.25H18C17.4033 11.25 16.831 11.4871 16.409 11.909C15.9871 12.331 15.75 12.9033 15.75 13.5V17.25C15.75 17.8467 15.9871 18.419 16.409 18.841C16.831 19.2629 17.4033 19.5 18 19.5H20.25C20.25 20.0967 20.0129 20.669 19.591 21.091C19.169 21.5129 18.5967 21.75 18 21.75H12.75C12.5511 21.75 12.3603 21.829 12.2197 21.9697C12.079 22.1103 12 22.3011 12 22.5C12 22.6989 12.079 22.8897 12.2197 23.0303C12.3603 23.171 12.5511 23.25 12.75 23.25H18C18.9946 23.25 19.9484 22.8549 20.6517 22.1516C21.3549 21.4484 21.75 20.4946 21.75 19.5V12C21.7549 10.7246 21.5081 9.46077 21.0237 8.28093C20.5393 7.10108 19.8268 6.02841 18.9272 5.12437ZM6 12.75C6.19891 12.75 6.38968 12.829 6.53033 12.9697C6.67098 13.1103 6.75 13.3011 6.75 13.5V17.25C6.75 17.4489 6.67098 17.6397 6.53033 17.7803C6.38968 17.921 6.19891 18 6 18H4.5C4.30109 18 4.11032 17.921 3.96967 17.7803C3.82902 17.6397 3.75 17.4489 3.75 17.25V12.75H6ZM18 18C17.8011 18 17.6103 17.921 17.4697 17.7803C17.329 17.6397 17.25 17.4489 17.25 17.25V13.5C17.25 13.3011 17.329 13.1103 17.4697 12.9697C17.6103 12.829 17.8011 12.75 18 12.75H20.25V18H18Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Headset.displayName = "Headset";
  var ImageIcon$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.25 3.75H3.75C3.35218 3.75 2.97064 3.90804 2.68934 4.18934C2.40804 4.47064 2.25 4.85218 2.25 5.25V18.75C2.25 19.1478 2.40804 19.5294 2.68934 19.8107C2.97064 20.092 3.35218 20.25 3.75 20.25H20.25C20.6478 20.25 21.0294 20.092 21.3107 19.8107C21.592 19.5294 21.75 19.1478 21.75 18.75V5.25C21.75 4.85218 21.592 4.47064 21.3107 4.18934C21.0294 3.90804 20.6478 3.75 20.25 3.75ZM20.25 5.25V14.8828L17.8059 12.4397C17.6666 12.3004 17.5013 12.1898 17.3193 12.1144C17.1372 12.039 16.9422 12.0002 16.7452 12.0002C16.5481 12.0002 16.3531 12.039 16.1711 12.1144C15.989 12.1898 15.8237 12.3004 15.6844 12.4397L13.8094 14.3147L9.68438 10.1897C9.4031 9.9086 9.02172 9.7507 8.62406 9.7507C8.22641 9.7507 7.84503 9.9086 7.56375 10.1897L3.75 14.0034V5.25H20.25ZM3.75 16.125L8.625 11.25L16.125 18.75H3.75V16.125ZM20.25 18.75H18.2466L14.8716 15.375L16.7466 13.5L20.25 17.0044V18.75ZM13.5 9.375C13.5 9.1525 13.566 8.93499 13.6896 8.74998C13.8132 8.56498 13.9889 8.42078 14.1945 8.33564C14.4 8.25049 14.6262 8.22821 14.8445 8.27162C15.0627 8.31502 15.2632 8.42217 15.4205 8.5795C15.5778 8.73684 15.685 8.93729 15.7284 9.15552C15.7718 9.37375 15.7495 9.59995 15.6644 9.80552C15.5792 10.0111 15.435 10.1868 15.25 10.3104C15.065 10.434 14.8475 10.5 14.625 10.5C14.3266 10.5 14.0405 10.3815 13.8295 10.1705C13.6185 9.95952 13.5 9.67337 13.5 9.375Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  ImageIcon$1.displayName = "ImageIcon";
  var InstagramLogo = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props, "InstagramLogo");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M12 7.5C11.11 7.5 10.24 7.76392 9.49993 8.25839C8.75991 8.75285 8.18314 9.45566 7.84254 10.2779C7.50195 11.1002 7.41283 12.005 7.58647 12.8779C7.7601 13.7508 8.18868 14.5526 8.81802 15.182C9.44736 15.8113 10.2492 16.2399 11.1221 16.4135C11.995 16.5872 12.8998 16.4981 13.7221 16.1575C14.5443 15.8169 15.2471 15.2401 15.7416 14.5001C16.2361 13.76 16.5 12.89 16.5 12C16.4988 10.8069 16.0243 9.66303 15.1806 8.81939C14.337 7.97575 13.1931 7.50124 12 7.5ZM12 15C11.4067 15 10.8266 14.8241 10.3333 14.4944C9.83994 14.1648 9.45542 13.6962 9.22836 13.1481C9.0013 12.5999 8.94189 11.9967 9.05764 11.4147C9.1734 10.8328 9.45912 10.2982 9.87868 9.87868C10.2982 9.45912 10.8328 9.1734 11.4147 9.05764C11.9967 8.94189 12.5999 9.0013 13.1481 9.22836C13.6962 9.45542 14.1648 9.83994 14.4944 10.3333C14.8241 10.8266 15 11.4067 15 12C15 12.7956 14.6839 13.5587 14.1213 14.1213C13.5587 14.6839 12.7956 15 12 15ZM16.5 2.25H7.5C6.10807 2.25149 4.77358 2.80509 3.78933 3.78933C2.80509 4.77358 2.25149 6.10807 2.25 7.5V16.5C2.25149 17.8919 2.80509 19.2264 3.78933 20.2107C4.77358 21.1949 6.10807 21.7485 7.5 21.75H16.5C17.8919 21.7485 19.2264 21.1949 20.2107 20.2107C21.1949 19.2264 21.7485 17.8919 21.75 16.5V7.5C21.7485 6.10807 21.1949 4.77358 20.2107 3.78933C19.2264 2.80509 17.8919 2.25149 16.5 2.25ZM20.25 16.5C20.25 17.4946 19.8549 18.4484 19.1516 19.1516C18.4484 19.8549 17.4946 20.25 16.5 20.25H7.5C6.50544 20.25 5.55161 19.8549 4.84835 19.1516C4.14509 18.4484 3.75 17.4946 3.75 16.5V7.5C3.75 6.50544 4.14509 5.55161 4.84835 4.84835C5.55161 4.14509 6.50544 3.75 7.5 3.75H16.5C17.4946 3.75 18.4484 4.14509 19.1516 4.84835C19.8549 5.55161 20.25 6.50544 20.25 7.5V16.5ZM18 7.125C18 7.3475 17.934 7.56501 17.8104 7.75002C17.6868 7.93502 17.5111 8.07922 17.3055 8.16436C17.1 8.24951 16.8738 8.27179 16.6555 8.22838C16.4373 8.18498 16.2368 8.07783 16.0795 7.9205C15.9222 7.76316 15.815 7.56271 15.7716 7.34448C15.7282 7.12625 15.7505 6.90005 15.8356 6.69448C15.9208 6.48891 16.065 6.31321 16.25 6.1896C16.435 6.06598 16.6525 6 16.875 6C17.1734 6 17.4595 6.11853 17.6705 6.3295C17.8815 6.54048 18 6.82663 18 7.125Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  InstagramLogo.displayName = "InstagramLogo";
  var KeyIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.3034 3.69649C19.1121 2.50353 17.5536 1.74675 15.8794 1.54826C14.2052 1.34978 12.513 1.72117 11.0758 2.6025C9.63853 3.48384 8.54018 4.82371 7.95792 6.4059C7.37567 7.9881 7.34349 9.72032 7.86656 11.3231L2.68969 16.4999C2.54979 16.6387 2.43888 16.8039 2.3634 16.9859C2.28792 17.168 2.24937 17.3632 2.25 17.5602V20.2499C2.25 20.6478 2.40804 21.0293 2.68934 21.3106C2.97064 21.5919 3.35218 21.7499 3.75 21.7499H6.75C6.94891 21.7499 7.13968 21.6709 7.28033 21.5303C7.42098 21.3896 7.5 21.1988 7.5 20.9999V19.4999H9C9.19891 19.4999 9.38968 19.4209 9.53033 19.2803C9.67098 19.1396 9.75 18.9488 9.75 18.7499V17.2499H11.25C11.3485 17.25 11.4461 17.2307 11.5371 17.193C11.6282 17.1554 11.7109 17.1002 11.7806 17.0306L12.6769 16.1334C13.4271 16.3774 14.2111 16.5011 15 16.4999H15.0094C16.492 16.4981 17.9408 16.057 19.1728 15.2321C20.4048 14.4073 21.3646 13.2359 21.9312 11.8658C22.4977 10.4957 22.6454 8.9884 22.3557 7.53438C22.066 6.08036 21.3518 4.74482 20.3034 3.69649ZM21 9.19681C20.8978 12.3927 18.2109 14.9962 15.0103 14.9999H15C14.2408 15.0012 13.4883 14.8577 12.7828 14.5771C12.6448 14.5172 12.492 14.5002 12.3442 14.5283C12.1964 14.5564 12.0605 14.6283 11.9541 14.7346L10.9397 15.7499H9C8.80109 15.7499 8.61032 15.8289 8.46967 15.9696C8.32902 16.1103 8.25 16.301 8.25 16.4999V17.9999H6.75C6.55109 17.9999 6.36032 18.0789 6.21967 18.2196C6.07902 18.3603 6 18.551 6 18.7499V20.2499H3.75V17.5602L9.26531 12.0459C9.37165 11.9395 9.44354 11.8035 9.47163 11.6557C9.49971 11.5079 9.48271 11.3551 9.42281 11.2171C9.14132 10.5093 8.99781 9.75417 9 8.99243C9 5.79181 11.6072 3.10493 14.8031 3.00274C15.6241 2.97535 16.4419 3.1168 17.2059 3.41835C17.97 3.7199 18.664 4.17512 19.2449 4.7558C19.8259 5.33649 20.2814 6.03027 20.5833 6.79418C20.8852 7.55809 21.027 8.37585 21 9.19681ZM18 7.12493C18 7.34743 17.934 7.56494 17.8104 7.74995C17.6868 7.93495 17.5111 8.07915 17.3055 8.1643C17.1 8.24944 16.8738 8.27172 16.6555 8.22831C16.4373 8.18491 16.2368 8.07776 16.0795 7.92043C15.9222 7.76309 15.815 7.56264 15.7716 7.34441C15.7282 7.12618 15.7505 6.89998 15.8356 6.69441C15.9208 6.48885 16.065 6.31314 16.25 6.18953C16.435 6.06591 16.6525 5.99993 16.875 5.99993C17.1734 5.99993 17.4595 6.11846 17.6705 6.32944C17.8815 6.54041 18 6.82656 18 7.12493Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  KeyIcon.displayName = "KeyIcon";
  var LinkIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M22.5 8.27158C22.4624 9.5772 21.9255 10.8187 21 11.7403L17.7422 15C17.2677 15.4771 16.7033 15.8553 16.0817 16.1128C15.46 16.3703 14.7935 16.5019 14.1206 16.5H14.1159C13.4316 16.4995 12.7543 16.3619 12.124 16.0953C11.4938 15.8286 10.9233 15.4384 10.4464 14.9476C9.96953 14.4568 9.59583 13.8754 9.34739 13.2377C9.09896 12.6001 8.98083 11.9191 9 11.235C9.00559 11.0361 9.08998 10.8476 9.23459 10.7109C9.37919 10.5742 9.57218 10.5005 9.77109 10.5061C9.97001 10.5117 10.1585 10.5961 10.2952 10.7407C10.4319 10.8853 10.5056 11.0783 10.5 11.2772C10.4863 11.7609 10.5698 12.2424 10.7454 12.6933C10.921 13.1442 11.1852 13.5553 11.5223 13.9023C11.8595 14.2494 12.2628 14.5253 12.7085 14.7139C13.1541 14.9024 13.633 14.9997 14.1169 15C14.5925 15.0012 15.0637 14.9082 15.5032 14.7262C15.9426 14.5442 16.3417 14.2769 16.6772 13.9397L19.935 10.6819C20.6072 10.0013 20.9827 9.08238 20.9797 8.12581C20.9767 7.16924 20.5954 6.25271 19.919 5.57631C19.2426 4.89991 18.3261 4.51859 17.3695 4.5156C16.413 4.5126 15.4941 4.88818 14.8134 5.56033L13.7822 6.59158C13.6404 6.7263 13.4516 6.80029 13.256 6.79779C13.0604 6.79528 12.8736 6.71648 12.7353 6.57818C12.597 6.43988 12.5182 6.25302 12.5157 6.05745C12.5132 5.86188 12.5872 5.67307 12.7219 5.53127L13.7531 4.50002C14.2289 4.02408 14.7938 3.64653 15.4155 3.38895C16.0372 3.13136 16.7036 2.99878 17.3766 2.99878C18.0495 2.99878 18.7159 3.13136 19.3376 3.38895C19.9593 3.64653 20.5242 4.02408 21 4.50002C21.4928 4.99404 21.8799 5.58318 22.1378 6.23157C22.3957 6.87996 22.5189 7.57405 22.5 8.27158ZM10.2188 17.4056L9.1875 18.4369C8.85115 18.7755 8.45084 19.0438 8.00986 19.2263C7.56887 19.4089 7.09601 19.5019 6.61875 19.5C5.90278 19.4994 5.20305 19.2867 4.60797 18.8886C4.01288 18.4905 3.54915 17.9249 3.27536 17.2634C3.00157 16.6018 2.93001 15.874 3.06972 15.1718C3.20944 14.4695 3.55415 13.8245 4.06031 13.3181L7.3125 10.0603C7.82474 9.54539 8.47998 9.19637 9.19312 9.0586C9.90626 8.92083 10.6443 9.00068 11.3115 9.28777C11.9787 9.57486 12.5442 10.0559 12.9344 10.6685C13.3247 11.2811 13.5217 11.9968 13.5 12.7228C13.4944 12.9217 13.5681 13.1147 13.7048 13.2593C13.8415 13.4039 14.03 13.4883 14.2289 13.4939C14.4278 13.4995 14.6208 13.4259 14.7654 13.2892C14.91 13.1525 14.9944 12.9639 15 12.765C15.018 12.0686 14.8943 11.3757 14.6365 10.7285C14.3786 10.0813 13.992 9.49327 13.5 9.00002C12.5392 8.03967 11.2364 7.50019 9.87797 7.50019C8.51953 7.50019 7.21671 8.03967 6.25594 9.00002L3 12.2578C2.28397 12.9736 1.79617 13.8855 1.59826 14.8784C1.40035 15.8713 1.5012 16.9006 1.88808 17.8361C2.27496 18.7717 2.93049 19.5716 3.77184 20.1348C4.61318 20.6979 5.60258 20.999 6.615 21C7.288 21.002 7.95471 20.8704 8.57651 20.6129C9.19832 20.3554 9.76288 19.9772 10.2375 19.5L11.2688 18.4688C11.3901 18.3258 11.4535 18.1426 11.4465 17.9551C11.4394 17.7677 11.3624 17.5898 11.2306 17.4563C11.0988 17.3229 10.9218 17.2437 10.7345 17.2343C10.5472 17.2249 10.3632 17.2861 10.2188 17.4056Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  LinkIcon.displayName = "LinkIcon";
  var LinkSimple = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props, "LinkSimple");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M15.5306 8.46927C15.6004 8.53892 15.6557 8.62164 15.6934 8.71269C15.7312 8.80373 15.7506 8.90133 15.7506 8.99989C15.7506 9.09845 15.7312 9.19605 15.6934 9.2871C15.6557 9.37814 15.6004 9.46086 15.5306 9.53052L9.53065 15.5305C9.46097 15.6002 9.37824 15.6555 9.2872 15.6932C9.19615 15.7309 9.09857 15.7503 9.00002 15.7503C8.90148 15.7503 8.8039 15.7309 8.71285 15.6932C8.62181 15.6555 8.53908 15.6002 8.4694 15.5305C8.39972 15.4608 8.34444 15.3781 8.30673 15.2871C8.26902 15.196 8.24961 15.0984 8.24961 14.9999C8.24961 14.9013 8.26902 14.8038 8.30673 14.7127C8.34444 14.6217 8.39972 14.5389 8.4694 14.4693L14.4694 8.46927C14.5391 8.39953 14.6218 8.34421 14.7128 8.30647C14.8039 8.26873 14.9015 8.2493 15 8.2493C15.0986 8.2493 15.1962 8.26873 15.2872 8.30647C15.3783 8.34421 15.461 8.39953 15.5306 8.46927ZM20.2125 3.78739C19.725 3.29983 19.1462 2.91307 18.5092 2.6492C17.8722 2.38532 17.1895 2.24951 16.5 2.24951C15.8105 2.24951 15.1278 2.38532 14.4908 2.6492C13.8538 2.91307 13.275 3.29983 12.7875 3.78739L9.9694 6.60458C9.82867 6.74531 9.74961 6.93618 9.74961 7.1352C9.74961 7.33423 9.82867 7.5251 9.9694 7.66583C10.1101 7.80656 10.301 7.88562 10.5 7.88562C10.699 7.88562 10.8899 7.80656 11.0306 7.66583L13.8488 4.85333C14.5546 4.163 15.5042 3.77887 16.4915 3.78431C17.4787 3.78975 18.4241 4.18431 19.1222 4.88237C19.8204 5.58043 20.2151 6.52566 20.2208 7.51294C20.2264 8.50022 19.8424 9.44988 19.1522 10.1558L16.3331 12.974C16.1924 13.1146 16.1133 13.3053 16.1132 13.5042C16.1131 13.7032 16.1921 13.894 16.3327 14.0347C16.4733 14.1755 16.664 14.2546 16.863 14.2547C17.0619 14.2548 17.2527 14.1758 17.3935 14.0352L20.2125 11.2124C20.7001 10.7249 21.0868 10.1461 21.3507 9.5091C21.6146 8.87211 21.7504 8.18938 21.7504 7.49989C21.7504 6.81041 21.6146 6.12767 21.3507 5.49068C21.0868 4.85368 20.7001 4.27491 20.2125 3.78739ZM12.9694 16.333L10.1513 19.1511C9.80447 19.5057 9.39077 19.788 8.93413 19.9816C8.47749 20.1752 7.98698 20.2763 7.491 20.279C6.99502 20.2818 6.50342 20.1861 6.04468 19.9975C5.58593 19.809 5.16915 19.5313 4.81846 19.1805C4.46778 18.8298 4.19015 18.4129 4.00167 17.9542C3.81319 17.4954 3.71759 17.0038 3.72041 16.5078C3.72323 16.0118 3.82441 15.5213 4.01809 15.0647C4.21178 14.6081 4.49412 14.1944 4.84877 13.8477L7.66596 11.0305C7.80669 10.8898 7.88575 10.6989 7.88575 10.4999C7.88575 10.3009 7.80669 10.11 7.66596 9.96927C7.52523 9.82854 7.33436 9.74947 7.13534 9.74947C6.93631 9.74947 6.74544 9.82854 6.60471 9.96927L3.78752 12.7874C2.80291 13.772 2.24976 15.1074 2.24976 16.4999C2.24976 17.8923 2.80291 19.2278 3.78752 20.2124C4.77214 21.197 6.10757 21.7502 7.50002 21.7502C8.89248 21.7502 10.2279 21.197 11.2125 20.2124L14.0306 17.3933C14.1713 17.2526 14.2502 17.0618 14.2501 16.8628C14.25 16.6639 14.1709 16.4732 14.0302 16.3325C13.8894 16.1919 13.6986 16.113 13.4997 16.1131C13.3008 16.1132 13.11 16.1923 12.9694 16.333Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  LinkSimple.displayName = "LinkSimple";
  var LockSimple = React.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M19.5 7.5H16.5V5.25C16.5 4.05653 16.0259 2.91193 15.182 2.06802C14.3381 1.22411 13.1935 0.75 12 0.75C10.8065 0.75 9.66193 1.22411 8.81802 2.06802C7.97411 2.91193 7.5 4.05653 7.5 5.25V7.5H4.5C4.10218 7.5 3.72064 7.65804 3.43934 7.93934C3.15804 8.22064 3 8.60218 3 9V19.5C3 19.8978 3.15804 20.2794 3.43934 20.5607C3.72064 20.842 4.10218 21 4.5 21H19.5C19.8978 21 20.2794 20.842 20.5607 20.5607C20.842 20.2794 21 19.8978 21 19.5V9C21 8.60218 20.842 8.22064 20.5607 7.93934C20.2794 7.65804 19.8978 7.5 19.5 7.5ZM9 5.25C9 4.45435 9.31607 3.69129 9.87868 3.12868C10.4413 2.56607 11.2044 2.25 12 2.25C12.7956 2.25 13.5587 2.56607 14.1213 3.12868C14.6839 3.69129 15 4.45435 15 5.25V7.5H9V5.25ZM19.5 19.5H4.5V9H19.5V19.5Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  LockSimple.displayName = "LockSimple";
  var Logo$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 32 32",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M19.1988 4.61268C19.1988 2.61447 17.8296 0.936016 15.9781 0.464416C16.6069 0.157861 17.2975 -0.000988396 17.9971 4.62724e-06C20.5446 4.62724e-06 22.6098 2.06519 22.6098 4.61268C22.6098 7.16017 20.5446 9.22536 17.9971 9.22536C17.2975 9.22635 16.6069 9.06751 15.9781 8.76095C17.8294 8.28935 19.1988 6.61089 19.1988 4.61268Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint0_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M19.1988 4.61268C19.1988 2.61447 17.8296 0.936016 15.9781 0.464416C16.6069 0.157861 17.2975 -0.000988396 17.9971 4.62724e-06C20.5446 4.62724e-06 22.6098 2.06519 22.6098 4.61268C22.6098 7.16017 20.5446 9.22536 17.9971 9.22536C17.2975 9.22635 16.6069 9.06751 15.9781 8.76095C17.8294 8.28935 19.1988 6.61089 19.1988 4.61268Z",
              "data-figma-gradient-fill": '{"type":"GRADIENT_ANGULAR","stops":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"stopsVar":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"transform":{"m00":22.266670227050781,"m01":-23.733333587646484,"m02":16.733337402343750,"m10":23.733339309692383,"m11":22.266677856445312,"m12":-7.0000061988830566},"opacity":1.0,"blendMode":"NORMAL","visible":true}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M13.0767 4.53889C12.077 2.8084 10.0524 2.03956 8.21323 2.55673C8.60453 1.97683 9.12316 1.49399 9.72951 1.14507C11.9357 -0.128032 14.7568 0.62716 16.0306 2.83349C17.3045 5.03983 16.5483 7.86076 14.3422 9.13441C13.7368 9.48509 13.0594 9.69283 12.3615 9.74181C13.7291 8.40763 14.0758 6.26938 13.0767 4.53889Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint1_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M13.0767 4.53889C12.077 2.8084 10.0524 2.03956 8.21323 2.55673C8.60453 1.97683 9.12316 1.49399 9.72951 1.14507C11.9357 -0.128032 14.7568 0.62716 16.0306 2.83349C17.3045 5.03983 16.5483 7.86076 14.3422 9.13441C13.7368 9.48509 13.0594 9.69283 12.3615 9.74181C13.7291 8.40763 14.0758 6.26938 13.0767 4.53889Z",
              "data-figma-gradient-fill": '{"type":"GRADIENT_ANGULAR","stops":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"stopsVar":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"transform":{"m00":22.266670227050781,"m01":-23.733333587646484,"m02":16.733337402343750,"m10":23.733339309692383,"m11":22.266677856445312,"m12":-7.0000061988830566},"opacity":1.0,"blendMode":"NORMAL","visible":true}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.73768 7.53658C6.007 6.53729 3.86893 6.88398 2.53458 8.25173C2.58352 7.55379 2.79127 6.87627 3.14197 6.27086C4.41507 4.06471 7.23674 3.30879 9.44289 4.58262C11.649 5.85646 12.405 8.67739 11.1313 10.8835C10.7823 11.4899 10.2994 12.0085 9.71947 12.3998C10.237 10.5603 9.46817 8.53532 7.73768 7.53658Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint2_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.73768 7.53658C6.007 6.53729 3.86893 6.88398 2.53458 8.25173C2.58352 7.55379 2.79127 6.87627 3.14197 6.27086C4.41507 4.06471 7.23674 3.30879 9.44289 4.58262C11.649 5.85646 12.405 8.67739 11.1313 10.8835C10.7823 11.4899 10.2994 12.0085 9.71947 12.3998C10.237 10.5603 9.46817 8.53532 7.73768 7.53658Z",
              "data-figma-gradient-fill": '{"type":"GRADIENT_ANGULAR","stops":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"stopsVar":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"transform":{"m00":22.266670227050781,"m01":-23.733333587646484,"m02":16.733337402343750,"m10":23.733339309692383,"m11":22.266677856445312,"m12":-7.0000061988830566},"opacity":1.0,"blendMode":"NORMAL","visible":true}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4.61268 12.8013C2.61429 12.8013 0.93601 14.1705 0.464409 16.0221C0.157854 15.3932 -0.000988397 14.7026 4.62746e-06 14.003C4.62746e-06 11.4555 2.06519 9.39035 4.61268 9.39035C7.16018 9.39035 9.22536 11.4555 9.22536 14.003C9.22627 14.7026 9.06743 15.3932 8.76096 16.0221C8.28936 14.1705 6.6109 12.8013 4.61268 12.8013Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint3_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4.61268 12.8013C2.61429 12.8013 0.93601 14.1705 0.464409 16.0221C0.157854 15.3932 -0.000988397 14.7026 4.62746e-06 14.003C4.62746e-06 11.4555 2.06519 9.39035 4.61268 9.39035C7.16018 9.39035 9.22536 11.4555 9.22536 14.003C9.22627 14.7026 9.06743 15.3932 8.76096 16.0221C8.28936 14.1705 6.6109 12.8013 4.61268 12.8013Z",
              "data-figma-gradient-fill": '{"type":"GRADIENT_ANGULAR","stops":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"stopsVar":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"transform":{"m00":22.266670227050781,"m01":-23.733333587646484,"m02":16.733337402343750,"m10":23.733339309692383,"m11":22.266677856445312,"m12":-7.0000061988830566},"opacity":1.0,"blendMode":"NORMAL","visible":true}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4.5389 18.9234C2.80823 19.9225 2.03975 21.9477 2.55637 23.7869C1.97647 23.3956 1.49363 22.8769 1.14471 22.2706C-0.128761 20.0646 0.627165 17.2433 2.83313 15.9695C5.0391 14.6956 7.8604 15.4516 9.13405 17.6579C9.48473 18.2633 9.69248 18.9407 9.74145 19.6386C8.40765 18.271 6.2694 17.9243 4.5389 18.9234Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint4_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4.5389 18.9234C2.80823 19.9225 2.03975 21.9477 2.55637 23.7869C1.97647 23.3956 1.49363 22.8769 1.14471 22.2706C-0.128761 20.0646 0.627165 17.2433 2.83313 15.9695C5.0391 14.6956 7.8604 15.4516 9.13405 17.6579C9.48473 18.2633 9.69248 18.9407 9.74145 19.6386C8.40765 18.271 6.2694 17.9243 4.5389 18.9234Z",
              "data-figma-gradient-fill": '{"type":"GRADIENT_ANGULAR","stops":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"stopsVar":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"transform":{"m00":22.266670227050781,"m01":-23.733333587646484,"m02":16.733337402343750,"m10":23.733339309692383,"m11":22.266677856445312,"m12":-7.0000061988830566},"opacity":1.0,"blendMode":"NORMAL","visible":true}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.53607 24.2623C6.53697 25.993 6.88365 28.131 8.25122 29.4654C7.55335 29.4164 6.87589 29.2087 6.27054 28.858C4.06438 27.5849 3.30846 24.7632 4.58211 22.5571C5.85576 20.3509 8.67706 19.595 10.8832 20.8687C11.4896 21.2176 12.0082 21.7004 12.3995 22.2803C10.5603 21.763 8.53536 22.5318 7.53607 24.2623Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint5_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.8011 27.3873C12.8011 29.3857 14.1705 31.064 16.022 31.5356C15.3932 31.8421 14.7026 32.001 14.003 32C11.4555 32 9.3903 29.9348 9.3903 27.3873C9.3903 24.8398 11.4555 22.7747 14.003 22.7747C14.7026 22.7738 15.3931 22.9326 16.022 23.2391C14.1705 23.7107 12.8011 25.3891 12.8011 27.3873Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint6_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M18.9234 27.4611C19.9225 29.1916 21.9476 29.9604 23.7868 29.4433C23.3955 30.0231 22.8768 30.506 22.2705 30.8549C20.0642 32.128 17.2433 31.3728 15.9694 29.1665C14.6956 26.9602 15.4515 24.1392 17.6579 22.8656C18.2632 22.5149 18.9407 22.3072 19.6385 22.2582C18.271 23.5924 17.9243 25.7306 18.9234 27.4611Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint7_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M24.2624 24.464C25.9929 25.4631 28.1311 25.1164 29.4655 23.7486C29.4164 24.4464 29.2086 25.1237 28.8579 25.729C27.5848 27.9351 24.7631 28.691 22.557 27.4174C20.3508 26.1437 19.5947 23.323 20.8686 21.1163C21.2175 20.5099 21.7003 19.9913 22.2802 19.6C21.7636 21.4397 22.5319 23.4647 24.2624 24.464Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint8_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M27.3873 19.1987C29.3855 19.1987 31.064 17.8295 31.5356 15.9779C31.8421 16.6068 32.001 17.2974 32 17.997C32 20.5445 29.9348 22.6097 27.3873 22.6097C24.8398 22.6097 22.7746 20.5445 22.7746 17.997C22.7738 17.2974 22.9328 16.6068 23.2396 15.9779C23.7106 17.8295 25.3891 19.1987 27.3873 19.1987Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint9_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M27.4611 13.0766C29.1916 12.0775 29.9605 10.0523 29.4431 8.21315C30.0231 8.60449 30.5059 9.1231 30.855 9.72943C32.1281 11.9358 31.3729 14.7567 29.1665 16.0305C26.9602 17.3044 24.1393 16.5484 22.8656 14.3421C22.515 13.7368 22.3072 13.0593 22.2582 12.3614C23.5924 13.729 25.7305 14.0757 27.4611 13.0766Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint10_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M24.4638 7.73767C25.4631 6.00718 25.1164 3.86893 23.7487 2.53458C24.4469 2.58344 25.1248 2.79126 25.7305 3.14216C27.9366 4.41526 28.6925 7.23692 27.4187 9.44307C26.1449 11.6492 23.3239 12.4053 21.1178 11.1315C20.5114 10.7825 19.9927 10.2997 19.6013 9.71984C21.4397 10.237 23.4647 9.46816 24.4638 7.73767Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint11_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint0_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.1988 4.61268C19.1988 2.61447 17.8296 0.936016 15.9781 0.464416C16.6069 0.157861 17.2975 -0.000988396 17.9971 4.62724e-06C20.5446 4.62724e-06 22.6098 2.06519 22.6098 4.61268C22.6098 7.16017 20.5446 9.22536 17.9971 9.22536C17.2975 9.22635 16.6069 9.06751 15.9781 8.76095C17.8294 8.28935 19.1988 6.61089 19.1988 4.61268Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint1_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.0767 4.53889C12.077 2.8084 10.0524 2.03956 8.21323 2.55673C8.60453 1.97683 9.12316 1.49399 9.72951 1.14507C11.9357 -0.128032 14.7568 0.62716 16.0306 2.83349C17.3045 5.03983 16.5483 7.86076 14.3422 9.13441C13.7368 9.48509 13.0594 9.69283 12.3615 9.74181C13.7291 8.40763 14.0758 6.26938 13.0767 4.53889Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint2_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.73768 7.53658C6.007 6.53729 3.86893 6.88398 2.53458 8.25173C2.58352 7.55379 2.79127 6.87627 3.14197 6.27086C4.41507 4.06471 7.23674 3.30879 9.44289 4.58262C11.649 5.85646 12.405 8.67739 11.1313 10.8835C10.7823 11.4899 10.2994 12.0085 9.71947 12.3998C10.237 10.5603 9.46817 8.53532 7.73768 7.53658Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint3_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4.61268 12.8013C2.61429 12.8013 0.93601 14.1705 0.464409 16.0221C0.157854 15.3932 -0.000988397 14.7026 4.62746e-06 14.003C4.62746e-06 11.4555 2.06519 9.39035 4.61268 9.39035C7.16018 9.39035 9.22536 11.4555 9.22536 14.003C9.22627 14.7026 9.06743 15.3932 8.76096 16.0221C8.28936 14.1705 6.6109 12.8013 4.61268 12.8013Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint4_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4.5389 18.9234C2.80823 19.9225 2.03975 21.9477 2.55637 23.7869C1.97647 23.3956 1.49363 22.8769 1.14471 22.2706C-0.128761 20.0646 0.627165 17.2433 2.83313 15.9695C5.0391 14.6956 7.8604 15.4516 9.13405 17.6579C9.48473 18.2633 9.69248 18.9407 9.74145 19.6386C8.40765 18.271 6.2694 17.9243 4.5389 18.9234Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint5_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.53607 24.2623C6.53697 25.993 6.88365 28.131 8.25122 29.4654C7.55335 29.4164 6.87589 29.2087 6.27054 28.858C4.06438 27.5849 3.30846 24.7632 4.58211 22.5571C5.85576 20.3509 8.67706 19.595 10.8832 20.8687C11.4896 21.2176 12.0082 21.7004 12.3995 22.2803C10.5603 21.763 8.53536 22.5318 7.53607 24.2623Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint6_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.8011 27.3873C12.8011 29.3857 14.1705 31.064 16.022 31.5356C15.3932 31.8421 14.7026 32.001 14.003 32C11.4555 32 9.3903 29.9348 9.3903 27.3873C9.3903 24.8398 11.4555 22.7747 14.003 22.7747C14.7026 22.7738 15.3931 22.9326 16.022 23.2391C14.1705 23.7107 12.8011 25.3891 12.8011 27.3873Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint7_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18.9234 27.4611C19.9225 29.1916 21.9476 29.9604 23.7868 29.4433C23.3955 30.0231 22.8768 30.506 22.2705 30.8549C20.0642 32.128 17.2433 31.3728 15.9694 29.1665C14.6956 26.9602 15.4515 24.1392 17.6579 22.8656C18.2632 22.5149 18.9407 22.3072 19.6385 22.2582C18.271 23.5924 17.9243 25.7306 18.9234 27.4611Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint8_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.2624 24.464C25.9929 25.4631 28.1311 25.1164 29.4655 23.7486C29.4164 24.4464 29.2086 25.1237 28.8579 25.729C27.5848 27.9351 24.7631 28.691 22.557 27.4174C20.3508 26.1437 19.5947 23.323 20.8686 21.1163C21.2175 20.5099 21.7003 19.9913 22.2802 19.6C21.7636 21.4397 22.5319 23.4647 24.2624 24.464Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint9_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M27.3873 19.1987C29.3855 19.1987 31.064 17.8295 31.5356 15.9779C31.8421 16.6068 32.001 17.2974 32 17.997C32 20.5445 29.9348 22.6097 27.3873 22.6097C24.8398 22.6097 22.7746 20.5445 22.7746 17.997C22.7738 17.2974 22.9328 16.6068 23.2396 15.9779C23.7106 17.8295 25.3891 19.1987 27.3873 19.1987Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint10_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M27.4611 13.0766C29.1916 12.0775 29.9605 10.0523 29.4431 8.21315C30.0231 8.60449 30.5059 9.1231 30.855 9.72943C32.1281 11.9358 31.3729 14.7567 29.1665 16.0305C26.9602 17.3044 24.1393 16.5484 22.8656 14.3421C22.515 13.7368 22.3072 13.0593 22.2582 12.3614C23.5924 13.729 25.7305 14.0757 27.4611 13.0766Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint11_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.4638 7.73767C25.4631 6.00718 25.1164 3.86893 23.7487 2.53458C24.4469 2.58344 25.1248 2.79126 25.7305 3.14216C27.9366 4.41526 28.6925 7.23692 27.4187 9.44307C26.1449 11.6492 23.3239 12.4053 21.1178 11.1315C20.5114 10.7825 19.9927 10.2997 19.6013 9.71984C21.4397 10.237 23.4647 9.46816 24.4638 7.73767Z" }) })
          ] })
        ]
      }
    )
  );
  Logo$1.displayName = "Logo";
  var MagnifyingGlass = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.5306 20.4693L16.8365 15.7762C18.1971 14.1428 18.8755 12.0478 18.7307 9.92691C18.5859 7.80604 17.629 5.82265 16.0591 4.38932C14.4892 2.95599 12.4271 2.18308 10.3019 2.23138C8.17663 2.27968 6.15181 3.14547 4.64864 4.64864C3.14547 6.15181 2.27968 8.17663 2.23138 10.3019C2.18308 12.4271 2.95599 14.4892 4.38932 16.0591C5.82265 17.629 7.80604 18.5859 9.92691 18.7307C12.0478 18.8755 14.1428 18.1971 15.7762 16.8365L20.4693 21.5306C20.539 21.6003 20.6218 21.6556 20.7128 21.6933C20.8038 21.731 20.9014 21.7504 21 21.7504C21.0985 21.7504 21.1961 21.731 21.2871 21.6933C21.3782 21.6556 21.4609 21.6003 21.5306 21.5306C21.6003 21.4609 21.6556 21.3782 21.6933 21.2871C21.731 21.1961 21.7504 21.0985 21.7504 21C21.7504 20.9014 21.731 20.8038 21.6933 20.7128C21.6556 20.6218 21.6003 20.539 21.5306 20.4693ZM3.74997 10.5C3.74997 9.16495 4.14585 7.8599 4.88755 6.74987C5.62925 5.63984 6.68346 4.77467 7.91686 4.26378C9.15026 3.75289 10.5075 3.61922 11.8168 3.87967C13.1262 4.14012 14.3289 4.78299 15.2729 5.727C16.2169 6.671 16.8598 7.87374 17.1203 9.18311C17.3807 10.4925 17.2471 11.8497 16.7362 13.0831C16.2253 14.3165 15.3601 15.3707 14.2501 16.1124C13.14 16.8541 11.835 17.25 10.5 17.25C8.71037 17.248 6.99463 16.5362 5.72919 15.2708C4.46375 14.0053 3.75196 12.2896 3.74997 10.5Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  MagnifyingGlass.displayName = "MagnifyingGlass";
  var MapPin$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 6C11.2583 6 10.5333 6.21993 9.91661 6.63199C9.29993 7.04404 8.81928 7.62971 8.53545 8.31494C8.25162 9.00016 8.17736 9.75416 8.32205 10.4816C8.46675 11.209 8.8239 11.8772 9.34835 12.4017C9.8728 12.9261 10.541 13.2833 11.2684 13.4279C11.9958 13.5726 12.7498 13.4984 13.4351 13.2145C14.1203 12.9307 14.706 12.4501 15.118 11.8334C15.5301 11.2167 15.75 10.4917 15.75 9.75C15.75 8.75544 15.3549 7.80161 14.6517 7.09835C13.9484 6.39509 12.9946 6 12 6ZM12 12C11.555 12 11.12 11.868 10.75 11.6208C10.38 11.3736 10.0916 11.0222 9.92127 10.611C9.75097 10.1999 9.70642 9.7475 9.79323 9.31105C9.88005 8.87459 10.0943 8.47368 10.409 8.15901C10.7237 7.84434 11.1246 7.63005 11.561 7.54323C11.9975 7.45642 12.4499 7.50097 12.861 7.67127C13.2722 7.84157 13.6236 8.12996 13.8708 8.49997C14.118 8.86998 14.25 9.30499 14.25 9.75C14.25 10.3467 14.0129 10.919 13.591 11.341C13.169 11.7629 12.5967 12 12 12ZM12 1.5C9.81273 1.50248 7.71575 2.37247 6.16911 3.91911C4.62247 5.46575 3.75248 7.56273 3.75 9.75C3.75 12.6938 5.11031 15.8138 7.6875 18.7734C8.84552 20.1108 10.1489 21.3151 11.5734 22.3641C11.6995 22.4524 11.8498 22.4998 12.0037 22.4998C12.1577 22.4998 12.308 22.4524 12.4341 22.3641C13.856 21.3147 15.1568 20.1104 16.3125 18.7734C18.8859 15.8138 20.25 12.6938 20.25 9.75C20.2475 7.56273 19.3775 5.46575 17.8309 3.91911C16.2843 2.37247 14.1873 1.50248 12 1.5ZM12 20.8125C10.4503 19.5938 5.25 15.1172 5.25 9.75C5.25 7.95979 5.96116 6.2429 7.22703 4.97703C8.4929 3.71116 10.2098 3 12 3C13.7902 3 15.5071 3.71116 16.773 4.97703C18.0388 6.2429 18.75 7.95979 18.75 9.75C18.75 15.1153 13.5497 19.5938 12 20.8125Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  MapPin$1.displayName = "MapPin";
  var Microphone$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 16.5C13.1931 16.4988 14.337 16.0243 15.1806 15.1806C16.0243 14.337 16.4988 13.1931 16.5 12V6C16.5 4.80653 16.0259 3.66193 15.182 2.81802C14.3381 1.97411 13.1935 1.5 12 1.5C10.8065 1.5 9.66193 1.97411 8.81802 2.81802C7.97411 3.66193 7.5 4.80653 7.5 6V12C7.50124 13.1931 7.97575 14.337 8.81939 15.1806C9.66303 16.0243 10.8069 16.4988 12 16.5ZM9 6C9 5.20435 9.31607 4.44129 9.87868 3.87868C10.4413 3.31607 11.2044 3 12 3C12.7956 3 13.5587 3.31607 14.1213 3.87868C14.6839 4.44129 15 5.20435 15 6V12C15 12.7956 14.6839 13.5587 14.1213 14.1213C13.5587 14.6839 12.7956 15 12 15C11.2044 15 10.4413 14.6839 9.87868 14.1213C9.31607 13.5587 9 12.7956 9 12V6ZM12.75 19.4625V22.5C12.75 22.6989 12.671 22.8897 12.5303 23.0303C12.3897 23.171 12.1989 23.25 12 23.25C11.8011 23.25 11.6103 23.171 11.4697 23.0303C11.329 22.8897 11.25 22.6989 11.25 22.5V19.4625C9.40091 19.2743 7.68728 18.4072 6.44048 17.0288C5.19368 15.6504 4.50228 13.8586 4.5 12C4.5 11.8011 4.57902 11.6103 4.71967 11.4697C4.86032 11.329 5.05109 11.25 5.25 11.25C5.44891 11.25 5.63968 11.329 5.78033 11.4697C5.92098 11.6103 6 11.8011 6 12C6 13.5913 6.63214 15.1174 7.75736 16.2426C8.88258 17.3679 10.4087 18 12 18C13.5913 18 15.1174 17.3679 16.2426 16.2426C17.3679 15.1174 18 13.5913 18 12C18 11.8011 18.079 11.6103 18.2197 11.4697C18.3603 11.329 18.5511 11.25 18.75 11.25C18.9489 11.25 19.1397 11.329 19.2803 11.4697C19.421 11.6103 19.5 11.8011 19.5 12C19.4977 13.8586 18.8063 15.6504 17.5595 17.0288C16.3127 18.4072 14.5991 19.2743 12.75 19.4625Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Microphone$1.displayName = "Microphone";
  var Minus = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21 12C21 12.1989 20.921 12.3897 20.7803 12.5303C20.6397 12.671 20.4489 12.75 20.25 12.75H3.75C3.55109 12.75 3.36032 12.671 3.21967 12.5303C3.07902 12.3897 3 12.1989 3 12C3 11.8011 3.07902 11.6103 3.21967 11.4697C3.36032 11.329 3.55109 11.25 3.75 11.25H20.25C20.4489 11.25 20.6397 11.329 20.7803 11.4697C20.921 11.6103 21 11.8011 21 12Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Minus.displayName = "Minus";
  var MinusCircleIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M16.5 12C16.5 12.1989 16.421 12.3897 16.2803 12.5303C16.1397 12.671 15.9489 12.75 15.75 12.75H8.25C8.05109 12.75 7.86033 12.671 7.71967 12.5303C7.57902 12.3897 7.5 12.1989 7.5 12C7.5 11.8011 7.57902 11.6103 7.71967 11.4697C7.86033 11.329 8.05109 11.25 8.25 11.25H15.75C15.9489 11.25 16.1397 11.329 16.2803 11.4697C16.421 11.6103 16.5 11.8011 16.5 12ZM21.75 12C21.75 13.9284 21.1782 15.8134 20.1068 17.4168C19.0355 19.0202 17.5127 20.2699 15.7312 21.0078C13.9496 21.7458 11.9892 21.9389 10.0979 21.5627C8.20656 21.1865 6.46928 20.2579 5.10571 18.8943C3.74215 17.5307 2.81355 15.7934 2.43735 13.9021C2.06114 12.0108 2.25422 10.0504 2.99218 8.26884C3.73013 6.48726 4.97982 4.96451 6.58319 3.89317C8.18657 2.82183 10.0716 2.25 12 2.25C14.585 2.25273 17.0634 3.28084 18.8913 5.10872C20.7192 6.93661 21.7473 9.41498 21.75 12ZM20.25 12C20.25 10.3683 19.7661 8.77325 18.8596 7.41655C17.9531 6.05984 16.6646 5.00242 15.1571 4.37799C13.6497 3.75357 11.9909 3.59019 10.3905 3.90852C8.79017 4.22685 7.32016 5.01259 6.16637 6.16637C5.01259 7.32015 4.22685 8.79016 3.90853 10.3905C3.5902 11.9908 3.75358 13.6496 4.378 15.1571C5.00242 16.6646 6.05984 17.9531 7.41655 18.8596C8.77326 19.7661 10.3683 20.25 12 20.25C14.1873 20.2475 16.2843 19.3775 17.8309 17.8309C19.3775 16.2843 20.2475 14.1873 20.25 12Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  MinusCircleIcon.displayName = "MinusCircleIcon";
  var PackageIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.97 6.20146L12.72 1.68739C12.4996 1.5656 12.2518 1.50171 12 1.50171C11.7482 1.50171 11.5004 1.5656 11.28 1.68739L3.03 6.20333C2.7944 6.33224 2.59772 6.52205 2.46052 6.75292C2.32331 6.98379 2.25061 7.24727 2.25 7.51583V16.4821C2.25061 16.7506 2.32331 17.0141 2.46052 17.245C2.59772 17.4759 2.7944 17.6657 3.03 17.7946L11.28 22.3105C11.5004 22.4323 11.7482 22.4962 12 22.4962C12.2518 22.4962 12.4996 22.4323 12.72 22.3105L20.97 17.7946C21.2056 17.6657 21.4023 17.4759 21.5395 17.245C21.6767 17.0141 21.7494 16.7506 21.75 16.4821V7.51677C21.7499 7.24773 21.6774 6.98366 21.5402 6.75225C21.403 6.52084 21.206 6.3306 20.97 6.20146ZM12 2.99989L19.5319 7.12489L16.7409 8.65302L9.20813 4.52802L12 2.99989ZM12 11.2499L4.46812 7.12489L7.64625 5.38489L15.1781 9.5099L12 11.2499ZM3.75 8.4374L11.25 12.5418V20.5846L3.75 16.483V8.4374ZM20.25 16.4793L12.75 20.5846V12.5455L15.75 10.904V14.2499C15.75 14.4488 15.829 14.6396 15.9697 14.7802C16.1103 14.9209 16.3011 14.9999 16.5 14.9999C16.6989 14.9999 16.8897 14.9209 17.0303 14.7802C17.171 14.6396 17.25 14.4488 17.25 14.2499V10.0827L20.25 8.4374V16.4783V16.4793Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  PackageIcon.displayName = "PackageIcon";
  var Paperclip$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M19.6556 11.4694C19.7254 11.5391 19.7807 11.6218 19.8184 11.7128C19.8562 11.8039 19.8756 11.9015 19.8756 12C19.8756 12.0986 19.8562 12.1962 19.8184 12.2873C19.7807 12.3783 19.7254 12.461 19.6556 12.5307L11.9634 20.2182C10.9787 21.2028 9.64315 21.7559 8.2506 21.7558C6.85806 21.7557 5.52258 21.2024 4.53797 20.2177C3.55335 19.233 3.00025 17.8974 3.00034 16.5049C3.00042 15.1123 3.55369 13.7769 4.53843 12.7922L13.8441 3.34973C14.5471 2.64596 15.5009 2.25028 16.4957 2.24976C17.4904 2.24923 18.4447 2.64389 19.1484 3.34692C19.8522 4.04995 20.2479 5.00376 20.2484 5.99853C20.2489 6.99329 19.8543 7.94752 19.1512 8.6513L9.84375 18.0938C9.42106 18.5165 8.84777 18.754 8.25 18.754C7.65223 18.754 7.07894 18.5165 6.65625 18.0938C6.23356 17.6711 5.99609 17.0978 5.99609 16.5C5.99609 15.9023 6.23356 15.329 6.65625 14.9063L14.4656 6.97317C14.534 6.90019 14.6163 6.84164 14.7077 6.80095C14.7991 6.76026 14.8977 6.73827 14.9977 6.73625C15.0977 6.73424 15.1971 6.75225 15.2901 6.78923C15.383 6.82621 15.4676 6.8814 15.5389 6.95157C15.6102 7.02173 15.6667 7.10545 15.7052 7.19779C15.7436 7.29013 15.7632 7.38923 15.7628 7.48926C15.7624 7.58929 15.7419 7.68822 15.7027 7.78023C15.6635 7.87225 15.6063 7.95548 15.5344 8.02505L7.72406 15.9666C7.65413 16.036 7.59855 16.1185 7.56049 16.2093C7.52244 16.3002 7.50265 16.3976 7.50226 16.4961C7.50186 16.5946 7.52088 16.6922 7.55821 16.7834C7.59554 16.8746 7.65047 16.9575 7.71984 17.0274C7.78922 17.0973 7.87169 17.1529 7.96254 17.191C8.05339 17.229 8.15086 17.2488 8.24936 17.2492C8.34786 17.2496 8.44548 17.2306 8.53663 17.1932C8.62778 17.1559 8.71069 17.101 8.78062 17.0316L18.0872 7.5938C18.5099 7.17198 18.7477 6.59952 18.7483 6.00237C18.7489 5.40521 18.5123 4.83227 18.0905 4.40958C17.6686 3.98689 17.0962 3.74908 16.499 3.74846C15.9019 3.74785 15.3289 3.98448 14.9062 4.4063L5.6025 13.845C5.25396 14.193 4.97738 14.6063 4.78854 15.0611C4.5997 15.516 4.5023 16.0036 4.50191 16.4961C4.50152 16.9886 4.59814 17.4764 4.78626 17.9316C4.97437 18.3868 5.2503 18.8004 5.59828 19.149C5.94626 19.4975 6.35949 19.7741 6.81436 19.9629C7.26923 20.1518 7.75684 20.2491 8.24936 20.2495C8.74187 20.2499 9.22964 20.1533 9.68481 19.9652C10.14 19.7771 10.5536 19.5012 10.9022 19.1532L18.5953 11.4657C18.7364 11.3256 18.9274 11.2473 19.1262 11.248C19.3251 11.2488 19.5155 11.3284 19.6556 11.4694Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Paperclip$1.displayName = "Paperclip";
  var PaperPlane = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M22.3031 18.7593L13.2984 3.01677C13.1679 2.7848 12.9781 2.59173 12.7483 2.45737C12.5186 2.32301 12.2572 2.2522 11.9911 2.2522C11.7249 2.2522 11.4636 2.32301 11.2338 2.45737C11.0041 2.59173 10.8142 2.7848 10.6837 3.01677L1.69405 18.7668C1.545 19.0326 1.48047 19.3376 1.50905 19.641C1.53764 19.9445 1.65798 20.232 1.85406 20.4653C2.05014 20.6987 2.31265 20.8667 2.60663 20.9472C2.90062 21.0276 3.21212 21.0166 3.49968 20.9155L12 18.0421L20.5003 20.9136C20.6609 20.9702 20.8298 20.9993 21 20.9999C21.262 20.999 21.5191 20.9296 21.7459 20.7984C21.9727 20.6673 22.1611 20.479 22.2926 20.2524C22.424 20.0258 22.4938 19.7687 22.4949 19.5067C22.4961 19.2448 22.4287 18.9871 22.2994 18.7593H22.3031ZM20.9859 19.4943L12.75 16.7118V11.2499C12.75 11.051 12.671 10.8602 12.5303 10.7196C12.3897 10.5789 12.1989 10.4999 12 10.4999C11.8011 10.4999 11.6103 10.5789 11.4697 10.7196C11.329 10.8602 11.25 11.051 11.25 11.2499V16.7118L3.01499 19.4943L2.99999 19.4999L11.9869 3.7499L21 19.4999L20.9859 19.4943Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  PaperPlane.displayName = "PaperPlane";
  var PaperPlaneTilt = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.3112 2.68876C21.1226 2.50025 20.8872 2.36544 20.6291 2.29821C20.3711 2.23098 20.0997 2.23376 19.8431 2.30626H19.8291L1.83469 7.76625C1.54256 7.85045 1.28291 8.02142 1.09014 8.25651C0.897378 8.49161 0.780601 8.77973 0.755286 9.08269C0.729972 9.38565 0.797314 9.68916 0.94839 9.95298C1.09947 10.2168 1.32714 10.4285 1.60125 10.56L9.5625 14.4375L13.4344 22.3941C13.5548 22.6511 13.7463 22.8682 13.9862 23.0199C14.226 23.1716 14.5043 23.2514 14.7881 23.25C14.8312 23.25 14.8744 23.2481 14.9175 23.2444C15.2202 23.2199 15.5082 23.1034 15.7428 22.9105C15.9774 22.7176 16.1474 22.4576 16.23 22.1653L21.6862 4.17094C21.6862 4.16626 21.6862 4.16157 21.6862 4.15688C21.7597 3.90091 21.7637 3.63 21.6978 3.37199C21.6319 3.11397 21.4984 2.87815 21.3112 2.68876ZM14.7966 21.7359L14.7919 21.7491V21.7425L11.0363 14.0269L15.5362 9.52688C15.671 9.38508 15.745 9.19627 15.7425 9.0007C15.7399 8.80513 15.6611 8.61827 15.5228 8.47997C15.3845 8.34167 15.1977 8.26287 15.0021 8.26036C14.8065 8.25786 14.6177 8.33185 14.4759 8.46657L9.97594 12.9666L2.2575 9.21094H2.25094H2.26406L20.25 3.75001L14.7966 21.7359Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  PaperPlaneTilt.displayName = "PaperPlaneTilt";
  var PencilSimple = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.3103 6.87842L17.1216 2.68873C16.9823 2.5494 16.8169 2.43888 16.6349 2.36348C16.4529 2.28808 16.2578 2.24927 16.0608 2.24927C15.8638 2.24927 15.6687 2.28808 15.4867 2.36348C15.3047 2.43888 15.1393 2.5494 15 2.68873L3.43969 14.25C3.2998 14.3888 3.18889 14.554 3.11341 14.736C3.03792 14.918 2.99938 15.1132 3.00001 15.3103V19.5C3.00001 19.8978 3.15804 20.2793 3.43935 20.5606C3.72065 20.8419 4.10218 21 4.50001 21H8.6897C8.88675 21.0006 9.08197 20.9621 9.26399 20.8866C9.44602 20.8111 9.61122 20.7002 9.75001 20.5603L21.3103 8.99998C21.4496 8.86069 21.5602 8.69531 21.6356 8.5133C21.711 8.33129 21.7498 8.13621 21.7498 7.9392C21.7498 7.74219 21.711 7.5471 21.6356 7.36509C21.5602 7.18308 21.4496 7.01771 21.3103 6.87842ZM8.6897 19.5H4.50001V15.3103L12.75 7.06029L16.9397 11.25L8.6897 19.5ZM18 10.1887L13.8103 5.99998L16.0603 3.74998L20.25 7.93873L18 10.1887Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  PencilSimple.displayName = "PencilSimple";
  var PlugsRegular = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M14.0306 12.9695C13.961 12.8997 13.8782 12.8444 13.7872 12.8067C13.6961 12.7689 13.5986 12.7495 13.5 12.7495C13.4014 12.7495 13.3038 12.7689 13.2128 12.8067C13.1217 12.8444 13.039 12.8997 12.9694 12.9695L11.25 14.6898L9.3103 12.7501L11.0306 11.0307C11.1713 10.89 11.2504 10.6991 11.2504 10.5001C11.2504 10.3011 11.1713 10.1102 11.0306 9.96948C10.8899 9.82875 10.699 9.74969 10.5 9.74969C10.301 9.74969 10.1101 9.82875 9.96936 9.96948L8.24999 11.6898L6.53061 9.96948C6.38988 9.82875 6.19901 9.74968 5.99999 9.74969C5.80097 9.74969 5.6101 9.82875 5.46936 9.96948C5.32863 10.1102 5.24957 10.3011 5.24957 10.5001C5.24957 10.6991 5.32863 10.89 5.46936 11.0307L6.06468 11.6251L3.87843 13.8104C3.59978 14.089 3.37874 14.4197 3.22793 14.7838C3.07713 15.1478 2.99951 15.538 2.99951 15.932C2.99951 16.326 3.07713 16.7162 3.22793 17.0802C3.37874 17.4442 3.59978 17.775 3.87843 18.0535L4.3828 18.557L1.71936 21.2195C1.64968 21.2892 1.59441 21.3719 1.55669 21.4629C1.51898 21.554 1.49957 21.6516 1.49957 21.7501C1.49957 21.8486 1.51898 21.9462 1.55669 22.0373C1.59441 22.1283 1.64968 22.211 1.71936 22.2807C1.8601 22.4215 2.05097 22.5005 2.24999 22.5005C2.34854 22.5005 2.44612 22.4811 2.53716 22.4434C2.62821 22.4057 2.71093 22.3504 2.78061 22.2807L5.44311 19.6173L5.94655 20.1217C6.22514 20.4003 6.55588 20.6214 6.91991 20.7722C7.28393 20.923 7.67409 21.0006 8.06811 21.0006C8.46214 21.0006 8.8523 20.923 9.21632 20.7722C9.58034 20.6214 9.91109 20.4003 10.1897 20.1217L12.375 17.9354L12.9694 18.5307C13.039 18.6004 13.1218 18.6557 13.2128 18.6934C13.3039 18.7311 13.4014 18.7505 13.5 18.7505C13.5985 18.7505 13.6961 18.7311 13.7872 18.6934C13.8782 18.6557 13.9609 18.6004 14.0306 18.5307C14.1003 18.461 14.1556 18.3783 14.1933 18.2873C14.231 18.1962 14.2504 18.0986 14.2504 18.0001C14.2504 17.9016 14.231 17.804 14.1933 17.7129C14.1556 17.6219 14.1003 17.5392 14.0306 17.4695L12.3103 15.7501L14.0306 14.0307C14.1003 13.9611 14.1557 13.8784 14.1934 13.7873C14.2312 13.6963 14.2506 13.5987 14.2506 13.5001C14.2506 13.4015 14.2312 13.3039 14.1934 13.2129C14.1557 13.1218 14.1003 13.0391 14.0306 12.9695ZM9.12843 19.0632C8.84715 19.3443 8.46577 19.5022 8.06811 19.5022C7.67046 19.5022 7.28908 19.3443 7.0078 19.0632L4.93968 16.9923C4.65859 16.711 4.50068 16.3296 4.50068 15.932C4.50068 15.5343 4.65859 15.1529 4.93968 14.8717L7.12499 12.6854L11.3147 16.8751L9.12843 19.0632ZM22.2806 1.71948C22.211 1.64974 22.1282 1.59443 22.0372 1.55668C21.9461 1.51894 21.8486 1.49951 21.75 1.49951C21.6514 1.49951 21.5538 1.51894 21.4628 1.55668C21.3717 1.59443 21.289 1.64974 21.2194 1.71948L18.5569 4.38291L18.0534 3.87854C17.4902 3.31693 16.7273 3.00155 15.9319 3.00155C15.1365 3.00155 14.3735 3.31693 13.8103 3.87854L11.625 6.06479L11.0306 5.46948C10.8899 5.32875 10.699 5.24968 10.5 5.24968C10.301 5.24968 10.1101 5.32875 9.96937 5.46948C9.82863 5.61021 9.74957 5.80108 9.74957 6.0001C9.74957 6.19912 9.82863 6.39 9.96936 6.53073L17.4694 14.0307C17.539 14.1004 17.6218 14.1557 17.7128 14.1934C17.8039 14.2311 17.9014 14.2505 18 14.2505C18.0985 14.2505 18.1961 14.2311 18.2872 14.1934C18.3782 14.1557 18.4609 14.1004 18.5306 14.0307C18.6003 13.961 18.6556 13.8783 18.6933 13.7873C18.731 13.6962 18.7504 13.5986 18.7504 13.5001C18.7504 13.4016 18.731 13.304 18.6933 13.2129C18.6556 13.1219 18.6003 13.0392 18.5306 12.9695L17.9353 12.3751L20.1216 10.1898C20.4002 9.91121 20.6212 9.58046 20.772 9.21644C20.9229 8.85241 21.0005 8.46225 21.0005 8.06823C21.0005 7.6742 20.9229 7.28404 20.772 6.92002C20.6212 6.556 20.4002 6.22525 20.1216 5.94666L19.6172 5.44323L22.2806 2.78073C22.3503 2.71107 22.4057 2.62836 22.4434 2.53731C22.4812 2.44626 22.5006 2.34866 22.5006 2.2501C22.5006 2.15154 22.4812 2.05395 22.4434 1.9629C22.4057 1.87185 22.3503 1.78913 22.2806 1.71948ZM19.0603 9.12573L16.875 11.3148L12.6853 7.1251L14.8716 4.93979C15.1528 4.6587 15.5342 4.5008 15.9319 4.5008C16.3295 4.5008 16.7109 4.6587 16.9922 4.93979L19.0603 7.00229C19.2003 7.14167 19.3114 7.30733 19.3873 7.48978C19.4631 7.67222 19.5021 7.86784 19.5021 8.06541C19.5021 8.26298 19.4631 8.45861 19.3873 8.64105C19.3114 8.82349 19.2003 8.98916 19.0603 9.12854V9.12573Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  PlugsRegular.displayName = "PlugsRegular";
  var ShoppingCartIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.5756 5.51906C21.5052 5.43481 21.4172 5.36705 21.3177 5.32056C21.2183 5.27407 21.1098 5.24998 21 5.25H5.87625L5.30625 2.11594C5.27485 1.94313 5.1838 1.78681 5.04897 1.67425C4.91414 1.56169 4.74408 1.50003 4.56844 1.5H2.25C2.05109 1.5 1.86032 1.57902 1.71967 1.71967C1.57902 1.86032 1.5 2.05109 1.5 2.25C1.5 2.44891 1.57902 2.63968 1.71967 2.78033C1.86032 2.92098 2.05109 3 2.25 3H3.9375L6.33375 16.1522C6.40434 16.5422 6.57671 16.9067 6.83344 17.2087C6.47911 17.5397 6.22336 17.9623 6.09455 18.4298C5.96575 18.8972 5.96892 19.3912 6.10371 19.8569C6.23851 20.3226 6.49966 20.7419 6.85821 21.0683C7.21676 21.3947 7.6587 21.6154 8.13502 21.7059C8.61134 21.7965 9.10344 21.7533 9.55673 21.5813C10.01 21.4092 10.4068 21.115 10.7031 20.7312C10.9994 20.3474 11.1836 19.889 11.2353 19.407C11.287 18.9249 11.2041 18.4379 10.9959 18H15.2541C15.0863 18.3513 14.9995 18.7357 15 19.125C15 19.6442 15.154 20.1517 15.4424 20.5834C15.7308 21.0151 16.1408 21.3515 16.6205 21.5502C17.1001 21.7489 17.6279 21.8008 18.1371 21.6996C18.6463 21.5983 19.114 21.3483 19.4812 20.9812C19.8483 20.614 20.0983 20.1463 20.1996 19.6371C20.3008 19.1279 20.2489 18.6001 20.0502 18.1205C19.8515 17.6408 19.5151 17.2308 19.0834 16.9424C18.6517 16.654 18.1442 16.5 17.625 16.5H8.54719C8.37155 16.5 8.20149 16.4383 8.06665 16.3257C7.93182 16.2132 7.84077 16.0569 7.80938 15.8841L7.51219 14.25H18.3872C18.9141 14.2499 19.4243 14.0649 19.8288 13.7272C20.2333 13.3896 20.5064 12.9206 20.6006 12.4022L21.7406 6.13406C21.7599 6.02572 21.7551 5.91447 21.7266 5.80818C21.6981 5.7019 21.6466 5.60319 21.5756 5.51906ZM9.75 19.125C9.75 19.3475 9.68402 19.565 9.5604 19.75C9.43679 19.935 9.26109 20.0792 9.05552 20.1644C8.84995 20.2495 8.62375 20.2718 8.40552 20.2284C8.18729 20.185 7.98684 20.0778 7.8295 19.9205C7.67217 19.7632 7.56502 19.5627 7.52162 19.3445C7.47821 19.1262 7.50049 18.9 7.58564 18.6945C7.67078 18.4889 7.81498 18.3132 7.99998 18.1896C8.18499 18.066 8.4025 18 8.625 18C8.92337 18 9.20952 18.1185 9.4205 18.3295C9.63147 18.5405 9.75 18.8266 9.75 19.125ZM18.75 19.125C18.75 19.3475 18.684 19.565 18.5604 19.75C18.4368 19.935 18.2611 20.0792 18.0555 20.1644C17.85 20.2495 17.6238 20.2718 17.4055 20.2284C17.1873 20.185 16.9868 20.0778 16.8295 19.9205C16.6722 19.7632 16.565 19.5627 16.5216 19.3445C16.4782 19.1262 16.5005 18.9 16.5856 18.6945C16.6708 18.4889 16.815 18.3132 17 18.1896C17.185 18.066 17.4025 18 17.625 18C17.9234 18 18.2095 18.1185 18.4205 18.3295C18.6315 18.5405 18.75 18.8266 18.75 19.125ZM19.125 12.1341C19.0935 12.3074 19.0021 12.464 18.8666 12.5766C18.7312 12.6893 18.5605 12.7506 18.3844 12.75H7.23938L6.14906 6.75H20.1009L19.125 12.1341Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  ShoppingCartIcon.displayName = "ShoppingCartIcon";
  var Plus = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props, "Plus");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M21 12C21 12.1989 20.921 12.3897 20.7803 12.5303C20.6397 12.671 20.4489 12.75 20.25 12.75H12.75V20.25C12.75 20.4489 20.671 20.6397 12.5303 20.7803C12.3897 20.921 12.1989 21 12 21C11.8011 21 11.6103 20.921 11.4697 20.7803C11.329 20.6397 11.25 20.4489 11.25 20.25V12.75H3.75C3.55109 12.75 3.36032 12.671 3.21967 12.5303C3.07902 12.3897 3 12.1989 3 12C3 11.8011 3.07902 11.6103 3.21967 11.4697C3.36032 11.329 3.55109 11.25 3.75 11.25H11.25V3.75C11.25 3.55109 11.329 3.36032 11.4697 3.21967C11.6103 3.07902 11.8011 3 12 3C12.1989 3 12.3897 3.07902 12.5303 3.21967C12.671 3.36032 12.75 3.55109 12.75 3.75V11.25H20.25C20.4489 11.25 20.6397 11.329 20.7803 11.4697C20.921 11.6103 21 11.8011 21 12Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  Plus.displayName = "Plus";
  var RecordIcon$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 2.25C10.0716 2.25 8.18657 2.82183 6.58319 3.89317C4.97981 4.96451 3.73013 6.48726 2.99217 8.26884C2.25422 10.0504 2.06113 12.0108 2.43734 13.9021C2.81355 15.7934 3.74214 17.5307 5.10571 18.8943C6.46927 20.2579 8.20655 21.1865 10.0979 21.5627C11.9892 21.9389 13.9496 21.7458 15.7312 21.0078C17.5127 20.2699 19.0355 19.0202 20.1068 17.4168C21.1782 15.8134 21.75 13.9284 21.75 12C21.7473 9.41498 20.7192 6.93661 18.8913 5.10872C17.0634 3.28084 14.585 2.25273 12 2.25ZM12 20.25C10.3683 20.25 8.77325 19.7661 7.41654 18.8596C6.05984 17.9531 5.00241 16.6646 4.37799 15.1571C3.75357 13.6496 3.59019 11.9908 3.90852 10.3905C4.22685 8.79016 5.01258 7.32015 6.16637 6.16637C7.32015 5.01259 8.79016 4.22685 10.3905 3.90852C11.9908 3.59019 13.6496 3.75357 15.1571 4.37799C16.6646 5.00242 17.9531 6.05984 18.8596 7.41655C19.7661 8.77325 20.25 10.3683 20.25 12C20.2475 14.1873 19.3775 16.2843 17.8309 17.8309C16.2843 19.3775 14.1873 20.2475 12 20.25ZM12 5.25C10.665 5.25 9.35993 5.64588 8.2499 6.38758C7.13987 7.12928 6.2747 8.18349 5.76381 9.41689C5.25292 10.6503 5.11925 12.0075 5.3797 13.3169C5.64015 14.6262 6.28302 15.829 7.22703 16.773C8.17103 17.717 9.37377 18.3599 10.6831 18.6203C11.9925 18.8808 13.3497 18.7471 14.5831 18.2362C15.8165 17.7253 16.8707 16.8601 17.6124 15.7501C18.3541 14.6401 18.75 13.335 18.75 12C18.748 10.2104 18.0362 8.49466 16.7708 7.22922C15.5053 5.96378 13.7896 5.25199 12 5.25ZM12 17.25C10.9616 17.25 9.94661 16.9421 9.08325 16.3652C8.2199 15.7883 7.54699 14.9684 7.14963 14.0091C6.75227 13.0498 6.6483 11.9942 6.85087 10.9758C7.05345 9.95738 7.55346 9.02192 8.28769 8.28769C9.02191 7.55346 9.95737 7.05345 10.9758 6.85088C11.9942 6.6483 13.0498 6.75227 14.0091 7.14963C14.9684 7.54699 15.7883 8.2199 16.3652 9.08326C16.9421 9.94661 17.25 10.9616 17.25 12C17.2485 13.3919 16.6949 14.7264 15.7107 15.7107C14.7264 16.6949 13.3919 17.2485 12 17.25Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  RecordIcon$1.displayName = "RecordIcon";
  var SidebarSimple = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.25 3.75H3.75C3.35218 3.75 2.97064 3.90804 2.68934 4.18934C2.40804 4.47064 2.25 4.85218 2.25 5.25V18.75C2.25 19.1478 2.40804 19.5294 2.68934 19.8107C2.97064 20.092 3.35218 20.25 3.75 20.25H20.25C20.6478 20.25 21.0294 20.092 21.3107 19.8107C21.592 19.5294 21.75 19.1478 21.75 18.75V5.25C21.75 4.85218 21.592 4.47064 21.3107 4.18934C21.0294 3.90804 20.6478 3.75 20.25 3.75ZM3.75 5.25H7.5V18.75H3.75V5.25ZM20.25 18.75H9V5.25H20.25V18.75Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  SidebarSimple.displayName = "SidebarSimple";
  var SignOut = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M11.25 20.25C11.25 20.4489 11.171 20.6397 11.0303 20.7803C10.8897 20.921 10.6989 21 10.5 21H4.5C4.30109 21 4.11032 20.921 3.96967 20.7803C3.82902 20.6397 3.75 20.4489 3.75 20.25V3.75C3.75 3.55109 3.82902 3.36032 3.96967 3.21967C4.11032 3.07902 4.30109 3 4.5 3H10.5C10.6989 3 10.8897 3.07902 11.0303 3.21967C11.171 3.36032 11.25 3.55109 11.25 3.75C11.25 3.94891 11.171 4.13968 11.0303 4.28033C10.8897 4.42098 10.6989 4.5 10.5 4.5H5.25V19.5H10.5C10.6989 19.5 10.8897 19.579 11.0303 19.7197C11.171 19.8603 11.25 20.0511 11.25 20.25ZM21.5306 11.4694L17.7806 7.71937C17.6399 7.57864 17.449 7.49958 17.25 7.49958C17.051 7.49958 16.8601 7.57864 16.7194 7.71937C16.5786 7.86011 16.4996 8.05098 16.4996 8.25C16.4996 8.44902 16.5786 8.63989 16.7194 8.78063L19.1897 11.25H10.5C10.3011 11.25 10.1103 11.329 9.96967 11.4697C9.82902 11.6103 9.75 11.8011 9.75 12C9.75 12.1989 9.82902 12.3897 9.96967 12.5303C10.1103 12.671 10.3011 12.75 10.5 12.75H19.1897L16.7194 15.2194C16.5786 15.3601 16.4996 15.551 16.4996 15.75C16.4996 15.949 16.5786 16.1399 16.7194 16.2806C16.8601 16.4214 17.051 16.5004 17.25 16.5004C17.449 16.5004 17.6399 16.4214 17.7806 16.2806L21.5306 12.5306C21.6004 12.461 21.6557 12.3783 21.6934 12.2872C21.7312 12.1962 21.7506 12.0986 21.7506 12C21.7506 11.9014 21.7312 11.8038 21.6934 11.7128C21.6557 11.6217 21.6004 11.539 21.5306 11.4694Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  SignOut.displayName = "SignOut";
  var Storefront = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.75 9C21.7504 8.93027 21.7409 8.86083 21.7219 8.79375L20.3766 4.0875C20.2861 3.77523 20.0971 3.50059 19.8378 3.30459C19.5784 3.10858 19.2626 3.00174 18.9375 3H5.0625C4.73741 3.00174 4.4216 3.10858 4.16223 3.30459C3.90287 3.50059 3.71386 3.77523 3.62344 4.0875L2.27906 8.79375C2.2597 8.86079 2.24991 8.93022 2.25 9V10.5C2.25 11.0822 2.38554 11.6563 2.6459 12.1771C2.90625 12.6978 3.28427 13.1507 3.75 13.5V20.25C3.75 20.4489 3.82902 20.6397 3.96967 20.7803C4.11032 20.921 4.30109 21 4.5 21H19.5C19.6989 21 19.8897 20.921 20.0303 20.7803C20.171 20.6397 20.25 20.4489 20.25 20.25V13.5C20.7157 13.1507 21.0937 12.6978 21.3541 12.1771C21.6145 11.6563 21.75 11.0822 21.75 10.5V9ZM5.0625 4.5H18.9375L20.0081 8.25H3.99469L5.0625 4.5ZM9.75 9.75H14.25V10.5C14.25 11.0967 14.0129 11.669 13.591 12.091C13.169 12.5129 12.5967 12.75 12 12.75C11.4033 12.75 10.831 12.5129 10.409 12.091C9.98705 11.669 9.75 11.0967 9.75 10.5V9.75ZM8.25 9.75V10.5C8.24987 10.8869 8.14996 11.2673 7.95993 11.6043C7.7699 11.9413 7.49617 12.2236 7.16518 12.424C6.83419 12.6244 6.45713 12.736 6.07041 12.7481C5.68369 12.7602 5.30038 12.6724 4.9575 12.4931C4.90533 12.4525 4.84794 12.4191 4.78688 12.3937C4.46913 12.1903 4.20764 11.9103 4.02646 11.5794C3.84527 11.2484 3.7502 10.8773 3.75 10.5V9.75H8.25ZM18.75 19.5H5.25V14.175C5.4969 14.2248 5.74813 14.2499 6 14.25C6.58217 14.25 7.15634 14.1145 7.67705 13.8541C8.19776 13.5937 8.6507 13.2157 9 12.75C9.3493 13.2157 9.80224 13.5937 10.323 13.8541C10.8437 14.1145 11.4178 14.25 12 14.25C12.5822 14.25 13.1563 14.1145 13.6771 13.8541C14.1978 13.5937 14.6507 13.2157 15 12.75C15.3493 13.2157 15.8022 13.5937 16.3229 13.8541C16.8437 14.1145 17.4178 14.25 18 14.25C18.2519 14.2499 18.5031 14.2248 18.75 14.175V19.5ZM19.2122 12.3937C19.1519 12.4191 19.0952 12.4522 19.0434 12.4922C18.7006 12.6716 18.3173 12.7596 17.9305 12.7477C17.5437 12.7357 17.1666 12.6242 16.8355 12.424C16.5044 12.2237 16.2305 11.9414 16.0404 11.6044C15.8502 11.2673 15.7502 10.887 15.75 10.5V9.75H20.25V10.5C20.2497 10.8774 20.1545 11.2486 19.9731 11.5795C19.7918 11.9104 19.5301 12.1904 19.2122 12.3937Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Storefront.displayName = "Storefront";
  var Tag = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M22.8103 12.75L13.5 3.43969C13.3612 3.2998 13.196 3.18889 13.014 3.11341C12.832 3.03792 12.6368 2.99938 12.4397 3.00001H3.75001C3.5511 3.00001 3.36033 3.07903 3.21968 3.21968C3.07903 3.36033 3.00001 3.5511 3.00001 3.75001V12.4397C2.99938 12.6368 3.03792 12.832 3.11341 13.014C3.18889 13.196 3.2998 13.3612 3.43969 13.5L12.75 22.8103C12.8893 22.9496 13.0547 23.0602 13.2367 23.1356C13.4187 23.211 13.6138 23.2498 13.8108 23.2498C14.0078 23.2498 14.2029 23.211 14.3849 23.1356C14.5669 23.0602 14.7323 22.9496 14.8716 22.8103L22.8103 14.8716C22.9496 14.7323 23.0602 14.5669 23.1356 14.3849C23.211 14.2029 23.2498 14.0078 23.2498 13.8108C23.2498 13.6138 23.211 13.4187 23.1356 13.2367C23.0602 13.0547 22.9496 12.8893 22.8103 12.75ZM13.8103 21.75L4.50001 12.4397V4.50001H12.4397L21.75 13.8103L13.8103 21.75ZM9.00001 7.87501C9.00001 8.09751 8.93403 8.31502 8.81041 8.50002C8.68679 8.68503 8.51109 8.82922 8.30553 8.91437C8.09996 8.99952 7.87376 9.0218 7.65553 8.97839C7.4373 8.93498 7.23685 8.82784 7.07951 8.6705C6.92218 8.51317 6.81503 8.31271 6.77162 8.09448C6.72822 7.87626 6.75049 7.65006 6.83564 7.44449C6.92079 7.23892 7.06499 7.06322 7.24999 6.9396C7.435 6.81599 7.6525 6.75001 7.87501 6.75001C8.17338 6.75001 8.45952 6.86853 8.6705 7.07951C8.88148 7.29049 9.00001 7.57664 9.00001 7.87501Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Tag.displayName = "Tag";
  var Ticket = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.75 9.75C21.9489 9.75 22.1397 9.67098 22.2803 9.53033C22.421 9.38968 22.5 9.19891 22.5 9V6C22.5 5.60218 22.342 5.22064 22.0607 4.93934C21.7794 4.65804 21.3978 4.5 21 4.5H3C2.60218 4.5 2.22064 4.65804 1.93934 4.93934C1.65804 5.22064 1.5 5.60218 1.5 6V9C1.5 9.19891 1.57902 9.38968 1.71967 9.53033C1.86032 9.67098 2.05109 9.75 2.25 9.75C2.84674 9.75 3.41903 9.98705 3.84099 10.409C4.26295 10.831 4.5 11.4033 4.5 12C4.5 12.5967 4.26295 13.169 3.84099 13.591C3.41903 14.0129 2.84674 14.25 2.25 14.25C2.05109 14.25 1.86032 14.329 1.71967 14.4697C1.57902 14.6103 1.5 14.8011 1.5 15V18C1.5 18.3978 1.65804 18.7794 1.93934 19.0607C2.22064 19.342 2.60218 19.5 3 19.5H21C21.3978 19.5 21.7794 19.342 22.0607 19.0607C22.342 18.7794 22.5 18.3978 22.5 18V15C22.5 14.8011 22.421 14.6103 22.2803 14.4697C22.1397 14.329 21.9489 14.25 21.75 14.25C21.1533 14.25 20.581 14.0129 20.159 13.591C19.7371 13.169 19.5 12.5967 19.5 12C19.5 11.4033 19.7371 10.831 20.159 10.409C20.581 9.98705 21.1533 9.75 21.75 9.75ZM3 15.675C3.84772 15.5029 4.60986 15.043 5.15728 14.3732C5.70471 13.7034 6.00376 12.865 6.00376 12C6.00376 11.135 5.70471 10.2966 5.15728 9.62681C4.60986 8.95705 3.84772 8.49714 3 8.325V6H8.25V18H3V15.675ZM21 15.675V18H9.75V6H21V8.325C20.1523 8.49714 19.3901 8.95705 18.8427 9.62681C18.2953 10.2966 17.9962 11.135 17.9962 12C17.9962 12.865 18.2953 13.7034 18.8427 14.3732C19.3901 15.043 20.1523 15.5029 21 15.675Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Ticket.displayName = "Ticket";
  var Trash$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: `0 0 24 24`,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.25 4.5H16.5V3.75C16.5 3.15326 16.2629 2.58097 15.841 2.15901C15.419 1.73705 14.8467 1.5 14.25 1.5H9.75C9.15326 1.5 8.58097 1.73705 8.15901 2.15901C7.73705 2.58097 7.5 3.15326 7.5 3.75V4.5H3.75C3.55109 4.5 3.36032 4.57902 3.21967 4.71967C3.07902 4.86032 3 5.05109 3 5.25C3 5.44891 3.07902 5.63968 3.21967 5.78033C3.36032 5.92098 3.55109 6 3.75 6H4.5V19.5C4.5 19.8978 4.65804 20.2794 4.93934 20.5607C5.22064 20.842 5.60218 21 6 21H18C18.3978 21 18.7794 20.842 19.0607 20.5607C19.342 20.2794 19.5 19.8978 19.5 19.5V6H20.25C20.4489 6 20.6397 5.92098 20.7803 5.78033C20.921 5.63968 21 5.44891 21 5.25C21 5.05109 20.921 4.86032 20.7803 4.71967C20.6397 4.57902 20.4489 4.5 20.25 4.5ZM9 3.75C9 3.55109 9.07902 3.36032 9.21967 3.21967C9.36032 3.07902 9.55109 3 9.75 3H14.25C14.4489 3 14.6397 3.07902 14.7803 3.21967C14.921 3.36032 15 3.55109 15 3.75V4.5H9V3.75ZM18 19.5H6V6H18V19.5ZM10.5 9.75V15.75C10.5 15.9489 10.421 16.1397 10.2803 16.2803C10.1397 16.421 9.94891 16.5 9.75 16.5C9.55109 16.5 9.36032 16.421 9.21967 16.2803C9.07902 16.1397 9 15.9489 9 15.75V9.75C9 9.55109 9.07902 9.36032 9.21967 9.21967C9.36032 9.07902 9.55109 9 9.75 9C9.94891 9 10.1397 9.07902 10.2803 9.21967C10.421 9.36032 10.5 9.55109 10.5 9.75ZM15 9.75V15.75C15 15.9489 14.921 16.1397 14.7803 16.2803C14.6397 16.421 14.4489 16.5 14.25 16.5C14.0511 16.5 13.8603 16.421 13.7197 16.2803C13.579 16.1397 13.5 15.9489 13.5 15.75V9.75C13.5 9.55109 13.579 9.36032 13.7197 9.21967C13.8603 9.07902 14.0511 9 14.25 9C14.4489 9 14.6397 9.07902 14.7803 9.21967C14.921 9.36032 15 9.55109 15 9.75Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Trash$1.displayName = "Trash";
  var UserCircle = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M12 2.25C10.0716 2.25 8.18657 2.82183 6.58319 3.89317C4.97982 4.96451 3.73013 6.48726 2.99218 8.26884C2.25422 10.0504 2.06114 12.0108 2.43735 13.9021C2.81355 15.7934 3.74215 17.5307 5.10571 18.8943C6.46928 20.2579 8.20656 21.1865 10.0979 21.5627C11.9892 21.9389 13.9496 21.7458 15.7312 21.0078C17.5127 20.2699 19.0355 19.0202 20.1068 17.4168C21.1782 15.8134 21.75 13.9284 21.75 12C21.7473 9.41498 20.7192 6.93661 18.8913 5.10872C17.0634 3.28084 14.585 2.25273 12 2.25ZM6.945 18.5156C7.48757 17.6671 8.23501 16.9688 9.11843 16.4851C10.0019 16.0013 10.9928 15.7478 12 15.7478C13.0072 15.7478 13.9982 16.0013 14.8816 16.4851C15.765 16.9688 16.5124 17.6671 17.055 18.5156C15.6097 19.6397 13.831 20.2499 12 20.2499C10.169 20.2499 8.39032 19.6397 6.945 18.5156ZM9 11.25C9 10.6567 9.17595 10.0766 9.5056 9.58329C9.83524 9.08994 10.3038 8.70542 10.852 8.47836C11.4001 8.2513 12.0033 8.19189 12.5853 8.30764C13.1672 8.4234 13.7018 8.70912 14.1213 9.12868C14.5409 9.54824 14.8266 10.0828 14.9424 10.6647C15.0581 11.2467 14.9987 11.8499 14.7716 12.3981C14.5446 12.9462 14.1601 13.4148 13.6667 13.7444C13.1734 14.0741 12.5933 14.25 12 14.25C11.2044 14.25 10.4413 13.9339 9.87868 13.3713C9.31607 12.8087 9 12.0456 9 11.25ZM18.165 17.4759C17.3285 16.2638 16.1524 15.3261 14.7844 14.7806C15.5192 14.2019 16.0554 13.4085 16.3184 12.5108C16.5815 11.6132 16.5582 10.6559 16.252 9.77207C15.9457 8.88825 15.3716 8.12183 14.6096 7.5794C13.8475 7.03696 12.9354 6.74548 12 6.74548C11.0646 6.74548 10.1525 7.03696 9.39044 7.5794C8.62839 8.12183 8.05432 8.88825 7.74805 9.77207C7.44179 10.6559 7.41855 11.6132 7.68157 12.5108C7.94459 13.4085 8.4808 14.2019 9.21563 14.7806C7.84765 15.3261 6.67147 16.2638 5.835 17.4759C4.77804 16.2873 4.0872 14.8185 3.84567 13.2464C3.60415 11.6743 3.82224 10.0658 4.47368 8.61478C5.12512 7.16372 6.18213 5.93192 7.51745 5.06769C8.85276 4.20346 10.4094 3.74367 12 3.74367C13.5906 3.74367 15.1473 4.20346 16.4826 5.06769C17.8179 5.93192 18.8749 7.16372 19.5263 8.61478C20.1778 10.0658 20.3959 11.6743 20.1543 13.2464C19.9128 14.8185 19.222 16.2873 18.165 17.4759Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  UserCircle.displayName = "UserCircle";
  var UserIcon$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M21.6488 19.8751C20.2209 17.4067 18.0206 15.6367 15.4528 14.7976C16.723 14.0415 17.7098 12.8893 18.2618 11.518C18.8137 10.1468 18.9003 8.63224 18.5082 7.20701C18.1161 5.78178 17.267 4.52467 16.0912 3.62873C14.9155 2.73279 13.4782 2.24756 12 2.24756C10.5218 2.24756 9.08451 2.73279 7.90878 3.62873C6.73306 4.52467 5.88394 5.78178 5.49183 7.20701C5.09971 8.63224 5.18629 10.1468 5.73825 11.518C6.29021 12.8893 7.27704 14.0415 8.5472 14.7976C5.97938 15.6357 3.77907 17.4057 2.35126 19.8751C2.2989 19.9605 2.26417 20.0555 2.24912 20.1545C2.23407 20.2535 2.239 20.3545 2.26363 20.4516C2.28825 20.5487 2.33207 20.6399 2.3925 20.7197C2.45293 20.7996 2.52874 20.8666 2.61547 20.9167C2.7022 20.9667 2.79808 20.999 2.89745 21.0114C2.99683 21.0238 3.0977 21.0163 3.19409 20.9891C3.29049 20.9619 3.38047 20.9157 3.45872 20.8532C3.53697 20.7907 3.6019 20.7131 3.6497 20.6251C5.41595 17.5726 8.53782 15.7501 12 15.7501C15.4622 15.7501 18.5841 17.5726 20.3503 20.6251C20.3981 20.7131 20.4631 20.7907 20.5413 20.8532C20.6196 20.9157 20.7095 20.9619 20.8059 20.9891C20.9023 21.0163 21.0032 21.0238 21.1026 21.0114C21.2019 20.999 21.2978 20.9667 21.3845 20.9167C21.4713 20.8666 21.5471 20.7996 21.6075 20.7197C21.6679 20.6399 21.7118 20.5487 21.7364 20.4516C21.761 20.3545 21.766 20.2535 21.7509 20.1545C21.7358 20.0555 21.7011 19.9605 21.6488 19.8751ZM6.75001 9.00011C6.75001 7.96176 7.05792 6.94672 7.63479 6.08337C8.21167 5.22001 9.03161 4.5471 9.99092 4.14974C10.9502 3.75238 12.0058 3.64841 13.0242 3.85099C14.0426 4.05356 14.9781 4.55357 15.7123 5.2878C16.4465 6.02202 16.9466 6.95748 17.1491 7.97589C17.3517 8.99429 17.2477 10.0499 16.8504 11.0092C16.453 11.9685 15.7801 12.7884 14.9168 13.3653C14.0534 13.9422 13.0384 14.2501 12 14.2501C10.6081 14.2486 9.27359 13.695 8.28934 12.7108C7.3051 11.7265 6.7515 10.392 6.75001 9.00011Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  UserIcon$1.displayName = "UserIcon";
  var Users = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, restProps } = getAccessibilityProps(
        props,
        "Users"
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10.9922 14.8048C11.9974 14.1356 12.7605 13.1607 13.1688 12.0243C13.577 10.8878 13.6087 9.65012 13.2592 8.49425C12.9096 7.33838 12.1973 6.32569 11.2277 5.60593C10.2581 4.88617 9.08256 4.49756 7.87499 4.49756C6.66741 4.49756 5.4919 4.88617 4.52227 5.60593C3.55264 6.32569 2.84039 7.33838 2.49082 8.49425C2.14126 9.65012 2.17295 10.8878 2.5812 12.0243C2.98946 13.1607 3.75261 14.1356 4.7578 14.8048C2.93951 15.475 1.38665 16.7151 0.330923 18.3402C0.275438 18.4226 0.236898 18.5153 0.217543 18.6128C0.198188 18.7103 0.198405 18.8106 0.21818 18.908C0.237956 19.0055 0.276896 19.098 0.332737 19.1802C0.388577 19.2624 0.460205 19.3327 0.543457 19.387C0.626708 19.4413 0.719922 19.4785 0.817681 19.4965C0.915439 19.5144 1.01579 19.5128 1.11291 19.4916C1.21002 19.4705 1.30196 19.4302 1.38338 19.3732C1.4648 19.3162 1.53407 19.2435 1.58717 19.1595C2.26816 18.1121 3.20001 17.2515 4.29808 16.6556C5.39616 16.0598 6.62568 15.7477 7.87499 15.7477C9.12429 15.7477 10.3538 16.0598 11.4519 16.6556C12.55 17.2515 13.4818 18.1121 14.1628 19.1595C14.2728 19.323 14.4427 19.4367 14.6358 19.4759C14.829 19.5151 15.0297 19.4767 15.1948 19.369C15.3598 19.2614 15.4759 19.0931 15.5179 18.9006C15.5598 18.708 15.5243 18.5067 15.419 18.3402C14.3633 16.7151 12.8105 15.475 10.9922 14.8048ZM3.74999 10.1248C3.74999 9.30899 3.99191 8.51147 4.44517 7.83311C4.89843 7.15476 5.54267 6.62605 6.29642 6.31384C7.05016 6.00163 7.87956 5.91994 8.67973 6.0791C9.47991 6.23827 10.2149 6.63113 10.7918 7.20803C11.3687 7.78492 11.7616 8.51992 11.9207 9.32009C12.0799 10.1203 11.9982 10.9497 11.686 11.7034C11.3738 12.4572 10.8451 13.1014 10.1667 13.5547C9.48836 14.0079 8.69083 14.2498 7.87499 14.2498C6.78135 14.2486 5.73286 13.8136 4.95954 13.0403C4.18622 12.267 3.75123 11.2185 3.74999 10.1248ZM23.4506 19.378C23.284 19.4866 23.0811 19.5246 22.8865 19.4837C22.6919 19.4427 22.5215 19.3261 22.4128 19.1595C21.7326 18.1115 20.8009 17.2505 19.7026 16.6549C18.6043 16.0593 17.3744 15.7482 16.125 15.7498C15.9261 15.7498 15.7353 15.6708 15.5947 15.5302C15.454 15.3895 15.375 15.1988 15.375 14.9998C15.375 14.8009 15.454 14.6102 15.5947 14.4695C15.7353 14.3289 15.9261 14.2498 16.125 14.2498C16.7325 14.2493 17.3323 14.1145 17.8817 13.8553C18.431 13.596 18.9163 13.2186 19.3029 12.75C19.6895 12.2814 19.9679 11.7332 20.1181 11.1446C20.2682 10.556 20.2866 9.9415 20.1717 9.34498C20.0569 8.74846 19.8117 8.18468 19.4537 7.6939C19.0957 7.20312 18.6337 6.79747 18.1008 6.50593C17.5678 6.2144 16.9771 6.04416 16.3707 6.0074C15.7644 5.97064 15.1574 6.06826 14.5931 6.29328C14.5011 6.33305 14.4021 6.35398 14.3018 6.35482C14.2016 6.35567 14.1022 6.33642 14.0096 6.29821C13.9169 6.26 13.8329 6.2036 13.7624 6.13236C13.6919 6.06111 13.6364 5.97645 13.5992 5.88339C13.5619 5.79033 13.5437 5.69076 13.5456 5.59055C13.5476 5.49034 13.5695 5.39152 13.6103 5.29995C13.651 5.20838 13.7097 5.1259 13.7829 5.0574C13.856 4.98889 13.9422 4.93574 14.0362 4.90109C15.3276 4.38608 16.764 4.36754 18.0682 4.84907C19.3724 5.33059 20.4521 6.27805 21.099 7.50867C21.7459 8.73929 21.9141 10.1659 21.5712 11.5132C21.2283 12.8605 20.3986 14.0332 19.2422 14.8048C21.0605 15.475 22.6133 16.7151 23.669 18.3402C23.7777 18.5068 23.8157 18.7097 23.7747 18.9043C23.7338 19.0989 23.6172 19.2693 23.4506 19.378Z",
              fill: props.color || "currentColor"
            }
          )
        }
      );
    }
  );
  Users.displayName = "Users";
  var VideoCamera$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M23.6034 6.84375C23.4838 6.77964 23.3491 6.74919 23.2135 6.75563C23.078 6.76207 22.9467 6.80516 22.8337 6.88031L19.5 9.09844V6.75C19.5 6.35218 19.342 5.97064 19.0607 5.68934C18.7794 5.40804 18.3978 5.25 18 5.25H3C2.60218 5.25 2.22064 5.40804 1.93934 5.68934C1.65804 5.97064 1.5 6.35218 1.5 6.75V17.25C1.5 17.6478 1.65804 18.0294 1.93934 18.3107C2.22064 18.592 2.60218 18.75 3 18.75H18C18.3978 18.75 18.7794 18.592 19.0607 18.3107C19.342 18.0294 19.5 17.6478 19.5 17.25V14.9062L22.8337 17.1291C22.9576 17.2095 23.1024 17.2515 23.25 17.25C23.4489 17.25 23.6397 17.171 23.7803 17.0303C23.921 16.8897 24 16.6989 24 16.5V7.5C23.9991 7.36506 23.9617 7.23287 23.8919 7.11737C23.8221 7.00187 23.7225 6.90734 23.6034 6.84375ZM18 17.25H3V6.75H18V17.25ZM22.5 15.0984L19.5 13.0988V10.9012L22.5 8.90625V15.0984Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  VideoCamera$1.displayName = "VideoCamera";
  var WhatsAppLogo = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props, "WhatsAppLogo");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M17.5857 13.5787L14.5857 12.0787C14.4676 12.0199 14.3361 11.9933 14.2044 12.0015C14.0727 12.0097 13.9455 12.0525 13.8357 12.1256L12.4585 13.0444C11.8263 12.6968 11.306 12.1766 10.9585 11.5444L11.8772 10.1672C11.9503 10.0573 11.9932 9.93016 12.0014 9.79848C12.0096 9.6668 11.983 9.53528 11.9241 9.41719L10.4241 6.41719C10.3619 6.29163 10.2658 6.186 10.1467 6.11226C10.0276 6.03853 9.89016 5.99964 9.75005 6C8.75549 6 7.80166 6.39509 7.0984 7.09835C6.39514 7.80161 6.00005 8.75544 6.00005 9.75C6.00253 11.9373 6.87252 14.0343 8.41916 15.5809C9.9658 17.1275 12.0628 17.9975 14.2501 18C14.7425 18 15.2301 17.903 15.6851 17.7145C16.1401 17.5261 16.5535 17.2499 16.9017 16.9017C17.2499 16.5534 17.5261 16.14 17.7146 15.6851C17.9031 15.2301 18.0001 14.7425 18.0001 14.25C18.0002 14.1107 17.9614 13.9741 17.8882 13.8555C17.8151 13.7369 17.7103 13.6411 17.5857 13.5787ZM14.2501 16.5C12.4605 16.498 10.7447 15.7862 9.47927 14.5208C8.21383 13.2553 7.50204 11.5396 7.50005 9.75C7.49991 9.2298 7.68002 8.72562 8.00974 8.32326C8.33945 7.9209 8.79841 7.64521 9.30849 7.54313L10.3847 9.69938L9.4688 11.0625C9.40036 11.1652 9.3583 11.2831 9.34636 11.406C9.33443 11.5288 9.35297 11.6526 9.40036 11.7666C9.93698 13.0419 10.9516 14.0565 12.2269 14.5931C12.3412 14.6426 12.466 14.6629 12.5901 14.6521C12.7141 14.6413 12.8336 14.5998 12.9376 14.5312L14.3072 13.6181L16.4635 14.6944C16.3606 15.205 16.0837 15.6642 15.6801 15.9935C15.2764 16.3228 14.771 16.5018 14.2501 16.5ZM12.0001 2.25C10.3167 2.24963 8.66201 2.68508 7.19691 3.51396C5.73182 4.34285 4.50628 5.53692 3.63959 6.97997C2.77289 8.42301 2.29457 10.0659 2.25117 11.7486C2.20777 13.4314 2.60077 15.0967 3.39193 16.5825L2.32787 19.7747C2.23973 20.039 2.22693 20.3226 2.29093 20.5938C2.35492 20.8649 2.49316 21.1129 2.69016 21.3099C2.88717 21.5069 3.13514 21.6451 3.4063 21.7091C3.67745 21.7731 3.96107 21.7603 4.22537 21.6722L7.41755 20.6081C8.72515 21.3036 10.174 21.6921 11.6541 21.744C13.1343 21.7959 14.6068 21.51 15.9599 20.9079C17.3131 20.3057 18.5112 19.4033 19.4635 18.269C20.4158 17.1346 21.0971 15.7983 21.4558 14.3613C21.8145 12.9244 21.8411 11.4246 21.5336 9.97578C21.2261 8.52701 20.5926 7.16732 19.6812 5.99992C18.7698 4.83253 17.6044 3.88811 16.2735 3.23836C14.9426 2.58861 13.4811 2.25061 12.0001 2.25ZM12.0001 20.25C10.5497 20.251 9.12483 19.8691 7.86943 19.1428C7.77751 19.0895 7.67532 19.0563 7.56962 19.0455C7.46391 19.0347 7.35712 19.0464 7.2563 19.08L3.75005 20.25L4.91912 16.7438C4.95281 16.643 4.96473 16.5362 4.95406 16.4305C4.94339 16.3248 4.91039 16.2226 4.85724 16.1306C3.94784 14.5584 3.58272 12.7299 3.81852 10.929C4.05432 9.12801 4.87786 7.4552 6.16139 6.17006C7.44491 4.88491 9.11667 4.05925 10.9173 3.82118C12.718 3.5831 14.5469 3.94591 16.1203 4.85333C17.6937 5.76074 18.9237 7.16204 19.6194 8.83983C20.3152 10.5176 20.4378 12.3781 19.9683 14.1327C19.4987 15.8873 18.4633 17.4379 17.0226 18.5439C15.5818 19.65 13.8164 20.2497 12.0001 20.25Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  WhatsAppLogo.displayName = "WhatsAppLogo";
  var WarningOctagon = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, restProps } = getAccessibilityProps(
        props,
        "WarningOctagon"
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.25 12.75V7.50001C11.25 7.3011 11.329 7.11033 11.4697 6.96968C11.6103 6.82903 11.8011 6.75001 12 6.75001C12.1989 6.75001 12.3897 6.82903 12.5303 6.96968C12.671 7.11033 12.75 7.3011 12.75 7.50001V12.75C12.75 12.9489 12.671 13.1397 12.5303 13.2803C12.3897 13.421 12.1989 13.5 12 13.5C11.8011 13.5 11.6103 13.421 11.4697 13.2803C11.329 13.1397 11.25 12.9489 11.25 12.75ZM21.75 8.58282V15.4172C21.7506 15.6142 21.7121 15.8095 21.6366 15.9915C21.5611 16.1735 21.4502 16.3387 21.3103 16.4775L16.4775 21.3103C16.3387 21.4502 16.1735 21.5611 15.9915 21.6366C15.8095 21.7121 15.6142 21.7506 15.4172 21.75H8.58281C8.38576 21.7506 8.19054 21.7121 8.00852 21.6366C7.82649 21.5611 7.66128 21.4502 7.5225 21.3103L2.68969 16.4775C2.54979 16.3387 2.43888 16.1735 2.3634 15.9915C2.28792 15.8095 2.24937 15.6142 2.25 15.4172V8.58282C2.24937 8.38577 2.28792 8.19055 2.3634 8.00852C2.43888 7.8265 2.54979 7.66129 2.68969 7.52251L7.5225 2.6897C7.66128 2.5498 7.82649 2.43889 8.00852 2.36341C8.19054 2.28792 8.38576 2.24938 8.58281 2.25001H15.4172C15.6142 2.24938 15.8095 2.28792 15.9915 2.36341C16.1735 2.43889 16.3387 2.5498 16.4775 2.6897L21.3103 7.52251C21.4502 7.66129 21.5611 7.8265 21.6366 8.00852C21.7121 8.19055 21.7506 8.38577 21.75 8.58282ZM20.25 8.58282L15.4172 3.75001H8.58281L3.75 8.58282V15.4172L8.58281 20.25H15.4172L20.25 15.4172V8.58282ZM12 15C11.7775 15 11.56 15.066 11.375 15.1896C11.19 15.3132 11.0458 15.4889 10.9606 15.6945C10.8755 15.9001 10.8532 16.1263 10.8966 16.3445C10.94 16.5627 11.0472 16.7632 11.2045 16.9205C11.3618 17.0778 11.5623 17.185 11.7805 17.2284C11.9988 17.2718 12.225 17.2495 12.4305 17.1644C12.6361 17.0792 12.8118 16.935 12.9354 16.75C13.059 16.565 13.125 16.3475 13.125 16.125C13.125 15.8266 13.0065 15.5405 12.7955 15.3295C12.5845 15.1185 12.2984 15 12 15Z",
              fill: props.color || "currentColor"
            }
          )
        }
      );
    }
  );
  WarningOctagon.displayName = "WarningOctagon";
  var WarningTriangle = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => {
      const { accessibilityProps, restProps } = getAccessibilityProps(
        props,
        "WarningTriangle"
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M22.2 17.6335L14.0016 3.39569C13.7967 3.04687 13.5042 2.75764 13.1531 2.55668C12.802 2.35572 12.4045 2.25 12 2.25C11.5955 2.25 11.198 2.35572 10.8469 2.55668C10.4958 2.75764 10.2033 3.04687 9.99844 3.39569L1.8 17.6335C1.60288 17.9709 1.49899 18.3546 1.49899 18.7454C1.49899 19.1361 1.60288 19.5199 1.8 19.8572C2.00225 20.2082 2.29422 20.499 2.64596 20.6998C2.9977 20.9006 3.39655 21.0043 3.80156 21.0001H20.1984C20.6031 21.0039 21.0016 20.9001 21.353 20.6993C21.7044 20.4985 21.996 20.2079 22.1981 19.8572C22.3955 19.52 22.4997 19.1364 22.5001 18.7456C22.5004 18.3549 22.3968 17.9711 22.2 17.6335ZM20.8997 19.1063C20.8282 19.2282 20.7256 19.3289 20.6024 19.3981C20.4792 19.4673 20.3397 19.5025 20.1984 19.5001H3.80156C3.66026 19.5025 3.52085 19.4673 3.39762 19.3981C3.27439 19.3289 3.17178 19.2282 3.10031 19.1063C3.03557 18.9967 3.00142 18.8717 3.00142 18.7444C3.00142 18.6171 3.03557 18.4922 3.10031 18.3826L11.2987 4.14475C11.3717 4.02341 11.4747 3.92301 11.5979 3.8533C11.7212 3.7836 11.8603 3.74696 12.0019 3.74696C12.1434 3.74696 12.2826 3.7836 12.4058 3.8533C12.529 3.92301 12.6321 4.02341 12.705 4.14475L20.9034 18.3826C20.9676 18.4925 21.0011 18.6176 21.0005 18.7449C20.9998 18.8722 20.965 18.997 20.8997 19.1063ZM11.25 13.5001V9.75006C11.25 9.55115 11.329 9.36038 11.4697 9.21973C11.6103 9.07908 11.8011 9.00006 12 9.00006C12.1989 9.00006 12.3897 9.07908 12.5303 9.21973C12.671 9.36038 12.75 9.55115 12.75 9.75006V13.5001C12.75 13.699 12.671 13.8897 12.5303 14.0304C12.3897 14.171 12.1989 14.2501 12 14.2501C11.8011 14.2501 11.6103 14.171 11.4697 14.0304C11.329 13.8897 11.25 13.699 11.25 13.5001ZM13.125 16.8751C13.125 17.0976 13.059 17.3151 12.9354 17.5001C12.8118 17.6851 12.6361 17.8293 12.4305 17.9144C12.2249 17.9996 11.9988 18.0219 11.7805 17.9784C11.5623 17.935 11.3618 17.8279 11.2045 17.6706C11.0472 17.5132 10.94 17.3128 10.8966 17.0945C10.8532 16.8763 10.8755 16.6501 10.9606 16.4445C11.0458 16.239 11.19 16.0633 11.375 15.9397C11.56 15.816 11.7775 15.7501 12 15.7501C12.2984 15.7501 12.5845 15.8686 12.7955 16.0796C13.0065 16.2905 13.125 16.5767 13.125 16.8751Z",
              fill: props.color || "currentColor"
            }
          )
        }
      );
    }
  );
  WarningTriangle.displayName = "WarningTriangle";
  var Waveform = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M5.25 9V15C5.25 15.1989 5.17098 15.3897 5.03033 15.5303C4.88968 15.671 4.69891 15.75 4.5 15.75C4.30109 15.75 4.11032 15.671 3.96967 15.5303C3.82902 15.3897 3.75 15.1989 3.75 15V9C3.75 8.80109 3.82902 8.61032 3.96967 8.46967C4.11032 8.32902 4.30109 8.25 4.5 8.25C4.69891 8.25 4.88968 8.32902 5.03033 8.46967C5.17098 8.61032 5.25 8.80109 5.25 9ZM8.25 2.25C8.05109 2.25 7.86032 2.32902 7.71967 2.46967C7.57902 2.61032 7.5 2.80109 7.5 3V21C7.5 21.1989 7.57902 21.3897 7.71967 21.5303C7.86032 21.671 8.05109 21.75 8.25 21.75C8.44891 21.75 8.63968 21.671 8.78033 21.5303C8.92098 21.3897 9 21.1989 9 21V3C9 2.80109 8.92098 2.61032 8.78033 2.46967C8.63968 2.32902 8.44891 2.25 8.25 2.25ZM12 5.25C11.8011 5.25 11.6103 5.32902 11.4697 5.46967C11.329 5.61032 11.25 5.80109 11.25 6V18C11.25 18.1989 11.329 18.3897 11.4697 18.5303C11.6103 18.671 11.8011 18.75 12 18.75C12.1989 18.75 12.3897 18.671 12.5303 18.5303C12.671 18.3897 12.75 18.1989 12.75 18V6C12.75 5.80109 12.671 5.61032 12.5303 5.46967C12.3897 5.32902 12.1989 5.25 12 5.25ZM15.75 8.25C15.5511 8.25 15.3603 8.32902 15.2197 8.46967C15.079 8.61032 15 8.80109 15 9V15C15 15.1989 15.079 15.3897 15.2197 15.5303C15.3603 15.671 15.5511 15.75 15.75 15.75C15.9489 15.75 16.1397 15.671 16.2803 15.5303C16.421 15.3897 16.5 15.1989 16.5 15V9C16.5 8.80109 16.421 8.61032 16.2803 8.46967C16.1397 8.32902 15.9489 8.25 15.75 8.25ZM19.5 6.75C19.3011 6.75 19.1103 6.82902 18.9697 6.96967C18.829 7.11032 18.75 7.30109 18.75 7.5V16.5C18.75 16.6989 18.829 16.8897 18.9697 17.0303C19.1103 17.171 19.3011 17.25 19.5 17.25C19.6989 17.25 19.8897 17.171 20.0303 17.0303C20.171 16.8897 20.25 16.6989 20.25 16.5V7.5C20.25 7.30109 20.171 7.11032 20.0303 6.96967C19.8897 6.82902 19.6989 6.75 19.5 6.75Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  Waveform.displayName = "Waveform";
  var WrenchIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.2587 6.46862C21.2133 6.35617 21.1412 6.25644 21.0487 6.17797C20.9562 6.09951 20.846 6.04465 20.7276 6.0181C20.6093 5.99155 20.4863 5.99411 20.3691 6.02555C20.2519 6.05699 20.1442 6.11638 20.055 6.19862L16.2769 9.68518L14.6616 9.33831L14.3147 7.72299L17.8012 3.94487C17.8835 3.85571 17.9429 3.74793 17.9743 3.63077C18.0058 3.51362 18.0083 3.39058 17.9818 3.27222C17.9552 3.15386 17.9004 3.04371 17.8219 2.95121C17.7434 2.8587 17.6437 2.78661 17.5312 2.74112C16.5065 2.32659 15.3956 2.17007 14.2962 2.28532C13.1968 2.40058 12.1426 2.78407 11.2261 3.4021C10.3096 4.02014 9.55889 4.85381 9.03997 5.82985C8.52105 6.8059 8.24978 7.89445 8.25 8.99987C8.24879 9.93332 8.44028 10.857 8.8125 11.713L3.16781 16.5936C3.15375 16.6049 3.14062 16.618 3.1275 16.6302C2.56482 17.1929 2.24872 17.956 2.24872 18.7517C2.24872 19.1458 2.32632 19.5359 2.47711 19.8999C2.62789 20.2639 2.84889 20.5947 3.1275 20.8733C3.40611 21.1519 3.73686 21.3729 4.10088 21.5237C4.4649 21.6745 4.85505 21.7521 5.24906 21.7521C6.0448 21.7521 6.80795 21.436 7.37062 20.8733C7.38281 20.8611 7.39594 20.8471 7.40719 20.8339L12.2869 15.1874C13.3148 15.6386 14.439 15.8263 15.5577 15.7336C16.6765 15.6408 17.7544 15.2705 18.694 14.6562C19.6335 14.0418 20.405 13.2029 20.9386 12.2152C21.4723 11.2276 21.7511 10.1224 21.75 8.99987C21.7515 8.13229 21.5846 7.27267 21.2587 6.46862ZM15 14.2499C14.1123 14.2487 13.2392 14.0229 12.4622 13.5936C12.3116 13.5105 12.1371 13.4816 11.9678 13.5118C11.7985 13.542 11.6447 13.6295 11.5322 13.7596L6.29156 19.8289C6.00797 20.0984 5.63034 20.2463 5.2392 20.2413C4.84806 20.2363 4.47435 20.0787 4.19774 19.8021C3.92114 19.5255 3.76353 19.1518 3.75853 18.7607C3.75352 18.3695 3.90151 17.9919 4.17094 17.7083L10.2356 12.4686C10.3659 12.3561 10.4536 12.2021 10.4838 12.0326C10.514 11.8631 10.485 11.6883 10.4016 11.5377C9.92346 10.673 9.69909 9.69089 9.75425 8.70435C9.8094 7.71781 10.1418 6.76686 10.7133 5.96082C11.2848 5.15479 12.0722 4.5264 12.9849 4.14788C13.8976 3.76937 14.8986 3.65611 15.8728 3.82112L12.9478 6.99081C12.8664 7.07909 12.8074 7.18563 12.7758 7.30146C12.7441 7.41729 12.7408 7.53903 12.7659 7.65643L13.2966 10.1249C13.3269 10.266 13.3974 10.3955 13.4995 10.4976C13.6016 10.5997 13.731 10.6701 13.8722 10.7005L16.3425 11.2311C16.4599 11.2563 16.5816 11.2529 16.6975 11.2213C16.8133 11.1896 16.9198 11.1306 17.0081 11.0492L20.1778 8.12424C20.3042 8.87706 20.265 9.64838 20.0631 10.3845C19.8612 11.1207 19.5013 11.804 19.0085 12.387C18.5157 12.97 17.9019 13.4386 17.2096 13.7603C16.5174 14.0821 15.7633 14.2491 15 14.2499Z",
            fill: props.color || "currentColor"
          }
        )
      }
    )
  );
  WrenchIcon.displayName = "WrenchIcon";
  var XIcon$1 = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(
        props,
        "XIcon"
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: size2,
          height: size2,
          viewBox: "0 0 24 24",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M19.2806 18.2193C19.3503 18.289 19.4056 18.3717 19.4433 18.4628C19.481 18.5538 19.5004 18.6514 19.5004 18.7499C19.5004 18.8485 19.481 18.9461 19.4433 19.0371C19.4056 19.1281 19.3503 19.2109 19.2806 19.2806C19.2109 19.3502 19.1282 19.4055 19.0372 19.4432C18.9461 19.4809 18.8485 19.5003 18.75 19.5003C18.6514 19.5003 18.5539 19.4809 18.4628 19.4432C18.3718 19.4055 18.289 19.3502 18.2194 19.2806L12 13.0602L5.78061 19.2806C5.63988 19.4213 5.44901 19.5003 5.24999 19.5003C5.05097 19.5003 4.8601 19.4213 4.71936 19.2806C4.57863 19.1398 4.49957 18.949 4.49957 18.7499C4.49957 18.5509 4.57863 18.36 4.71936 18.2193L10.9397 11.9999L4.71936 5.78055C4.57863 5.63982 4.49957 5.44895 4.49957 5.24993C4.49957 5.05091 4.57863 4.86003 4.71936 4.7193C4.8601 4.57857 5.05097 4.49951 5.24999 4.49951C5.44901 4.49951 5.63988 4.57857 5.78061 4.7193L12 10.9396L18.2194 4.7193C18.3601 4.57857 18.551 4.49951 18.75 4.49951C18.949 4.49951 19.1399 4.57857 19.2806 4.7193C19.4213 4.86003 19.5004 5.05091 19.5004 5.24993C19.5004 5.44895 19.4213 5.63982 19.2806 5.78055L13.0603 11.9999L19.2806 18.2193Z",
                fill: restProps.color || "currentColor"
              }
            )
          ]
        }
      );
    }
  );
  XIcon$1.displayName = "XIcon";
  var DownloadIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        ref,
        width: size2,
        height: size2,
        fill: "none",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: "Download" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: props.color || "currentColor", fillOpacity: ".6", d: "M21 13.5v6a.75.75 0 0 1-.75.75H3.75A.75.75 0 0 1 3 19.5v-6a.75.75 0 1 1 1.5 0v5.25h15V13.5a.75.75 0 1 1 1.5 0M8.78 7.282l2.47-2.47v8.69a.75.75 0 1 0 1.5 0V4.81l2.47 2.47a.75.75 0 1 0 1.06-1.061l-3.75-3.75a.75.75 0 0 0-1.06 0L7.72 6.22a.75.75 0 0 0 1.06 1.061" })
        ]
      }
    )
  );
  DownloadIcon.displayName = "DownloadIcon";
  var TextIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: "Text" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: props.color || "currentColor", fillOpacity: ".6", d: "M19.5 5.25v3a.75.75 0 1 1-1.5 0V6h-5.25v12H15a.75.75 0 1 1 0 1.5H9A.75.75 0 1 1 9 18h2.25V6H6v2.25a.75.75 0 0 1-1.5 0v-3a.75.75 0 0 1 .75-.75h13.5a.75.75 0 0 1 .75.75" })
        ]
      }
    )
  );
  TextIcon.displayName = "TextIcon";
  var aep_exports = {};
  __export$1(aep_exports, {
    AEP: () => AEP$1
  });
  var AEP$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5101)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M14.0932 65H10.7977L15.819 50.4545H19.7821L24.7963 65H21.5009L17.8574 53.7784H17.7437L14.0932 65ZM13.8872 59.2827H21.6713V61.6832H13.8872V59.2827ZM26.147 65V50.4545H35.9482V52.9901H29.2223V56.456H35.4439V58.9915H29.2223V62.4645H35.9766V65H26.147ZM37.9931 65V50.4545H43.7317C44.835 50.4545 45.7748 50.6652 46.5514 51.0866C47.3279 51.5033 47.9197 52.0833 48.3269 52.8267C48.7389 53.5653 48.9448 54.4176 48.9448 55.3835C48.9448 56.3494 48.7365 57.2017 48.3198 57.9403C47.9031 58.679 47.2995 59.2543 46.5087 59.6662C45.7228 60.0781 44.771 60.2841 43.6536 60.2841H39.996V57.8196H43.1565C43.7483 57.8196 44.236 57.7178 44.6195 57.5142C45.0078 57.3059 45.2966 57.0194 45.486 56.6548C45.6801 56.2855 45.7772 55.8617 45.7772 55.3835C45.7772 54.9006 45.6801 54.4792 45.486 54.1193C45.2966 53.7547 45.0078 53.473 44.6195 53.2741C44.2313 53.0705 43.7388 52.9688 43.1423 52.9688H41.0684V65H37.9931Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5101", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  AEP$1.displayName = "AEP";
  var ai_exports = {};
  __export$1(ai_exports, {
    AI: () => AI$1
  });
  var AI$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5079)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#FF5C00"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M24.1881 65H20.8926L25.914 50.4545H29.877L34.8912 65H31.5958L27.9523 53.7784H27.8387L24.1881 65ZM23.9821 59.2827H31.7662V61.6832H23.9821V59.2827ZM39.3172 50.4545V65H36.2419V50.4545H39.3172Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5079", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  AI$1.displayName = "AI";
  var avi_exports = {};
  __export$1(avi_exports, {
    AVI: () => AVI$1
  });
  var AVI$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5095)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M17.8158 65H14.5204L19.5417 50.4545H23.5048L28.519 65H25.2235L21.58 53.7784H21.4664L17.8158 65ZM17.6099 59.2827H25.394V61.6832H17.6099V59.2827ZM30.6811 50.4545L34.1967 61.5057H34.3317L37.8544 50.4545H41.2635L36.2493 65H32.2862L27.2649 50.4545H30.6811ZM45.6895 50.4545V65H42.6142V50.4545H45.6895Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5095", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  AVI$1.displayName = "AVI";
  var blend_exports = {};
  __export$1(blend_exports, {
    Blend: () => Blend$1
  });
  var Blend$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5094)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#FF8A00"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M5.22168 64V52.3636H9.88077C10.7368 52.3636 11.4508 52.4905 12.0228 52.7443C12.5948 52.9981 13.0247 53.3504 13.3126 53.8011C13.6005 54.2481 13.7444 54.7633 13.7444 55.3466C13.7444 55.8011 13.6535 56.2008 13.4717 56.5455C13.2899 56.8864 13.0399 57.1667 12.7217 57.3864C12.4073 57.6023 12.0474 57.7557 11.6421 57.8466V57.9602C12.0853 57.9792 12.5001 58.1042 12.8864 58.3352C13.2766 58.5663 13.5929 58.8902 13.8353 59.3068C14.0777 59.7197 14.1989 60.2121 14.1989 60.7841C14.1989 61.4015 14.0455 61.9527 13.7387 62.4375C13.4357 62.9186 12.9868 63.2992 12.3921 63.5795C11.7974 63.8598 11.0645 64 10.1933 64H5.22168ZM7.6819 61.9886H9.68758C10.3732 61.9886 10.8732 61.858 11.1876 61.5966C11.502 61.3314 11.6592 60.9792 11.6592 60.5398C11.6592 60.2178 11.5815 59.9337 11.4262 59.6875C11.2709 59.4413 11.0493 59.2481 10.7614 59.108C10.4774 58.9678 10.1383 58.8977 9.7444 58.8977H7.6819V61.9886ZM7.6819 57.233H9.50577C9.84289 57.233 10.1421 57.1742 10.4035 57.0568C10.6686 56.9356 10.877 56.7652 11.0285 56.5455C11.1838 56.3258 11.2614 56.0625 11.2614 55.7557C11.2614 55.3352 11.1118 54.9962 10.8126 54.7386C10.5171 54.4811 10.0967 54.3523 9.55122 54.3523H7.6819V57.233ZM15.4798 64V52.3636H17.94V61.9716H22.9287V64H15.4798ZM24.2379 64V52.3636H32.0788V54.392H26.6982V57.1648H31.6754V59.1932H26.6982V61.9716H32.1016V64H24.2379ZM43.4478 52.3636V64H41.3228L36.2603 56.6761H36.175V64H33.7148V52.3636H35.8739L40.8966 59.6818H40.9989V52.3636H43.4478ZM49.2854 64H45.1604V52.3636H49.3195C50.49 52.3636 51.4975 52.5966 52.3422 53.0625C53.1869 53.5246 53.8366 54.1894 54.2911 55.0568C54.7494 55.9242 54.9786 56.9621 54.9786 58.1705C54.9786 59.3826 54.7494 60.4242 54.2911 61.2955C53.8366 62.1667 53.1832 62.8352 52.3309 63.3011C51.4824 63.767 50.4672 64 49.2854 64ZM47.6207 61.892H49.1832C49.9104 61.892 50.5222 61.7633 51.0184 61.5057C51.5184 61.2443 51.8934 60.8409 52.1434 60.2955C52.3972 59.7462 52.5241 59.0379 52.5241 58.1705C52.5241 57.3106 52.3972 56.608 52.1434 56.0625C51.8934 55.517 51.5203 55.1155 51.0241 54.858C50.5279 54.6004 49.9161 54.4716 49.1888 54.4716H47.6207V61.892Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5094", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Blend$1.displayName = "Blend";
  var c4d_exports = {};
  __export$1(c4d_exports, {
    C4D: () => C4D$1
  });
  var C4D$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5096)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#344054"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M23.4257 55.5469H20.315C20.2581 55.1444 20.1421 54.7869 19.9669 54.4744C19.7917 54.1572 19.5668 53.8873 19.2922 53.6648C19.0176 53.4422 18.7004 53.2718 18.3405 53.1534C17.9854 53.035 17.5995 52.9759 17.1828 52.9759C16.43 52.9759 15.7742 53.1629 15.2155 53.5369C14.6568 53.9062 14.2236 54.446 13.9158 55.1562C13.608 55.8617 13.4542 56.7187 13.4542 57.7273C13.4542 58.7642 13.608 59.6354 13.9158 60.3409C14.2283 61.0464 14.6639 61.5791 15.2226 61.9389C15.7813 62.2988 16.4276 62.4787 17.1615 62.4787C17.5735 62.4787 17.9546 62.4242 18.305 62.3153C18.6601 62.2064 18.975 62.0478 19.2496 61.8395C19.5242 61.6264 19.7515 61.3684 19.9314 61.0653C20.1161 60.7623 20.2439 60.4167 20.315 60.0284L23.4257 60.0426C23.3453 60.7102 23.144 61.3542 22.8221 61.9744C22.5048 62.59 22.0763 63.1416 21.5365 63.6293C21.0015 64.1122 20.3623 64.4957 19.6189 64.7798C18.8803 65.0592 18.0446 65.1989 17.1118 65.1989C15.8145 65.1989 14.6544 64.9053 13.6317 64.3182C12.6137 63.7311 11.8088 62.8812 11.2169 61.7685C10.6298 60.6558 10.3363 59.3087 10.3363 57.7273C10.3363 56.1411 10.6346 54.7917 11.2311 53.679C11.8277 52.5663 12.6374 51.7187 13.6601 51.1364C14.6828 50.5492 15.8334 50.2557 17.1118 50.2557C17.9546 50.2557 18.7359 50.3741 19.4556 50.6108C20.18 50.8475 20.8216 51.1932 21.3803 51.6477C21.939 52.0975 22.3935 52.6491 22.7439 53.3026C23.099 53.956 23.3263 54.7041 23.4257 55.5469ZM24.9256 62.4432V60.0213L30.998 50.4545H33.0861V53.8068H31.8503L28.0222 59.8651V59.9787H36.6515V62.4432H24.9256ZM31.9071 65V61.7045L31.964 60.6321V50.4545H34.8475V65H31.9071ZM43.5419 65H38.3857V50.4545H43.5846C45.0476 50.4545 46.3071 50.7457 47.363 51.3281C48.4188 51.9058 49.2309 52.7367 49.799 53.821C50.372 54.9053 50.6584 56.2027 50.6584 57.7131C50.6584 59.2282 50.372 60.5303 49.799 61.6193C49.2309 62.7083 48.4141 63.544 47.3488 64.1264C46.2882 64.7088 45.0192 65 43.5419 65ZM41.461 62.3651H43.4141C44.3232 62.3651 45.0879 62.2041 45.7081 61.8821C46.3331 61.5554 46.8019 61.0511 47.1144 60.3693C47.4316 59.6828 47.5902 58.7973 47.5902 57.7131C47.5902 56.6383 47.4316 55.7599 47.1144 55.0781C46.8019 54.3963 46.3355 53.8944 45.7152 53.5724C45.095 53.2505 44.3303 53.0895 43.4212 53.0895H41.461V62.3651Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5096", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  C4D$1.displayName = "C4D";
  var cdr_exports = {};
  __export$1(cdr_exports, {
    CDR: () => CDR$1
  });
  var CDR$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5098)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M23.1406 55.5469H20.0298C19.973 55.1444 19.857 54.7869 19.6818 54.4744C19.5066 54.1572 19.2817 53.8873 19.0071 53.6648C18.7324 53.4422 18.4152 53.2718 18.0554 53.1534C17.7002 53.035 17.3144 52.9759 16.8977 52.9759C16.1449 52.9759 15.4891 53.1629 14.9304 53.5369C14.3717 53.9062 13.9384 54.446 13.6306 55.1562C13.3229 55.8617 13.169 56.7187 13.169 57.7273C13.169 58.7642 13.3229 59.6354 13.6306 60.3409C13.9431 61.0464 14.3788 61.5791 14.9375 61.9389C15.4962 62.2988 16.1425 62.4787 16.8764 62.4787C17.2883 62.4787 17.6695 62.4242 18.0199 62.3153C18.375 62.2064 18.6898 62.0478 18.9645 61.8395C19.2391 61.6264 19.4663 61.3684 19.6463 61.0653C19.8309 60.7623 19.9588 60.4167 20.0298 60.0284L23.1406 60.0426C23.0601 60.7102 22.8589 61.3542 22.5369 61.9744C22.2197 62.59 21.7912 63.1416 21.2514 63.6293C20.7163 64.1122 20.0771 64.4957 19.3338 64.7798C18.5951 65.0592 17.7594 65.1989 16.8267 65.1989C15.5293 65.1989 14.3693 64.9053 13.3466 64.3182C12.3286 63.7311 11.5236 62.8812 10.9318 61.7685C10.3447 60.6558 10.0511 59.3087 10.0511 57.7273C10.0511 56.1411 10.3494 54.7917 10.946 53.679C11.5426 52.5663 12.3522 51.7187 13.375 51.1364C14.3977 50.5492 15.5483 50.2557 16.8267 50.2557C17.6695 50.2557 18.4507 50.3741 19.1704 50.6108C19.8949 50.8475 20.5364 51.1932 21.0951 51.6477C21.6538 52.0975 22.1084 52.6491 22.4588 53.3026C22.8139 53.956 23.0412 54.7041 23.1406 55.5469ZM30.1021 65H24.9458V50.4545H30.1447C31.6078 50.4545 32.8672 50.7457 33.9231 51.3281C34.979 51.9058 35.791 52.7367 36.3592 53.821C36.9321 54.9053 37.2186 56.2027 37.2186 57.7131C37.2186 59.2282 36.9321 60.5303 36.3592 61.6193C35.791 62.7083 34.9743 63.544 33.9089 64.1264C32.8483 64.7088 31.5794 65 30.1021 65ZM28.0211 62.3651H29.9743C30.8833 62.3651 31.648 62.2041 32.2683 61.8821C32.8933 61.5554 33.362 61.0511 33.6745 60.3693C33.9918 59.6828 34.1504 58.7973 34.1504 57.7131C34.1504 56.6383 33.9918 55.7599 33.6745 55.0781C33.362 54.3963 32.8957 53.8944 32.2754 53.5724C31.6551 53.2505 30.8904 53.0895 29.9814 53.0895H28.0211V62.3651ZM39.0966 65V50.4545H44.8353C45.9337 50.4545 46.8712 50.651 47.6478 51.044C48.429 51.4323 49.0232 51.9839 49.4304 52.6989C49.8424 53.4091 50.0483 54.2448 50.0483 55.206C50.0483 56.1719 49.84 57.0028 49.4233 57.6989C49.0067 58.3902 48.403 58.9205 47.6123 59.2898C46.8263 59.6591 45.8746 59.8438 44.7571 59.8438H40.9148V57.3722H44.26C44.8471 57.3722 45.3348 57.2917 45.723 57.1307C46.1113 56.9697 46.4001 56.7282 46.5895 56.4062C46.7837 56.0843 46.8807 55.6842 46.8807 55.206C46.8807 54.723 46.7837 54.3158 46.5895 53.9844C46.4001 53.6529 46.1089 53.402 45.7159 53.2315C45.3277 53.0563 44.8376 52.9688 44.2458 52.9688H42.1719V65H39.0966ZM46.9517 58.3807L50.5668 65H47.1719L43.635 58.3807H46.9517Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5098", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  CDR$1.displayName = "CDR";
  var css_exports = {};
  __export$1(css_exports, {
    CSS: () => CSS$2
  });
  var CSS$2 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5071)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M24.373 55.5469H21.2622C21.2054 55.1444 21.0894 54.7869 20.9142 54.4744C20.739 54.1572 20.5141 53.8873 20.2395 53.6648C19.9649 53.4422 19.6476 53.2718 19.2878 53.1534C18.9327 53.035 18.5468 52.9759 18.1301 52.9759C17.3773 52.9759 16.7215 53.1629 16.1628 53.5369C15.6041 53.9062 15.1708 54.446 14.8631 55.1562C14.5553 55.8617 14.4014 56.7187 14.4014 57.7273C14.4014 58.7642 14.5553 59.6354 14.8631 60.3409C15.1756 61.0464 15.6112 61.5791 16.1699 61.9389C16.7286 62.2988 17.3749 62.4787 18.1088 62.4787C18.5207 62.4787 18.9019 62.4242 19.2523 62.3153C19.6074 62.2064 19.9223 62.0478 20.1969 61.8395C20.4715 61.6264 20.6988 61.3684 20.8787 61.0653C21.0634 60.7623 21.1912 60.4167 21.2622 60.0284L24.373 60.0426C24.2925 60.7102 24.0913 61.3542 23.7693 61.9744C23.4521 62.59 23.0236 63.1416 22.4838 63.6293C21.9488 64.1122 21.3096 64.4957 20.5662 64.7798C19.8276 65.0592 18.9919 65.1989 18.0591 65.1989C16.7617 65.1989 15.6017 64.9053 14.579 64.3182C13.561 63.7311 12.7561 62.8812 12.1642 61.7685C11.5771 60.6558 11.2835 59.3087 11.2835 57.7273C11.2835 56.1411 11.5818 54.7917 12.1784 53.679C12.775 52.5663 13.5847 51.7187 14.6074 51.1364C15.6301 50.5492 16.7807 50.2557 18.0591 50.2557C18.9019 50.2557 19.6831 50.3741 20.4028 50.6108C21.1273 50.8475 21.7688 51.1932 22.3276 51.6477C22.8863 52.0975 23.3408 52.6491 23.6912 53.3026C24.0463 53.956 24.2736 54.7041 24.373 55.5469ZM34.0689 54.6378C34.0121 54.0649 33.7682 53.6198 33.3374 53.3026C32.9065 52.9853 32.3217 52.8267 31.5831 52.8267C31.0812 52.8267 30.6574 52.8977 30.3118 53.0398C29.9661 53.1771 29.701 53.3688 29.5163 53.6151C29.3364 53.8613 29.2464 54.1406 29.2464 54.4531C29.237 54.7135 29.2914 54.9408 29.4098 55.1349C29.5329 55.3291 29.701 55.4972 29.9141 55.6392C30.1271 55.7765 30.3733 55.8973 30.6527 56.0014C30.9321 56.1009 31.2304 56.1861 31.5476 56.2571L32.8544 56.5696C33.4889 56.7116 34.0713 56.901 34.6016 57.1378C35.1319 57.3745 35.5911 57.6657 35.9794 58.0114C36.3677 58.357 36.6683 58.7642 36.8814 59.233C37.0992 59.7017 37.2105 60.2391 37.2152 60.8452C37.2105 61.7353 36.9832 62.5071 36.5334 63.1605C36.0883 63.8092 35.4444 64.3134 34.6016 64.6733C33.7635 65.0284 32.7526 65.206 31.5689 65.206C30.3946 65.206 29.3719 65.026 28.5007 64.6662C27.6342 64.3063 26.9571 63.7737 26.4695 63.0682C25.9865 62.358 25.7332 61.4796 25.7095 60.4332H28.6854C28.7185 60.9209 28.8582 61.3281 29.1044 61.6548C29.3554 61.9768 29.6892 62.2206 30.1058 62.3864C30.5272 62.5473 31.0031 62.6278 31.5334 62.6278C32.0542 62.6278 32.5064 62.5521 32.8899 62.4006C33.2782 62.2491 33.5788 62.0384 33.7919 61.7685C34.005 61.4986 34.1115 61.1884 34.1115 60.8381C34.1115 60.5114 34.0144 60.2367 33.8203 60.0142C33.6309 59.7917 33.3516 59.6023 32.9822 59.446C32.6177 59.2898 32.1702 59.1477 31.6399 59.0199L30.0561 58.6222C28.8298 58.3239 27.8615 57.8575 27.1513 57.223C26.4411 56.5885 26.0883 55.7339 26.093 54.6591C26.0883 53.7784 26.3227 53.009 26.7962 52.3509C27.2744 51.6927 27.9302 51.179 28.7635 50.8097C29.5968 50.4403 30.5438 50.2557 31.6044 50.2557C32.6839 50.2557 33.6262 50.4403 34.4311 50.8097C35.2408 51.179 35.8705 51.6927 36.3203 52.3509C36.7701 53.009 37.0021 53.7713 37.0163 54.6378H34.0689ZM46.7744 54.6378C46.7175 54.0649 46.4737 53.6198 46.0428 53.3026C45.612 52.9853 45.0272 52.8267 44.2886 52.8267C43.7867 52.8267 43.3629 52.8977 43.0173 53.0398C42.6716 53.1771 42.4065 53.3688 42.2218 53.6151C42.0419 53.8613 41.9519 54.1406 41.9519 54.4531C41.9424 54.7135 41.9969 54.9408 42.1153 55.1349C42.2384 55.3291 42.4065 55.4972 42.6195 55.6392C42.8326 55.7765 43.0788 55.8973 43.3582 56.0014C43.6375 56.1009 43.9358 56.1861 44.2531 56.2571L45.5599 56.5696C46.1943 56.7116 46.7767 56.901 47.307 57.1378C47.8373 57.3745 48.2966 57.6657 48.6849 58.0114C49.0731 58.357 49.3738 58.7642 49.5869 59.233C49.8047 59.7017 49.9159 60.2391 49.9207 60.8452C49.9159 61.7353 49.6887 62.5071 49.2389 63.1605C48.7938 63.8092 48.1498 64.3134 47.307 64.6733C46.469 65.0284 45.4581 65.206 44.2744 65.206C43.1001 65.206 42.0774 65.026 41.2062 64.6662C40.3397 64.3063 39.6626 63.7737 39.1749 63.0682C38.692 62.358 38.4387 61.4796 38.415 60.4332H41.3908C41.424 60.9209 41.5637 61.3281 41.8099 61.6548C42.0608 61.9768 42.3946 62.2206 42.8113 62.3864C43.2327 62.5473 43.7085 62.6278 44.2388 62.6278C44.7597 62.6278 45.2119 62.5521 45.5954 62.4006C45.9836 62.2491 46.2843 62.0384 46.4974 61.7685C46.7104 61.4986 46.817 61.1884 46.817 60.8381C46.817 60.5114 46.7199 60.2367 46.5258 60.0142C46.3364 59.7917 46.057 59.6023 45.6877 59.446C45.3231 59.2898 44.8757 59.1477 44.3454 59.0199L42.7616 58.6222C41.5353 58.3239 40.567 57.8575 39.8567 57.223C39.1465 56.5885 38.7938 55.7339 38.7985 54.6591C38.7938 53.7784 39.0281 53.009 39.5016 52.3509C39.9799 51.6927 40.6356 51.179 41.469 50.8097C42.3023 50.4403 43.2493 50.2557 44.3099 50.2557C45.3894 50.2557 46.3317 50.4403 47.1366 50.8097C47.9462 51.179 48.576 51.6927 49.0258 52.3509C49.4756 53.009 49.7076 53.7713 49.7218 54.6378H46.7744Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5071", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  CSS$2.displayName = "CSS";
  var csv_exports = {};
  __export$1(csv_exports, {
    CSV: () => CSV$1
  });
  var CSV$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5075)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M23.4453 55.5469H20.3345C20.2777 55.1444 20.1617 54.7869 19.9865 54.4744C19.8113 54.1572 19.5864 53.8873 19.3118 53.6648C19.0371 53.4422 18.7199 53.2718 18.36 53.1534C18.0049 53.035 17.619 52.9759 17.2024 52.9759C16.4495 52.9759 15.7938 53.1629 15.235 53.5369C14.6763 53.9062 14.2431 54.446 13.9353 55.1562C13.6276 55.8617 13.4737 56.7187 13.4737 57.7273C13.4737 58.7642 13.6276 59.6354 13.9353 60.3409C14.2478 61.0464 14.6834 61.5791 15.2422 61.9389C15.8009 62.2988 16.4472 62.4787 17.1811 62.4787C17.593 62.4787 17.9742 62.4242 18.3245 62.3153C18.6797 62.2064 18.9945 62.0478 19.2691 61.8395C19.5438 61.6264 19.771 61.3684 19.951 61.0653C20.1356 60.7623 20.2635 60.4167 20.3345 60.0284L23.4453 60.0426C23.3648 60.7102 23.1636 61.3542 22.8416 61.9744C22.5243 62.59 22.0958 63.1416 21.5561 63.6293C21.021 64.1122 20.3818 64.4957 19.6385 64.7798C18.8998 65.0592 18.0641 65.1989 17.1314 65.1989C15.834 65.1989 14.674 64.9053 13.6512 64.3182C12.6333 63.7311 11.8283 62.8812 11.2365 61.7685C10.6493 60.6558 10.3558 59.3087 10.3558 57.7273C10.3558 56.1411 10.6541 54.7917 11.2507 53.679C11.8473 52.5663 12.6569 51.7187 13.6797 51.1364C14.7024 50.5492 15.8529 50.2557 17.1314 50.2557C17.9742 50.2557 18.7554 50.3741 19.4751 50.6108C20.1995 50.8475 20.8411 51.1932 21.3998 51.6477C21.9585 52.0975 22.4131 52.6491 22.7635 53.3026C23.1186 53.956 23.3458 54.7041 23.4453 55.5469ZM33.1412 54.6378C33.0843 54.0649 32.8405 53.6198 32.4096 53.3026C31.9788 52.9853 31.394 52.8267 30.6554 52.8267C30.1535 52.8267 29.7297 52.8977 29.3841 53.0398C29.0384 53.1771 28.7733 53.3688 28.5886 53.6151C28.4087 53.8613 28.3187 54.1406 28.3187 54.4531C28.3092 54.7135 28.3637 54.9408 28.4821 55.1349C28.6052 55.3291 28.7733 55.4972 28.9863 55.6392C29.1994 55.7765 29.4456 55.8973 29.725 56.0014C30.0043 56.1009 30.3026 56.1861 30.6199 56.2571L31.9267 56.5696C32.5611 56.7116 33.1435 56.901 33.6738 57.1378C34.2041 57.3745 34.6634 57.6657 35.0517 58.0114C35.4399 58.357 35.7406 58.7642 35.9537 59.233C36.1715 59.7017 36.2827 60.2391 36.2875 60.8452C36.2827 61.7353 36.0555 62.5071 35.6056 63.1605C35.1606 63.8092 34.5166 64.3134 33.6738 64.6733C32.8358 65.0284 31.8249 65.206 30.6412 65.206C29.4669 65.206 28.4442 65.026 27.573 64.6662C26.7065 64.3063 26.0294 63.7737 25.5417 63.0682C25.0588 62.358 24.8055 61.4796 24.7818 60.4332H27.7576C27.7908 60.9209 27.9305 61.3281 28.1767 61.6548C28.4276 61.9768 28.7614 62.2206 29.1781 62.3864C29.5995 62.5473 30.0753 62.6278 30.6056 62.6278C31.1265 62.6278 31.5787 62.5521 31.9622 62.4006C32.3504 62.2491 32.6511 62.0384 32.8642 61.7685C33.0772 61.4986 33.1838 61.1884 33.1838 60.8381C33.1838 60.5114 33.0867 60.2367 32.8926 60.0142C32.7032 59.7917 32.4238 59.6023 32.0545 59.446C31.6899 59.2898 31.2425 59.1477 30.7122 59.0199L29.1284 58.6222C27.902 58.3239 26.9338 57.8575 26.2235 57.223C25.5133 56.5885 25.1606 55.7339 25.1653 54.6591C25.1606 53.7784 25.3949 53.009 25.8684 52.3509C26.3467 51.6927 27.0024 51.179 27.8358 50.8097C28.6691 50.4403 29.6161 50.2557 30.6767 50.2557C31.7562 50.2557 32.6984 50.4403 33.5034 50.8097C34.313 51.179 34.9428 51.6927 35.3926 52.3509C35.8424 53.009 36.0744 53.7713 36.0886 54.6378H33.1412ZM40.5838 50.4545L44.0995 61.5057H44.2344L47.7571 50.4545H51.1662L46.152 65H42.189L37.1676 50.4545H40.5838Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5075", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  CSV$1.displayName = "CSV";
  var dmg_exports = {};
  __export$1(dmg_exports, {
    DMG: () => DMG$1
  });
  var DMG$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5091)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.7873 65H7.631V50.4545H12.8299C14.2929 50.4545 15.5524 50.7457 16.6083 51.3281C17.6641 51.9058 18.4762 52.7367 19.0444 53.821C19.6173 54.9053 19.9037 56.2027 19.9037 57.7131C19.9037 59.2282 19.6173 60.5303 19.0444 61.6193C18.4762 62.7083 17.6594 63.544 16.5941 64.1264C15.5335 64.7088 14.2645 65 12.7873 65ZM10.7063 62.3651H12.6594C13.5685 62.3651 14.3332 62.2041 14.9534 61.8821C15.5784 61.5554 16.0472 61.0511 16.3597 60.3693C16.6769 59.6828 16.8355 58.7973 16.8355 57.7131C16.8355 56.6383 16.6769 55.7599 16.3597 55.0781C16.0472 54.3963 15.5808 53.8944 14.9605 53.5724C14.3403 53.2505 13.5756 53.0895 12.6665 53.0895H10.7063V62.3651ZM21.7818 50.4545H25.5744L29.5801 60.2273H29.7505L33.7562 50.4545H37.5488V65H34.5659V55.5327H34.4451L30.6809 64.929H28.6497L24.8855 55.4972H24.7647V65H21.7818V50.4545ZM49.3274 55.1562C49.228 54.8106 49.0883 54.5052 48.9084 54.2401C48.7285 53.9702 48.5083 53.7429 48.2479 53.5582C47.9922 53.3688 47.6987 53.2244 47.3672 53.125C47.0405 53.0256 46.6783 52.9759 46.2806 52.9759C45.5372 52.9759 44.8838 53.1605 44.3203 53.5298C43.7616 53.8991 43.326 54.4366 43.0135 55.142C42.701 55.8428 42.5448 56.6998 42.5448 57.7131C42.5448 58.7263 42.6987 59.5881 43.0064 60.2983C43.3142 61.0085 43.7498 61.5507 44.3132 61.9247C44.8767 62.294 45.5419 62.4787 46.309 62.4787C47.005 62.4787 47.5992 62.3556 48.0917 62.1094C48.5888 61.8584 48.9676 61.5057 49.228 61.0511C49.4932 60.5966 49.6257 60.0592 49.6257 59.4389L50.2507 59.5312H46.5007V57.2159H52.5874V59.0483C52.5874 60.3267 52.3175 61.4252 51.7777 62.3438C51.238 63.2576 50.4946 63.9631 49.5476 64.4602C48.6006 64.9527 47.5164 65.1989 46.2948 65.1989C44.9311 65.1989 43.7332 64.8982 42.701 64.2969C41.6688 63.6908 40.8639 62.8314 40.2863 61.7188C39.7133 60.6013 39.4269 59.2756 39.4269 57.7415C39.4269 56.5625 39.5973 55.5114 39.9382 54.5881C40.2839 53.66 40.7668 52.8741 41.3871 52.2301C42.0074 51.5862 42.7294 51.0961 43.5533 50.7599C44.3772 50.4238 45.2697 50.2557 46.2309 50.2557C47.0547 50.2557 47.8218 50.3764 48.532 50.6179C49.2422 50.8546 49.872 51.1908 50.4212 51.6264C50.9752 52.062 51.4274 52.5805 51.7777 53.1818C52.1281 53.7784 52.353 54.4366 52.4524 55.1562H49.3274Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5091", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  DMG$1.displayName = "DMG";
  var doc_exports = {};
  __export$1(doc_exports, {
    DOC: () => DOC$1
  });
  var DOC$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5078)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M14.7033 65H9.54702V50.4545H14.7459C16.2089 50.4545 17.4684 50.7457 18.5243 51.3281C19.5802 51.9058 20.3922 52.7367 20.9604 53.821C21.5333 54.9053 21.8197 56.2027 21.8197 57.7131C21.8197 59.2282 21.5333 60.5303 20.9604 61.6193C20.3922 62.7083 19.5754 63.544 18.5101 64.1264C17.4495 64.7088 16.1805 65 14.7033 65ZM12.6223 62.3651H14.5754C15.4845 62.3651 16.2492 62.2041 16.8695 61.8821C17.4945 61.5554 17.9632 61.0511 18.2757 60.3693C18.5929 59.6828 18.7516 58.7973 18.7516 57.7131C18.7516 56.6383 18.5929 55.7599 18.2757 55.0781C17.9632 54.3963 17.4968 53.8944 16.8766 53.5724C16.2563 53.2505 15.4916 53.0895 14.5825 53.0895H12.6223V62.3651ZM37.0643 57.7273C37.0643 59.3134 36.7636 60.6629 36.1623 61.7756C35.5657 62.8883 34.7513 63.7382 33.7191 64.3253C32.6916 64.9077 31.5363 65.1989 30.2532 65.1989C28.9606 65.1989 27.8005 64.9053 26.7731 64.3182C25.7456 63.7311 24.9336 62.8812 24.337 61.7685C23.7404 60.6558 23.4421 59.3087 23.4421 57.7273C23.4421 56.1411 23.7404 54.7917 24.337 53.679C24.9336 52.5663 25.7456 51.7187 26.7731 51.1364C27.8005 50.5492 28.9606 50.2557 30.2532 50.2557C31.5363 50.2557 32.6916 50.5492 33.7191 51.1364C34.7513 51.7187 35.5657 52.5663 36.1623 53.679C36.7636 54.7917 37.0643 56.1411 37.0643 57.7273ZM33.9464 57.7273C33.9464 56.6998 33.7925 55.8333 33.4847 55.1278C33.1817 54.4223 32.7532 53.8873 32.1992 53.5227C31.6452 53.1581 30.9966 52.9759 30.2532 52.9759C29.5098 52.9759 28.8612 53.1581 28.3072 53.5227C27.7532 53.8873 27.3223 54.4223 27.0146 55.1278C26.7115 55.8333 26.56 56.6998 26.56 57.7273C26.56 58.7547 26.7115 59.6212 27.0146 60.3267C27.3223 61.0322 27.7532 61.5672 28.3072 61.9318C28.8612 62.2964 29.5098 62.4787 30.2532 62.4787C30.9966 62.4787 31.6452 62.2964 32.1992 61.9318C32.7532 61.5672 33.1817 61.0322 33.4847 60.3267C33.7925 59.6212 33.9464 58.7547 33.9464 57.7273ZM51.7761 55.5469H48.6653C48.6085 55.1444 48.4925 54.7869 48.3173 54.4744C48.1421 54.1572 47.9172 53.8873 47.6426 53.6648C47.368 53.4422 47.0508 53.2718 46.6909 53.1534C46.3358 53.035 45.9499 52.9759 45.5332 52.9759C44.7804 52.9759 44.1246 53.1629 43.5659 53.5369C43.0072 53.9062 42.574 54.446 42.2662 55.1562C41.9584 55.8617 41.8045 56.7187 41.8045 57.7273C41.8045 58.7642 41.9584 59.6354 42.2662 60.3409C42.5787 61.0464 43.0143 61.5791 43.573 61.9389C44.1317 62.2988 44.778 62.4787 45.5119 62.4787C45.9239 62.4787 46.305 62.4242 46.6554 62.3153C47.0105 62.2064 47.3254 62.0478 47.6 61.8395C47.8746 61.6264 48.1019 61.3684 48.2818 61.0653C48.4665 60.7623 48.5943 60.4167 48.6653 60.0284L51.7761 60.0426C51.6956 60.7102 51.4944 61.3542 51.1724 61.9744C50.8552 62.59 50.4267 63.1416 49.8869 63.6293C49.3519 64.1122 48.7127 64.4957 47.9693 64.7798C47.2307 65.0592 46.395 65.1989 45.4622 65.1989C44.1649 65.1989 43.0048 64.9053 41.9821 64.3182C40.9641 63.7311 40.1592 62.8812 39.5673 61.7685C38.9802 60.6558 38.6866 59.3087 38.6866 57.7273C38.6866 56.1411 38.9849 54.7917 39.5815 53.679C40.1781 52.5663 40.9878 51.7187 42.0105 51.1364C43.0332 50.5492 44.1838 50.2557 45.4622 50.2557C46.305 50.2557 47.0863 50.3741 47.806 50.6108C48.5304 50.8475 49.172 51.1932 49.7307 51.6477C50.2894 52.0975 50.7439 52.6491 51.0943 53.3026C51.4494 53.956 51.6767 54.7041 51.7761 55.5469Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5078", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  DOC$1.displayName = "DOC";
  var exe_exports = {};
  __export$1(exe_exports, {
    EXE: () => EXE$1
  });
  var EXE$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5082)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.2697 65V50.4545H22.0708V52.9901H15.345V56.456H21.5665V58.9915H15.345V62.4645H22.0992V65H12.2697ZM26.9993 50.4545L29.9325 55.4119H30.0462L32.9936 50.4545H36.4666L32.0277 57.7273L36.5661 65H33.0291L30.0462 60.0355H29.9325L26.9496 65H23.4268L27.9794 57.7273L23.5121 50.4545H26.9993ZM38.0126 65V50.4545H47.8138V52.9901H41.0879V56.456H47.3095V58.9915H41.0879V62.4645H47.8422V65H38.0126Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5082", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  EXE$1.displayName = "EXE";
  var fig_exports = {};
  __export$1(fig_exports, {
    Fig: () => Fig$1
  });
  var Fig$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5083)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M15.4044 65V50.4545H25.0351V52.9901H18.4797V56.456H24.3959V58.9915H18.4797V65H15.4044ZM29.7789 50.4545V65H26.7037V50.4545H29.7789ZM41.554 55.1562C41.4546 54.8106 41.3149 54.5052 41.135 54.2401C40.9551 53.9702 40.7349 53.7429 40.4745 53.5582C40.2188 53.3688 39.9252 53.2244 39.5938 53.125C39.2671 53.0256 38.9049 52.9759 38.5071 52.9759C37.7638 52.9759 37.1104 53.1605 36.5469 53.5298C35.9882 53.8991 35.5526 54.4366 35.2401 55.142C34.9276 55.8428 34.7713 56.6998 34.7713 57.7131C34.7713 58.7263 34.9252 59.5881 35.233 60.2983C35.5408 61.0085 35.9764 61.5507 36.5398 61.9247C37.1033 62.294 37.7685 62.4787 38.5355 62.4787C39.2316 62.4787 39.8258 62.3556 40.3182 62.1094C40.8154 61.8584 41.1942 61.5057 41.4546 61.0511C41.7197 60.5966 41.8523 60.0592 41.8523 59.4389L42.4773 59.5312H38.7273V57.2159H44.814V59.0483C44.814 60.3267 44.5441 61.4252 44.0043 62.3438C43.4645 63.2576 42.7212 63.9631 41.7742 64.4602C40.8272 64.9527 39.7429 65.1989 38.5213 65.1989C37.1577 65.1989 35.9598 64.8982 34.9276 64.2969C33.8954 63.6908 33.0905 62.8314 32.5128 61.7188C31.9399 60.6013 31.6534 59.2756 31.6534 57.7415C31.6534 56.5625 31.8239 55.5114 32.1648 54.5881C32.5105 53.66 32.9934 52.8741 33.6137 52.2301C34.2339 51.5862 34.956 51.0961 35.7799 50.7599C36.6037 50.4238 37.4962 50.2557 38.4574 50.2557C39.2813 50.2557 40.0483 50.3764 40.7586 50.6179C41.4688 50.8546 42.0985 51.1908 42.6478 51.6264C43.2017 52.062 43.6539 52.5805 44.0043 53.1818C44.3547 53.7784 44.5796 54.4366 44.679 55.1562H41.554Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5083", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Fig$1.displayName = "Fig";
  var gif_exports = {};
  __export$1(gif_exports, {
    GIF: () => GIF$1
  });
  var GIF$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5105)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M25.0493 55.1562C24.9499 54.8106 24.8102 54.5052 24.6303 54.2401C24.4504 53.9702 24.2302 53.7429 23.9698 53.5582C23.7141 53.3688 23.4205 53.2244 23.0891 53.125C22.7624 53.0256 22.4002 52.9759 22.0025 52.9759C21.2591 52.9759 20.6057 53.1605 20.0422 53.5298C19.4835 53.8991 19.0479 54.4366 18.7354 55.142C18.4229 55.8428 18.2667 56.6998 18.2667 57.7131C18.2667 58.7263 18.4205 59.5881 18.7283 60.2983C19.0361 61.0085 19.4717 61.5507 20.0351 61.9247C20.5986 62.294 21.2638 62.4787 22.0309 62.4787C22.7269 62.4787 23.3211 62.3556 23.8135 62.1094C24.3107 61.8584 24.6895 61.5057 24.9499 61.0511C25.215 60.5966 25.3476 60.0592 25.3476 59.4389L25.9726 59.5312H22.2226V57.2159H28.3093V59.0483C28.3093 60.3267 28.0394 61.4252 27.4996 62.3438C26.9598 63.2576 26.2165 63.9631 25.2695 64.4602C24.3225 64.9527 23.2382 65.1989 22.0167 65.1989C20.653 65.1989 19.4551 64.8982 18.4229 64.2969C17.3907 63.6908 16.5858 62.8314 16.0081 61.7188C15.4352 60.6013 15.1488 59.2756 15.1488 57.7415C15.1488 56.5625 15.3192 55.5114 15.6601 54.5881C16.0058 53.66 16.4887 52.8741 17.109 52.2301C17.7292 51.5862 18.4513 51.0961 19.2752 50.7599C20.099 50.4238 20.9916 50.2557 21.9527 50.2557C22.7766 50.2557 23.5436 50.3764 24.2539 50.6179C24.9641 50.8546 25.5938 51.1908 26.1431 51.6264C26.6971 52.062 27.1492 52.5805 27.4996 53.1818C27.85 53.7784 28.0749 54.4366 28.1743 55.1562H25.0493ZM33.2946 50.4545V65H30.2193V50.4545H33.2946ZM35.4248 65V50.4545H45.0554V52.9901H38.5V56.456H44.4162V58.9915H38.5V65H35.4248Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5105", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  GIF$1.displayName = "GIF";
  var html_exports = {};
  __export$1(html_exports, {
    HTML: () => HTML$1
  });
  var HTML$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5072)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M5.60943 65V51.9091H8.37718V57.3104H13.9958V51.9091H16.7572V65H13.9958V59.5923H8.37718V65H5.60943ZM18.1805 54.1911V51.9091H28.932V54.1911H24.9241V65H22.1883V54.1911H18.1805ZM30.3426 51.9091H33.7559L37.361 60.7045H37.5144L41.1195 51.9091H44.5329V65H41.8482V56.4794H41.7396L38.3518 64.9361H36.5237L33.1359 56.4474H33.0272V65H30.3426V51.9091ZM46.4533 65V51.9091H49.221V62.718H54.8332V65H46.4533Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5072", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  HTML$1.displayName = "HTML";
  var ico_exports = {};
  __export$1(ico_exports, {
    ICO: () => ICO$1
  });
  var ICO$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5088)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M16.595 50.4545V65H13.5197V50.4545H16.595ZM31.5589 55.5469H28.4482C28.3913 55.1444 28.2753 54.7869 28.1001 54.4744C27.925 54.1572 27.7 53.8873 27.4254 53.6648C27.1508 53.4422 26.8336 53.2718 26.4737 53.1534C26.1186 53.035 25.7327 52.9759 25.3161 52.9759C24.5632 52.9759 23.9074 53.1629 23.3487 53.5369C22.79 53.9062 22.3568 54.446 22.049 55.1562C21.7412 55.8617 21.5874 56.7187 21.5874 57.7273C21.5874 58.7642 21.7412 59.6354 22.049 60.3409C22.3615 61.0464 22.7971 61.5791 23.3558 61.9389C23.9145 62.2988 24.5608 62.4787 25.2947 62.4787C25.7067 62.4787 26.0878 62.4242 26.4382 62.3153C26.7933 62.2064 27.1082 62.0478 27.3828 61.8395C27.6574 61.6264 27.8847 61.3684 28.0646 61.0653C28.2493 60.7623 28.3771 60.4167 28.4482 60.0284L31.5589 60.0426C31.4785 60.7102 31.2772 61.3542 30.9553 61.9744C30.638 62.59 30.2095 63.1416 29.6697 63.6293C29.1347 64.1122 28.4955 64.4957 27.7521 64.7798C27.0135 65.0592 26.1778 65.1989 25.245 65.1989C23.9477 65.1989 22.7876 64.9053 21.7649 64.3182C20.7469 63.7311 19.942 62.8812 19.3501 61.7685C18.763 60.6558 18.4695 59.3087 18.4695 57.7273C18.4695 56.1411 18.7678 54.7917 19.3643 53.679C19.9609 52.5663 20.7706 51.7187 21.7933 51.1364C22.8161 50.5492 23.9666 50.2557 25.245 50.2557C26.0878 50.2557 26.8691 50.3741 27.5888 50.6108C28.3132 50.8475 28.9548 51.1932 29.5135 51.6477C30.0722 52.0975 30.5268 52.6491 30.8771 53.3026C31.2322 53.956 31.4595 54.7041 31.5589 55.5469ZM46.7307 57.7273C46.7307 59.3134 46.43 60.6629 45.8287 61.7756C45.2321 62.8883 44.4177 63.7382 43.3855 64.3253C42.358 64.9077 41.2027 65.1989 39.9196 65.1989C38.627 65.1989 37.467 64.9053 36.4395 64.3182C35.412 63.7311 34.6 62.8812 34.0034 61.7685C33.4068 60.6558 33.1085 59.3087 33.1085 57.7273C33.1085 56.1411 33.4068 54.7917 34.0034 53.679C34.6 52.5663 35.412 51.7187 36.4395 51.1364C37.467 50.5492 38.627 50.2557 39.9196 50.2557C41.2027 50.2557 42.358 50.5492 43.3855 51.1364C44.4177 51.7187 45.2321 52.5663 45.8287 53.679C46.43 54.7917 46.7307 56.1411 46.7307 57.7273ZM43.6128 57.7273C43.6128 56.6998 43.4589 55.8333 43.1511 55.1278C42.8481 54.4223 42.4196 53.8873 41.8656 53.5227C41.3116 53.1581 40.663 52.9759 39.9196 52.9759C39.1762 52.9759 38.5276 53.1581 37.9736 53.5227C37.4196 53.8873 36.9887 54.4223 36.681 55.1278C36.3779 55.8333 36.2264 56.6998 36.2264 57.7273C36.2264 58.7547 36.3779 59.6212 36.681 60.3267C36.9887 61.0322 37.4196 61.5672 37.9736 61.9318C38.5276 62.2964 39.1762 62.4787 39.9196 62.4787C40.663 62.4787 41.3116 62.2964 41.8656 61.9318C42.4196 61.5672 42.8481 61.0322 43.1511 60.3267C43.4589 59.6212 43.6128 58.7547 43.6128 57.7273Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5088", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  ICO$1.displayName = "ICO";
  var java_exports = {};
  __export$1(java_exports, {
    Java: () => Java$1
  });
  var Java$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5070)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M13.7767 51.9091H16.5125V61.0369C16.5125 61.8807 16.3228 62.6136 15.9436 63.2358C15.5686 63.858 15.0466 64.3374 14.3775 64.674C13.7085 65.0107 12.9308 65.179 12.0444 65.179C11.2561 65.179 10.5402 65.0405 9.89671 64.7635C9.25751 64.4822 8.75041 64.0561 8.37541 63.4851C8.00041 62.9098 7.81504 62.1875 7.8193 61.3182H10.5743C10.5828 61.6634 10.6531 61.9595 10.7852 62.2067C10.9216 62.4496 11.1069 62.6371 11.3413 62.7692C11.58 62.897 11.8612 62.9609 12.1851 62.9609C12.526 62.9609 12.8136 62.8885 13.048 62.7436C13.2866 62.5945 13.4677 62.3771 13.5913 62.0916C13.7149 61.8061 13.7767 61.4545 13.7767 61.0369V51.9091ZM20.6972 65H17.7313L22.2505 51.9091H25.8173L30.33 65H27.3641L24.085 54.9006H23.9827L20.6972 65ZM20.5119 59.8544H27.5175V62.0149H20.5119V59.8544ZM32.276 51.9091L35.44 61.8551H35.5615L38.7319 51.9091H41.8001L37.2873 65H33.7206L29.2014 51.9091H32.276ZM43.5319 65H40.566L45.0852 51.9091H48.6519L53.1647 65H50.1988L46.9197 54.9006H46.8174L43.5319 65ZM43.3465 59.8544H50.3522V62.0149H43.3465V59.8544Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5070", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Java$1.displayName = "Java";
  var jpeg_exports = {};
  __export$1(jpeg_exports, {
    JPEG: () => JPEG$1
  });
  var JPEG$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5085)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.2799 50.4545H15.3196V60.5966C15.3196 61.5341 15.1089 62.3485 14.6875 63.0398C14.2709 63.7311 13.6909 64.2637 12.9475 64.6378C12.2041 65.0118 11.34 65.1989 10.3551 65.1989C9.4792 65.1989 8.68375 65.045 7.96879 64.7372C7.25856 64.4247 6.69511 63.9512 6.27844 63.3168C5.86178 62.6776 5.65581 61.875 5.66055 60.9091H8.72163C8.7311 61.2926 8.80922 61.6217 8.956 61.8963C9.10752 62.1662 9.31348 62.3745 9.5739 62.5213C9.83905 62.6634 10.1516 62.7344 10.5114 62.7344C10.8902 62.7344 11.2098 62.6539 11.4702 62.4929C11.7354 62.3272 11.9366 62.0857 12.0739 61.7685C12.2112 61.4512 12.2799 61.0606 12.2799 60.5966V50.4545ZM17.4623 65V50.4545H23.2009C24.3041 50.4545 25.244 50.6652 26.0205 51.0866C26.797 51.5033 27.3889 52.0833 27.7961 52.8267C28.208 53.5653 28.414 54.4176 28.414 55.3835C28.414 56.3494 28.2056 57.2017 27.789 57.9403C27.3723 58.679 26.7686 59.2543 25.9779 59.6662C25.1919 60.0781 24.2402 60.2841 23.1228 60.2841H19.4651V57.8196H22.6256C23.2175 57.8196 23.7052 57.7178 24.0887 57.5142C24.4769 57.3059 24.7658 57.0194 24.9552 56.6548C25.1493 56.2855 25.2463 55.8617 25.2463 55.3835C25.2463 54.9006 25.1493 54.4792 24.9552 54.1193C24.7658 53.7547 24.4769 53.473 24.0887 53.2741C23.7004 53.0705 23.208 52.9688 22.6114 52.9688H20.5375V65H17.4623ZM30.0115 65V50.4545H39.8126V52.9901H33.0868V56.456H39.3083V58.9915H33.0868V62.4645H39.841V65H30.0115ZM51.5025 55.1562C51.403 54.8106 51.2633 54.5052 51.0834 54.2401C50.9035 53.9702 50.6833 53.7429 50.4229 53.5582C50.1672 53.3688 49.8737 53.2244 49.5422 53.125C49.2155 53.0256 48.8533 52.9759 48.4556 52.9759C47.7122 52.9759 47.0588 53.1605 46.4953 53.5298C45.9366 53.8991 45.501 54.4366 45.1885 55.142C44.876 55.8428 44.7198 56.6998 44.7198 57.7131C44.7198 58.7263 44.8737 59.5881 45.1814 60.2983C45.4892 61.0085 45.9248 61.5507 46.4882 61.9247C47.0517 62.294 47.7169 62.4787 48.484 62.4787C49.18 62.4787 49.7742 62.3556 50.2667 62.1094C50.7638 61.8584 51.1426 61.5057 51.403 61.0511C51.6682 60.5966 51.8007 60.0592 51.8007 59.4389L52.4257 59.5312H48.6757V57.2159H54.7624V59.0483C54.7624 60.3267 54.4925 61.4252 53.9527 62.3438C53.413 63.2576 52.6696 63.9631 51.7226 64.4602C50.7757 64.9527 49.6914 65.1989 48.4698 65.1989C47.1061 65.1989 45.9082 64.8982 44.876 64.2969C43.8438 63.6908 43.0389 62.8314 42.4613 61.7188C41.8883 60.6013 41.6019 59.2756 41.6019 57.7415C41.6019 56.5625 41.7723 55.5114 42.1132 54.5881C42.4589 53.66 42.9418 52.8741 43.5621 52.2301C44.1824 51.5862 44.9044 51.0961 45.7283 50.7599C46.5522 50.4238 47.4447 50.2557 48.4059 50.2557C49.2297 50.2557 49.9968 50.3764 50.707 50.6179C51.4172 50.8546 52.047 51.1908 52.5962 51.6264C53.1502 52.062 53.6024 52.5805 53.9527 53.1818C54.3031 53.7784 54.528 54.4366 54.6275 55.1562H51.5025Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5085", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  JPEG$1.displayName = "JPEG";
  var jpg_exports = {};
  __export$1(jpg_exports, {
    JPG: () => JPG$1
  });
  var JPG$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5093)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M18.2029 50.4545H21.2427V60.5966C21.2427 61.5341 21.032 62.3485 20.6106 63.0398C20.1939 63.7311 19.6139 64.2637 18.8705 64.6378C18.1272 65.0118 17.263 65.1989 16.2782 65.1989C15.4022 65.1989 14.6068 65.045 13.8918 64.7372C13.1816 64.4247 12.6182 63.9512 12.2015 63.3168C11.7848 62.6776 11.5789 61.875 11.5836 60.9091H14.6447C14.6541 61.2926 14.7323 61.6217 14.879 61.8963C15.0306 62.1662 15.2365 62.3745 15.4969 62.5213C15.7621 62.6634 16.0746 62.7344 16.4344 62.7344C16.8132 62.7344 17.1328 62.6539 17.3933 62.4929C17.6584 62.3272 17.8596 62.0857 17.9969 61.7685C18.1343 61.4512 18.2029 61.0606 18.2029 60.5966V50.4545ZM23.3853 65V50.4545H29.1239C30.2272 50.4545 31.167 50.6652 31.9435 51.0866C32.7201 51.5033 33.3119 52.0833 33.7191 52.8267C34.131 53.5653 34.337 54.4176 34.337 55.3835C34.337 56.3494 34.1287 57.2017 33.712 57.9403C33.2953 58.679 32.6916 59.2543 31.9009 59.6662C31.1149 60.0781 30.1632 60.2841 29.0458 60.2841H25.3881V57.8196H28.5487C29.1405 57.8196 29.6282 57.7178 30.0117 57.5142C30.4 57.3059 30.6888 57.0194 30.8782 56.6548C31.0723 56.2855 31.1694 55.8617 31.1694 55.3835C31.1694 54.9006 31.0723 54.4792 30.8782 54.1193C30.6888 53.7547 30.4 53.473 30.0117 53.2741C29.6235 53.0705 29.131 52.9688 28.5344 52.9688H26.4606V65H23.3853ZM45.5794 55.1562C45.48 54.8106 45.3403 54.5052 45.1604 54.2401C44.9804 53.9702 44.7603 53.7429 44.4999 53.5582C44.2442 53.3688 43.9506 53.2244 43.6192 53.125C43.2925 53.0256 42.9303 52.9759 42.5325 52.9759C41.7892 52.9759 41.1357 53.1605 40.5723 53.5298C40.0136 53.8991 39.578 54.4366 39.2655 55.142C38.953 55.8428 38.7967 56.6998 38.7967 57.7131C38.7967 58.7263 38.9506 59.5881 39.2584 60.2983C39.5661 61.0085 40.0018 61.5507 40.5652 61.9247C41.1286 62.294 41.7939 62.4787 42.5609 62.4787C43.257 62.4787 43.8512 62.3556 44.3436 62.1094C44.8408 61.8584 45.2196 61.5057 45.48 61.0511C45.7451 60.5966 45.8777 60.0592 45.8777 59.4389L46.5027 59.5312H42.7527V57.2159H48.8393V59.0483C48.8393 60.3267 48.5695 61.4252 48.0297 62.3438C47.4899 63.2576 46.7465 63.9631 45.7996 64.4602C44.8526 64.9527 43.7683 65.1989 42.5467 65.1989C41.1831 65.1989 39.9852 64.8982 38.953 64.2969C37.9208 63.6908 37.1159 62.8314 36.5382 61.7188C35.9653 60.6013 35.6788 59.2756 35.6788 57.7415C35.6788 56.5625 35.8493 55.5114 36.1902 54.5881C36.5358 53.66 37.0188 52.8741 37.6391 52.2301C38.2593 51.5862 38.9814 51.0961 39.8053 50.7599C40.6291 50.4238 41.5216 50.2557 42.4828 50.2557C43.3067 50.2557 44.0737 50.3764 44.7839 50.6179C45.4942 50.8546 46.1239 51.1908 46.6732 51.6264C47.2271 52.062 47.6793 52.5805 48.0297 53.1818C48.3801 53.7784 48.605 54.4366 48.7044 55.1562H45.5794Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5093", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  JPG$1.displayName = "JPG";
  var js_exports = {};
  __export$1(js_exports, {
    JS: () => JS$1
  });
  var JS$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5076)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M25.5322 50.4545H28.572V60.5966C28.572 61.5341 28.3613 62.3485 27.9399 63.0398C27.5232 63.7311 26.9432 64.2637 26.1998 64.6378C25.4565 65.0118 24.5923 65.1989 23.6075 65.1989C22.7315 65.1989 21.9361 65.045 21.2211 64.7372C20.5109 64.4247 19.9475 63.9512 19.5308 63.3168C19.1141 62.6776 18.9082 61.875 18.9129 60.9091H21.974C21.9834 61.2926 22.0616 61.6217 22.2083 61.8963C22.3599 62.1662 22.5658 62.3745 22.8262 62.5213C23.0914 62.6634 23.4039 62.7344 23.7637 62.7344C24.1425 62.7344 24.4621 62.6539 24.7225 62.4929C24.9877 62.3272 25.1889 62.0857 25.3262 61.7685C25.4636 61.4512 25.5322 61.0606 25.5322 60.5966V50.4545ZM38.6052 54.6378C38.5484 54.0649 38.3046 53.6198 37.8737 53.3026C37.4428 52.9853 36.8581 52.8267 36.1194 52.8267C35.6175 52.8267 35.1938 52.8977 34.8481 53.0398C34.5025 53.1771 34.2373 53.3688 34.0527 53.6151C33.8727 53.8613 33.7828 54.1406 33.7828 54.4531C33.7733 54.7135 33.8278 54.9408 33.9461 55.1349C34.0692 55.3291 34.2373 55.4972 34.4504 55.6392C34.6635 55.7765 34.9097 55.8973 35.189 56.0014C35.4684 56.1009 35.7667 56.1861 36.0839 56.2571L37.3907 56.5696C38.0252 56.7116 38.6076 56.901 39.1379 57.1378C39.6682 57.3745 40.1275 57.6657 40.5157 58.0114C40.904 58.357 41.2047 58.7642 41.4177 59.233C41.6355 59.7017 41.7468 60.2391 41.7515 60.8452C41.7468 61.7353 41.5195 62.5071 41.0697 63.1605C40.6246 63.8092 39.9807 64.3134 39.1379 64.6733C38.2998 65.0284 37.2889 65.206 36.1052 65.206C34.931 65.206 33.9083 65.026 33.037 64.6662C32.1706 64.3063 31.4935 63.7737 31.0058 63.0682C30.5228 62.358 30.2695 61.4796 30.2458 60.4332H33.2217C33.2548 60.9209 33.3945 61.3281 33.6407 61.6548C33.8917 61.9768 34.2255 62.2206 34.6422 62.3864C35.0636 62.5473 35.5394 62.6278 36.0697 62.6278C36.5905 62.6278 37.0427 62.5521 37.4262 62.4006C37.8145 62.2491 38.1152 62.0384 38.3282 61.7685C38.5413 61.4986 38.6478 61.1884 38.6478 60.8381C38.6478 60.5114 38.5508 60.2367 38.3566 60.0142C38.1672 59.7917 37.8879 59.6023 37.5186 59.446C37.154 59.2898 36.7065 59.1477 36.1762 59.0199L34.5924 58.6222C33.3661 58.3239 32.3978 57.8575 31.6876 57.223C30.9774 56.5885 30.6246 55.7339 30.6294 54.6591C30.6246 53.7784 30.859 53.009 31.3325 52.3509C31.8107 51.6927 32.4665 51.179 33.2998 50.8097C34.1332 50.4403 35.0801 50.2557 36.1407 50.2557C37.2203 50.2557 38.1625 50.4403 38.9674 50.8097C39.7771 51.179 40.4068 51.6927 40.8566 52.3509C41.3065 53.009 41.5385 53.7713 41.5527 54.6378H38.6052Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5076", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  JS$1.displayName = "JS";
  var json_exports = {};
  __export$1(json_exports, {
    JSON: () => JSON$1
  });
  var JSON$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5081)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.7308 51.9091H15.4666V61.0369C15.4666 61.8807 15.277 62.6136 14.8977 63.2358C14.5227 63.858 14.0007 64.3374 13.3316 64.674C12.6626 65.0107 11.8849 65.179 10.9985 65.179C10.2102 65.179 9.49428 65.0405 8.85081 64.7635C8.21161 64.4822 7.70451 64.0561 7.32951 63.4851C6.95451 62.9098 6.76914 62.1875 6.7734 61.3182H9.52837C9.53689 61.6634 9.60721 61.9595 9.73931 62.2067C9.87567 62.4496 10.061 62.6371 10.2954 62.7692C10.5341 62.897 10.8153 62.9609 11.1392 62.9609C11.4801 62.9609 11.7677 62.8885 12.0021 62.7436C12.2407 62.5945 12.4218 62.3771 12.5454 62.0916C12.669 61.8061 12.7308 61.4545 12.7308 61.0369V51.9091ZM24.4965 55.674C24.4454 55.1584 24.2259 54.7578 23.8381 54.4723C23.4503 54.1868 22.9241 54.044 22.2593 54.044C21.8076 54.044 21.4262 54.108 21.1151 54.2358C20.804 54.3594 20.5654 54.532 20.3992 54.7536C20.2373 54.9751 20.1563 55.2266 20.1563 55.5078C20.1478 55.7422 20.1968 55.9467 20.3033 56.1214C20.4141 56.2962 20.5654 56.4474 20.7571 56.5753C20.9489 56.6989 21.1705 56.8075 21.4219 56.9013C21.6733 56.9908 21.9418 57.0675 22.2273 57.1314L23.4035 57.4126C23.9745 57.5405 24.4986 57.7109 24.9759 57.924C25.4532 58.1371 25.8665 58.3991 26.216 58.7102C26.5654 59.0213 26.836 59.3878 27.0277 59.8097C27.2238 60.2315 27.3239 60.7152 27.3282 61.2607C27.3239 62.0618 27.1194 62.7564 26.7145 63.3445C26.314 63.9283 25.7344 64.3821 24.9759 64.706C24.2216 65.0256 23.3118 65.1854 22.2465 65.1854C21.1897 65.1854 20.2692 65.0234 19.4851 64.6996C18.7053 64.3757 18.0959 63.8963 17.657 63.2614C17.2223 62.6222 16.9944 61.8317 16.9731 60.8899H19.6513C19.6812 61.3288 19.8069 61.6953 20.0285 61.9893C20.2543 62.2791 20.5547 62.4986 20.9297 62.6477C21.309 62.7926 21.7373 62.8651 22.2145 62.8651C22.6833 62.8651 23.0902 62.7969 23.4354 62.6605C23.7848 62.5241 24.0554 62.3345 24.2472 62.0916C24.439 61.8487 24.5348 61.5696 24.5348 61.2543C24.5348 60.9602 24.4475 60.7131 24.2728 60.5128C24.1023 60.3125 23.8509 60.142 23.5185 60.0014C23.1904 59.8608 22.7877 59.733 22.3104 59.6179L20.885 59.2599C19.7813 58.9915 18.9098 58.5717 18.2706 58.0007C17.6314 57.4297 17.314 56.6605 17.3182 55.6932C17.314 54.9006 17.5249 54.2081 17.951 53.6158C18.3814 53.0234 18.9716 52.5611 19.7216 52.2287C20.4716 51.8963 21.3239 51.7301 22.2785 51.7301C23.25 51.7301 24.0981 51.8963 24.8225 52.2287C25.5512 52.5611 26.1179 53.0234 26.5228 53.6158C26.9276 54.2081 27.1364 54.8942 27.1492 55.674H24.4965ZM40.8597 58.4545C40.8597 59.8821 40.5891 61.0966 40.0479 62.098C39.511 63.0994 38.778 63.8643 37.849 64.3928C36.9243 64.9169 35.8845 65.179 34.7297 65.179C33.5664 65.179 32.5223 64.9148 31.5976 64.3864C30.6729 63.858 29.9421 63.093 29.4051 62.0916C28.8682 61.0902 28.5997 59.8778 28.5997 58.4545C28.5997 57.027 28.8682 55.8125 29.4051 54.8111C29.9421 53.8097 30.6729 53.0469 31.5976 52.5227C32.5223 51.9943 33.5664 51.7301 34.7297 51.7301C35.8845 51.7301 36.9243 51.9943 37.849 52.5227C38.778 53.0469 39.511 53.8097 40.0479 54.8111C40.5891 55.8125 40.8597 57.027 40.8597 58.4545ZM38.0536 58.4545C38.0536 57.5298 37.9151 56.75 37.6381 56.1151C37.3654 55.4801 36.9797 54.9986 36.4811 54.6705C35.9826 54.3423 35.3987 54.1783 34.7297 54.1783C34.0607 54.1783 33.4769 54.3423 32.9783 54.6705C32.4797 54.9986 32.0919 55.4801 31.8149 56.1151C31.5422 56.75 31.4059 57.5298 31.4059 58.4545C31.4059 59.3793 31.5422 60.1591 31.8149 60.794C32.0919 61.429 32.4797 61.9105 32.9783 62.2386C33.4769 62.5668 34.0607 62.7308 34.7297 62.7308C35.3987 62.7308 35.9826 62.5668 36.4811 62.2386C36.9797 61.9105 37.3654 61.429 37.6381 60.794C37.9151 60.1591 38.0536 59.3793 38.0536 58.4545ZM53.4995 51.9091V65H51.1089L45.4136 56.7607H45.3177V65H42.5499V51.9091H44.9789L50.6295 60.142H50.7445V51.9091H53.4995Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5081", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  JSON$1.displayName = "JSON";
  var mov_exports = {};
  __export$1(mov_exports, {
    MOV: () => MOV$1
  });
  var MOV$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5084)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.62124 50.4545H11.4138L15.4195 60.2273H15.59L19.5957 50.4545H23.3883V65H20.4053V55.5327H20.2846L16.5204 64.929H14.4891L10.7249 55.4972H10.6042V65H7.62124V50.4545ZM38.8885 57.7273C38.8885 59.3134 38.5878 60.6629 37.9865 61.7756C37.3899 62.8883 36.5755 63.7382 35.5433 64.3253C34.5159 64.9077 33.3606 65.1989 32.0774 65.1989C30.7848 65.1989 29.6248 64.9053 28.5973 64.3182C27.5698 63.7311 26.7578 62.8812 26.1612 61.7685C25.5646 60.6558 25.2663 59.3087 25.2663 57.7273C25.2663 56.1411 25.5646 54.7917 26.1612 53.679C26.7578 52.5663 27.5698 51.7187 28.5973 51.1364C29.6248 50.5492 30.7848 50.2557 32.0774 50.2557C33.3606 50.2557 34.5159 50.5492 35.5433 51.1364C36.5755 51.7187 37.3899 52.5663 37.9865 53.679C38.5878 54.7917 38.8885 56.1411 38.8885 57.7273ZM35.7706 57.7273C35.7706 56.6998 35.6167 55.8333 35.3089 55.1278C35.0059 54.4223 34.5774 53.8873 34.0234 53.5227C33.4695 53.1581 32.8208 52.9759 32.0774 52.9759C31.334 52.9759 30.6854 53.1581 30.1314 53.5227C29.5774 53.8873 29.1465 54.4223 28.8388 55.1278C28.5357 55.8333 28.3842 56.6998 28.3842 57.7273C28.3842 58.7547 28.5357 59.6212 28.8388 60.3267C29.1465 61.0322 29.5774 61.5672 30.1314 61.9318C30.6854 62.2964 31.334 62.4787 32.0774 62.4787C32.8208 62.4787 33.4695 62.2964 34.0234 61.9318C34.5774 61.5672 35.0059 61.0322 35.3089 60.3267C35.6167 59.6212 35.7706 58.7547 35.7706 57.7273ZM42.5741 50.4545L46.0897 61.5057H46.2246L49.7474 50.4545H53.1565L48.1423 65H44.1792L39.1579 50.4545H42.5741Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5084", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  MOV$1.displayName = "MOV";
  var mp3_exports = {};
  __export$1(mp3_exports, {
    MP3: () => MP3$1
  });
  var MP3$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5100)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9.44741 50.4545H13.24L17.2457 60.2273H17.4162L21.4218 50.4545H25.2145V65H22.2315V55.5327H22.1108L18.3466 64.929H16.3153L12.5511 55.4972H12.4304V65H9.44741V50.4545ZM27.3482 65V50.4545H33.0868C34.19 50.4545 35.1299 50.6652 35.9064 51.0866C36.6829 51.5033 37.2748 52.0833 37.682 52.8267C38.0939 53.5653 38.2999 54.4176 38.2999 55.3835C38.2999 56.3494 38.0916 57.2017 37.6749 57.9403C37.2582 58.679 36.6545 59.2543 35.8638 59.6662C35.0778 60.0781 34.1261 60.2841 33.0087 60.2841H29.351V57.8196H32.5115C33.1034 57.8196 33.5911 57.7178 33.9746 57.5142C34.3629 57.3059 34.6517 57.0194 34.8411 56.6548C35.0352 56.2855 35.1323 55.8617 35.1323 55.3835C35.1323 54.9006 35.0352 54.4792 34.8411 54.1193C34.6517 53.7547 34.3629 53.473 33.9746 53.2741C33.5864 53.0705 33.0939 52.9688 32.4973 52.9688H30.4235V65H27.3482ZM45.1886 65.1989C44.128 65.1989 43.1834 65.0166 42.3548 64.652C41.5309 64.2827 40.8799 63.776 40.4017 63.1321C39.9282 62.4834 39.6843 61.7353 39.6701 60.8878H42.7667C42.7857 61.2429 42.9017 61.5554 43.1147 61.8253C43.3325 62.0904 43.6214 62.2964 43.9812 62.4432C44.3411 62.59 44.7459 62.6634 45.1957 62.6634C45.6645 62.6634 46.0788 62.5805 46.4386 62.4148C46.7984 62.2491 47.0802 62.0194 47.2838 61.7259C47.4874 61.4323 47.5892 61.0937 47.5892 60.7102C47.5892 60.322 47.4803 59.9787 47.2625 59.6804C47.0494 59.3774 46.7416 59.1406 46.3392 58.9702C45.9414 58.7997 45.468 58.7145 44.9187 58.7145H43.5622V56.456H44.9187C45.3827 56.456 45.7923 56.3755 46.1474 56.2145C46.5073 56.0535 46.7866 55.831 46.9855 55.5469C47.1843 55.258 47.2838 54.9219 47.2838 54.5384C47.2838 54.1738 47.1962 53.8542 47.021 53.5795C46.8505 53.3002 46.6091 53.0824 46.2966 52.9261C45.9888 52.7699 45.6289 52.6918 45.217 52.6918C44.8003 52.6918 44.4192 52.7675 44.0735 52.919C43.7279 53.0658 43.4509 53.2765 43.2426 53.5511C43.0342 53.8258 42.923 54.1477 42.9088 54.517H39.9613C39.9755 53.679 40.2146 52.9403 40.6787 52.3011C41.1427 51.6619 41.7677 51.1624 42.5537 50.8026C43.3444 50.438 44.2369 50.2557 45.2312 50.2557C46.235 50.2557 47.1133 50.438 47.8662 50.8026C48.619 51.1671 49.2038 51.6596 49.6204 52.2798C50.0418 52.8954 50.2502 53.5866 50.2454 54.3537C50.2502 55.1681 49.9968 55.8475 49.4855 56.392C48.9788 56.9366 48.3183 57.2822 47.5039 57.429V57.5426C48.574 57.6799 49.3884 58.0516 49.9471 58.6577C50.5106 59.259 50.7899 60.0118 50.7852 60.9162C50.7899 61.7448 50.5508 62.4811 50.0679 63.125C49.5896 63.7689 48.9291 64.2756 48.0863 64.6449C47.2435 65.0142 46.2776 65.1989 45.1886 65.1989Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  MP3$1.displayName = "MP3";
  var mp4_exports = {};
  __export$1(mp4_exports, {
    MP4: () => MP4$1
  });
  var MP4$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5086)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9.76186 50.4545H13.5545L17.5602 60.2273H17.7306L21.7363 50.4545H25.5289V65H22.546V55.5327H22.4252L18.661 64.929H16.6298L12.8656 55.4972H12.7448V65H9.76186V50.4545ZM27.6626 65V50.4545H33.4013C34.5045 50.4545 35.4444 50.6652 36.2209 51.0866C36.9974 51.5033 37.5893 52.0833 37.9964 52.8267C38.4084 53.5653 38.6143 54.4176 38.6143 55.3835C38.6143 56.3494 38.406 57.2017 37.9893 57.9403C37.5727 58.679 36.969 59.2543 36.1783 59.6662C35.3923 60.0781 34.4406 60.2841 33.3232 60.2841H29.6655V57.8196H32.826C33.4179 57.8196 33.9055 57.7178 34.2891 57.5142C34.6773 57.3059 34.9661 57.0194 35.1555 56.6548C35.3497 56.2855 35.4467 55.8617 35.4467 55.3835C35.4467 54.9006 35.3497 54.4792 35.1555 54.1193C34.9661 53.7547 34.6773 53.473 34.2891 53.2741C33.9008 53.0705 33.4084 52.9688 32.8118 52.9688H30.7379V65H27.6626ZM39.9065 62.4432V60.0213L45.9789 50.4545H48.067V53.8068H46.8312L43.0031 59.8651V59.9787H51.6323V62.4432H39.9065ZM46.888 65V61.7045L46.9448 60.6321V50.4545H49.8283V65H46.888Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5086", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  MP4$1.displayName = "MP4";
  var mpg_exports = {};
  __export$1(mpg_exports, {
    MPG: () => MPG$1
  });
  var MPG$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5092)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M8.43178 50.4545H12.2244L16.2301 60.2273H16.4005L20.4062 50.4545H24.1988V65H21.2159V55.5327H21.0951L17.3309 64.929H15.2997L11.5355 55.4972H11.4147V65H8.43178V50.4545ZM26.3326 65V50.4545H32.0712C33.1744 50.4545 34.1143 50.6652 34.8908 51.0866C35.6673 51.5033 36.2592 52.0833 36.6664 52.8267C37.0783 53.5653 37.2843 54.4176 37.2843 55.3835C37.2843 56.3494 37.0759 57.2017 36.6593 57.9403C36.2426 58.679 35.6389 59.2543 34.8482 59.6662C34.0622 60.0781 33.1105 60.2841 31.9931 60.2841H28.3354V57.8196H31.4959C32.0878 57.8196 32.5755 57.7178 32.959 57.5142C33.3472 57.3059 33.6361 57.0194 33.8255 56.6548C34.0196 56.2855 34.1167 55.8617 34.1167 55.3835C34.1167 54.9006 34.0196 54.4792 33.8255 54.1193C33.6361 53.7547 33.3472 53.473 32.959 53.2741C32.5707 53.0705 32.0783 52.9688 31.4817 52.9688H29.4078V65H26.3326ZM48.5267 55.1562C48.4272 54.8106 48.2876 54.5052 48.1076 54.2401C47.9277 53.9702 47.7075 53.7429 47.4471 53.5582C47.1914 53.3688 46.8979 53.2244 46.5664 53.125C46.2397 53.0256 45.8775 52.9759 45.4798 52.9759C44.7364 52.9759 44.083 53.1605 43.5196 53.5298C42.9609 53.8991 42.5252 54.4366 42.2127 55.142C41.9002 55.8428 41.744 56.6998 41.744 57.7131C41.744 58.7263 41.8979 59.5881 42.2056 60.2983C42.5134 61.0085 42.949 61.5507 43.5125 61.9247C44.0759 62.294 44.7412 62.4787 45.5082 62.4787C46.2042 62.4787 46.7984 62.3556 47.2909 62.1094C47.788 61.8584 48.1668 61.5057 48.4272 61.0511C48.6924 60.5966 48.825 60.0592 48.825 59.4389L49.45 59.5312H45.7V57.2159H51.7866V59.0483C51.7866 60.3267 51.5167 61.4252 50.977 62.3438C50.4372 63.2576 49.6938 63.9631 48.7468 64.4602C47.7999 64.9527 46.7156 65.1989 45.494 65.1989C44.1304 65.1989 42.9324 64.8982 41.9002 64.2969C40.8681 63.6908 40.0631 62.8314 39.4855 61.7188C38.9126 60.6013 38.6261 59.2756 38.6261 57.7415C38.6261 56.5625 38.7966 55.5114 39.1375 54.5881C39.4831 53.66 39.9661 52.8741 40.5863 52.2301C41.2066 51.5862 41.9287 51.0961 42.7525 50.7599C43.5764 50.4238 44.4689 50.2557 45.4301 50.2557C46.2539 50.2557 47.021 50.3764 47.7312 50.6179C48.4414 50.8546 49.0712 51.1908 49.6204 51.6264C50.1744 52.062 50.6266 52.5805 50.977 53.1818C51.3273 53.7784 51.5522 54.4366 51.6517 55.1562H48.5267Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5092", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  MPG$1.displayName = "MPG";
  var pdf_exports = {};
  __export$1(pdf_exports, {
    PDF: () => PDF$1
  });
  var PDF$1 = reactExports.forwardRef(
    ({ ...props }, ref) => {
      const { accessibilityProps, title, restProps } = getAccessibilityProps(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref,
          width: "30",
          height: "40",
          viewBox: "0 0 60 80",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          ...accessibilityProps,
          ...restProps,
          children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5102)", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                  fill: "#FF1607"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                  fill: "white",
                  fillOpacity: "0.5"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M12.5646 65V50.4545H18.3032C19.4065 50.4545 20.3463 50.6652 21.1228 51.0866C21.8993 51.5033 22.4912 52.0833 22.8984 52.8267C23.3103 53.5653 23.5163 54.4176 23.5163 55.3835C23.5163 56.3494 23.308 57.2017 22.8913 57.9403C22.4746 58.679 21.8709 59.2543 21.0802 59.6662C20.2942 60.0781 19.3425 60.2841 18.2251 60.2841H14.5674V57.8196H17.7279C18.3198 57.8196 18.8075 57.7178 19.191 57.5142C19.5793 57.3059 19.8681 57.0194 20.0575 56.6548C20.2516 56.2855 20.3487 55.8617 20.3487 55.3835C20.3487 54.9006 20.2516 54.4792 20.0575 54.1193C19.8681 53.7547 19.5793 53.473 19.191 53.2741C18.8028 53.0705 18.3103 52.9688 17.7137 52.9688H15.6399V65H12.5646ZM30.2701 65H25.1138V50.4545H30.3127C31.7757 50.4545 33.0352 50.7457 34.0911 51.3281C35.147 51.9058 35.959 52.7367 36.5272 53.821C37.1001 54.9053 37.3865 56.2027 37.3865 57.7131C37.3865 59.2282 37.1001 60.5303 36.5272 61.6193C35.959 62.7083 35.1422 63.544 34.0769 64.1264C33.0163 64.7088 31.7473 65 30.2701 65ZM28.1891 62.3651H30.1422C31.0513 62.3651 31.816 62.2041 32.4363 61.8821C33.0613 61.5554 33.53 61.0511 33.8425 60.3693C34.1597 59.6828 34.3184 58.7973 34.3184 57.7131C34.3184 56.6383 34.1597 55.7599 33.8425 55.0781C33.53 54.3963 33.0636 53.8944 32.4434 53.5724C31.8231 53.2505 31.0584 53.0895 30.1493 53.0895H28.1891V62.3651ZM39.2646 65V50.4545H48.8953V52.9901H42.3399V56.456H48.2561V58.9915H42.3399V65H39.2646Z",
                fill: "white"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5102", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
          ]
        }
      );
    }
  );
  PDF$1.displayName = "PDF";
  var png_exports = {};
  __export$1(png_exports, {
    PNG: () => PNG$1
  });
  var PNG$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5087)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10.7287 65V50.4545H16.4673C17.5705 50.4545 18.5104 50.6652 19.2869 51.0866C20.0634 51.5033 20.6553 52.0833 21.0625 52.8267C21.4744 53.5653 21.6804 54.4176 21.6804 55.3835C21.6804 56.3494 21.472 57.2017 21.0554 57.9403C20.6387 58.679 20.035 59.2543 19.2443 59.6662C18.4583 60.0781 17.5066 60.2841 16.3892 60.2841H12.7315V57.8196H15.892C16.4839 57.8196 16.9716 57.7178 17.3551 57.5142C17.7433 57.3059 18.0322 57.0194 18.2216 56.6548C18.4157 56.2855 18.5127 55.8617 18.5127 55.3835C18.5127 54.9006 18.4157 54.4792 18.2216 54.1193C18.0322 53.7547 17.7433 53.473 17.3551 53.2741C16.9668 53.0705 16.4744 52.9688 15.8778 52.9688H13.8039V65H10.7287ZM35.4441 50.4545V65H32.7878L26.4597 55.8452H26.3532V65H23.2779V50.4545H25.9767L32.2551 59.6023H32.383V50.4545H35.4441ZM47.2298 55.1562C47.1304 54.8106 46.9907 54.5052 46.8108 54.2401C46.6308 53.9702 46.4107 53.7429 46.1502 53.5582C45.8946 53.3688 45.601 53.2244 45.2696 53.125C44.9429 53.0256 44.5806 52.9759 44.1829 52.9759C43.4395 52.9759 42.7861 53.1605 42.2227 53.5298C41.664 53.8991 41.2284 54.4366 40.9159 55.142C40.6034 55.8428 40.4471 56.6998 40.4471 57.7131C40.4471 58.7263 40.601 59.5881 40.9088 60.2983C41.2165 61.0085 41.6521 61.5507 42.2156 61.9247C42.779 62.294 43.4443 62.4787 44.2113 62.4787C44.9074 62.4787 45.5016 62.3556 45.994 62.1094C46.4912 61.8584 46.8699 61.5057 47.1304 61.0511C47.3955 60.5966 47.5281 60.0592 47.5281 59.4389L48.1531 59.5312H44.4031V57.2159H50.4897V59.0483C50.4897 60.3267 50.2199 61.4252 49.6801 62.3438C49.1403 63.2576 48.3969 63.9631 47.45 64.4602C46.503 64.9527 45.4187 65.1989 44.1971 65.1989C42.8335 65.1989 41.6356 64.8982 40.6034 64.2969C39.5712 63.6908 38.7663 62.8314 38.1886 61.7188C37.6157 60.6013 37.3292 59.2756 37.3292 57.7415C37.3292 56.5625 37.4997 55.5114 37.8406 54.5881C38.1862 53.66 38.6692 52.8741 39.2895 52.2301C39.9097 51.5862 40.6318 51.0961 41.4556 50.7599C42.2795 50.4238 43.172 50.2557 44.1332 50.2557C44.9571 50.2557 45.7241 50.3764 46.4343 50.6179C47.1446 50.8546 47.7743 51.1908 48.3235 51.6264C48.8775 52.062 49.3297 52.5805 49.6801 53.1818C50.0305 53.7784 50.2554 54.4366 50.3548 55.1562H47.2298Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5087", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  PNG$1.displayName = "PNG";
  var ppt_exports = {};
  __export$1(ppt_exports, {
    PPT: () => PPT$1
  });
  var PPT$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5077)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#FF1607"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.5353 65V50.4545H18.2739C19.3772 50.4545 20.317 50.6652 21.0935 51.0866C21.8701 51.5033 22.4619 52.0833 22.8691 52.8267C23.281 53.5653 23.487 54.4176 23.487 55.3835C23.487 56.3494 23.2787 57.2017 22.862 57.9403C22.4453 58.679 21.8416 59.2543 21.0509 59.6662C20.2649 60.0781 19.3132 60.2841 18.1958 60.2841H14.5381V57.8196H17.6987C18.2905 57.8196 18.7782 57.7178 19.1617 57.5142C19.55 57.3059 19.8388 57.0194 20.0282 56.6548C20.2223 56.2855 20.3194 55.8617 20.3194 55.3835C20.3194 54.9006 20.2223 54.4792 20.0282 54.1193C19.8388 53.7547 19.55 53.473 19.1617 53.2741C18.7735 53.0705 18.281 52.9688 17.6844 52.9688H15.6106V65H12.5353ZM25.0845 65V50.4545H30.8232C31.9264 50.4545 32.8662 50.6652 33.6428 51.0866C34.4193 51.5033 35.0111 52.0833 35.4183 52.8267C35.8303 53.5653 36.0362 54.4176 36.0362 55.3835C36.0362 56.3494 35.8279 57.2017 35.4112 57.9403C34.9946 58.679 34.3909 59.2543 33.6001 59.6662C32.8142 60.0781 31.8625 60.2841 30.745 60.2841H27.0874V57.8196H30.2479C30.8397 57.8196 31.3274 57.7178 31.7109 57.5142C32.0992 57.3059 32.388 57.0194 32.5774 56.6548C32.7715 56.2855 32.8686 55.8617 32.8686 55.3835C32.8686 54.9006 32.7715 54.4792 32.5774 54.1193C32.388 53.7547 32.0992 53.473 31.7109 53.2741C31.3227 53.0705 30.8303 52.9688 30.2337 52.9688H28.1598V65H25.0845ZM37.0798 52.9901V50.4545H49.0258V52.9901H44.5727V65H41.5329V52.9901H37.0798Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5077", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  PPT$1.displayName = "PPT";
  var psd_exports = {};
  __export$1(psd_exports, {
    PSD: () => PSD$1
  });
  var PSD$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5097)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.3615 65V50.4545H17.1001C18.2033 50.4545 19.1432 50.6652 19.9197 51.0866C20.6962 51.5033 21.2881 52.0833 21.6953 52.8267C22.1072 53.5653 22.3132 54.4176 22.3132 55.3835C22.3132 56.3494 22.1048 57.2017 21.6882 57.9403C21.2715 58.679 20.6678 59.2543 19.8771 59.6662C19.0911 60.0781 18.1394 60.2841 17.022 60.2841H13.3643V57.8196H16.5248C17.1167 57.8196 17.6044 57.7178 17.9879 57.5142C18.3761 57.3059 18.665 57.0194 18.8544 56.6548C19.0485 56.2855 19.1456 55.8617 19.1456 55.3835C19.1456 54.9006 19.0485 54.4792 18.8544 54.1193C18.665 53.7547 18.3761 53.473 17.9879 53.2741C17.5996 53.0705 17.1072 52.9688 16.5106 52.9688H14.4368V65H11.3615ZM31.8013 54.6378C31.7445 54.0649 31.5007 53.6198 31.0698 53.3026C30.6389 52.9853 30.0542 52.8267 29.3155 52.8267C28.8136 52.8267 28.3899 52.8977 28.0442 53.0398C27.6986 53.1771 27.4334 53.3688 27.2488 53.6151C27.0688 53.8613 26.9789 54.1406 26.9789 54.4531C26.9694 54.7135 27.0239 54.9408 27.1422 55.1349C27.2653 55.3291 27.4334 55.4972 27.6465 55.6392C27.8596 55.7765 28.1058 55.8973 28.3851 56.0014C28.6645 56.1009 28.9628 56.1861 29.28 56.2571L30.5868 56.5696C31.2213 56.7116 31.8037 56.901 32.334 57.1378C32.8643 57.3745 33.3236 57.6657 33.7118 58.0114C34.1001 58.357 34.4007 58.7642 34.6138 59.233C34.8316 59.7017 34.9429 60.2391 34.9476 60.8452C34.9429 61.7353 34.7156 62.5071 34.2658 63.1605C33.8207 63.8092 33.1768 64.3134 32.334 64.6733C31.4959 65.0284 30.485 65.206 29.3013 65.206C28.1271 65.206 27.1043 65.026 26.2331 64.6662C25.3667 64.3063 24.6896 63.7737 24.2019 63.0682C23.7189 62.358 23.4656 61.4796 23.4419 60.4332H26.4178C26.4509 60.9209 26.5906 61.3281 26.8368 61.6548C27.0878 61.9768 27.4216 62.2206 27.8382 62.3864C28.2596 62.5473 28.7355 62.6278 29.2658 62.6278C29.7866 62.6278 30.2388 62.5521 30.6223 62.4006C31.0106 62.2491 31.3113 62.0384 31.5243 61.7685C31.7374 61.4986 31.8439 61.1884 31.8439 60.8381C31.8439 60.5114 31.7469 60.2367 31.5527 60.0142C31.3633 59.7917 31.084 59.6023 30.7147 59.446C30.3501 59.2898 29.9026 59.1477 29.3723 59.0199L27.7885 58.6222C26.5622 58.3239 25.5939 57.8575 24.8837 57.223C24.1735 56.5885 23.8207 55.7339 23.8255 54.6591C23.8207 53.7784 24.0551 53.009 24.5286 52.3509C25.0068 51.6927 25.6626 51.179 26.4959 50.8097C27.3292 50.4403 28.2762 50.2557 29.3368 50.2557C30.4164 50.2557 31.3586 50.4403 32.1635 50.8097C32.9732 51.179 33.6029 51.6927 34.0527 52.3509C34.5025 53.009 34.7346 53.7713 34.7488 54.6378H31.8013ZM41.7724 65H36.6162V50.4545H41.815C43.2781 50.4545 44.5376 50.7457 45.5934 51.3281C46.6493 51.9058 47.4613 52.7367 48.0295 53.821C48.6024 54.9053 48.8889 56.2027 48.8889 57.7131C48.8889 59.2282 48.6024 60.5303 48.0295 61.6193C47.4613 62.7083 46.6446 63.544 45.5792 64.1264C44.5186 64.7088 43.2497 65 41.7724 65ZM39.6914 62.3651H41.6446C42.5537 62.3651 43.3183 62.2041 43.9386 61.8821C44.5636 61.5554 45.0324 61.0511 45.3449 60.3693C45.6621 59.6828 45.8207 58.7973 45.8207 57.7131C45.8207 56.6383 45.6621 55.7599 45.3449 55.0781C45.0324 54.3963 44.566 53.8944 43.9457 53.5724C43.3254 53.2505 42.5608 53.0895 41.6517 53.0895H39.6914V62.3651Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5097", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  PSD$1.displayName = "PSD";
  var rar_exports = {};
  __export$1(rar_exports, {
    Rar: () => Rar$1
  });
  var Rar$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5073)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#344054"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.5587 65V50.4545H17.2974C18.3959 50.4545 19.3334 50.651 20.1099 51.044C20.8911 51.4323 21.4853 51.9839 21.8925 52.6989C22.3045 53.4091 22.5104 54.2448 22.5104 55.206C22.5104 56.1719 22.3021 57.0028 21.8854 57.6989C21.4688 58.3902 20.8651 58.9205 20.0744 59.2898C19.2884 59.6591 18.3367 59.8438 17.2192 59.8438H13.3769V57.3722H16.7221C17.3092 57.3722 17.7969 57.2917 18.1852 57.1307C18.5734 56.9697 18.8622 56.7282 19.0516 56.4062C19.2458 56.0843 19.3428 55.6842 19.3428 55.206C19.3428 54.723 19.2458 54.3158 19.0516 53.9844C18.8622 53.6529 18.571 53.402 18.1781 53.2315C17.7898 53.0563 17.2997 52.9688 16.7079 52.9688H14.634V65H11.5587ZM19.4138 58.3807L23.0289 65H19.634L16.0971 58.3807H19.4138ZM26.7908 65H23.4954L28.5167 50.4545H32.4798L37.494 65H34.1985L30.555 53.7784H30.4414L26.7908 65ZM26.5849 59.2827H34.369V61.6832H26.5849V59.2827ZM38.8447 65V50.4545H44.5833C45.6818 50.4545 46.6193 50.651 47.3958 51.044C48.1771 51.4323 48.7713 51.9839 49.1785 52.6989C49.5904 53.4091 49.7964 54.2448 49.7964 55.206C49.7964 56.1719 49.588 57.0028 49.1714 57.6989C48.7547 58.3902 48.151 58.9205 47.3603 59.2898C46.5743 59.6591 45.6226 59.8438 44.5052 59.8438H40.6629V57.3722H44.008C44.5951 57.3722 45.0828 57.2917 45.4711 57.1307C45.8594 56.9697 46.1482 56.7282 46.3376 56.4062C46.5317 56.0843 46.6288 55.6842 46.6288 55.206C46.6288 54.723 46.5317 54.3158 46.3376 53.9844C46.1482 53.6529 45.857 53.402 45.464 53.2315C45.0757 53.0563 44.5857 52.9688 43.9938 52.9688H41.92V65H38.8447ZM46.6998 58.3807L50.3148 65H46.92L43.383 58.3807H46.6998Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5073", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Rar$1.displayName = "Rar";
  var sketch_exports = {};
  __export$1(sketch_exports, {
    Sketch: () => Sketch$1
  });
  var Sketch$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5106)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#FFBA35"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.3739 55.7102C11.3284 55.2519 11.1333 54.8958 10.7886 54.642C10.4439 54.3883 9.97614 54.2614 9.38523 54.2614C8.98371 54.2614 8.6447 54.3182 8.36818 54.4318C8.09167 54.5417 7.87954 54.6951 7.73182 54.892C7.58788 55.089 7.51591 55.3125 7.51591 55.5625C7.50833 55.7708 7.55189 55.9527 7.64659 56.108C7.74508 56.2633 7.87954 56.3977 8.05 56.5114C8.22045 56.6212 8.41742 56.7178 8.64091 56.8011C8.86439 56.8807 9.10303 56.9489 9.35682 57.0057L10.4023 57.2557C10.9098 57.3693 11.3758 57.5208 11.8 57.7102C12.2242 57.8996 12.5917 58.1326 12.9023 58.4091C13.2129 58.6856 13.4534 59.0114 13.6239 59.3864C13.7981 59.7614 13.8871 60.1913 13.8909 60.6761C13.8871 61.3883 13.7053 62.0057 13.3455 62.5284C12.9894 63.0473 12.4742 63.4508 11.8 63.7386C11.1295 64.0227 10.3208 64.1648 9.37386 64.1648C8.43447 64.1648 7.61629 64.0208 6.91932 63.733C6.22614 63.4451 5.68447 63.0189 5.29432 62.4545C4.90795 61.8864 4.7053 61.1837 4.68636 60.3466H7.06704C7.09356 60.7367 7.2053 61.0625 7.40227 61.3239C7.60303 61.5814 7.87008 61.7765 8.20341 61.9091C8.54053 62.0379 8.92121 62.1023 9.34545 62.1023C9.76212 62.1023 10.1239 62.0417 10.4307 61.9205C10.7413 61.7992 10.9818 61.6307 11.1523 61.4148C11.3227 61.1989 11.408 60.9508 11.408 60.6705C11.408 60.4091 11.3303 60.1894 11.175 60.0114C11.0235 59.8333 10.8 59.6818 10.5045 59.5568C10.2129 59.4318 9.85492 59.3182 9.43068 59.2159L8.16364 58.8977C7.18258 58.6591 6.40795 58.286 5.83977 57.7784C5.27159 57.2708 4.98939 56.5871 4.99318 55.7273C4.98939 55.0227 5.17689 54.4072 5.55568 53.8807C5.93826 53.3542 6.46288 52.9432 7.12954 52.6477C7.79621 52.3523 8.55379 52.2045 9.40227 52.2045C10.2659 52.2045 11.0197 52.3523 11.6636 52.6477C12.3114 52.9432 12.8152 53.3542 13.175 53.8807C13.5348 54.4072 13.7205 55.017 13.7318 55.7102H11.3739ZM17.3735 61.4886L17.3791 58.5852H17.7314L20.5269 55.2727H23.3053L19.5496 59.6591H18.9757L17.3735 61.4886ZM15.1803 64V52.3636H17.6007V64H15.1803ZM20.6348 64L18.0666 60.1989L19.6803 58.4886L23.4701 64H20.6348ZM27.7907 64.1705C26.893 64.1705 26.1202 63.9886 25.4725 63.625C24.8286 63.2576 24.3323 62.7386 23.9839 62.0682C23.6354 61.3939 23.4611 60.5966 23.4611 59.6761C23.4611 58.7784 23.6354 57.9905 23.9839 57.3125C24.3323 56.6345 24.8229 56.1061 25.4555 55.7273C26.0918 55.3485 26.838 55.1591 27.6941 55.1591C28.2698 55.1591 28.8058 55.2519 29.302 55.4375C29.802 55.6193 30.2377 55.8939 30.6089 56.2614C30.9839 56.6288 31.2755 57.0909 31.4839 57.6477C31.6922 58.2008 31.7964 58.8485 31.7964 59.5909V60.2557H24.427V58.7557H29.518C29.518 58.4072 29.4422 58.0985 29.2907 57.8295C29.1392 57.5606 28.9289 57.3504 28.66 57.1989C28.3948 57.0436 28.0861 56.9659 27.7339 56.9659C27.3664 56.9659 27.0407 57.0511 26.7566 57.2216C26.4763 57.3883 26.2566 57.6136 26.0975 57.8977C25.9384 58.178 25.857 58.4905 25.8532 58.8352V60.2614C25.8532 60.6932 25.9327 61.0663 26.0918 61.3807C26.2547 61.6951 26.4839 61.9375 26.7793 62.108C27.0748 62.2784 27.4252 62.3636 27.8305 62.3636C28.0994 62.3636 28.3456 62.3258 28.5691 62.25C28.7926 62.1742 28.9839 62.0606 29.143 61.9091C29.302 61.7576 29.4233 61.572 29.5066 61.3523L31.7452 61.5C31.6316 62.0379 31.3986 62.5076 31.0464 62.9091C30.6979 63.3068 30.2471 63.6174 29.6941 63.8409C29.1448 64.0606 28.5104 64.1705 27.7907 64.1705ZM37.698 55.2727V57.0909H32.4423V55.2727H37.698ZM33.6355 53.1818H36.0559V61.3182C36.0559 61.5417 36.09 61.7159 36.1582 61.8409C36.2264 61.9621 36.3211 62.0473 36.4423 62.0966C36.5673 62.1458 36.7112 62.1705 36.8741 62.1705C36.9877 62.1705 37.1014 62.161 37.215 62.142C37.3286 62.1193 37.4158 62.1023 37.4764 62.0909L37.857 63.892C37.7358 63.9299 37.5654 63.9735 37.3457 64.0227C37.126 64.0758 36.8589 64.108 36.5445 64.1193C35.9612 64.142 35.4498 64.0644 35.0105 63.8864C34.5748 63.7083 34.2358 63.4318 33.9934 63.0568C33.751 62.6818 33.6317 62.2083 33.6355 61.6364V53.1818ZM42.8041 64.1705C41.9102 64.1705 41.1412 63.9811 40.4973 63.6023C39.8571 63.2197 39.3647 62.6894 39.02 62.0114C38.6791 61.3333 38.5086 60.553 38.5086 59.6705C38.5086 58.7765 38.681 57.9924 39.0257 57.3182C39.3742 56.6402 39.8685 56.1117 40.5086 55.733C41.1488 55.3504 41.9102 55.1591 42.7927 55.1591C43.5541 55.1591 44.2208 55.2973 44.7927 55.5739C45.3647 55.8504 45.8173 56.2386 46.1507 56.7386C46.484 57.2386 46.6677 57.8258 46.7018 58.5H44.4177C44.3533 58.0644 44.1829 57.714 43.9064 57.4489C43.6336 57.1799 43.2757 57.0455 42.8325 57.0455C42.4575 57.0455 42.1298 57.1477 41.8495 57.3523C41.573 57.553 41.3571 57.8466 41.2018 58.233C41.0465 58.6193 40.9689 59.0871 40.9689 59.6364C40.9689 60.1932 41.0446 60.6667 41.1961 61.0568C41.3514 61.447 41.5692 61.7443 41.8495 61.9489C42.1298 62.1534 42.4575 62.2557 42.8325 62.2557C43.109 62.2557 43.3571 62.1989 43.5768 62.0852C43.8003 61.9716 43.984 61.8068 44.128 61.5909C44.2757 61.3712 44.3723 61.108 44.4177 60.8011H46.7018C46.6639 61.4678 46.4821 62.0549 46.1564 62.5625C45.8344 63.0663 45.3893 63.4602 44.8211 63.7443C44.253 64.0284 43.5806 64.1705 42.8041 64.1705ZM50.352 58.9545V64H47.9315V52.3636H50.2838V56.8125H50.3861C50.5831 56.2973 50.9012 55.8939 51.3406 55.6023C51.78 55.3068 52.3312 55.1591 52.994 55.1591C53.6001 55.1591 54.1285 55.2917 54.5793 55.5568C55.0338 55.8182 55.3861 56.1951 55.6361 56.6875C55.8899 57.1761 56.0149 57.7614 56.0111 58.4432V64H53.5906V58.875C53.5944 58.3371 53.4581 57.9186 53.1815 57.6193C52.9088 57.3201 52.5262 57.1705 52.0338 57.1705C51.7043 57.1705 51.4126 57.2405 51.1588 57.3807C50.9088 57.5208 50.7118 57.7254 50.5679 57.9943C50.4277 58.2595 50.3558 58.5795 50.352 58.9545Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5106", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Sketch$1.displayName = "Sketch";
  var svg_exports = {};
  __export$1(svg_exports, {
    SVG: () => SVG$1
  });
  var SVG$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5089)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M18.3244 54.6378C18.2675 54.0649 18.0237 53.6198 17.5928 53.3026C17.162 52.9853 16.5772 52.8267 15.8386 52.8267C15.3367 52.8267 14.9129 52.8977 14.5673 53.0398C14.2216 53.1771 13.9565 53.3688 13.7718 53.6151C13.5919 53.8613 13.5019 54.1406 13.5019 54.4531C13.4924 54.7135 13.5469 54.9408 13.6653 55.1349C13.7884 55.3291 13.9565 55.4972 14.1695 55.6392C14.3826 55.7765 14.6288 55.8973 14.9082 56.0014C15.1875 56.1009 15.4858 56.1861 15.8031 56.2571L17.1099 56.5696C17.7443 56.7116 18.3267 56.901 18.857 57.1378C19.3873 57.3745 19.8466 57.6657 20.2349 58.0114C20.6231 58.357 20.9238 58.7642 21.1369 59.233C21.3547 59.7017 21.4659 60.2391 21.4707 60.8452C21.4659 61.7353 21.2387 62.5071 20.7888 63.1605C20.3438 63.8092 19.6998 64.3134 18.857 64.6733C18.019 65.0284 17.0081 65.206 15.8244 65.206C14.6501 65.206 13.6274 65.026 12.7562 64.6662C11.8897 64.3063 11.2126 63.7737 10.7249 63.0682C10.242 62.358 9.98866 61.4796 9.96499 60.4332H12.9408C12.974 60.9209 13.1137 61.3281 13.3599 61.6548C13.6108 61.9768 13.9446 62.2206 14.3613 62.3864C14.7827 62.5473 15.2585 62.6278 15.7888 62.6278C16.3097 62.6278 16.7619 62.5521 17.1454 62.4006C17.5336 62.2491 17.8343 62.0384 18.0474 61.7685C18.2604 61.4986 18.367 61.1884 18.367 60.8381C18.367 60.5114 18.2699 60.2367 18.0758 60.0142C17.8864 59.7917 17.607 59.6023 17.2377 59.446C16.8731 59.2898 16.4257 59.1477 15.8954 59.0199L14.3116 58.6222C13.0853 58.3239 12.117 57.8575 11.4067 57.223C10.6965 56.5885 10.3438 55.7339 10.3485 54.6591C10.3438 53.7784 10.5781 53.009 11.0516 52.3509C11.5299 51.6927 12.1856 51.179 13.019 50.8097C13.8523 50.4403 14.7993 50.2557 15.8599 50.2557C16.9394 50.2557 17.8817 50.4403 18.6866 50.8097C19.4962 51.179 20.126 51.6927 20.5758 52.3509C21.0256 53.009 21.2576 53.7713 21.2718 54.6378H18.3244ZM25.767 50.4545L29.2827 61.5057H29.4176L32.9403 50.4545H36.3494L31.3352 65H27.3722L22.3509 50.4545H25.767ZM46.5247 55.1562C46.4253 54.8106 46.2856 54.5052 46.1057 54.2401C45.9258 53.9702 45.7056 53.7429 45.4452 53.5582C45.1895 53.3688 44.8959 53.2244 44.5645 53.125C44.2378 53.0256 43.8756 52.9759 43.4778 52.9759C42.7345 52.9759 42.0811 53.1605 41.5176 53.5298C40.9589 53.8991 40.5233 54.4366 40.2108 55.142C39.8983 55.8428 39.742 56.6998 39.742 57.7131C39.742 58.7263 39.8959 59.5881 40.2037 60.2983C40.5115 61.0085 40.9471 61.5507 41.5105 61.9247C42.074 62.294 42.7392 62.4787 43.5063 62.4787C44.2023 62.4787 44.7965 62.3556 45.2889 62.1094C45.7861 61.8584 46.1649 61.5057 46.4253 61.0511C46.6904 60.5966 46.823 60.0592 46.823 59.4389L47.448 59.5312H43.698V57.2159H49.7847V59.0483C49.7847 60.3267 49.5148 61.4252 48.975 62.3438C48.4352 63.2576 47.6919 63.9631 46.7449 64.4602C45.7979 64.9527 44.7136 65.1989 43.492 65.1989C42.1284 65.1989 40.9305 64.8982 39.8983 64.2969C38.8661 63.6908 38.0612 62.8314 37.4835 61.7188C36.9106 60.6013 36.6241 59.2756 36.6241 57.7415C36.6241 56.5625 36.7946 55.5114 37.1355 54.5881C37.4812 53.66 37.9641 52.8741 38.5844 52.2301C39.2046 51.5862 39.9267 51.0961 40.7506 50.7599C41.5744 50.4238 42.467 50.2557 43.4281 50.2557C44.252 50.2557 45.019 50.3764 45.7293 50.6179C46.4395 50.8546 47.0692 51.1908 47.6185 51.6264C48.1724 52.062 48.6246 52.5805 48.975 53.1818C49.3254 53.7784 49.5503 54.4366 49.6497 55.1562H46.5247Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5089", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  SVG$1.displayName = "SVG";
  var tiff_exports = {};
  __export$1(tiff_exports, {
    TIFF: () => TIFF$1
  });
  var TIFF$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5090)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10.1286 52.9901V50.4545H22.0746V52.9901H17.6215V65H14.5817V52.9901H10.1286ZM26.7172 50.4545V65H23.6419V50.4545H26.7172ZM28.8474 65V50.4545H38.4781V52.9901H31.9227V56.456H37.8389V58.9915H31.9227V65H28.8474ZM40.1466 65V50.4545H49.7773V52.9901H43.2219V56.456H49.1381V58.9915H43.2219V65H40.1466Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5090", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  TIFF$1.displayName = "TIFF";
  var txt_exports = {};
  __export$1(txt_exports, {
    TXT: () => TXT$1
  });
  var TXT$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5080)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#344054"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.1024 52.9901V50.4545H23.0484V52.9901H18.5953V65H15.5555V52.9901H11.1024ZM27.4993 50.4545L30.4325 55.4119H30.5462L33.4936 50.4545H36.9666L32.5277 57.7273L37.0661 65H33.5291L30.5462 60.0355H30.4325L27.4496 65H23.9268L28.4794 57.7273L24.0121 50.4545H27.4993ZM37.9587 52.9901V50.4545H49.9047V52.9901H45.4516V65H42.4118V52.9901H37.9587Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5080", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  TXT$1.displayName = "TXT";
  var wav_exports = {};
  __export$1(wav_exports, {
    WAV: () => WAV$1
  });
  var WAV$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5104)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.7567 65L7.59478 50.4545H10.9542L13.3618 60.5611H13.4826L16.1388 50.4545H19.0152L21.6644 60.5824H21.7922L24.1999 50.4545H27.5593L23.3973 65H20.4002L17.6303 55.4901H17.5167L14.7539 65H11.7567ZM29.8475 65H26.552L31.5733 50.4545H35.5364L40.5506 65H37.2551L33.6117 53.7784H33.498L29.8475 65ZM29.6415 59.2827H37.4256V61.6832H29.6415V59.2827ZM42.7127 50.4545L46.2284 61.5057H46.3633L49.886 50.4545H53.2951L48.2809 65H44.3179L39.2966 50.4545H42.7127Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5104", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  WAV$1.displayName = "WAV";
  var webp_exports = {};
  __export$1(webp_exports, {
    WEBP: () => WEBP$1
  });
  var WEBP$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5103)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9.23283 65L5.69519 52.6364H8.55066L10.5972 61.2269H10.6998L12.9576 52.6364H15.4026L17.6544 61.245H17.763L19.8095 52.6364H22.665L19.1274 65H16.5798L14.2254 56.9165H14.1288L11.7804 65H9.23283ZM23.7241 65V52.6364H32.055V54.7915H26.3381V57.7376H31.6264V59.8928H26.3381V62.8448H32.0792V65H23.7241ZM33.7932 65V52.6364H38.7435C39.6531 52.6364 40.4117 52.7712 41.0195 53.0408C41.6272 53.3105 42.084 53.6848 42.3898 54.1637C42.6957 54.6386 42.8486 55.186 42.8486 55.8058C42.8486 56.2887 42.7521 56.7133 42.5589 57.0795C42.3657 57.4418 42.1001 57.7396 41.762 57.973C41.428 58.2024 41.0456 58.3654 40.615 58.462V58.5827C41.0859 58.6029 41.5266 58.7357 41.9371 58.9812C42.3516 59.2267 42.6877 59.5708 42.9452 60.0135C43.2028 60.4522 43.3316 60.9754 43.3316 61.5831C43.3316 62.2391 43.1686 62.8247 42.8426 63.3398C42.5206 63.851 42.0437 64.2554 41.4119 64.5533C40.78 64.8511 40.0012 65 39.0756 65H33.7932ZM36.4072 62.8629H38.5383C39.2667 62.8629 39.798 62.7241 40.132 62.4464C40.4661 62.1647 40.6331 61.7904 40.6331 61.3235C40.6331 60.9814 40.5506 60.6796 40.3856 60.418C40.2206 60.1564 39.9851 59.9511 39.6793 59.8022C39.3774 59.6533 39.0172 59.5788 38.5986 59.5788H36.4072V62.8629ZM36.4072 57.81H38.3451C38.7033 57.81 39.0212 57.7476 39.2989 57.6229C39.5807 57.4941 39.802 57.313 39.963 57.0795C40.128 56.8461 40.2105 56.5664 40.2105 56.2404C40.2105 55.7937 40.0515 55.4335 39.7336 55.1598C39.4197 54.8861 38.9729 54.7493 38.3934 54.7493H36.4072V57.81ZM44.6925 65V52.6364H49.5703C50.5081 52.6364 51.307 52.8155 51.967 53.1737C52.627 53.5278 53.1301 54.0208 53.4762 54.6527C53.8264 55.2805 54.0015 56.005 54.0015 56.826C54.0015 57.647 53.8244 58.3714 53.4702 58.9993C53.116 59.6271 52.6029 60.1161 51.9308 60.4663C51.2627 60.8164 50.4537 60.9915 49.5039 60.9915H46.3949V58.8967H49.0814C49.5844 58.8967 49.999 58.8101 50.325 58.6371C50.655 58.46 50.9005 58.2165 51.0615 57.9066C51.2265 57.5927 51.309 57.2325 51.309 56.826C51.309 56.4155 51.2265 56.0573 51.0615 55.7514C50.9005 55.4415 50.655 55.2021 50.325 55.033C49.9949 54.86 49.5764 54.7734 49.0693 54.7734H47.3065V65H44.6925Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5103", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  WEBP$1.displayName = "WEBP";
  var xls_exports = {};
  __export$1(xls_exports, {
    XLS: () => XLS$1
  });
  var XLS$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5099)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M15.1727 50.4545L18.106 55.4119H18.2196L21.167 50.4545H24.6401L20.2011 57.7273L24.7395 65H21.2026L18.2196 60.0355H18.106L15.123 65H11.6003L16.1528 57.7273L11.6855 50.4545H15.1727ZM26.1861 65V50.4545H29.2614V62.4645H35.4972V65H26.1861ZM45.0244 54.6378C44.9675 54.0649 44.7237 53.6198 44.2928 53.3026C43.862 52.9853 43.2772 52.8267 42.5386 52.8267C42.0367 52.8267 41.6129 52.8977 41.2673 53.0398C40.9216 53.1771 40.6565 53.3688 40.4718 53.6151C40.2919 53.8613 40.2019 54.1406 40.2019 54.4531C40.1924 54.7135 40.2469 54.9408 40.3653 55.1349C40.4884 55.3291 40.6565 55.4972 40.8695 55.6392C41.0826 55.7765 41.3288 55.8973 41.6082 56.0014C41.8875 56.1009 42.1858 56.1861 42.5031 56.2571L43.8099 56.5696C44.4443 56.7116 45.0267 56.901 45.557 57.1378C46.0873 57.3745 46.5466 57.6657 46.9349 58.0114C47.3231 58.357 47.6238 58.7642 47.8369 59.233C48.0547 59.7017 48.1659 60.2391 48.1707 60.8452C48.1659 61.7353 47.9387 62.5071 47.4889 63.1605C47.0438 63.8092 46.3998 64.3134 45.557 64.6733C44.719 65.0284 43.7081 65.206 42.5244 65.206C41.3501 65.206 40.3274 65.026 39.4562 64.6662C38.5897 64.3063 37.9126 63.7737 37.4249 63.0682C36.942 62.358 36.6887 61.4796 36.665 60.4332H39.6408C39.674 60.9209 39.8137 61.3281 40.0599 61.6548C40.3108 61.9768 40.6446 62.2206 41.0613 62.3864C41.4827 62.5473 41.9585 62.6278 42.4888 62.6278C43.0097 62.6278 43.4619 62.5521 43.8454 62.4006C44.2336 62.2491 44.5343 62.0384 44.7474 61.7685C44.9604 61.4986 45.067 61.1884 45.067 60.8381C45.067 60.5114 44.9699 60.2367 44.7758 60.0142C44.5864 59.7917 44.307 59.6023 43.9377 59.446C43.5731 59.2898 43.1257 59.1477 42.5954 59.0199L41.0116 58.6222C39.7853 58.3239 38.817 57.8575 38.1067 57.223C37.3965 56.5885 37.0438 55.7339 37.0485 54.6591C37.0438 53.7784 37.2781 53.009 37.7516 52.3509C38.2299 51.6927 38.8856 51.179 39.719 50.8097C40.5523 50.4403 41.4993 50.2557 42.5599 50.2557C43.6394 50.2557 44.5817 50.4403 45.3866 50.8097C46.1962 51.179 46.826 51.6927 47.2758 52.3509C47.7256 53.009 47.9576 53.7713 47.9718 54.6378H45.0244Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5099", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  XLS$1.displayName = "XLS";
  var zip_exports = {};
  __export$1(zip_exports, {
    Zip: () => Zip$1
  });
  var Zip$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5074)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#344054"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M15.5607 65V63.1747L22.8192 52.9901H15.5465V50.4545H26.6828V52.2798L19.4172 62.4645H26.6971V65H15.5607ZM31.7321 50.4545V65H28.6568V50.4545H31.7321ZM33.8623 65V50.4545H39.6009C40.7041 50.4545 41.644 50.6652 42.4205 51.0866C43.197 51.5033 43.7889 52.0833 44.1961 52.8267C44.608 53.5653 44.814 54.4176 44.814 55.3835C44.814 56.3494 44.6056 57.2017 44.189 57.9403C43.7723 58.679 43.1686 59.2543 42.3779 59.6662C41.5919 60.0781 40.6402 60.2841 39.5228 60.2841H35.8651V57.8196H39.0256C39.6175 57.8196 40.1051 57.7178 40.4887 57.5142C40.8769 57.3059 41.1658 57.0194 41.3551 56.6548C41.5493 56.2855 41.6463 55.8617 41.6463 55.3835C41.6463 54.9006 41.5493 54.4792 41.3551 54.1193C41.1658 53.7547 40.8769 53.473 40.4887 53.2741C40.1004 53.0705 39.608 52.9688 39.0114 52.9688H36.9375V65H33.8623Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5074", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Zip$1.displayName = "Zip";
  var CarouselContext = reactExports.createContext(null);
  function useCarousel() {
    const context = reactExports.useContext(CarouselContext);
    if (!context) {
      throw new Error("useCarousel must be used within a <Carousel />");
    }
    return context;
  }
  var Carousel = reactExports.forwardRef(
    ({
      orientation: orientation2 = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    }, ref) => {
      const [carouselRef, api] = useEmblaCarousel(
        {
          ...opts,
          axis: orientation2 === "horizontal" ? "x" : "y"
        },
        plugins
      );
      const [canScrollPrev, setCanScrollPrev] = reactExports.useState(false);
      const [canScrollNext, setCanScrollNext] = reactExports.useState(false);
      const [slideCount, setSlideCount] = reactExports.useState(0);
      const onSelect = reactExports.useCallback((api2) => {
        if (!api2) {
          return;
        }
        setCanScrollPrev(api2.canScrollPrev());
        setCanScrollNext(api2.canScrollNext());
        setSlideCount(api2.scrollSnapList().length);
      }, []);
      const scrollPrev = reactExports.useCallback(() => {
        api == null ? void 0 : api.scrollPrev();
      }, [api]);
      const scrollNext = reactExports.useCallback(() => {
        api == null ? void 0 : api.scrollNext();
      }, [api]);
      const handleKeyDown = reactExports.useCallback(
        (event) => {
          if (event.key === "ArrowLeft") {
            event.preventDefault();
            scrollPrev();
          } else if (event.key === "ArrowRight") {
            event.preventDefault();
            scrollNext();
          }
        },
        [scrollPrev, scrollNext]
      );
      reactExports.useEffect(() => {
        if (!api || !setApi) {
          return;
        }
        setApi(api);
      }, [api, setApi]);
      reactExports.useEffect(() => {
        if (!api) {
          return;
        }
        onSelect(api);
        api.on("reInit", onSelect);
        api.on("select", onSelect);
        return () => {
          api == null ? void 0 : api.off("select", onSelect);
        };
      }, [api, onSelect]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CarouselContext.Provider,
        {
          value: {
            carouselRef,
            api,
            opts,
            orientation: orientation2 || ((opts == null ? void 0 : opts.axis) === "y" ? "vertical" : "horizontal"),
            scrollPrev,
            scrollNext,
            canScrollPrev,
            canScrollNext
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              ref,
              onKeyDownCapture: handleKeyDown,
              className: cn$1("lua:relative", className),
              role: "region",
              "aria-roledescription": "carousel",
              "aria-label": `Carousel with ${slideCount} slides`,
              "aria-live": "polite",
              "aria-atomic": "false",
              tabIndex: 0,
              ...props,
              children
            }
          )
        }
      );
    }
  );
  Carousel.displayName = "Carousel";
  var CarouselContent = reactExports.forwardRef(({ className, ...props }, ref) => {
    const { carouselRef, orientation: orientation2 } = useCarousel();
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: carouselRef, className: "lua:overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref,
        className: cn$1(
          "lua:flex",
          orientation2 === "horizontal" ? "lua:-mx-2" : "lua:-my-2 lua:flex-col",
          className
        ),
        ...props
      }
    ) });
  });
  CarouselContent.displayName = "CarouselContent";
  var CarouselItem = reactExports.forwardRef(({ className, ...props }, ref) => {
    const { orientation: orientation2 } = useCarousel();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref,
        role: "group",
        "aria-roledescription": "slide",
        className: cn$1(
          "lua:min-w-0 lua:flex-none lua:w-full",
          orientation2 === "horizontal" ? "lua:px-2" : "lua:py-2",
          className
        ),
        ...props
      }
    );
  });
  CarouselItem.displayName = "CarouselItem";
  var CarouselPrevious = reactExports.forwardRef(({ className, variant = "outline", size: size2 = "small", ...props }, ref) => {
    const { orientation: orientation2, scrollPrev, canScrollPrev } = useCarousel();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        ref,
        variant,
        size: size2,
        className: cn$1(
          "lua:absolute lua:h-8 lua:w-8 lua:p-0 lua:rounded-full lua:bg-white lua:border lua:border-gray-200 lua:hover:bg-gray-100 lua:hover:text-gray-900 lua:focus:ring-2 lua:focus:ring-blue-600 lua:focus:ring-offset-2 lua:disabled:opacity-50 lua:disabled:cursor-not-allowed",
          orientation2 === "horizontal" ? "lua:-left-12 lua:top-1/2 lua:-translate-y-1/2" : "lua:-top-12 lua:left-1/2 lua:-translate-x-1/2 lua:rotate-90",
          className
        ),
        disabled: !canScrollPrev,
        onClick: scrollPrev,
        "aria-label": "Go to previous slide",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeft$1, { size: 16, "aria-hidden": true })
      }
    );
  });
  CarouselPrevious.displayName = "CarouselPrevious";
  var CarouselNext = reactExports.forwardRef(({ className, variant = "outline", size: size2 = "small", ...props }, ref) => {
    const { orientation: orientation2, scrollNext, canScrollNext } = useCarousel();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        ref,
        variant,
        size: size2,
        className: cn$1(
          "lua:absolute lua:h-8 lua:w-8 lua:p-0 lua:rounded-full lua:bg-white lua:border lua:border-gray-200 lua:hover:bg-gray-100 lua:hover:text-gray-900 lua:focus:ring-2 lua:focus:ring-blue-600 lua:focus:ring-offset-2 lua:disabled:opacity-50 lua:disabled:cursor-not-allowed",
          orientation2 === "horizontal" ? "lua:-right-12 lua:top-1/2 lua:-translate-y-1/2" : "lua:-bottom-12 lua:left-1/2 lua:-translate-x-1/2 lua:rotate-90",
          className
        ),
        disabled: !canScrollNext,
        onClick: scrollNext,
        "aria-label": "Go to next slide",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { size: 16, "aria-hidden": true })
      }
    );
  });
  CarouselNext.displayName = "CarouselNext";
  var Dialog = Root$3;
  var DialogPortal = Portal$2;
  var DialogOverlay = reactExports.forwardRef(({ className, style, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Overlay,
    {
      ref,
      className: cn$1(
        "lua:fixed lua:inset-0 lua:z-50 lua:transition-opacity lua:duration-200",
        className
      ),
      style: {
        backgroundColor: "rgba(0, 0, 0, 0.8)",
        backdropFilter: "blur(4px)",
        ...style
      },
      ...props
    }
  ));
  DialogOverlay.displayName = Overlay.displayName;
  var DialogContent = reactExports.forwardRef(({ className, children, showClose = true, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogPortal, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlay, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Content,
      {
        ref,
        className: cn$1(
          "lua:fixed lua:z-50 lua:max-w-lg lua:outline-hidden lua:border lua:border-gray-200 lua:bg-white lua:p-6 lua:shadow-lg lua:transition-all lua:duration-200 lua:rounded-xl lua:mx-4",
          className
        ),
        style: {
          left: "50%",
          top: "50%",
          transform: "translateX(-50%) translateY(-50%)"
        },
        ...props,
        children: [
          children,
          showClose && /* @__PURE__ */ jsxRuntimeExports.jsx(Close, { className: "lua:absolute lua:right-4 lua:top-4 lua:rounded-sm lua:opacity-70 lua:ring-offset-white lua:transition-opacity lua:hover:opacity-100 lua:focus:outline-hidden lua:focus:ring-2 lua:focus:ring-blue-600 lua:focus:ring-offset-2 lua:disabled:pointer-events-none lua:hover:bg-gray-100 lua:text-gray-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(XIcon$1, { size: 24 }) })
        ]
      }
    )
  ] }));
  DialogContent.displayName = Content.displayName;
  var DialogTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Title,
    {
      ref,
      className: cn$1(
        "lua:text-lg lua:font-semibold lua:leading-none lua:tracking-tight",
        className
      ),
      ...props
    }
  ));
  DialogTitle.displayName = Title.displayName;
  var DialogDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Description,
    {
      ref,
      className: cn$1("lua:text-sm lua:text-gray-600", className),
      ...props
    }
  ));
  DialogDescription.displayName = Description.displayName;
  var SheetPortal = Portal$2;
  var SheetOverlay = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Overlay,
    {
      className: cn$1(
        "lua:fixed lua:inset-0 lua:z-50 lua:bg-black/80 lua:backdrop-blur-sm data-[state=open]:lua:animate-in data-[state=closed]:lua:animate-out data-[state=closed]:lua:fade-out-0 data-[state=open]:lua:fade-in-0",
        className
      ),
      ...props,
      ref
    }
  ));
  SheetOverlay.displayName = Overlay.displayName;
  var sheetVariants = cva(
    "lua:fixed lua:z-50 lua:gap-4 lua:bg-white lua:shadow-lg lua:transition lua:ease-in-out lua:data-[state=open]:animate-in lua:data-[state=closed]:animate-out lua:data-[state=closed]:duration-300 lua:data-[state=open]:duration-500",
    {
      variants: {
        side: {
          top: "lua:inset-x-0 lua:top-0 lua:border-b data-[state=closed]:lua:slide-out-to-top data-[state=open]:lua:slide-in-from-top",
          bottom: "lua:inset-x-0 lua:bottom-0 lua:border-t data-[state=closed]:lua:slide-out-to-bottom data-[state=open]:lua:slide-in-from-bottom",
          left: "lua:inset-y-0 lua:left-0 lua:h-full lua:w-3/4 lua:border-r lua:data-[state=closed]:slide-out-to-left lua:data-[state=open]:slide-in-from-left lua:sm:max-w-sm",
          right: "lua:inset-y-0 lua:right-0 lua:h-full lua:w-3/4 lua:border-l lua:data-[state=closed]:slide-out-to-right lua:data-[state=open]:slide-in-from-right lua:sm:max-w-sm"
        }
      },
      defaultVariants: {
        side: "right"
      }
    }
  );
  var SheetContent = reactExports.forwardRef(
    ({
      side = "right",
      className,
      children,
      showClose = true,
      showOverlay = true,
      ...props
    }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(SheetPortal, { children: [
      showOverlay && /* @__PURE__ */ jsxRuntimeExports.jsx(SheetOverlay, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Content,
        {
          ref,
          className: cn$1(sheetVariants({ side }), className),
          ...props,
          children: [
            children,
            showClose && /* @__PURE__ */ jsxRuntimeExports.jsxs(Close, { className: "lua:absolute lua:right-4 lua:top-4 lua:rounded-sm lua:opacity-70 lua:ring-offset-white lua:transition-opacity lua:hover:opacity-100 lua:focus:outline-hidden lua:focus:ring-2 lua:focus:ring-blue-600 lua:focus:ring-offset-2 lua:disabled:pointer-events-none lua:data-[state=open]:bg-gray-100", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(XIcon$1, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:sr-only", children: "Close" })
            ] })
          ]
        }
      )
    ] })
  );
  SheetContent.displayName = Content.displayName;
  var SheetTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Title,
    {
      ref,
      className: cn$1(
        "lua:text-base lua:font-semibold lua:text-gray-900",
        className
      ),
      ...props
    }
  ));
  SheetTitle.displayName = Title.displayName;
  var SheetDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Description,
    {
      ref,
      className: cn$1("lua:text-sm lua:text-gray-600", className),
      ...props
    }
  ));
  SheetDescription.displayName = Description.displayName;
  var variantStyles = {
    h1: "lua:text-4xl lua:font-bold lua:leading-tight lua:tracking-tight lua:font-onest",
    h2: "lua:text-3xl lua:font-semibold lua:leading-tight lua:tracking-tight lua:font-onest",
    h3: "lua:text-2xl lua:font-semibold lua:leading-snug lua:font-onest",
    h4: "lua:text-xl lua:font-semibold lua:leading-snug lua:font-onest",
    h5: "lua:text-lg lua:font-semibold lua:leading-normal lua:font-onest",
    h6: "lua:text-base lua:font-semibold lua:leading-normal lua:font-onest",
    "body-xl": "lua:text-lg lua:leading-relaxed lua:font-sans",
    "body-lg": "lua:text-base lua:leading-relaxed lua:font-sans",
    "body": "lua:text-sm lua:leading-relaxed lua:font-sans",
    "body-sm": "lua:text-xs lua:leading-normal lua:font-sans",
    "caption": "lua:text-xs lua:leading-snug lua:font-sans",
    "overline": "lua:text-xs lua:leading-snug lua:font-medium lua:uppercase lua:tracking-wide lua:font-sans"
  };
  var defaultElements = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    "body-xl": "p",
    "body-lg": "p",
    "body": "p",
    "body-sm": "p",
    "caption": "span",
    "overline": "span"
  };
  var Typography = React.forwardRef(
    ({ variant = "body", as, className, children, ...props }, ref) => {
      const Component2 = as || defaultElements[variant];
      return React.createElement(
        Component2,
        {
          ref,
          className: cn$1(variantStyles[variant], className),
          ...props
        },
        children
      );
    }
  );
  Typography.displayName = "Typography";
  var Heading1 = React.forwardRef(
    (props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { ref, variant: "h1", ...props })
  );
  Heading1.displayName = "Heading1";
  var Heading2 = React.forwardRef(
    (props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { ref, variant: "h2", ...props })
  );
  Heading2.displayName = "Heading2";
  var Heading3 = React.forwardRef(
    (props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { ref, variant: "h3", ...props })
  );
  Heading3.displayName = "Heading3";
  var Heading4 = React.forwardRef(
    (props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { ref, variant: "h4", ...props })
  );
  Heading4.displayName = "Heading4";
  var Heading5 = React.forwardRef(
    (props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { ref, variant: "h5", ...props })
  );
  Heading5.displayName = "Heading5";
  var Heading6 = React.forwardRef(
    (props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { ref, variant: "h6", ...props })
  );
  Heading6.displayName = "Heading6";
  var Text = React.forwardRef(
    ({ size: size2 = "default", ...props }, ref) => {
      const variant = size2 === "xl" ? "body-xl" : size2 === "lg" ? "body-lg" : size2 === "sm" ? "body-sm" : "body";
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { ref, variant, ...props });
    }
  );
  Text.displayName = "Text";
  var Caption = React.forwardRef(
    (props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { ref, variant: "caption", ...props })
  );
  Caption.displayName = "Caption";
  var Overline = React.forwardRef(
    (props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { ref, variant: "overline", ...props })
  );
  Overline.displayName = "Overline";
  var Link = React.forwardRef(
    ({ variant = "primary", className, children, ...props }, ref) => {
      const variantClass = `link-${variant}`;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          ref,
          className: cn$1(variantClass, className),
          ...props,
          children
        }
      );
    }
  );
  Link.displayName = "Link";
  var PaginationContext = reactExports.createContext({
    size: "default"
  });
  var usePaginationContext = () => {
    const context = reactExports.useContext(PaginationContext);
    return context;
  };
  var paginationVariants = cva(
    "lua:mx-auto lua:flex lua:w-full lua:justify-center",
    {
      variants: {
        size: {
          default: "",
          small: ""
        }
      },
      defaultVariants: {
        size: "default"
      }
    }
  );
  var Pagination = reactExports.forwardRef(
    ({ className, size: size2 = "default", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationContext.Provider, { value: { size: size2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "nav",
      {
        ref,
        role: "navigation",
        "aria-label": "pagination",
        className: cn$1(paginationVariants({ size: size2 }), className),
        ...props
      }
    ) })
  );
  Pagination.displayName = "Pagination";
  var PaginationContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "ul",
    {
      ref,
      className: cn$1("lua:flex lua:flex-row lua:items-center lua:gap-1", className),
      ...props
    }
  ));
  PaginationContent.displayName = "PaginationContent";
  var PaginationItem = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { ref, className: cn$1("", className), ...props }));
  PaginationItem.displayName = "PaginationItem";
  var paginationLinkVariants = cva(
    [
      "lua:flex lua:items-center lua:justify-center lua:rounded-md lua:font-semibold lua:transition-colors lua:no-underline",
      "lua:bg-black lua:text-white",
      "lua:hover:bg-black-hover",
      "lua:active:bg-black-hover",
      "lua:focus-visible:outline-hidden lua:focus-visible:ring-2 lua:focus-visible:ring-black lua:focus-visible:ring-offset-2 lua:focus-visible:ring-offset-white"
    ],
    {
      variants: {
        size: {
          default: "lua:h-8 lua:w-8 lua:text-sm",
          small: "lua:h-7 lua:w-7 lua:text-xs"
        }
      },
      defaultVariants: {
        size: "default"
      }
    }
  );
  var PaginationLink = reactExports.forwardRef(({ className, isActive, ...props }, ref) => {
    const { size: size2 } = usePaginationContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "a",
      {
        ref,
        "aria-current": isActive ? "page" : void 0,
        className: cn$1(
          paginationLinkVariants({ size: size2 }),
          isActive && "lua:bg-black-hover",
          className
        ),
        ...props
      }
    );
  });
  PaginationLink.displayName = "PaginationLink";
  var PaginationPrevious = reactExports.forwardRef(({ className, ...props }, ref) => {
    const { size: size2 } = usePaginationContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      PaginationLink,
      {
        ref,
        "aria-label": "Go to previous page",
        className: cn$1(
          "lua:gap-1 lua:w-auto",
          size2 === "small" ? "lua:px-2" : "lua:px-3",
          className
        ),
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeft$1, { size: size2 === "small" ? 12 : 16, "aria-hidden": true }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:hidden lua:sm:lua:inline", children: "Previous" })
        ]
      }
    );
  });
  PaginationPrevious.displayName = "PaginationPrevious";
  var PaginationNext = reactExports.forwardRef(({ className, ...props }, ref) => {
    const { size: size2 } = usePaginationContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      PaginationLink,
      {
        ref,
        "aria-label": "Go to next page",
        className: cn$1(
          "lua:gap-1 lua:w-auto",
          size2 === "small" ? "lua:px-2" : "lua:px-3",
          className
        ),
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:hidden lua:sm:lua:inline", children: "Next" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { size: size2 === "small" ? 12 : 16, "aria-hidden": true })
        ]
      }
    );
  });
  PaginationNext.displayName = "PaginationNext";
  var PaginationEllipsis = reactExports.forwardRef(({ className, ...props }, ref) => {
    const { size: size2 } = usePaginationContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref,
        "aria-hidden": "true",
        className: cn$1(
          "lua:flex lua:items-center lua:justify-center",
          size2 === "small" ? "lua:h-7 lua:w-7" : "lua:h-8 lua:w-8",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DotsThree, { size: size2 === "small" ? 12 : 16 })
      }
    );
  });
  PaginationEllipsis.displayName = "PaginationEllipsis";
  var DropdownMenuSubTrigger = reactExports.forwardRef(({ className, inset, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SubTrigger2,
    {
      ref,
      className: cn$1(
        "lua:flex lua:cursor-default lua:select-none lua:items-center lua:gap-2 lua:rounded-sm lua:px-2 lua:py-2 lua:text-sm lua:outline-hidden lua:focus:bg-gray-100 data-[state=open]:lua:bg-gray-100 [&_svg]:lua:pointer-events-none [&_svg]:lua:size-4 [&_svg]:lua:shrink-0",
        inset && "lua:pl-8",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsx(CaretRight, { size: 16, className: "lua:ml-auto" })
      ]
    }
  ));
  DropdownMenuSubTrigger.displayName = SubTrigger2.displayName;
  var DropdownMenuSubContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent2,
    {
      ref,
      className: cn$1(
        "lua:z-50 lua:min-w-32 lua:overflow-hidden lua:rounded-md lua:border lua:border-gray-200 lua:bg-white lua:text-gray-900 lua:p-1 lua:shadow-lg data-[state=open]:lua:animate-in data-[state=closed]:lua:animate-out data-[state=closed]:lua:fade-out-0 data-[state=open]:lua:fade-in-0 data-[state=closed]:lua:zoom-out-95 data-[state=open]:lua:zoom-in-95",
        className
      ),
      ...props
    }
  ));
  DropdownMenuSubContent.displayName = SubContent2.displayName;
  var DropdownMenuContent = reactExports.forwardRef(({ className, sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content2$1,
    {
      ref,
      sideOffset,
      className: cn$1(
        "lua:z-50 lua:max-h-96 lua:min-w-32 lua:overflow-y-auto lua:overflow-x-hidden lua:rounded-md lua:border lua:border-gray-200 lua:bg-white lua:text-gray-900 lua:p-1 lua:shadow-md",
        "data-[state=open]:lua:animate-in data-[state=closed]:lua:animate-out data-[state=closed]:lua:fade-out-0 data-[state=open]:lua:fade-in-0 data-[state=closed]:lua:zoom-out-95 data-[state=open]:lua:zoom-in-95",
        className
      ),
      ...props
    }
  ) }));
  DropdownMenuContent.displayName = Content2$1.displayName;
  var DropdownMenuItem = reactExports.forwardRef(({ className, inset, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Item2$1,
    {
      ref,
      className: cn$1(
        "lua:relative lua:flex lua:cursor-default lua:select-none lua:items-center lua:gap-2 lua:rounded-sm lua:px-2 lua:py-2 lua:text-sm lua:outline-hidden lua:transition-colors lua:focus:bg-gray-100 lua:focus:text-gray-900 data-disabled:lua:pointer-events-none data-disabled:lua:opacity-50 [&>svg]:lua:size-4 [&>svg]:lua:shrink-0",
        inset && "lua:pl-8",
        className
      ),
      ...props
    }
  ));
  DropdownMenuItem.displayName = Item2$1.displayName;
  var DropdownMenuCheckboxItem = reactExports.forwardRef(({ className, children, checked, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    CheckboxItem2,
    {
      ref,
      className: cn$1(
        "lua:relative lua:flex lua:cursor-default lua:select-none lua:items-center lua:rounded-sm lua:py-2 lua:pl-8 lua:pr-2 lua:text-sm lua:outline-hidden lua:transition-colors lua:focus:bg-gray-100 lua:focus:text-gray-900 data-disabled:lua:pointer-events-none data-disabled:lua:opacity-50",
        className
      ),
      checked,
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:absolute lua:left-2 lua:flex lua:h-4 lua:w-4 lua:items-center lua:justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 16 }) }) }),
        children
      ]
    }
  ));
  DropdownMenuCheckboxItem.displayName = CheckboxItem2.displayName;
  var DropdownMenuRadioItem = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    RadioItem2,
    {
      ref,
      className: cn$1(
        "lua:relative lua:flex lua:cursor-default lua:select-none lua:items-center lua:rounded-sm lua:py-2 lua:pl-8 lua:pr-2 lua:text-sm lua:outline-hidden lua:transition-colors lua:focus:bg-gray-100 lua:focus:text-gray-900 data-disabled:lua:pointer-events-none data-disabled:lua:opacity-50",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:absolute lua:left-2 lua:flex lua:h-4 lua:w-4 lua:items-center lua:justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Circle, { size: 8, className: "lua:fill-current" }) }) }),
        children
      ]
    }
  ));
  DropdownMenuRadioItem.displayName = RadioItem2.displayName;
  var DropdownMenuLabel = reactExports.forwardRef(({ className, inset, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Label2,
    {
      ref,
      className: cn$1(
        "lua:px-2 lua:py-2 lua:text-sm lua:font-semibold",
        inset && "lua:pl-8",
        className
      ),
      ...props
    }
  ));
  DropdownMenuLabel.displayName = Label2.displayName;
  var DropdownMenuSeparator = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Separator2,
    {
      ref,
      className: cn$1("lua:-mx-1 lua:my-1 lua:h-px lua:bg-gray-200", className),
      ...props
    }
  ));
  DropdownMenuSeparator.displayName = Separator2.displayName;
  var TableWrapper = reactExports.forwardRef(
    ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref,
        "data-slot": "table-wrapper",
        className: cn$1(
          " lua:border-gray-200 lua:rounded-xl lua:border-0 lua:md:border-1",
          className
        ),
        ...props
      }
    )
  );
  TableWrapper.displayName = "TableWrapper";
  var Table = reactExports.forwardRef(
    ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        "data-slot": "table-container",
        className: "lua:relative lua:w-full lua:overflow-x-auto lua:rounded-xl",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "table",
          {
            ref,
            "data-slot": "table",
            className: cn$1(
              "lua:w-full lua:caption-bottom lua:text-sm lua:block lua:md:table",
              className
            ),
            ...props
          }
        )
      }
    )
  );
  Table.displayName = "Table";
  var TableHeader = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "thead",
    {
      ref,
      "data-slot": "table-header",
      className: cn$1(
        "lua:[&_tr]:border-none lua:hidden lua:md:table-header-group",
        className
      ),
      ...props
    }
  ));
  TableHeader.displayName = "TableHeader";
  var TableBody = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "tbody",
    {
      ref,
      "data-slot": "table-body",
      className: cn$1(
        "lua:[&_tr:last-child]:border-0 lua:block lua:md:table-row-group lua:space-y-4 lua:md:space-y-0",
        className
      ),
      ...props
    }
  ));
  TableBody.displayName = "TableBody";
  var TableFooter = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "tfoot",
    {
      ref,
      "data-slot": "table-footer",
      className: cn$1(
        "lua:bg-gray-50 lua:border-t lua:font-medium lua:[&>tr]:last:border-b-0 lua:block lua:md:table-footer-group lua:mt-4 lua:md:mt-0",
        className
      ),
      ...props
    }
  ));
  TableFooter.displayName = "TableFooter";
  var TableRow = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "tr",
    {
      ref,
      "data-slot": "table-row",
      className: cn$1(
        "lua:transition-colors lua:block lua:md:table-row",
        // Mobile card styles (default)
        "lua:bg-white lua:border lua:border-gray-200 lua:rounded-lg lua:p-4 lua:shadow-sm lua:mb-4",
        // Desktop table styles (md and up)
        "lua:md:bg-transparent lua:md:border-0 lua:md:border-b lua:md:border-gray-200 lua:md:rounded-none lua:md:p-0 lua:md:shadow-none lua:md:mb-0",
        "lua:md:hover:bg-gray-50 lua:md:data-[state=selected]:bg-gray-100",
        className
      ),
      ...props
    }
  ));
  TableRow.displayName = "TableRow";
  var TableHead = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "th",
    {
      ref,
      "data-slot": "table-head",
      className: cn$1(
        "lua:bg-gray-100 lua:text-gray-900 lua:h-11 lua:px-4 lua:text-left lua:align-middle lua:font-medium lua:whitespace-nowrap [&:has([role=checkbox])]:lua:pr-0 [&>[role=checkbox]]:lua:translate-y-[2px] lua:hidden lua:md:table-cell",
        className
      ),
      ...props
    }
  ));
  TableHead.displayName = "TableHead";
  var TableCell = reactExports.forwardRef(({ className, label, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "td",
    {
      ref,
      "data-slot": "table-cell",
      "data-label": label,
      className: cn$1(
        "lua:[&:has([role=checkbox])]:pr-0 lua:[&>[role=checkbox]]:translate-y-[2px] lua:block lua:md:table-cell",
        // Mobile card cell styles (default)
        "lua:py-3 lua:px-0 lua:border-b lua:border-gray-100 last:lua:border-b-0 lua:text-left",
        "lua:before:content-[attr(data-label)] lua:before:float-left lua:before:font-normal before:lua:text-gray-700 lua:before:mr-4 lua:before:min-w-[100px]",
        // Desktop table cell styles (md and up)
        "lua:md:px-4 lua:md:align-middle lua:md:whitespace-nowrap lua:md:text-left lua:md:border-b-0",
        "lua:md:before:content-none",
        className
      ),
      ...props
    }
  ));
  TableCell.displayName = "TableCell";
  var TableCaption = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "caption",
    {
      ref,
      "data-slot": "table-caption",
      className: cn$1("lua:text-gray-600 lua:mt-4 lua:text-sm", className),
      ...props
    }
  ));
  TableCaption.displayName = "TableCaption";
  var SelectTrigger = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Trigger,
    {
      ref,
      className: cn$1(
        "lua:flex lua:h-10 lua:w-full lua:items-center lua:justify-between lua:rounded-md lua:border lua:border-gray-300 lua:bg-white lua:px-3 lua:py-2 lua:text-sm lua:text-gray-900 lua:ring-offset-white lua:placeholder:text-gray-500 lua:focus:outline-hidden lua:focus:ring-2 lua:focus:ring-blue-600 lua:focus:ring-offset-2 lua:disabled:cursor-not-allowed lua:disabled:opacity-50 [&>span]:lua:line-clamp-1",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CaretDown, { size: 16, className: "lua:opacity-50" }) })
      ]
    }
  ));
  SelectTrigger.displayName = Trigger.displayName;
  var SelectScrollUpButton = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollUpButton,
    {
      ref,
      className: cn$1(
        "lua:flex lua:cursor-default lua:items-center lua:justify-center lua:py-1",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CaretRight, { size: 16, className: "lua:rotate-270" })
    }
  ));
  SelectScrollUpButton.displayName = ScrollUpButton.displayName;
  var SelectScrollDownButton = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollDownButton,
    {
      ref,
      className: cn$1(
        "lua:flex lua:cursor-default lua:items-center lua:justify-center lua:py-1",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CaretRight, { size: 16, className: "lua:rotate-90" })
    }
  ));
  SelectScrollDownButton.displayName = ScrollDownButton.displayName;
  var SelectContent = reactExports.forwardRef(({ className, children, position: position2 = "popper", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Content2,
    {
      ref,
      className: cn$1(
        "lua:relative lua:z-50 lua:max-h-96 lua:min-w-32 lua:overflow-hidden lua:rounded-md lua:border lua:border-gray-200 lua:bg-white lua:text-gray-900 lua:shadow-md data-[state=open]:lua:animate-in data-[state=closed]:lua:animate-out data-[state=closed]:lua:fade-out-0 data-[state=open]:lua:fade-in-0 data-[state=closed]:lua:zoom-out-95 data-[state=open]:lua:zoom-in-95",
        className
      ),
      position: position2,
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollUpButton, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Viewport,
          {
            className: cn$1(
              "lua:p-1",
              position2 === "popper" && "lua:h-auto lua:w-full lua:min-w-32"
            ),
            children
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollDownButton, {})
      ]
    }
  ) }));
  SelectContent.displayName = Content2.displayName;
  var SelectLabel = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Label$1,
    {
      ref,
      className: cn$1("lua:py-2 lua:pl-8 lua:pr-2 lua:text-sm lua:font-semibold", className),
      ...props
    }
  ));
  SelectLabel.displayName = Label$1.displayName;
  var SelectItem = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Item,
    {
      ref,
      className: cn$1(
        "lua:relative lua:flex lua:w-full lua:cursor-default lua:select-none lua:items-center lua:rounded-sm lua:py-2 lua:pl-8 lua:pr-2 lua:text-sm lua:outline-hidden lua:focus:bg-gray-100 lua:focus:text-gray-900 data-disabled:lua:pointer-events-none data-disabled:lua:opacity-50",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:absolute lua:left-2 lua:flex lua:h-4 lua:w-4 lua:items-center lua:justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 16 }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
      ]
    }
  ));
  SelectItem.displayName = Item.displayName;
  var SelectSeparator = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Separator,
    {
      ref,
      className: cn$1("lua:-mx-1 lua:my-1 lua:h-px lua:bg-gray-200", className),
      ...props
    }
  ));
  SelectSeparator.displayName = Separator.displayName;
  var Label3 = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root$2,
    {
      ref,
      className: cn$1(
        "lua:text-sm lua:font-medium lua:leading-none lua:peer-disabled:cursor-not-allowed lua:peer-disabled:opacity-70",
        className
      ),
      ...props
    }
  ));
  Label3.displayName = Root$2.displayName;
  var Switch = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root$1,
    {
      className: cn$1(
        "lua:peer lua:inline-flex lua:h-5 lua:w-9 lua:shrink-0 lua:cursor-pointer lua:items-center lua:rounded-full lua:border-2 lua:border-transparent lua:transition-all lua:focus-visible:outline-none lua:focus-visible:ring-2 lua:focus-visible:ring-blue-600 lua:focus-visible:ring-offset-2 lua:disabled:cursor-not-allowed lua:disabled:opacity-50 lua:data-[state=checked]:bg-blue-500 lua:data-[state=unchecked]:bg-gray-200",
        className
      ),
      ...props,
      ref,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb$1, { className: "lua:pointer-events-none lua:block lua:h-4 lua:w-4 lua:rounded-full lua:bg-white lua:shadow-lg lua:ring-0 lua:transition-transform lua:data-[state=checked]:translate-x-4 lua:data-[state=unchecked]:translate-x-0" })
    }
  ));
  Switch.displayName = Root$1.displayName;
  var RadioGroup2 = reactExports.forwardRef(({ className, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root2,
      {
        className: cn$1("lua:grid lua:gap-2", className),
        ...props,
        ref
      }
    );
  });
  RadioGroup2.displayName = Root2.displayName;
  var RadioGroupItem = reactExports.forwardRef(({ className, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item2,
      {
        ref,
        className: cn$1(
          "lua:aspect-square lua:h-4 lua:w-4 lua:rounded-full lua:border lua:border-blue-600 lua:text-blue-600 lua:ring-offset-white lua:focus:outline-hidden lua:focus-visible:ring-2 lua:focus-visible:ring-blue-600 lua:focus-visible:ring-offset-2 lua:disabled:cursor-not-allowed lua:disabled:opacity-50",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator, { className: "lua:flex lua:items-center lua:justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "8", height: "8", viewBox: "0 0 8 8", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "4", cy: "4", r: "4", fill: "currentColor" }) }) })
      }
    );
  });
  RadioGroupItem.displayName = Item2.displayName;
  var Checkbox = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Checkbox$1,
    {
      ref,
      className: cn$1(
        "lua:peer lua:h-4 lua:w-4 lua:shrink-0 lua:rounded lua:border lua:border-gray-300 lua:bg-white lua:shadow-xs lua:transition-all lua:outline-hidden lua:focus-visible:ring-2 lua:focus-visible:ring-blue-600 lua:focus-visible:ring-offset-2 lua:focus-visible:ring-offset-white lua:disabled:cursor-not-allowed lua:disabled:opacity-50 lua:data-[state=checked]:bg-blue-600 lua:data-[state=checked]:text-white lua:data-[state=checked]:border-blue-600 lua:aria-[invalid=true]:border-red-500 lua:aria-[invalid=true]:ring-red-200",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxIndicator, { className: "lua:flex lua:items-center lua:justify-center lua:text-current lua:transition-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 12 }) })
    }
  ));
  Checkbox.displayName = Checkbox$1.displayName;
  var MultiSelect = reactExports.forwardRef(
    ({
      options: options2,
      value = [],
      onValueChange,
      placeholder = "Select items...",
      disabled = false,
      className,
      showSelectAll = false,
      selectAllLabel = "Select all",
      maxDisplayItems = 3,
      ...props
    }, ref) => {
      const [open, setOpen] = reactExports.useState(false);
      const handleSelectAll = reactExports.useCallback(() => {
        if (!onValueChange) return;
        const enabledOptions2 = options2.filter((option) => !option.disabled);
        const allValues = enabledOptions2.map((option) => option.value);
        const isAllSelected2 = enabledOptions2.every(
          (option) => value.includes(option.value)
        );
        if (isAllSelected2) {
          onValueChange([]);
        } else {
          onValueChange(allValues);
        }
      }, [options2, value, onValueChange]);
      const handleItemToggle = reactExports.useCallback(
        (itemValue) => {
          if (!onValueChange) return;
          const newValue = value.includes(itemValue) ? value.filter((v) => v !== itemValue) : [...value, itemValue];
          onValueChange(newValue);
        },
        [value, onValueChange]
      );
      const displayValue = reactExports.useMemo(() => {
        if (value.length === 0) {
          return placeholder;
        }
        if (value.length <= maxDisplayItems) {
          const selectedLabels = value.map((v) => {
            var _a2;
            return (_a2 = options2.find((option) => option.value === v)) == null ? void 0 : _a2.label;
          }).filter(Boolean);
          return selectedLabels.join(", ");
        }
        return `${value.length} items selected`;
      }, [value, options2, placeholder, maxDisplayItems]);
      const enabledOptions = options2.filter((option) => !option.disabled);
      const isAllSelected = enabledOptions.length > 0 && enabledOptions.every((option) => value.includes(option.value));
      const isPartiallySelected = enabledOptions.some((option) => value.includes(option.value)) && !isAllSelected;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$1, { open, onOpenChange: setOpen, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Trigger$1,
          {
            ref,
            className: cn$1(
              "lua:flex lua:h-10 lua:w-full lua:items-center lua:justify-between lua:rounded-md lua:border lua:border-gray-300 lua:bg-white lua:px-3 lua:py-2 lua:text-sm lua:text-gray-900 lua:ring-offset-white lua:placeholder:text-gray-500 lua:focus:outline-hidden lua:focus:ring-2 lua:focus:ring-blue-600 lua:focus:ring-offset-2 lua:disabled:cursor-not-allowed lua:disabled:opacity-50",
              className
            ),
            disabled,
            "aria-haspopup": "listbox",
            "aria-expanded": open,
            role: "combobox",
            ...props,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: cn$1(
                    "lua:line-clamp-1",
                    value.length === 0 && "lua:text-gray-500"
                  ),
                  children: displayValue
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(CaretDown, { size: 16, className: "lua:opacity-50 lua:shrink-0" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content2$1,
          {
            className: "lua:z-50 lua:max-h-96 lua:w-[var(--radix-dropdown-menu-trigger-width)] lua:overflow-y-auto lua:overflow-x-hidden lua:rounded-md lua:border lua:border-gray-200 lua:bg-white lua:text-gray-900 lua:p-1 lua:shadow-md data-[state=open]:lua:animate-in data-[state=closed]:lua:animate-out data-[state=closed]:lua:fade-out-0 data-[state=open]:lua:fade-in-0 data-[state=closed]:lua:zoom-out-95 data-[state=open]:lua:zoom-in-95",
            sideOffset: 4,
            align: "start",
            role: "listbox",
            "aria-multiselectable": "true",
            children: [
              showSelectAll && enabledOptions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: "lua:relative lua:flex lua:cursor-default lua:select-none lua:items-center lua:gap-2 lua:rounded-sm lua:px-2 lua:py-2 lua:text-sm lua:outline-hidden lua:transition-colors lua:focus:bg-gray-100 lua:focus:text-gray-900",
                    role: "option",
                    "aria-selected": isAllSelected,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Checkbox,
                        {
                          id: "multi-select-checkbox-select-all",
                          checked: isAllSelected ? true : isPartiallySelected ? "indeterminate" : false,
                          onCheckedChange: handleSelectAll,
                          "aria-label": `${selectAllLabel} - ${isAllSelected ? "All selected" : isPartiallySelected ? "Some selected" : "None selected"}`
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Label3,
                        {
                          htmlFor: "multi-select-checkbox-select-all",
                          className: "lua:font-normal lua:w-full",
                          children: selectAllLabel
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Separator2, { className: "lua:-mx-1 lua:my-1 lua:h-px lua:bg-gray-200" })
              ] }),
              options2.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: cn$1(
                    "lua:relative lua:flex lua:cursor-default lua:select-none lua:items-center lua:gap-2 lua:rounded-sm lua:px-2 lua:py-2 lua:text-sm lua:outline-hidden lua:transition-colors lua:focus:bg-gray-100 lua:focus:text-gray-900",
                    option.disabled && "lua:pointer-events-none lua:opacity-50"
                  ),
                  role: "option",
                  "aria-selected": value.includes(option.value),
                  "aria-disabled": option.disabled,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Checkbox,
                      {
                        id: `multi-select-checkbox-${option.value}`,
                        checked: value.includes(option.value),
                        disabled: option.disabled,
                        onCheckedChange: () => !option.disabled && handleItemToggle(option.value),
                        "aria-label": `${option.label} - ${value.includes(option.value) ? "Selected" : "Not selected"}`
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Label3,
                      {
                        htmlFor: `multi-select-checkbox-${option.value}`,
                        className: "lua:font-normal lua:w-full",
                        children: option.label
                      }
                    )
                  ]
                },
                option.value
              ))
            ]
          }
        ) })
      ] });
    }
  );
  MultiSelect.displayName = "MultiSelect";
  var Slider = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Root,
    {
      ref,
      className: cn$1(
        "lua:relative lua:flex lua:w-full lua:touch-none lua:select-none lua:items-center",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Track, { className: "lua:relative lua:h-2 lua:w-full lua:grow lua:overflow-hidden lua:rounded-full lua:bg-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Range, { className: "lua:absolute lua:h-full lua:bg-gradient-to-r lua:from-blue-600 lua:to-purple-600" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb, { className: "lua:block lua:h-5 lua:w-5 lua:rounded-full lua:border-2 lua:border-white lua:bg-purple-600 lua:shadow-lg lua:ring-offset-white lua:transition-all lua:focus-visible:outline-none lua:focus-visible:ring-2 lua:focus-visible:ring-blue-600 lua:focus-visible:ring-offset-2 lua:hover:shadow-xl lua:hover:scale-105 lua:active:scale-95 lua:disabled:bg-gray-200 lua:disabled:pointer-events-none lua:disabled:opacity-50" })
      ]
    }
  ));
  Slider.displayName = Root.displayName;
  function ok$1() {
  }
  function unreachable() {
  }
  function stringify$1(values, options2) {
    const settings = {};
    const input = values[values.length - 1] === "" ? [...values, ""] : values;
    return input.join(
      (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
    ).trim();
  }
  const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
  const nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
  const emptyOptions$2 = {};
  function name$s(name2, options2) {
    const settings = emptyOptions$2;
    const re2 = settings.jsx ? nameReJsx : nameRe;
    return re2.test(name2);
  }
  const re$1 = /[ \t\n\f\r]/g;
  function whitespace(thing) {
    return typeof thing === "object" ? thing.type === "text" ? empty$1(thing.value) : false : empty$1(thing);
  }
  function empty$1(value) {
    return value.replace(re$1, "") === "";
  }
  class Schema {
    /**
     * @param {SchemaType['property']} property
     *   Property.
     * @param {SchemaType['normal']} normal
     *   Normal.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Schema.
     */
    constructor(property, normal, space2) {
      this.normal = normal;
      this.property = property;
      if (space2) {
        this.space = space2;
      }
    }
  }
  Schema.prototype.normal = {};
  Schema.prototype.property = {};
  Schema.prototype.space = void 0;
  function merge$1(definitions, space2) {
    const property = {};
    const normal = {};
    for (const definition2 of definitions) {
      Object.assign(property, definition2.property);
      Object.assign(normal, definition2.normal);
    }
    return new Schema(property, normal, space2);
  }
  function normalize$1(value) {
    return value.toLowerCase();
  }
  class Info {
    /**
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @returns
     *   Info.
     */
    constructor(property, attribute) {
      this.attribute = attribute;
      this.property = property;
    }
  }
  Info.prototype.attribute = "";
  Info.prototype.booleanish = false;
  Info.prototype.boolean = false;
  Info.prototype.commaOrSpaceSeparated = false;
  Info.prototype.commaSeparated = false;
  Info.prototype.defined = false;
  Info.prototype.mustUseProperty = false;
  Info.prototype.number = false;
  Info.prototype.overloadedBoolean = false;
  Info.prototype.property = "";
  Info.prototype.spaceSeparated = false;
  Info.prototype.space = void 0;
  let powers = 0;
  const boolean = increment();
  const booleanish = increment();
  const overloadedBoolean = increment();
  const number$1 = increment();
  const spaceSeparated = increment();
  const commaSeparated = increment();
  const commaOrSpaceSeparated = increment();
  function increment() {
    return 2 ** ++powers;
  }
  const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    boolean,
    booleanish,
    commaOrSpaceSeparated,
    commaSeparated,
    number: number$1,
    overloadedBoolean,
    spaceSeparated
  }, Symbol.toStringTag, { value: "Module" }));
  const checks = (
    /** @type {ReadonlyArray<keyof typeof types>} */
    Object.keys(types)
  );
  class DefinedInfo extends Info {
    /**
     * @constructor
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @param {number | null | undefined} [mask]
     *   Mask.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Info.
     */
    constructor(property, attribute, mask, space2) {
      let index2 = -1;
      super(property, attribute);
      mark(this, "space", space2);
      if (typeof mask === "number") {
        while (++index2 < checks.length) {
          const check = checks[index2];
          mark(this, checks[index2], (mask & types[check]) === types[check]);
        }
      }
    }
  }
  DefinedInfo.prototype.defined = true;
  function mark(values, key, value) {
    if (value) {
      values[key] = value;
    }
  }
  function create(definition2) {
    const properties = {};
    const normals = {};
    for (const [property, value] of Object.entries(definition2.properties)) {
      const info = new DefinedInfo(
        property,
        definition2.transform(definition2.attributes || {}, property),
        value,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(property)) {
        info.mustUseProperty = true;
      }
      properties[property] = info;
      normals[normalize$1(property)] = property;
      normals[normalize$1(info.attribute)] = property;
    }
    return new Schema(properties, normals, definition2.space);
  }
  const aria = create({
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: booleanish,
      ariaAutoComplete: null,
      ariaBusy: booleanish,
      ariaChecked: booleanish,
      ariaColCount: number$1,
      ariaColIndex: number$1,
      ariaColSpan: number$1,
      ariaControls: spaceSeparated,
      ariaCurrent: null,
      ariaDescribedBy: spaceSeparated,
      ariaDetails: null,
      ariaDisabled: booleanish,
      ariaDropEffect: spaceSeparated,
      ariaErrorMessage: null,
      ariaExpanded: booleanish,
      ariaFlowTo: spaceSeparated,
      ariaGrabbed: booleanish,
      ariaHasPopup: null,
      ariaHidden: booleanish,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: spaceSeparated,
      ariaLevel: number$1,
      ariaLive: null,
      ariaModal: booleanish,
      ariaMultiLine: booleanish,
      ariaMultiSelectable: booleanish,
      ariaOrientation: null,
      ariaOwns: spaceSeparated,
      ariaPlaceholder: null,
      ariaPosInSet: number$1,
      ariaPressed: booleanish,
      ariaReadOnly: booleanish,
      ariaRelevant: null,
      ariaRequired: booleanish,
      ariaRoleDescription: spaceSeparated,
      ariaRowCount: number$1,
      ariaRowIndex: number$1,
      ariaRowSpan: number$1,
      ariaSelected: booleanish,
      ariaSetSize: number$1,
      ariaSort: null,
      ariaValueMax: number$1,
      ariaValueMin: number$1,
      ariaValueNow: number$1,
      ariaValueText: null,
      role: null
    },
    transform(_, property) {
      return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
    }
  });
  function caseSensitiveTransform(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
  }
  function caseInsensitiveTransform(attributes, property) {
    return caseSensitiveTransform(attributes, property.toLowerCase());
  }
  const html$2 = create({
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: commaSeparated,
      acceptCharset: spaceSeparated,
      accessKey: spaceSeparated,
      action: null,
      allow: null,
      allowFullScreen: boolean,
      allowPaymentRequest: boolean,
      allowUserMedia: boolean,
      alt: null,
      as: null,
      async: boolean,
      autoCapitalize: null,
      autoComplete: spaceSeparated,
      autoFocus: boolean,
      autoPlay: boolean,
      blocking: spaceSeparated,
      capture: null,
      charSet: null,
      checked: boolean,
      cite: null,
      className: spaceSeparated,
      cols: number$1,
      colSpan: null,
      content: null,
      contentEditable: booleanish,
      controls: boolean,
      controlsList: spaceSeparated,
      coords: number$1 | commaSeparated,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: boolean,
      defer: boolean,
      dir: null,
      dirName: null,
      disabled: boolean,
      download: overloadedBoolean,
      draggable: booleanish,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: boolean,
      formTarget: null,
      headers: spaceSeparated,
      height: number$1,
      hidden: overloadedBoolean,
      high: number$1,
      href: null,
      hrefLang: null,
      htmlFor: spaceSeparated,
      httpEquiv: spaceSeparated,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: boolean,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: boolean,
      itemId: null,
      itemProp: spaceSeparated,
      itemRef: spaceSeparated,
      itemScope: boolean,
      itemType: spaceSeparated,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: boolean,
      low: number$1,
      manifest: null,
      max: null,
      maxLength: number$1,
      media: null,
      method: null,
      min: null,
      minLength: number$1,
      multiple: boolean,
      muted: boolean,
      name: null,
      nonce: null,
      noModule: boolean,
      noValidate: boolean,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeToggle: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: boolean,
      optimum: number$1,
      pattern: null,
      ping: spaceSeparated,
      placeholder: null,
      playsInline: boolean,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: boolean,
      referrerPolicy: null,
      rel: spaceSeparated,
      required: boolean,
      reversed: boolean,
      rows: number$1,
      rowSpan: number$1,
      sandbox: spaceSeparated,
      scope: null,
      scoped: boolean,
      seamless: boolean,
      selected: boolean,
      shadowRootClonable: boolean,
      shadowRootDelegatesFocus: boolean,
      shadowRootMode: null,
      shape: null,
      size: number$1,
      sizes: null,
      slot: null,
      span: number$1,
      spellCheck: booleanish,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: number$1,
      step: null,
      style: null,
      tabIndex: number$1,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: boolean,
      useMap: null,
      value: booleanish,
      width: number$1,
      wrap: null,
      writingSuggestions: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: spaceSeparated,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: number$1,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: number$1,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: boolean,
      // Lists. Use CSS to reduce space between items instead
      declare: boolean,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: number$1,
      // `<img>` and `<object>`
      leftMargin: number$1,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: number$1,
      // `<body>`
      marginWidth: number$1,
      // `<body>`
      noResize: boolean,
      // `<frame>`
      noHref: boolean,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: boolean,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: boolean,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: number$1,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: booleanish,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: number$1,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: number$1,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: boolean,
      disableRemotePlayback: boolean,
      prefix: null,
      property: null,
      results: number$1,
      security: null,
      unselectable: null
    },
    space: "html",
    transform: caseInsensitiveTransform
  });
  const svg$1 = create({
    attributes: {
      accentHeight: "accent-height",
      alignmentBaseline: "alignment-baseline",
      arabicForm: "arabic-form",
      baselineShift: "baseline-shift",
      capHeight: "cap-height",
      className: "class",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      crossOrigin: "crossorigin",
      dataType: "datatype",
      dominantBaseline: "dominant-baseline",
      enableBackground: "enable-background",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      hrefLang: "hreflang",
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      horizOriginY: "horiz-origin-y",
      imageRendering: "image-rendering",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      navDown: "nav-down",
      navDownLeft: "nav-down-left",
      navDownRight: "nav-down-right",
      navLeft: "nav-left",
      navNext: "nav-next",
      navPrev: "nav-prev",
      navRight: "nav-right",
      navUp: "nav-up",
      navUpLeft: "nav-up-left",
      navUpRight: "nav-up-right",
      onAbort: "onabort",
      onActivate: "onactivate",
      onAfterPrint: "onafterprint",
      onBeforePrint: "onbeforeprint",
      onBegin: "onbegin",
      onCancel: "oncancel",
      onCanPlay: "oncanplay",
      onCanPlayThrough: "oncanplaythrough",
      onChange: "onchange",
      onClick: "onclick",
      onClose: "onclose",
      onCopy: "oncopy",
      onCueChange: "oncuechange",
      onCut: "oncut",
      onDblClick: "ondblclick",
      onDrag: "ondrag",
      onDragEnd: "ondragend",
      onDragEnter: "ondragenter",
      onDragExit: "ondragexit",
      onDragLeave: "ondragleave",
      onDragOver: "ondragover",
      onDragStart: "ondragstart",
      onDrop: "ondrop",
      onDurationChange: "ondurationchange",
      onEmptied: "onemptied",
      onEnd: "onend",
      onEnded: "onended",
      onError: "onerror",
      onFocus: "onfocus",
      onFocusIn: "onfocusin",
      onFocusOut: "onfocusout",
      onHashChange: "onhashchange",
      onInput: "oninput",
      onInvalid: "oninvalid",
      onKeyDown: "onkeydown",
      onKeyPress: "onkeypress",
      onKeyUp: "onkeyup",
      onLoad: "onload",
      onLoadedData: "onloadeddata",
      onLoadedMetadata: "onloadedmetadata",
      onLoadStart: "onloadstart",
      onMessage: "onmessage",
      onMouseDown: "onmousedown",
      onMouseEnter: "onmouseenter",
      onMouseLeave: "onmouseleave",
      onMouseMove: "onmousemove",
      onMouseOut: "onmouseout",
      onMouseOver: "onmouseover",
      onMouseUp: "onmouseup",
      onMouseWheel: "onmousewheel",
      onOffline: "onoffline",
      onOnline: "ononline",
      onPageHide: "onpagehide",
      onPageShow: "onpageshow",
      onPaste: "onpaste",
      onPause: "onpause",
      onPlay: "onplay",
      onPlaying: "onplaying",
      onPopState: "onpopstate",
      onProgress: "onprogress",
      onRateChange: "onratechange",
      onRepeat: "onrepeat",
      onReset: "onreset",
      onResize: "onresize",
      onScroll: "onscroll",
      onSeeked: "onseeked",
      onSeeking: "onseeking",
      onSelect: "onselect",
      onShow: "onshow",
      onStalled: "onstalled",
      onStorage: "onstorage",
      onSubmit: "onsubmit",
      onSuspend: "onsuspend",
      onTimeUpdate: "ontimeupdate",
      onToggle: "ontoggle",
      onUnload: "onunload",
      onVolumeChange: "onvolumechange",
      onWaiting: "onwaiting",
      onZoom: "onzoom",
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pointerEvents: "pointer-events",
      referrerPolicy: "referrerpolicy",
      renderingIntent: "rendering-intent",
      shapeRendering: "shape-rendering",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      strokeDashArray: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeLineCap: "stroke-linecap",
      strokeLineJoin: "stroke-linejoin",
      strokeMiterLimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      tabIndex: "tabindex",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      transformOrigin: "transform-origin",
      typeOf: "typeof",
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      vectorEffect: "vector-effect",
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      xHeight: "x-height",
      // These were camelcased in Tiny. Now lowercased in SVG 2
      playbackOrder: "playbackorder",
      timelineBegin: "timelinebegin"
    },
    properties: {
      about: commaOrSpaceSeparated,
      accentHeight: number$1,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: number$1,
      amplitude: number$1,
      arabicForm: null,
      ascent: number$1,
      attributeName: null,
      attributeType: null,
      azimuth: number$1,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: number$1,
      by: null,
      calcMode: null,
      capHeight: number$1,
      className: spaceSeparated,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: number$1,
      diffuseConstant: number$1,
      direction: null,
      display: null,
      dur: null,
      divisor: number$1,
      dominantBaseline: null,
      download: boolean,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: number$1,
      enableBackground: null,
      end: null,
      event: null,
      exponent: number$1,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: number$1,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: commaSeparated,
      g2: commaSeparated,
      glyphName: commaSeparated,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: number$1,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: number$1,
      horizOriginX: number$1,
      horizOriginY: number$1,
      id: null,
      ideographic: number$1,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: number$1,
      k: number$1,
      k1: number$1,
      k2: number$1,
      k3: number$1,
      k4: number$1,
      kernelMatrix: commaOrSpaceSeparated,
      kernelUnitLength: null,
      keyPoints: null,
      // SEMI_COLON_SEPARATED
      keySplines: null,
      // SEMI_COLON_SEPARATED
      keyTimes: null,
      // SEMI_COLON_SEPARATED
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: number$1,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: number$1,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: number$1,
      overlineThickness: number$1,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: number$1,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: spaceSeparated,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: number$1,
      pointsAtY: number$1,
      pointsAtZ: number$1,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: commaOrSpaceSeparated,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: commaOrSpaceSeparated,
      rev: commaOrSpaceSeparated,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: commaOrSpaceSeparated,
      requiredFeatures: commaOrSpaceSeparated,
      requiredFonts: commaOrSpaceSeparated,
      requiredFormats: commaOrSpaceSeparated,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: number$1,
      specularExponent: number$1,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: number$1,
      strikethroughThickness: number$1,
      string: null,
      stroke: null,
      strokeDashArray: commaOrSpaceSeparated,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: number$1,
      strokeOpacity: number$1,
      strokeWidth: null,
      style: null,
      surfaceScale: number$1,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: commaOrSpaceSeparated,
      tabIndex: number$1,
      tableValues: null,
      target: null,
      targetX: number$1,
      targetY: number$1,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: commaOrSpaceSeparated,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: number$1,
      underlineThickness: number$1,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: number$1,
      values: null,
      vAlphabetic: number$1,
      vMathematical: number$1,
      vectorEffect: null,
      vHanging: number$1,
      vIdeographic: number$1,
      version: null,
      vertAdvY: number$1,
      vertOriginX: number$1,
      vertOriginY: number$1,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: number$1,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null
    },
    space: "svg",
    transform: caseSensitiveTransform
  });
  const xlink = create({
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    },
    space: "xlink",
    transform(_, property) {
      return "xlink:" + property.slice(5).toLowerCase();
    }
  });
  const xmlns = create({
    attributes: { xmlnsxlink: "xmlns:xlink" },
    properties: { xmlnsXLink: null, xmlns: null },
    space: "xmlns",
    transform: caseInsensitiveTransform
  });
  const xml = create({
    properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
    space: "xml",
    transform(_, property) {
      return "xml:" + property.slice(3).toLowerCase();
    }
  });
  const hastToReact = {
    classId: "classID",
    dataType: "datatype",
    itemId: "itemID",
    strokeDashArray: "strokeDasharray",
    strokeDashOffset: "strokeDashoffset",
    strokeLineCap: "strokeLinecap",
    strokeLineJoin: "strokeLinejoin",
    strokeMiterLimit: "strokeMiterlimit",
    typeOf: "typeof",
    xLinkActuate: "xlinkActuate",
    xLinkArcRole: "xlinkArcrole",
    xLinkHref: "xlinkHref",
    xLinkRole: "xlinkRole",
    xLinkShow: "xlinkShow",
    xLinkTitle: "xlinkTitle",
    xLinkType: "xlinkType",
    xmlnsXLink: "xmlnsXlink"
  };
  const cap$1 = /[A-Z]/g;
  const dash = /-[a-z]/g;
  const valid = /^data[-\w.:]+$/i;
  function find(schema, value) {
    const normal = normalize$1(value);
    let property = value;
    let Type = Info;
    if (normal in schema.normal) {
      return schema.property[schema.normal[normal]];
    }
    if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
      if (value.charAt(4) === "-") {
        const rest = value.slice(5).replace(dash, camelcase);
        property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
      } else {
        const rest = value.slice(4);
        if (!dash.test(rest)) {
          let dashes = rest.replace(cap$1, kebab);
          if (dashes.charAt(0) !== "-") {
            dashes = "-" + dashes;
          }
          value = "data" + dashes;
        }
      }
      Type = DefinedInfo;
    }
    return new Type(property, value);
  }
  function kebab($0) {
    return "-" + $0.toLowerCase();
  }
  function camelcase($0) {
    return $0.charAt(1).toUpperCase();
  }
  const html$1 = merge$1([aria, html$2, xlink, xmlns, xml], "html");
  const svg = merge$1([aria, svg$1, xlink, xmlns, xml], "svg");
  function stringify(values) {
    return values.join(" ").trim();
  }
  var cjs$1 = {};
  var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
  var NEWLINE_REGEX = /\n/g;
  var WHITESPACE_REGEX = /^\s*/;
  var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
  var COLON_REGEX = /^:\s*/;
  var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
  var SEMICOLON_REGEX = /^[;\s]*/;
  var TRIM_REGEX = /^\s+|\s+$/g;
  var NEWLINE = "\n";
  var FORWARD_SLASH = "/";
  var ASTERISK = "*";
  var EMPTY_STRING = "";
  var TYPE_COMMENT = "comment";
  var TYPE_DECLARATION = "declaration";
  var inlineStyleParser = function(style, options2) {
    if (typeof style !== "string") {
      throw new TypeError("First argument must be a string");
    }
    if (!style) return [];
    options2 = options2 || {};
    var lineno = 1;
    var column = 1;
    function updatePosition(str) {
      var lines = str.match(NEWLINE_REGEX);
      if (lines) lineno += lines.length;
      var i = str.lastIndexOf(NEWLINE);
      column = ~i ? str.length - i : column + str.length;
    }
    function position2() {
      var start = { line: lineno, column };
      return function(node2) {
        node2.position = new Position(start);
        whitespace2();
        return node2;
      };
    }
    function Position(start) {
      this.start = start;
      this.end = { line: lineno, column };
      this.source = options2.source;
    }
    Position.prototype.content = style;
    function error(msg) {
      var err = new Error(
        options2.source + ":" + lineno + ":" + column + ": " + msg
      );
      err.reason = msg;
      err.filename = options2.source;
      err.line = lineno;
      err.column = column;
      err.source = style;
      if (options2.silent) ;
      else {
        throw err;
      }
    }
    function match(re2) {
      var m2 = re2.exec(style);
      if (!m2) return;
      var str = m2[0];
      updatePosition(str);
      style = style.slice(str.length);
      return m2;
    }
    function whitespace2() {
      match(WHITESPACE_REGEX);
    }
    function comments(rules) {
      var c;
      rules = rules || [];
      while (c = comment()) {
        if (c !== false) {
          rules.push(c);
        }
      }
      return rules;
    }
    function comment() {
      var pos = position2();
      if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
      var i = 2;
      while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
        ++i;
      }
      i += 2;
      if (EMPTY_STRING === style.charAt(i - 1)) {
        return error("End of comment missing");
      }
      var str = style.slice(2, i - 2);
      column += 2;
      updatePosition(str);
      style = style.slice(i);
      column += 2;
      return pos({
        type: TYPE_COMMENT,
        comment: str
      });
    }
    function declaration() {
      var pos = position2();
      var prop = match(PROPERTY_REGEX);
      if (!prop) return;
      comment();
      if (!match(COLON_REGEX)) return error("property missing ':'");
      var val = match(VALUE_REGEX);
      var ret = pos({
        type: TYPE_DECLARATION,
        property: trim$1(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
        value: val ? trim$1(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
      });
      match(SEMICOLON_REGEX);
      return ret;
    }
    function declarations() {
      var decls = [];
      comments(decls);
      var decl;
      while (decl = declaration()) {
        if (decl !== false) {
          decls.push(decl);
          comments(decls);
        }
      }
      return decls;
    }
    whitespace2();
    return declarations();
  };
  function trim$1(str) {
    return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
  }
  var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(cjs$1, "__esModule", { value: true });
  cjs$1.default = StyleToObject;
  var inline_style_parser_1 = __importDefault$1(inlineStyleParser);
  function StyleToObject(style, iterator2) {
    var styleObject = null;
    if (!style || typeof style !== "string") {
      return styleObject;
    }
    var declarations = (0, inline_style_parser_1.default)(style);
    var hasIterator = typeof iterator2 === "function";
    declarations.forEach(function(declaration) {
      if (declaration.type !== "declaration") {
        return;
      }
      var property = declaration.property, value = declaration.value;
      if (hasIterator) {
        iterator2(property, value, declaration);
      } else if (value) {
        styleObject = styleObject || {};
        styleObject[property] = value;
      }
    });
    return styleObject;
  }
  var utilities = {};
  Object.defineProperty(utilities, "__esModule", { value: true });
  utilities.camelCase = void 0;
  var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/;
  var HYPHEN_REGEX = /-([a-z])/g;
  var NO_HYPHEN_REGEX = /^[^-]+$/;
  var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
  var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;
  var skipCamelCase = function(property) {
    return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
  };
  var capitalize = function(match, character) {
    return character.toUpperCase();
  };
  var trimHyphen = function(match, prefix) {
    return "".concat(prefix, "-");
  };
  var camelCase = function(property, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (skipCamelCase(property)) {
      return property;
    }
    property = property.toLowerCase();
    if (options2.reactCompat) {
      property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
    } else {
      property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
    }
    return property.replace(HYPHEN_REGEX, capitalize);
  };
  utilities.camelCase = camelCase;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var style_to_object_1 = __importDefault(cjs$1);
  var utilities_1 = utilities;
  function StyleToJS(style, options2) {
    var output = {};
    if (!style || typeof style !== "string") {
      return output;
    }
    (0, style_to_object_1.default)(style, function(property, value) {
      if (property && value) {
        output[(0, utilities_1.camelCase)(property, options2)] = value;
      }
    });
    return output;
  }
  StyleToJS.default = StyleToJS;
  var cjs = StyleToJS;
  const styleToJs = /* @__PURE__ */ getDefaultExportFromCjs(cjs);
  const pointEnd = point$2("end");
  const pointStart = point$2("start");
  function point$2(type) {
    return point2;
    function point2(node2) {
      const point3 = node2 && node2.position && node2.position[type] || {};
      if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
        return {
          line: point3.line,
          column: point3.column,
          offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
        };
      }
    }
  }
  function position$1(node2) {
    const start = pointStart(node2);
    const end = pointEnd(node2);
    if (start && end) {
      return { start, end };
    }
  }
  function stringifyPosition(value) {
    if (!value || typeof value !== "object") {
      return "";
    }
    if ("position" in value || "type" in value) {
      return position(value.position);
    }
    if ("start" in value || "end" in value) {
      return position(value);
    }
    if ("line" in value || "column" in value) {
      return point$1(value);
    }
    return "";
  }
  function point$1(point2) {
    return index(point2 && point2.line) + ":" + index(point2 && point2.column);
  }
  function position(pos) {
    return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
  }
  function index(value) {
    return value && typeof value === "number" ? value : 1;
  }
  class VFileMessage extends Error {
    /**
     * Create a message for `reason`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {Options | null | undefined} [options]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns
     *   Instance of `VFileMessage`.
     */
    // eslint-disable-next-line complexity
    constructor(causeOrReason, optionsOrParentOrPlace, origin2) {
      super();
      if (typeof optionsOrParentOrPlace === "string") {
        origin2 = optionsOrParentOrPlace;
        optionsOrParentOrPlace = void 0;
      }
      let reason = "";
      let options2 = {};
      let legacyCause = false;
      if (optionsOrParentOrPlace) {
        if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
          options2 = { place: optionsOrParentOrPlace };
        } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
          options2 = { place: optionsOrParentOrPlace };
        } else if ("type" in optionsOrParentOrPlace) {
          options2 = {
            ancestors: [optionsOrParentOrPlace],
            place: optionsOrParentOrPlace.position
          };
        } else {
          options2 = { ...optionsOrParentOrPlace };
        }
      }
      if (typeof causeOrReason === "string") {
        reason = causeOrReason;
      } else if (!options2.cause && causeOrReason) {
        legacyCause = true;
        reason = causeOrReason.message;
        options2.cause = causeOrReason;
      }
      if (!options2.ruleId && !options2.source && typeof origin2 === "string") {
        const index2 = origin2.indexOf(":");
        if (index2 === -1) {
          options2.ruleId = origin2;
        } else {
          options2.source = origin2.slice(0, index2);
          options2.ruleId = origin2.slice(index2 + 1);
        }
      }
      if (!options2.place && options2.ancestors && options2.ancestors) {
        const parent = options2.ancestors[options2.ancestors.length - 1];
        if (parent) {
          options2.place = parent.position;
        }
      }
      const start = options2.place && "start" in options2.place ? options2.place.start : options2.place;
      this.ancestors = options2.ancestors || void 0;
      this.cause = options2.cause || void 0;
      this.column = start ? start.column : void 0;
      this.fatal = void 0;
      this.file;
      this.message = reason;
      this.line = start ? start.line : void 0;
      this.name = stringifyPosition(options2.place) || "1:1";
      this.place = options2.place || void 0;
      this.reason = this.message;
      this.ruleId = options2.ruleId || void 0;
      this.source = options2.source || void 0;
      this.stack = legacyCause && options2.cause && typeof options2.cause.stack === "string" ? options2.cause.stack : "";
      this.actual;
      this.expected;
      this.note;
      this.url;
    }
  }
  VFileMessage.prototype.file = "";
  VFileMessage.prototype.name = "";
  VFileMessage.prototype.reason = "";
  VFileMessage.prototype.message = "";
  VFileMessage.prototype.stack = "";
  VFileMessage.prototype.column = void 0;
  VFileMessage.prototype.line = void 0;
  VFileMessage.prototype.ancestors = void 0;
  VFileMessage.prototype.cause = void 0;
  VFileMessage.prototype.fatal = void 0;
  VFileMessage.prototype.place = void 0;
  VFileMessage.prototype.ruleId = void 0;
  VFileMessage.prototype.source = void 0;
  const own$3 = {}.hasOwnProperty;
  const emptyMap = /* @__PURE__ */ new Map();
  const cap = /[A-Z]/g;
  const tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
  const tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
  const docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
  function toJsxRuntime(tree, options2) {
    if (!options2 || options2.Fragment === void 0) {
      throw new TypeError("Expected `Fragment` in options");
    }
    const filePath = options2.filePath || void 0;
    let create2;
    if (options2.development) {
      if (typeof options2.jsxDEV !== "function") {
        throw new TypeError(
          "Expected `jsxDEV` in options when `development: true`"
        );
      }
      create2 = developmentCreate(filePath, options2.jsxDEV);
    } else {
      if (typeof options2.jsx !== "function") {
        throw new TypeError("Expected `jsx` in production options");
      }
      if (typeof options2.jsxs !== "function") {
        throw new TypeError("Expected `jsxs` in production options");
      }
      create2 = productionCreate(filePath, options2.jsx, options2.jsxs);
    }
    const state = {
      Fragment: options2.Fragment,
      ancestors: [],
      components: options2.components || {},
      create: create2,
      elementAttributeNameCase: options2.elementAttributeNameCase || "react",
      evaluater: options2.createEvaluater ? options2.createEvaluater() : void 0,
      filePath,
      ignoreInvalidStyle: options2.ignoreInvalidStyle || false,
      passKeys: options2.passKeys !== false,
      passNode: options2.passNode || false,
      schema: options2.space === "svg" ? svg : html$1,
      stylePropertyNameCase: options2.stylePropertyNameCase || "dom",
      tableCellAlignToStyle: options2.tableCellAlignToStyle !== false
    };
    const result = one$1(state, tree, void 0);
    if (result && typeof result !== "string") {
      return result;
    }
    return state.create(
      tree,
      state.Fragment,
      { children: result || void 0 },
      void 0
    );
  }
  function one$1(state, node2, key) {
    if (node2.type === "element") {
      return element$1(state, node2, key);
    }
    if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression") {
      return mdxExpression(state, node2);
    }
    if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement") {
      return mdxJsxElement(state, node2, key);
    }
    if (node2.type === "mdxjsEsm") {
      return mdxEsm(state, node2);
    }
    if (node2.type === "root") {
      return root$1(state, node2, key);
    }
    if (node2.type === "text") {
      return text$3(state, node2);
    }
  }
  function element$1(state, node2, key) {
    const parentSchema = state.schema;
    let schema = parentSchema;
    if (node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
      schema = svg;
      state.schema = schema;
    }
    state.ancestors.push(node2);
    const type = findComponentFromName(state, node2.tagName, false);
    const props = createElementProps(state, node2);
    let children = createChildren(state, node2);
    if (tableElements.has(node2.tagName)) {
      children = children.filter(function(child) {
        return typeof child === "string" ? !whitespace(child) : true;
      });
    }
    addNode(state, props, type, node2);
    addChildren(props, children);
    state.ancestors.pop();
    state.schema = parentSchema;
    return state.create(node2, type, props, key);
  }
  function mdxExpression(state, node2) {
    if (node2.data && node2.data.estree && state.evaluater) {
      const program = node2.data.estree;
      const expression = program.body[0];
      ok$1(expression.type === "ExpressionStatement");
      return (
        /** @type {Child | undefined} */
        state.evaluater.evaluateExpression(expression.expression)
      );
    }
    crashEstree(state, node2.position);
  }
  function mdxEsm(state, node2) {
    if (node2.data && node2.data.estree && state.evaluater) {
      return (
        /** @type {Child | undefined} */
        state.evaluater.evaluateProgram(node2.data.estree)
      );
    }
    crashEstree(state, node2.position);
  }
  function mdxJsxElement(state, node2, key) {
    const parentSchema = state.schema;
    let schema = parentSchema;
    if (node2.name === "svg" && parentSchema.space === "html") {
      schema = svg;
      state.schema = schema;
    }
    state.ancestors.push(node2);
    const type = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, true);
    const props = createJsxElementProps(state, node2);
    const children = createChildren(state, node2);
    addNode(state, props, type, node2);
    addChildren(props, children);
    state.ancestors.pop();
    state.schema = parentSchema;
    return state.create(node2, type, props, key);
  }
  function root$1(state, node2, key) {
    const props = {};
    addChildren(props, createChildren(state, node2));
    return state.create(node2, state.Fragment, props, key);
  }
  function text$3(_, node2) {
    return node2.value;
  }
  function addNode(state, props, type, node2) {
    if (typeof type !== "string" && type !== state.Fragment && state.passNode) {
      props.node = node2;
    }
  }
  function addChildren(props, children) {
    if (children.length > 0) {
      const value = children.length > 1 ? children : children[0];
      if (value) {
        props.children = value;
      }
    }
  }
  function productionCreate(_, jsx, jsxs) {
    return create2;
    function create2(_2, type, props, key) {
      const isStaticChildren = Array.isArray(props.children);
      const fn = isStaticChildren ? jsxs : jsx;
      return key ? fn(type, props, key) : fn(type, props);
    }
  }
  function developmentCreate(filePath, jsxDEV) {
    return create2;
    function create2(node2, type, props, key) {
      const isStaticChildren = Array.isArray(props.children);
      const point2 = pointStart(node2);
      return jsxDEV(
        type,
        props,
        key,
        isStaticChildren,
        {
          columnNumber: point2 ? point2.column - 1 : void 0,
          fileName: filePath,
          lineNumber: point2 ? point2.line : void 0
        },
        void 0
      );
    }
  }
  function createElementProps(state, node2) {
    const props = {};
    let alignValue;
    let prop;
    for (prop in node2.properties) {
      if (prop !== "children" && own$3.call(node2.properties, prop)) {
        const result = createProperty(state, prop, node2.properties[prop]);
        if (result) {
          const [key, value] = result;
          if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
            alignValue = value;
          } else {
            props[key] = value;
          }
        }
      }
    }
    if (alignValue) {
      const style = (
        /** @type {Style} */
        props.style || (props.style = {})
      );
      style[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
    }
    return props;
  }
  function createJsxElementProps(state, node2) {
    const props = {};
    for (const attribute of node2.attributes) {
      if (attribute.type === "mdxJsxExpressionAttribute") {
        if (attribute.data && attribute.data.estree && state.evaluater) {
          const program = attribute.data.estree;
          const expression = program.body[0];
          ok$1(expression.type === "ExpressionStatement");
          const objectExpression = expression.expression;
          ok$1(objectExpression.type === "ObjectExpression");
          const property = objectExpression.properties[0];
          ok$1(property.type === "SpreadElement");
          Object.assign(
            props,
            state.evaluater.evaluateExpression(property.argument)
          );
        } else {
          crashEstree(state, node2.position);
        }
      } else {
        const name2 = attribute.name;
        let value;
        if (attribute.value && typeof attribute.value === "object") {
          if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
            const program = attribute.value.data.estree;
            const expression = program.body[0];
            ok$1(expression.type === "ExpressionStatement");
            value = state.evaluater.evaluateExpression(expression.expression);
          } else {
            crashEstree(state, node2.position);
          }
        } else {
          value = attribute.value === null ? true : attribute.value;
        }
        props[name2] = /** @type {Props[keyof Props]} */
        value;
      }
    }
    return props;
  }
  function createChildren(state, node2) {
    const children = [];
    let index2 = -1;
    const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
    while (++index2 < node2.children.length) {
      const child = node2.children[index2];
      let key;
      if (state.passKeys) {
        const name2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
        if (name2) {
          const count2 = countsByName.get(name2) || 0;
          key = name2 + "-" + count2;
          countsByName.set(name2, count2 + 1);
        }
      }
      const result = one$1(state, child, key);
      if (result !== void 0) children.push(result);
    }
    return children;
  }
  function createProperty(state, prop, value) {
    const info = find(state.schema, prop);
    if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
      return;
    }
    if (Array.isArray(value)) {
      value = info.commaSeparated ? stringify$1(value) : stringify(value);
    }
    if (info.property === "style") {
      let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
      if (state.stylePropertyNameCase === "css") {
        styleObject = transformStylesToCssCasing(styleObject);
      }
      return ["style", styleObject];
    }
    return [
      state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
      value
    ];
  }
  function parseStyle(state, value) {
    try {
      return styleToJs(value, { reactCompat: true });
    } catch (error) {
      if (state.ignoreInvalidStyle) {
        return {};
      }
      const cause = (
        /** @type {Error} */
        error
      );
      const message = new VFileMessage("Cannot parse `style` attribute", {
        ancestors: state.ancestors,
        cause,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      message.file = state.filePath || void 0;
      message.url = docs + "#cannot-parse-style-attribute";
      throw message;
    }
  }
  function findComponentFromName(state, name2, allowExpression) {
    let result;
    if (!allowExpression) {
      result = { type: "Literal", value: name2 };
    } else if (name2.includes(".")) {
      const identifiers = name2.split(".");
      let index2 = -1;
      let node2;
      while (++index2 < identifiers.length) {
        const prop = name$s(identifiers[index2]) ? { type: "Identifier", name: identifiers[index2] } : { type: "Literal", value: identifiers[index2] };
        node2 = node2 ? {
          type: "MemberExpression",
          object: node2,
          property: prop,
          computed: Boolean(index2 && prop.type === "Literal"),
          optional: false
        } : prop;
      }
      result = node2;
    } else {
      result = name$s(name2) && !/^[a-z]/.test(name2) ? { type: "Identifier", name: name2 } : { type: "Literal", value: name2 };
    }
    if (result.type === "Literal") {
      const name3 = (
        /** @type {string | number} */
        result.value
      );
      return own$3.call(state.components, name3) ? state.components[name3] : name3;
    }
    if (state.evaluater) {
      return state.evaluater.evaluateExpression(result);
    }
    crashEstree(state);
  }
  function crashEstree(state, place) {
    const message = new VFileMessage(
      "Cannot handle MDX estrees without `createEvaluater`",
      {
        ancestors: state.ancestors,
        place,
        ruleId: "mdx-estree",
        source: "hast-util-to-jsx-runtime"
      }
    );
    message.file = state.filePath || void 0;
    message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
    throw message;
  }
  function transformStylesToCssCasing(domCasing) {
    const cssCasing = {};
    let from;
    for (from in domCasing) {
      if (own$3.call(domCasing, from)) {
        cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
      }
    }
    return cssCasing;
  }
  function transformStyleToCssCasing(from) {
    let to = from.replace(cap, toDash);
    if (to.slice(0, 3) === "ms-") to = "-" + to;
    return to;
  }
  function toDash($0) {
    return "-" + $0.toLowerCase();
  }
  const urlAttributes = {
    action: ["form"],
    cite: ["blockquote", "del", "ins", "q"],
    data: ["object"],
    formAction: ["button", "input"],
    href: ["a", "area", "base", "link"],
    icon: ["menuitem"],
    itemId: null,
    manifest: ["html"],
    ping: ["a", "area"],
    poster: ["video"],
    src: [
      "audio",
      "embed",
      "iframe",
      "img",
      "input",
      "script",
      "source",
      "track",
      "video"
    ]
  };
  const emptyOptions$1 = {};
  function toString$2(value, options2) {
    const settings = emptyOptions$1;
    const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
    const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
    return one(value, includeImageAlt, includeHtml);
  }
  function one(value, includeImageAlt, includeHtml) {
    if (node(value)) {
      if ("value" in value) {
        return value.type === "html" && !includeHtml ? "" : value.value;
      }
      if (includeImageAlt && "alt" in value && value.alt) {
        return value.alt;
      }
      if ("children" in value) {
        return all$1(value.children, includeImageAlt, includeHtml);
      }
    }
    if (Array.isArray(value)) {
      return all$1(value, includeImageAlt, includeHtml);
    }
    return "";
  }
  function all$1(values, includeImageAlt, includeHtml) {
    const result = [];
    let index2 = -1;
    while (++index2 < values.length) {
      result[index2] = one(values[index2], includeImageAlt, includeHtml);
    }
    return result.join("");
  }
  function node(value) {
    return Boolean(value && typeof value === "object");
  }
  const element = document.createElement("i");
  function decodeNamedCharacterReference(value) {
    const characterReference2 = "&" + value + ";";
    element.innerHTML = characterReference2;
    const character = element.textContent;
    if (
      // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
      // yield `null`.
      character.charCodeAt(character.length - 1) === 59 && value !== "semi"
    ) {
      return false;
    }
    return character === characterReference2 ? false : character;
  }
  function splice(list2, start, remove, items) {
    const end = list2.length;
    let chunkStart = 0;
    let parameters;
    if (start < 0) {
      start = -start > end ? 0 : end + start;
    } else {
      start = start > end ? end : start;
    }
    remove = remove > 0 ? remove : 0;
    if (items.length < 1e4) {
      parameters = Array.from(items);
      parameters.unshift(start, remove);
      list2.splice(...parameters);
    } else {
      if (remove) list2.splice(start, remove);
      while (chunkStart < items.length) {
        parameters = items.slice(chunkStart, chunkStart + 1e4);
        parameters.unshift(start, 0);
        list2.splice(...parameters);
        chunkStart += 1e4;
        start += 1e4;
      }
    }
  }
  function push(list2, items) {
    if (list2.length > 0) {
      splice(list2, list2.length, 0, items);
      return list2;
    }
    return items;
  }
  const hasOwnProperty$1 = {}.hasOwnProperty;
  function combineExtensions(extensions) {
    const all2 = {};
    let index2 = -1;
    while (++index2 < extensions.length) {
      syntaxExtension(all2, extensions[index2]);
    }
    return all2;
  }
  function syntaxExtension(all2, extension2) {
    let hook;
    for (hook in extension2) {
      const maybe = hasOwnProperty$1.call(all2, hook) ? all2[hook] : void 0;
      const left = maybe || (all2[hook] = {});
      const right = extension2[hook];
      let code2;
      if (right) {
        for (code2 in right) {
          if (!hasOwnProperty$1.call(left, code2)) left[code2] = [];
          const value = right[code2];
          constructs(
            // @ts-expect-error Looks like a list.
            left[code2],
            Array.isArray(value) ? value : value ? [value] : []
          );
        }
      }
    }
  }
  function constructs(existing, list2) {
    let index2 = -1;
    const before = [];
    while (++index2 < list2.length) {
      (list2[index2].add === "after" ? existing : before).push(list2[index2]);
    }
    splice(existing, 0, 0, before);
  }
  function decodeNumericCharacterReference(value, base) {
    const code2 = Number.parseInt(value, base);
    if (
      // C0 except for HT, LF, FF, CR, space.
      code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
      code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
      code2 > 55295 && code2 < 57344 || // Noncharacters.
      code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
      (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
      // Out of range
      code2 > 1114111
    ) {
      return "";
    }
    return String.fromCodePoint(code2);
  }
  function normalizeIdentifier(value) {
    return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
  }
  const asciiAlpha = regexCheck(/[A-Za-z]/);
  const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
  const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
  function asciiControl(code2) {
    return (
      // Special whitespace codes (which have negative values), C0 and Control
      // character DEL
      code2 !== null && (code2 < 32 || code2 === 127)
    );
  }
  const asciiDigit = regexCheck(/\d/);
  const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
  const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
  function markdownLineEnding(code2) {
    return code2 !== null && code2 < -2;
  }
  function markdownLineEndingOrSpace(code2) {
    return code2 !== null && (code2 < 0 || code2 === 32);
  }
  function markdownSpace(code2) {
    return code2 === -2 || code2 === -1 || code2 === 32;
  }
  const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
  const unicodeWhitespace = regexCheck(/\s/);
  function regexCheck(regex) {
    return check;
    function check(code2) {
      return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
    }
  }
  function normalizeUri(value) {
    const result = [];
    let index2 = -1;
    let start = 0;
    let skip = 0;
    while (++index2 < value.length) {
      const code2 = value.charCodeAt(index2);
      let replace = "";
      if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
        skip = 2;
      } else if (code2 < 128) {
        if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
          replace = String.fromCharCode(code2);
        }
      } else if (code2 > 55295 && code2 < 57344) {
        const next = value.charCodeAt(index2 + 1);
        if (code2 < 56320 && next > 56319 && next < 57344) {
          replace = String.fromCharCode(code2, next);
          skip = 1;
        } else {
          replace = "";
        }
      } else {
        replace = String.fromCharCode(code2);
      }
      if (replace) {
        result.push(value.slice(start, index2), encodeURIComponent(replace));
        start = index2 + skip + 1;
        replace = "";
      }
      if (skip) {
        index2 += skip;
        skip = 0;
      }
    }
    return result.join("") + value.slice(start);
  }
  function factorySpace(effects, ok2, type, max2) {
    const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
    let size2 = 0;
    return start;
    function start(code2) {
      if (markdownSpace(code2)) {
        effects.enter(type);
        return prefix(code2);
      }
      return ok2(code2);
    }
    function prefix(code2) {
      if (markdownSpace(code2) && size2++ < limit) {
        effects.consume(code2);
        return prefix;
      }
      effects.exit(type);
      return ok2(code2);
    }
  }
  const content$1 = {
    tokenize: initializeContent
  };
  function initializeContent(effects) {
    const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
    let previous2;
    return contentStart;
    function afterContentStartConstruct(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, contentStart, "linePrefix");
    }
    function paragraphInitial(code2) {
      effects.enter("paragraph");
      return lineStart(code2);
    }
    function lineStart(code2) {
      const token = effects.enter("chunkText", {
        contentType: "text",
        previous: previous2
      });
      if (previous2) {
        previous2.next = token;
      }
      previous2 = token;
      return data(code2);
    }
    function data(code2) {
      if (code2 === null) {
        effects.exit("chunkText");
        effects.exit("paragraph");
        effects.consume(code2);
        return;
      }
      if (markdownLineEnding(code2)) {
        effects.consume(code2);
        effects.exit("chunkText");
        return lineStart;
      }
      effects.consume(code2);
      return data;
    }
  }
  const document$2 = {
    tokenize: initializeDocument
  };
  const containerConstruct = {
    tokenize: tokenizeContainer
  };
  function initializeDocument(effects) {
    const self2 = this;
    const stack = [];
    let continued = 0;
    let childFlow;
    let childToken;
    let lineStartOffset;
    return start;
    function start(code2) {
      if (continued < stack.length) {
        const item = stack[continued];
        self2.containerState = item[1];
        return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code2);
      }
      return checkNewContainers(code2);
    }
    function documentContinue(code2) {
      continued++;
      if (self2.containerState._closeFlow) {
        self2.containerState._closeFlow = void 0;
        if (childFlow) {
          closeFlow();
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let point2;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
        }
        exitContainers(continued);
        let index2 = indexBeforeExits;
        while (index2 < self2.events.length) {
          self2.events[index2][1].end = {
            ...point2
          };
          index2++;
        }
        splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
        self2.events.length = index2;
        return checkNewContainers(code2);
      }
      return start(code2);
    }
    function checkNewContainers(code2) {
      if (continued === stack.length) {
        if (!childFlow) {
          return documentContinued(code2);
        }
        if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
          return flowStart(code2);
        }
        self2.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
      }
      self2.containerState = {};
      return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code2);
    }
    function thereIsANewContainer(code2) {
      if (childFlow) closeFlow();
      exitContainers(continued);
      return documentContinued(code2);
    }
    function thereIsNoNewContainer(code2) {
      self2.parser.lazy[self2.now().line] = continued !== stack.length;
      lineStartOffset = self2.now().offset;
      return flowStart(code2);
    }
    function documentContinued(code2) {
      self2.containerState = {};
      return effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
    }
    function containerContinue(code2) {
      continued++;
      stack.push([self2.currentConstruct, self2.containerState]);
      return documentContinued(code2);
    }
    function flowStart(code2) {
      if (code2 === null) {
        if (childFlow) closeFlow();
        exitContainers(0);
        effects.consume(code2);
        return;
      }
      childFlow = childFlow || self2.parser.flow(self2.now());
      effects.enter("chunkFlow", {
        _tokenizer: childFlow,
        contentType: "flow",
        previous: childToken
      });
      return flowContinue(code2);
    }
    function flowContinue(code2) {
      if (code2 === null) {
        writeToChild(effects.exit("chunkFlow"), true);
        exitContainers(0);
        effects.consume(code2);
        return;
      }
      if (markdownLineEnding(code2)) {
        effects.consume(code2);
        writeToChild(effects.exit("chunkFlow"));
        continued = 0;
        self2.interrupt = void 0;
        return start;
      }
      effects.consume(code2);
      return flowContinue;
    }
    function writeToChild(token, endOfFile) {
      const stream = self2.sliceStream(token);
      if (endOfFile) stream.push(null);
      token.previous = childToken;
      if (childToken) childToken.next = token;
      childToken = token;
      childFlow.defineSkip(token.start);
      childFlow.write(stream);
      if (self2.parser.lazy[token.start.line]) {
        let index2 = childFlow.events.length;
        while (index2--) {
          if (
            // The token starts before the line ending
            childFlow.events[index2][1].start.offset < lineStartOffset && // and either is not ended yet
            (!childFlow.events[index2][1].end || // or ends after it.
            childFlow.events[index2][1].end.offset > lineStartOffset)
          ) {
            return;
          }
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let seen;
        let point2;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            if (seen) {
              point2 = self2.events[indexBeforeFlow][1].end;
              break;
            }
            seen = true;
          }
        }
        exitContainers(continued);
        index2 = indexBeforeExits;
        while (index2 < self2.events.length) {
          self2.events[index2][1].end = {
            ...point2
          };
          index2++;
        }
        splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
        self2.events.length = index2;
      }
    }
    function exitContainers(size2) {
      let index2 = stack.length;
      while (index2-- > size2) {
        const entry = stack[index2];
        self2.containerState = entry[1];
        entry[0].exit.call(self2, effects);
      }
      stack.length = size2;
    }
    function closeFlow() {
      childFlow.write([null]);
      childToken = void 0;
      childFlow = void 0;
      self2.containerState._closeFlow = void 0;
    }
  }
  function tokenizeContainer(effects, ok2, nok) {
    return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }
  function classifyCharacter(code2) {
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return 1;
    }
    if (unicodePunctuation(code2)) {
      return 2;
    }
  }
  function resolveAll(constructs2, events, context) {
    const called = [];
    let index2 = -1;
    while (++index2 < constructs2.length) {
      const resolve = constructs2[index2].resolveAll;
      if (resolve && !called.includes(resolve)) {
        events = resolve(events, context);
        called.push(resolve);
      }
    }
    return events;
  }
  const attention = {
    name: "attention",
    resolveAll: resolveAllAttention,
    tokenize: tokenizeAttention
  };
  function resolveAllAttention(events, context) {
    let index2 = -1;
    let open;
    let group;
    let text2;
    let openingSequence;
    let closingSequence;
    let use;
    let nextEvents;
    let offset2;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
        open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
            if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
              continue;
            }
            use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
            const start = {
              ...events[open][1].end
            };
            const end = {
              ...events[index2][1].start
            };
            movePoint(start, -use);
            movePoint(end, use);
            openingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start,
              end: {
                ...events[open][1].end
              }
            };
            closingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start: {
                ...events[index2][1].start
              },
              end
            };
            text2 = {
              type: use > 1 ? "strongText" : "emphasisText",
              start: {
                ...events[open][1].end
              },
              end: {
                ...events[index2][1].start
              }
            };
            group = {
              type: use > 1 ? "strong" : "emphasis",
              start: {
                ...openingSequence.start
              },
              end: {
                ...closingSequence.end
              }
            };
            events[open][1].end = {
              ...openingSequence.start
            };
            events[index2][1].start = {
              ...closingSequence.end
            };
            nextEvents = [];
            if (events[open][1].end.offset - events[open][1].start.offset) {
              nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]]);
            }
            nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text2, context]]);
            nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
            nextEvents = push(nextEvents, [["exit", text2, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]);
            if (events[index2][1].end.offset - events[index2][1].start.offset) {
              offset2 = 2;
              nextEvents = push(nextEvents, [["enter", events[index2][1], context], ["exit", events[index2][1], context]]);
            } else {
              offset2 = 0;
            }
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - offset2 - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "attentionSequence") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeAttention(effects, ok2) {
    const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
    const previous2 = this.previous;
    const before = classifyCharacter(previous2);
    let marker;
    return start;
    function start(code2) {
      marker = code2;
      effects.enter("attentionSequence");
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        return inside;
      }
      const token = effects.exit("attentionSequence");
      const after = classifyCharacter(code2);
      const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
      const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
      token._open = Boolean(marker === 42 ? open : open && (before || !close));
      token._close = Boolean(marker === 42 ? close : close && (after || !open));
      return ok2(code2);
    }
  }
  function movePoint(point2, offset2) {
    point2.column += offset2;
    point2.offset += offset2;
    point2._bufferIndex += offset2;
  }
  const autolink = {
    name: "autolink",
    tokenize: tokenizeAutolink
  };
  function tokenizeAutolink(effects, ok2, nok) {
    let size2 = 0;
    return start;
    function start(code2) {
      effects.enter("autolink");
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.enter("autolinkProtocol");
      return open;
    }
    function open(code2) {
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        return schemeOrEmailAtext;
      }
      if (code2 === 64) {
        return nok(code2);
      }
      return emailAtext(code2);
    }
    function schemeOrEmailAtext(code2) {
      if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
        size2 = 1;
        return schemeInsideOrEmailAtext(code2);
      }
      return emailAtext(code2);
    }
    function schemeInsideOrEmailAtext(code2) {
      if (code2 === 58) {
        effects.consume(code2);
        size2 = 0;
        return urlInside;
      }
      if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size2++ < 32) {
        effects.consume(code2);
        return schemeInsideOrEmailAtext;
      }
      size2 = 0;
      return emailAtext(code2);
    }
    function urlInside(code2) {
      if (code2 === 62) {
        effects.exit("autolinkProtocol");
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok2;
      }
      if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return urlInside;
    }
    function emailAtext(code2) {
      if (code2 === 64) {
        effects.consume(code2);
        return emailAtSignOrDot;
      }
      if (asciiAtext(code2)) {
        effects.consume(code2);
        return emailAtext;
      }
      return nok(code2);
    }
    function emailAtSignOrDot(code2) {
      return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
    }
    function emailLabel(code2) {
      if (code2 === 46) {
        effects.consume(code2);
        size2 = 0;
        return emailAtSignOrDot;
      }
      if (code2 === 62) {
        effects.exit("autolinkProtocol").type = "autolinkEmail";
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok2;
      }
      return emailValue(code2);
    }
    function emailValue(code2) {
      if ((code2 === 45 || asciiAlphanumeric(code2)) && size2++ < 63) {
        const next = code2 === 45 ? emailValue : emailLabel;
        effects.consume(code2);
        return next;
      }
      return nok(code2);
    }
  }
  const blankLine = {
    partial: true,
    tokenize: tokenizeBlankLine
  };
  function tokenizeBlankLine(effects, ok2, nok) {
    return start;
    function start(code2) {
      return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
    }
    function after(code2) {
      return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
    }
  }
  const blockQuote = {
    continuation: {
      tokenize: tokenizeBlockQuoteContinuation
    },
    exit,
    name: "blockQuote",
    tokenize: tokenizeBlockQuoteStart
  };
  function tokenizeBlockQuoteStart(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      if (code2 === 62) {
        const state = self2.containerState;
        if (!state.open) {
          effects.enter("blockQuote", {
            _container: true
          });
          state.open = true;
        }
        effects.enter("blockQuotePrefix");
        effects.enter("blockQuoteMarker");
        effects.consume(code2);
        effects.exit("blockQuoteMarker");
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      if (markdownSpace(code2)) {
        effects.enter("blockQuotePrefixWhitespace");
        effects.consume(code2);
        effects.exit("blockQuotePrefixWhitespace");
        effects.exit("blockQuotePrefix");
        return ok2;
      }
      effects.exit("blockQuotePrefix");
      return ok2(code2);
    }
  }
  function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
    const self2 = this;
    return contStart;
    function contStart(code2) {
      if (markdownSpace(code2)) {
        return factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
      }
      return contBefore(code2);
    }
    function contBefore(code2) {
      return effects.attempt(blockQuote, ok2, nok)(code2);
    }
  }
  function exit(effects) {
    effects.exit("blockQuote");
  }
  const characterEscape = {
    name: "characterEscape",
    tokenize: tokenizeCharacterEscape
  };
  function tokenizeCharacterEscape(effects, ok2, nok) {
    return start;
    function start(code2) {
      effects.enter("characterEscape");
      effects.enter("escapeMarker");
      effects.consume(code2);
      effects.exit("escapeMarker");
      return inside;
    }
    function inside(code2) {
      if (asciiPunctuation(code2)) {
        effects.enter("characterEscapeValue");
        effects.consume(code2);
        effects.exit("characterEscapeValue");
        effects.exit("characterEscape");
        return ok2;
      }
      return nok(code2);
    }
  }
  const characterReference = {
    name: "characterReference",
    tokenize: tokenizeCharacterReference
  };
  function tokenizeCharacterReference(effects, ok2, nok) {
    const self2 = this;
    let size2 = 0;
    let max2;
    let test2;
    return start;
    function start(code2) {
      effects.enter("characterReference");
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      return open;
    }
    function open(code2) {
      if (code2 === 35) {
        effects.enter("characterReferenceMarkerNumeric");
        effects.consume(code2);
        effects.exit("characterReferenceMarkerNumeric");
        return numeric;
      }
      effects.enter("characterReferenceValue");
      max2 = 31;
      test2 = asciiAlphanumeric;
      return value(code2);
    }
    function numeric(code2) {
      if (code2 === 88 || code2 === 120) {
        effects.enter("characterReferenceMarkerHexadecimal");
        effects.consume(code2);
        effects.exit("characterReferenceMarkerHexadecimal");
        effects.enter("characterReferenceValue");
        max2 = 6;
        test2 = asciiHexDigit;
        return value;
      }
      effects.enter("characterReferenceValue");
      max2 = 7;
      test2 = asciiDigit;
      return value(code2);
    }
    function value(code2) {
      if (code2 === 59 && size2) {
        const token = effects.exit("characterReferenceValue");
        if (test2 === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
          return nok(code2);
        }
        effects.enter("characterReferenceMarker");
        effects.consume(code2);
        effects.exit("characterReferenceMarker");
        effects.exit("characterReference");
        return ok2;
      }
      if (test2(code2) && size2++ < max2) {
        effects.consume(code2);
        return value;
      }
      return nok(code2);
    }
  }
  const nonLazyContinuation = {
    partial: true,
    tokenize: tokenizeNonLazyContinuation
  };
  const codeFenced = {
    concrete: true,
    name: "codeFenced",
    tokenize: tokenizeCodeFenced
  };
  function tokenizeCodeFenced(effects, ok2, nok) {
    const self2 = this;
    const closeStart = {
      partial: true,
      tokenize: tokenizeCloseStart
    };
    let initialPrefix = 0;
    let sizeOpen = 0;
    let marker;
    return start;
    function start(code2) {
      return beforeSequenceOpen(code2);
    }
    function beforeSequenceOpen(code2) {
      const tail = self2.events[self2.events.length - 1];
      initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
      marker = code2;
      effects.enter("codeFenced");
      effects.enter("codeFencedFence");
      effects.enter("codeFencedFenceSequence");
      return sequenceOpen(code2);
    }
    function sequenceOpen(code2) {
      if (code2 === marker) {
        sizeOpen++;
        effects.consume(code2);
        return sequenceOpen;
      }
      if (sizeOpen < 3) {
        return nok(code2);
      }
      effects.exit("codeFencedFenceSequence");
      return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
    }
    function infoBefore(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
      }
      effects.enter("codeFencedFenceInfo");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return info(code2);
    }
    function info(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return infoBefore(code2);
      }
      if (markdownSpace(code2)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return factorySpace(effects, metaBefore, "whitespace")(code2);
      }
      if (code2 === 96 && code2 === marker) {
        return nok(code2);
      }
      effects.consume(code2);
      return info;
    }
    function metaBefore(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return infoBefore(code2);
      }
      effects.enter("codeFencedFenceMeta");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return meta(code2);
    }
    function meta(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceMeta");
        return infoBefore(code2);
      }
      if (code2 === 96 && code2 === marker) {
        return nok(code2);
      }
      effects.consume(code2);
      return meta;
    }
    function atNonLazyBreak(code2) {
      return effects.attempt(closeStart, after, contentBefore)(code2);
    }
    function contentBefore(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return contentStart;
    }
    function contentStart(code2) {
      return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code2) : beforeContentChunk(code2);
    }
    function beforeContentChunk(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
      }
      effects.enter("codeFlowValue");
      return contentChunk(code2);
    }
    function contentChunk(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("codeFlowValue");
        return beforeContentChunk(code2);
      }
      effects.consume(code2);
      return contentChunk;
    }
    function after(code2) {
      effects.exit("codeFenced");
      return ok2(code2);
    }
    function tokenizeCloseStart(effects2, ok3, nok2) {
      let size2 = 0;
      return startBefore;
      function startBefore(code2) {
        effects2.enter("lineEnding");
        effects2.consume(code2);
        effects2.exit("lineEnding");
        return start2;
      }
      function start2(code2) {
        effects2.enter("codeFencedFence");
        return markdownSpace(code2) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : beforeSequenceClose(code2);
      }
      function beforeSequenceClose(code2) {
        if (code2 === marker) {
          effects2.enter("codeFencedFenceSequence");
          return sequenceClose(code2);
        }
        return nok2(code2);
      }
      function sequenceClose(code2) {
        if (code2 === marker) {
          size2++;
          effects2.consume(code2);
          return sequenceClose;
        }
        if (size2 >= sizeOpen) {
          effects2.exit("codeFencedFenceSequence");
          return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
        }
        return nok2(code2);
      }
      function sequenceCloseAfter(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects2.exit("codeFencedFence");
          return ok3(code2);
        }
        return nok2(code2);
      }
    }
  }
  function tokenizeNonLazyContinuation(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
    }
  }
  const codeIndented = {
    name: "codeIndented",
    tokenize: tokenizeCodeIndented
  };
  const furtherStart = {
    partial: true,
    tokenize: tokenizeFurtherStart
  };
  function tokenizeCodeIndented(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      effects.enter("codeIndented");
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
    }
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
    }
    function atBreak(code2) {
      if (code2 === null) {
        return after(code2);
      }
      if (markdownLineEnding(code2)) {
        return effects.attempt(furtherStart, atBreak, after)(code2);
      }
      effects.enter("codeFlowValue");
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("codeFlowValue");
        return atBreak(code2);
      }
      effects.consume(code2);
      return inside;
    }
    function after(code2) {
      effects.exit("codeIndented");
      return ok2(code2);
    }
  }
  function tokenizeFurtherStart(effects, ok2, nok) {
    const self2 = this;
    return furtherStart2;
    function furtherStart2(code2) {
      if (self2.parser.lazy[self2.now().line]) {
        return nok(code2);
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return furtherStart2;
      }
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
    }
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
    }
  }
  const codeText = {
    name: "codeText",
    previous,
    resolve: resolveCodeText,
    tokenize: tokenizeCodeText
  };
  function resolveCodeText(events) {
    let tailExitIndex = events.length - 4;
    let headEnterIndex = 3;
    let index2;
    let enter;
    if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
      index2 = headEnterIndex;
      while (++index2 < tailExitIndex) {
        if (events[index2][1].type === "codeTextData") {
          events[headEnterIndex][1].type = "codeTextPadding";
          events[tailExitIndex][1].type = "codeTextPadding";
          headEnterIndex += 2;
          tailExitIndex -= 2;
          break;
        }
      }
    }
    index2 = headEnterIndex - 1;
    tailExitIndex++;
    while (++index2 <= tailExitIndex) {
      if (enter === void 0) {
        if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
          enter = index2;
        }
      } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
        events[enter][1].type = "codeTextData";
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          tailExitIndex -= index2 - enter - 2;
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return events;
  }
  function previous(code2) {
    return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  function tokenizeCodeText(effects, ok2, nok) {
    let sizeOpen = 0;
    let size2;
    let token;
    return start;
    function start(code2) {
      effects.enter("codeText");
      effects.enter("codeTextSequence");
      return sequenceOpen(code2);
    }
    function sequenceOpen(code2) {
      if (code2 === 96) {
        effects.consume(code2);
        sizeOpen++;
        return sequenceOpen;
      }
      effects.exit("codeTextSequence");
      return between(code2);
    }
    function between(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 32) {
        effects.enter("space");
        effects.consume(code2);
        effects.exit("space");
        return between;
      }
      if (code2 === 96) {
        token = effects.enter("codeTextSequence");
        size2 = 0;
        return sequenceClose(code2);
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return between;
      }
      effects.enter("codeTextData");
      return data(code2);
    }
    function data(code2) {
      if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
        effects.exit("codeTextData");
        return between(code2);
      }
      effects.consume(code2);
      return data;
    }
    function sequenceClose(code2) {
      if (code2 === 96) {
        effects.consume(code2);
        size2++;
        return sequenceClose;
      }
      if (size2 === sizeOpen) {
        effects.exit("codeTextSequence");
        effects.exit("codeText");
        return ok2(code2);
      }
      token.type = "codeTextData";
      return data(code2);
    }
  }
  class SpliceBuffer {
    /**
     * @param {ReadonlyArray<T> | null | undefined} [initial]
     *   Initial items (optional).
     * @returns
     *   Splice buffer.
     */
    constructor(initial) {
      this.left = initial ? [...initial] : [];
      this.right = [];
    }
    /**
     * Array access;
     * does not move the cursor.
     *
     * @param {number} index
     *   Index.
     * @return {T}
     *   Item.
     */
    get(index2) {
      if (index2 < 0 || index2 >= this.left.length + this.right.length) {
        throw new RangeError("Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
      }
      if (index2 < this.left.length) return this.left[index2];
      return this.right[this.right.length - index2 + this.left.length - 1];
    }
    /**
     * The length of the splice buffer, one greater than the largest index in the
     * array.
     */
    get length() {
      return this.left.length + this.right.length;
    }
    /**
     * Remove and return `list[0]`;
     * moves the cursor to `0`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    shift() {
      this.setCursor(0);
      return this.right.pop();
    }
    /**
     * Slice the buffer to get an array;
     * does not move the cursor.
     *
     * @param {number} start
     *   Start.
     * @param {number | null | undefined} [end]
     *   End (optional).
     * @returns {Array<T>}
     *   Array of items.
     */
    slice(start, end) {
      const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
      if (stop < this.left.length) {
        return this.left.slice(start, stop);
      }
      if (start > this.left.length) {
        return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();
      }
      return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
    }
    /**
     * Mimics the behavior of Array.prototype.splice() except for the change of
     * interface necessary to avoid segfaults when patching in very large arrays.
     *
     * This operation moves cursor is moved to `start` and results in the cursor
     * placed after any inserted items.
     *
     * @param {number} start
     *   Start;
     *   zero-based index at which to start changing the array;
     *   negative numbers count backwards from the end of the array and values
     *   that are out-of bounds are clamped to the appropriate end of the array.
     * @param {number | null | undefined} [deleteCount=0]
     *   Delete count (default: `0`);
     *   maximum number of elements to delete, starting from start.
     * @param {Array<T> | null | undefined} [items=[]]
     *   Items to include in place of the deleted items (default: `[]`).
     * @return {Array<T>}
     *   Any removed items.
     */
    splice(start, deleteCount, items) {
      const count2 = deleteCount || 0;
      this.setCursor(Math.trunc(start));
      const removed = this.right.splice(this.right.length - count2, Number.POSITIVE_INFINITY);
      if (items) chunkedPush(this.left, items);
      return removed.reverse();
    }
    /**
     * Remove and return the highest-numbered item in the array, so
     * `list[list.length - 1]`;
     * Moves the cursor to `length`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    pop() {
      this.setCursor(Number.POSITIVE_INFINITY);
      return this.left.pop();
    }
    /**
     * Inserts a single item to the high-numbered side of the array;
     * moves the cursor to `length`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    push(item) {
      this.setCursor(Number.POSITIVE_INFINITY);
      this.left.push(item);
    }
    /**
     * Inserts many items to the high-numbered side of the array.
     * Moves the cursor to `length`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    pushMany(items) {
      this.setCursor(Number.POSITIVE_INFINITY);
      chunkedPush(this.left, items);
    }
    /**
     * Inserts a single item to the low-numbered side of the array;
     * Moves the cursor to `0`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    unshift(item) {
      this.setCursor(0);
      this.right.push(item);
    }
    /**
     * Inserts many items to the low-numbered side of the array;
     * moves the cursor to `0`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    unshiftMany(items) {
      this.setCursor(0);
      chunkedPush(this.right, items.reverse());
    }
    /**
     * Move the cursor to a specific position in the array. Requires
     * time proportional to the distance moved.
     *
     * If `n < 0`, the cursor will end up at the beginning.
     * If `n > length`, the cursor will end up at the end.
     *
     * @param {number} n
     *   Position.
     * @return {undefined}
     *   Nothing.
     */
    setCursor(n) {
      if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;
      if (n < this.left.length) {
        const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
        chunkedPush(this.right, removed.reverse());
      } else {
        const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);
        chunkedPush(this.left, removed.reverse());
      }
    }
  }
  function chunkedPush(list2, right) {
    let chunkStart = 0;
    if (right.length < 1e4) {
      list2.push(...right);
    } else {
      while (chunkStart < right.length) {
        list2.push(...right.slice(chunkStart, chunkStart + 1e4));
        chunkStart += 1e4;
      }
    }
  }
  function subtokenize(eventsArray) {
    const jumps = {};
    let index2 = -1;
    let event;
    let lineIndex;
    let otherIndex;
    let otherEvent;
    let parameters;
    let subevents;
    let more;
    const events = new SpliceBuffer(eventsArray);
    while (++index2 < events.length) {
      while (index2 in jumps) {
        index2 = jumps[index2];
      }
      event = events.get(index2);
      if (index2 && event[1].type === "chunkFlow" && events.get(index2 - 1)[1].type === "listItemPrefix") {
        subevents = event[1]._tokenizer.events;
        otherIndex = 0;
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
          otherIndex += 2;
        }
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
          while (++otherIndex < subevents.length) {
            if (subevents[otherIndex][1].type === "content") {
              break;
            }
            if (subevents[otherIndex][1].type === "chunkText") {
              subevents[otherIndex][1]._isInFirstContentOfListItem = true;
              otherIndex++;
            }
          }
        }
      }
      if (event[0] === "enter") {
        if (event[1].contentType) {
          Object.assign(jumps, subcontent(events, index2));
          index2 = jumps[index2];
          more = true;
        }
      } else if (event[1]._container) {
        otherIndex = index2;
        lineIndex = void 0;
        while (otherIndex--) {
          otherEvent = events.get(otherIndex);
          if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
            if (otherEvent[0] === "enter") {
              if (lineIndex) {
                events.get(lineIndex)[1].type = "lineEndingBlank";
              }
              otherEvent[1].type = "lineEnding";
              lineIndex = otherIndex;
            }
          } else if (otherEvent[1].type === "linePrefix" || otherEvent[1].type === "listItemIndent") ;
          else {
            break;
          }
        }
        if (lineIndex) {
          event[1].end = {
            ...events.get(lineIndex)[1].start
          };
          parameters = events.slice(lineIndex, index2);
          parameters.unshift(event);
          events.splice(lineIndex, index2 - lineIndex + 1, parameters);
        }
      }
    }
    splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
    return !more;
  }
  function subcontent(events, eventIndex) {
    const token = events.get(eventIndex)[1];
    const context = events.get(eventIndex)[2];
    let startPosition = eventIndex - 1;
    const startPositions = [];
    let tokenizer = token._tokenizer;
    if (!tokenizer) {
      tokenizer = context.parser[token.contentType](token.start);
      if (token._contentTypeTextTrailing) {
        tokenizer._contentTypeTextTrailing = true;
      }
    }
    const childEvents = tokenizer.events;
    const jumps = [];
    const gaps = {};
    let stream;
    let previous2;
    let index2 = -1;
    let current = token;
    let adjust = 0;
    let start = 0;
    const breaks = [start];
    while (current) {
      while (events.get(++startPosition)[1] !== current) {
      }
      startPositions.push(startPosition);
      if (!current._tokenizer) {
        stream = context.sliceStream(current);
        if (!current.next) {
          stream.push(null);
        }
        if (previous2) {
          tokenizer.defineSkip(current.start);
        }
        if (current._isInFirstContentOfListItem) {
          tokenizer._gfmTasklistFirstContentOfListItem = true;
        }
        tokenizer.write(stream);
        if (current._isInFirstContentOfListItem) {
          tokenizer._gfmTasklistFirstContentOfListItem = void 0;
        }
      }
      previous2 = current;
      current = current.next;
    }
    current = token;
    while (++index2 < childEvents.length) {
      if (
        // Find a void token that includes a break.
        childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
      ) {
        start = index2 + 1;
        breaks.push(start);
        current._tokenizer = void 0;
        current.previous = void 0;
        current = current.next;
      }
    }
    tokenizer.events = [];
    if (current) {
      current._tokenizer = void 0;
      current.previous = void 0;
    } else {
      breaks.pop();
    }
    index2 = breaks.length;
    while (index2--) {
      const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
      const start2 = startPositions.pop();
      jumps.push([start2, start2 + slice.length - 1]);
      events.splice(start2, 2, slice);
    }
    jumps.reverse();
    index2 = -1;
    while (++index2 < jumps.length) {
      gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
      adjust += jumps[index2][1] - jumps[index2][0] - 1;
    }
    return gaps;
  }
  const content = {
    resolve: resolveContent,
    tokenize: tokenizeContent
  };
  const continuationConstruct = {
    partial: true,
    tokenize: tokenizeContinuation
  };
  function resolveContent(events) {
    subtokenize(events);
    return events;
  }
  function tokenizeContent(effects, ok2) {
    let previous2;
    return chunkStart;
    function chunkStart(code2) {
      effects.enter("content");
      previous2 = effects.enter("chunkContent", {
        contentType: "content"
      });
      return chunkInside(code2);
    }
    function chunkInside(code2) {
      if (code2 === null) {
        return contentEnd(code2);
      }
      if (markdownLineEnding(code2)) {
        return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
      }
      effects.consume(code2);
      return chunkInside;
    }
    function contentEnd(code2) {
      effects.exit("chunkContent");
      effects.exit("content");
      return ok2(code2);
    }
    function contentContinue(code2) {
      effects.consume(code2);
      effects.exit("chunkContent");
      previous2.next = effects.enter("chunkContent", {
        contentType: "content",
        previous: previous2
      });
      previous2 = previous2.next;
      return chunkInside;
    }
  }
  function tokenizeContinuation(effects, ok2, nok) {
    const self2 = this;
    return startLookahead;
    function startLookahead(code2) {
      effects.exit("chunkContent");
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, prefixed, "linePrefix");
    }
    function prefixed(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return nok(code2);
      }
      const tail = self2.events[self2.events.length - 1];
      if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
        return ok2(code2);
      }
      return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
    }
  }
  function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
    const limit = max2 || Number.POSITIVE_INFINITY;
    let balance = 0;
    return start;
    function start(code2) {
      if (code2 === 60) {
        effects.enter(type);
        effects.enter(literalType);
        effects.enter(literalMarkerType);
        effects.consume(code2);
        effects.exit(literalMarkerType);
        return enclosedBefore;
      }
      if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
        return nok(code2);
      }
      effects.enter(type);
      effects.enter(rawType);
      effects.enter(stringType);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return raw(code2);
    }
    function enclosedBefore(code2) {
      if (code2 === 62) {
        effects.enter(literalMarkerType);
        effects.consume(code2);
        effects.exit(literalMarkerType);
        effects.exit(literalType);
        effects.exit(type);
        return ok2;
      }
      effects.enter(stringType);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return enclosed(code2);
    }
    function enclosed(code2) {
      if (code2 === 62) {
        effects.exit("chunkString");
        effects.exit(stringType);
        return enclosedBefore(code2);
      }
      if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? enclosedEscape : enclosed;
    }
    function enclosedEscape(code2) {
      if (code2 === 60 || code2 === 62 || code2 === 92) {
        effects.consume(code2);
        return enclosed;
      }
      return enclosed(code2);
    }
    function raw(code2) {
      if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok2(code2);
      }
      if (balance < limit && code2 === 40) {
        effects.consume(code2);
        balance++;
        return raw;
      }
      if (code2 === 41) {
        effects.consume(code2);
        balance--;
        return raw;
      }
      if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? rawEscape : raw;
    }
    function rawEscape(code2) {
      if (code2 === 40 || code2 === 41 || code2 === 92) {
        effects.consume(code2);
        return raw;
      }
      return raw(code2);
    }
  }
  function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
    const self2 = this;
    let size2 = 0;
    let seen;
    return start;
    function start(code2) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.enter(stringType);
      return atBreak;
    }
    function atBreak(code2) {
      if (size2 > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || // To do: remove in the future once weve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesnt need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      code2 === 94 && !size2 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
        return nok(code2);
      }
      if (code2 === 93) {
        effects.exit(stringType);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        effects.exit(type);
        return ok2;
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return atBreak;
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return labelInside(code2);
    }
    function labelInside(code2) {
      if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size2++ > 999) {
        effects.exit("chunkString");
        return atBreak(code2);
      }
      effects.consume(code2);
      if (!seen) seen = !markdownSpace(code2);
      return code2 === 92 ? labelEscape : labelInside;
    }
    function labelEscape(code2) {
      if (code2 === 91 || code2 === 92 || code2 === 93) {
        effects.consume(code2);
        size2++;
        return labelInside;
      }
      return labelInside(code2);
    }
  }
  function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
    let marker;
    return start;
    function start(code2) {
      if (code2 === 34 || code2 === 39 || code2 === 40) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        marker = code2 === 40 ? 41 : code2;
        return begin;
      }
      return nok(code2);
    }
    function begin(code2) {
      if (code2 === marker) {
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        effects.exit(type);
        return ok2;
      }
      effects.enter(stringType);
      return atBreak(code2);
    }
    function atBreak(code2) {
      if (code2 === marker) {
        effects.exit(stringType);
        return begin(marker);
      }
      if (code2 === null) {
        return nok(code2);
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace(effects, atBreak, "linePrefix");
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
        effects.exit("chunkString");
        return atBreak(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? escape : inside;
    }
    function escape(code2) {
      if (code2 === marker || code2 === 92) {
        effects.consume(code2);
        return inside;
      }
      return inside(code2);
    }
  }
  function factoryWhitespace(effects, ok2) {
    let seen;
    return start;
    function start(code2) {
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        seen = true;
        return start;
      }
      if (markdownSpace(code2)) {
        return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code2);
      }
      return ok2(code2);
    }
  }
  const definition = {
    name: "definition",
    tokenize: tokenizeDefinition
  };
  const titleBefore = {
    partial: true,
    tokenize: tokenizeTitleBefore
  };
  function tokenizeDefinition(effects, ok2, nok) {
    const self2 = this;
    let identifier;
    return start;
    function start(code2) {
      effects.enter("definition");
      return before(code2);
    }
    function before(code2) {
      return factoryLabel.call(
        self2,
        effects,
        labelAfter,
        // Note: we dont need to reset the way `markdown-rs` does.
        nok,
        "definitionLabel",
        "definitionLabelMarker",
        "definitionLabelString"
      )(code2);
    }
    function labelAfter(code2) {
      identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
      if (code2 === 58) {
        effects.enter("definitionMarker");
        effects.consume(code2);
        effects.exit("definitionMarker");
        return markerAfter;
      }
      return nok(code2);
    }
    function markerAfter(code2) {
      return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
    }
    function destinationBefore(code2) {
      return factoryDestination(
        effects,
        destinationAfter,
        // Note: we dont need to reset the way `markdown-rs` does.
        nok,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )(code2);
    }
    function destinationAfter(code2) {
      return effects.attempt(titleBefore, after, after)(code2);
    }
    function after(code2) {
      return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
    }
    function afterWhitespace(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("definition");
        self2.parser.defined.push(identifier);
        return ok2(code2);
      }
      return nok(code2);
    }
  }
  function tokenizeTitleBefore(effects, ok2, nok) {
    return titleBefore2;
    function titleBefore2(code2) {
      return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
    }
    function beforeMarker(code2) {
      return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
    }
    function titleAfter(code2) {
      return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
    }
    function titleAfterOptionalWhitespace(code2) {
      return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
    }
  }
  const hardBreakEscape = {
    name: "hardBreakEscape",
    tokenize: tokenizeHardBreakEscape
  };
  function tokenizeHardBreakEscape(effects, ok2, nok) {
    return start;
    function start(code2) {
      effects.enter("hardBreakEscape");
      effects.consume(code2);
      return after;
    }
    function after(code2) {
      if (markdownLineEnding(code2)) {
        effects.exit("hardBreakEscape");
        return ok2(code2);
      }
      return nok(code2);
    }
  }
  const headingAtx = {
    name: "headingAtx",
    resolve: resolveHeadingAtx,
    tokenize: tokenizeHeadingAtx
  };
  function resolveHeadingAtx(events, context) {
    let contentEnd = events.length - 2;
    let contentStart = 3;
    let content2;
    let text2;
    if (events[contentStart][1].type === "whitespace") {
      contentStart += 2;
    }
    if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
      contentEnd -= 2;
    }
    if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
      contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
    }
    if (contentEnd > contentStart) {
      content2 = {
        type: "atxHeadingText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end
      };
      text2 = {
        type: "chunkText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end,
        contentType: "text"
      };
      splice(events, contentStart, contentEnd - contentStart + 1, [["enter", content2, context], ["enter", text2, context], ["exit", text2, context], ["exit", content2, context]]);
    }
    return events;
  }
  function tokenizeHeadingAtx(effects, ok2, nok) {
    let size2 = 0;
    return start;
    function start(code2) {
      effects.enter("atxHeading");
      return before(code2);
    }
    function before(code2) {
      effects.enter("atxHeadingSequence");
      return sequenceOpen(code2);
    }
    function sequenceOpen(code2) {
      if (code2 === 35 && size2++ < 6) {
        effects.consume(code2);
        return sequenceOpen;
      }
      if (code2 === null || markdownLineEndingOrSpace(code2)) {
        effects.exit("atxHeadingSequence");
        return atBreak(code2);
      }
      return nok(code2);
    }
    function atBreak(code2) {
      if (code2 === 35) {
        effects.enter("atxHeadingSequence");
        return sequenceFurther(code2);
      }
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("atxHeading");
        return ok2(code2);
      }
      if (markdownSpace(code2)) {
        return factorySpace(effects, atBreak, "whitespace")(code2);
      }
      effects.enter("atxHeadingText");
      return data(code2);
    }
    function sequenceFurther(code2) {
      if (code2 === 35) {
        effects.consume(code2);
        return sequenceFurther;
      }
      effects.exit("atxHeadingSequence");
      return atBreak(code2);
    }
    function data(code2) {
      if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
        effects.exit("atxHeadingText");
        return atBreak(code2);
      }
      effects.consume(code2);
      return data;
    }
  }
  const htmlBlockNames = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];
  const htmlRawNames = ["pre", "script", "style", "textarea"];
  const htmlFlow = {
    concrete: true,
    name: "htmlFlow",
    resolveTo: resolveToHtmlFlow,
    tokenize: tokenizeHtmlFlow
  };
  const blankLineBefore = {
    partial: true,
    tokenize: tokenizeBlankLineBefore
  };
  const nonLazyContinuationStart = {
    partial: true,
    tokenize: tokenizeNonLazyContinuationStart
  };
  function resolveToHtmlFlow(events) {
    let index2 = events.length;
    while (index2--) {
      if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
        break;
      }
    }
    if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
      events[index2][1].start = events[index2 - 2][1].start;
      events[index2 + 1][1].start = events[index2 - 2][1].start;
      events.splice(index2 - 2, 2);
    }
    return events;
  }
  function tokenizeHtmlFlow(effects, ok2, nok) {
    const self2 = this;
    let marker;
    let closingTag;
    let buffer;
    let index2;
    let markerB;
    return start;
    function start(code2) {
      return before(code2);
    }
    function before(code2) {
      effects.enter("htmlFlow");
      effects.enter("htmlFlowData");
      effects.consume(code2);
      return open;
    }
    function open(code2) {
      if (code2 === 33) {
        effects.consume(code2);
        return declarationOpen;
      }
      if (code2 === 47) {
        effects.consume(code2);
        closingTag = true;
        return tagCloseStart;
      }
      if (code2 === 63) {
        effects.consume(code2);
        marker = 3;
        return self2.interrupt ? ok2 : continuationDeclarationInside;
      }
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        buffer = String.fromCharCode(code2);
        return tagName;
      }
      return nok(code2);
    }
    function declarationOpen(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        marker = 2;
        return commentOpenInside;
      }
      if (code2 === 91) {
        effects.consume(code2);
        marker = 5;
        index2 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        marker = 4;
        return self2.interrupt ? ok2 : continuationDeclarationInside;
      }
      return nok(code2);
    }
    function commentOpenInside(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return self2.interrupt ? ok2 : continuationDeclarationInside;
      }
      return nok(code2);
    }
    function cdataOpenInside(code2) {
      const value = "CDATA[";
      if (code2 === value.charCodeAt(index2++)) {
        effects.consume(code2);
        if (index2 === value.length) {
          return self2.interrupt ? ok2 : continuation;
        }
        return cdataOpenInside;
      }
      return nok(code2);
    }
    function tagCloseStart(code2) {
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        buffer = String.fromCharCode(code2);
        return tagName;
      }
      return nok(code2);
    }
    function tagName(code2) {
      if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
        const slash = code2 === 47;
        const name2 = buffer.toLowerCase();
        if (!slash && !closingTag && htmlRawNames.includes(name2)) {
          marker = 1;
          return self2.interrupt ? ok2(code2) : continuation(code2);
        }
        if (htmlBlockNames.includes(buffer.toLowerCase())) {
          marker = 6;
          if (slash) {
            effects.consume(code2);
            return basicSelfClosing;
          }
          return self2.interrupt ? ok2(code2) : continuation(code2);
        }
        marker = 7;
        return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
      }
      if (code2 === 45 || asciiAlphanumeric(code2)) {
        effects.consume(code2);
        buffer += String.fromCharCode(code2);
        return tagName;
      }
      return nok(code2);
    }
    function basicSelfClosing(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        return self2.interrupt ? ok2 : continuation;
      }
      return nok(code2);
    }
    function completeClosingTagAfter(code2) {
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return completeClosingTagAfter;
      }
      return completeEnd(code2);
    }
    function completeAttributeNameBefore(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        return completeEnd;
      }
      if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
        effects.consume(code2);
        return completeAttributeName;
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return completeAttributeNameBefore;
      }
      return completeEnd(code2);
    }
    function completeAttributeName(code2) {
      if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
        effects.consume(code2);
        return completeAttributeName;
      }
      return completeAttributeNameAfter(code2);
    }
    function completeAttributeNameAfter(code2) {
      if (code2 === 61) {
        effects.consume(code2);
        return completeAttributeValueBefore;
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return completeAttributeNameAfter;
      }
      return completeAttributeNameBefore(code2);
    }
    function completeAttributeValueBefore(code2) {
      if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
        return nok(code2);
      }
      if (code2 === 34 || code2 === 39) {
        effects.consume(code2);
        markerB = code2;
        return completeAttributeValueQuoted;
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return completeAttributeValueBefore;
      }
      return completeAttributeValueUnquoted(code2);
    }
    function completeAttributeValueQuoted(code2) {
      if (code2 === markerB) {
        effects.consume(code2);
        markerB = null;
        return completeAttributeValueQuotedAfter;
      }
      if (code2 === null || markdownLineEnding(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return completeAttributeValueQuoted;
    }
    function completeAttributeValueUnquoted(code2) {
      if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
        return completeAttributeNameAfter(code2);
      }
      effects.consume(code2);
      return completeAttributeValueUnquoted;
    }
    function completeAttributeValueQuotedAfter(code2) {
      if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
        return completeAttributeNameBefore(code2);
      }
      return nok(code2);
    }
    function completeEnd(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        return completeAfter;
      }
      return nok(code2);
    }
    function completeAfter(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return continuation(code2);
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return completeAfter;
      }
      return nok(code2);
    }
    function continuation(code2) {
      if (code2 === 45 && marker === 2) {
        effects.consume(code2);
        return continuationCommentInside;
      }
      if (code2 === 60 && marker === 1) {
        effects.consume(code2);
        return continuationRawTagOpen;
      }
      if (code2 === 62 && marker === 4) {
        effects.consume(code2);
        return continuationClose;
      }
      if (code2 === 63 && marker === 3) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      if (code2 === 93 && marker === 5) {
        effects.consume(code2);
        return continuationCdataInside;
      }
      if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
        effects.exit("htmlFlowData");
        return effects.check(blankLineBefore, continuationAfter, continuationStart)(code2);
      }
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("htmlFlowData");
        return continuationStart(code2);
      }
      effects.consume(code2);
      return continuation;
    }
    function continuationStart(code2) {
      return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code2);
    }
    function continuationStartNonLazy(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return continuationBefore;
    }
    function continuationBefore(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return continuationStart(code2);
      }
      effects.enter("htmlFlowData");
      return continuation(code2);
    }
    function continuationCommentInside(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      return continuation(code2);
    }
    function continuationRawTagOpen(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        buffer = "";
        return continuationRawEndTag;
      }
      return continuation(code2);
    }
    function continuationRawEndTag(code2) {
      if (code2 === 62) {
        const name2 = buffer.toLowerCase();
        if (htmlRawNames.includes(name2)) {
          effects.consume(code2);
          return continuationClose;
        }
        return continuation(code2);
      }
      if (asciiAlpha(code2) && buffer.length < 8) {
        effects.consume(code2);
        buffer += String.fromCharCode(code2);
        return continuationRawEndTag;
      }
      return continuation(code2);
    }
    function continuationCdataInside(code2) {
      if (code2 === 93) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      return continuation(code2);
    }
    function continuationDeclarationInside(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        return continuationClose;
      }
      if (code2 === 45 && marker === 2) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      return continuation(code2);
    }
    function continuationClose(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("htmlFlowData");
        return continuationAfter(code2);
      }
      effects.consume(code2);
      return continuationClose;
    }
    function continuationAfter(code2) {
      effects.exit("htmlFlow");
      return ok2(code2);
    }
  }
  function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
    }
  }
  function tokenizeBlankLineBefore(effects, ok2, nok) {
    return start;
    function start(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return effects.attempt(blankLine, ok2, nok);
    }
  }
  const htmlText = {
    name: "htmlText",
    tokenize: tokenizeHtmlText
  };
  function tokenizeHtmlText(effects, ok2, nok) {
    const self2 = this;
    let marker;
    let index2;
    let returnState;
    return start;
    function start(code2) {
      effects.enter("htmlText");
      effects.enter("htmlTextData");
      effects.consume(code2);
      return open;
    }
    function open(code2) {
      if (code2 === 33) {
        effects.consume(code2);
        return declarationOpen;
      }
      if (code2 === 47) {
        effects.consume(code2);
        return tagCloseStart;
      }
      if (code2 === 63) {
        effects.consume(code2);
        return instruction;
      }
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        return tagOpen;
      }
      return nok(code2);
    }
    function declarationOpen(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return commentOpenInside;
      }
      if (code2 === 91) {
        effects.consume(code2);
        index2 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        return declaration;
      }
      return nok(code2);
    }
    function commentOpenInside(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return commentEnd;
      }
      return nok(code2);
    }
    function comment(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 45) {
        effects.consume(code2);
        return commentClose;
      }
      if (markdownLineEnding(code2)) {
        returnState = comment;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return comment;
    }
    function commentClose(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return commentEnd;
      }
      return comment(code2);
    }
    function commentEnd(code2) {
      return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment(code2);
    }
    function cdataOpenInside(code2) {
      const value = "CDATA[";
      if (code2 === value.charCodeAt(index2++)) {
        effects.consume(code2);
        return index2 === value.length ? cdata : cdataOpenInside;
      }
      return nok(code2);
    }
    function cdata(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 93) {
        effects.consume(code2);
        return cdataClose;
      }
      if (markdownLineEnding(code2)) {
        returnState = cdata;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return cdata;
    }
    function cdataClose(code2) {
      if (code2 === 93) {
        effects.consume(code2);
        return cdataEnd;
      }
      return cdata(code2);
    }
    function cdataEnd(code2) {
      if (code2 === 62) {
        return end(code2);
      }
      if (code2 === 93) {
        effects.consume(code2);
        return cdataEnd;
      }
      return cdata(code2);
    }
    function declaration(code2) {
      if (code2 === null || code2 === 62) {
        return end(code2);
      }
      if (markdownLineEnding(code2)) {
        returnState = declaration;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return declaration;
    }
    function instruction(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 63) {
        effects.consume(code2);
        return instructionClose;
      }
      if (markdownLineEnding(code2)) {
        returnState = instruction;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return instruction;
    }
    function instructionClose(code2) {
      return code2 === 62 ? end(code2) : instruction(code2);
    }
    function tagCloseStart(code2) {
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        return tagClose;
      }
      return nok(code2);
    }
    function tagClose(code2) {
      if (code2 === 45 || asciiAlphanumeric(code2)) {
        effects.consume(code2);
        return tagClose;
      }
      return tagCloseBetween(code2);
    }
    function tagCloseBetween(code2) {
      if (markdownLineEnding(code2)) {
        returnState = tagCloseBetween;
        return lineEndingBefore(code2);
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return tagCloseBetween;
      }
      return end(code2);
    }
    function tagOpen(code2) {
      if (code2 === 45 || asciiAlphanumeric(code2)) {
        effects.consume(code2);
        return tagOpen;
      }
      if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
        return tagOpenBetween(code2);
      }
      return nok(code2);
    }
    function tagOpenBetween(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        return end;
      }
      if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
        effects.consume(code2);
        return tagOpenAttributeName;
      }
      if (markdownLineEnding(code2)) {
        returnState = tagOpenBetween;
        return lineEndingBefore(code2);
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return tagOpenBetween;
      }
      return end(code2);
    }
    function tagOpenAttributeName(code2) {
      if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
        effects.consume(code2);
        return tagOpenAttributeName;
      }
      return tagOpenAttributeNameAfter(code2);
    }
    function tagOpenAttributeNameAfter(code2) {
      if (code2 === 61) {
        effects.consume(code2);
        return tagOpenAttributeValueBefore;
      }
      if (markdownLineEnding(code2)) {
        returnState = tagOpenAttributeNameAfter;
        return lineEndingBefore(code2);
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return tagOpenAttributeNameAfter;
      }
      return tagOpenBetween(code2);
    }
    function tagOpenAttributeValueBefore(code2) {
      if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
        return nok(code2);
      }
      if (code2 === 34 || code2 === 39) {
        effects.consume(code2);
        marker = code2;
        return tagOpenAttributeValueQuoted;
      }
      if (markdownLineEnding(code2)) {
        returnState = tagOpenAttributeValueBefore;
        return lineEndingBefore(code2);
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return tagOpenAttributeValueBefore;
      }
      effects.consume(code2);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuoted(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        marker = void 0;
        return tagOpenAttributeValueQuotedAfter;
      }
      if (code2 === null) {
        return nok(code2);
      }
      if (markdownLineEnding(code2)) {
        returnState = tagOpenAttributeValueQuoted;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return tagOpenAttributeValueQuoted;
    }
    function tagOpenAttributeValueUnquoted(code2) {
      if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
        return nok(code2);
      }
      if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
        return tagOpenBetween(code2);
      }
      effects.consume(code2);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuotedAfter(code2) {
      if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
        return tagOpenBetween(code2);
      }
      return nok(code2);
    }
    function end(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        effects.exit("htmlTextData");
        effects.exit("htmlText");
        return ok2;
      }
      return nok(code2);
    }
    function lineEndingBefore(code2) {
      effects.exit("htmlTextData");
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return lineEndingAfter;
    }
    function lineEndingAfter(code2) {
      return markdownSpace(code2) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : lineEndingAfterPrefix(code2);
    }
    function lineEndingAfterPrefix(code2) {
      effects.enter("htmlTextData");
      return returnState(code2);
    }
  }
  const labelEnd = {
    name: "labelEnd",
    resolveAll: resolveAllLabelEnd,
    resolveTo: resolveToLabelEnd,
    tokenize: tokenizeLabelEnd
  };
  const resourceConstruct = {
    tokenize: tokenizeResource
  };
  const referenceFullConstruct = {
    tokenize: tokenizeReferenceFull
  };
  const referenceCollapsedConstruct = {
    tokenize: tokenizeReferenceCollapsed
  };
  function resolveAllLabelEnd(events) {
    let index2 = -1;
    const newEvents = [];
    while (++index2 < events.length) {
      const token = events[index2][1];
      newEvents.push(events[index2]);
      if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
        const offset2 = token.type === "labelImage" ? 4 : 2;
        token.type = "data";
        index2 += offset2;
      }
    }
    if (events.length !== newEvents.length) {
      splice(events, 0, events.length, newEvents);
    }
    return events;
  }
  function resolveToLabelEnd(events, context) {
    let index2 = events.length;
    let offset2 = 0;
    let token;
    let open;
    let close;
    let media;
    while (index2--) {
      token = events[index2][1];
      if (open) {
        if (token.type === "link" || token.type === "labelLink" && token._inactive) {
          break;
        }
        if (events[index2][0] === "enter" && token.type === "labelLink") {
          token._inactive = true;
        }
      } else if (close) {
        if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
          open = index2;
          if (token.type !== "labelLink") {
            offset2 = 2;
            break;
          }
        }
      } else if (token.type === "labelEnd") {
        close = index2;
      }
    }
    const group = {
      type: events[open][1].type === "labelLink" ? "link" : "image",
      start: {
        ...events[open][1].start
      },
      end: {
        ...events[events.length - 1][1].end
      }
    };
    const label = {
      type: "label",
      start: {
        ...events[open][1].start
      },
      end: {
        ...events[close][1].end
      }
    };
    const text2 = {
      type: "labelText",
      start: {
        ...events[open + offset2 + 2][1].end
      },
      end: {
        ...events[close - 2][1].start
      }
    };
    media = [["enter", group, context], ["enter", label, context]];
    media = push(media, events.slice(open + 1, open + offset2 + 3));
    media = push(media, [["enter", text2, context]]);
    media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset2 + 4, close - 3), context));
    media = push(media, [["exit", text2, context], events[close - 2], events[close - 1], ["exit", label, context]]);
    media = push(media, events.slice(close + 1));
    media = push(media, [["exit", group, context]]);
    splice(events, open, events.length, media);
    return events;
  }
  function tokenizeLabelEnd(effects, ok2, nok) {
    const self2 = this;
    let index2 = self2.events.length;
    let labelStart;
    let defined;
    while (index2--) {
      if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
        labelStart = self2.events[index2][1];
        break;
      }
    }
    return start;
    function start(code2) {
      if (!labelStart) {
        return nok(code2);
      }
      if (labelStart._inactive) {
        return labelEndNok(code2);
      }
      defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      })));
      effects.enter("labelEnd");
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelEnd");
      return after;
    }
    function after(code2) {
      if (code2 === 40) {
        return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code2);
      }
      if (code2 === 91) {
        return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code2);
      }
      return defined ? labelEndOk(code2) : labelEndNok(code2);
    }
    function referenceNotFull(code2) {
      return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code2);
    }
    function labelEndOk(code2) {
      return ok2(code2);
    }
    function labelEndNok(code2) {
      labelStart._balanced = true;
      return nok(code2);
    }
  }
  function tokenizeResource(effects, ok2, nok) {
    return resourceStart;
    function resourceStart(code2) {
      effects.enter("resource");
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      return resourceBefore;
    }
    function resourceBefore(code2) {
      return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
    }
    function resourceOpen(code2) {
      if (code2 === 41) {
        return resourceEnd(code2);
      }
      return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
    }
    function resourceDestinationAfter(code2) {
      return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
    }
    function resourceDestinationMissing(code2) {
      return nok(code2);
    }
    function resourceBetween(code2) {
      if (code2 === 34 || code2 === 39 || code2 === 40) {
        return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
      }
      return resourceEnd(code2);
    }
    function resourceTitleAfter(code2) {
      return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
    }
    function resourceEnd(code2) {
      if (code2 === 41) {
        effects.enter("resourceMarker");
        effects.consume(code2);
        effects.exit("resourceMarker");
        effects.exit("resource");
        return ok2;
      }
      return nok(code2);
    }
  }
  function tokenizeReferenceFull(effects, ok2, nok) {
    const self2 = this;
    return referenceFull;
    function referenceFull(code2) {
      return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code2);
    }
    function referenceFullAfter(code2) {
      return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok2(code2) : nok(code2);
    }
    function referenceFullMissing(code2) {
      return nok(code2);
    }
  }
  function tokenizeReferenceCollapsed(effects, ok2, nok) {
    return referenceCollapsedStart;
    function referenceCollapsedStart(code2) {
      effects.enter("reference");
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      return referenceCollapsedOpen;
    }
    function referenceCollapsedOpen(code2) {
      if (code2 === 93) {
        effects.enter("referenceMarker");
        effects.consume(code2);
        effects.exit("referenceMarker");
        effects.exit("reference");
        return ok2;
      }
      return nok(code2);
    }
  }
  const labelStartImage = {
    name: "labelStartImage",
    resolveAll: labelEnd.resolveAll,
    tokenize: tokenizeLabelStartImage
  };
  function tokenizeLabelStartImage(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      effects.enter("labelImage");
      effects.enter("labelImageMarker");
      effects.consume(code2);
      effects.exit("labelImageMarker");
      return open;
    }
    function open(code2) {
      if (code2 === 91) {
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelImage");
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
    }
  }
  const labelStartLink = {
    name: "labelStartLink",
    resolveAll: labelEnd.resolveAll,
    tokenize: tokenizeLabelStartLink
  };
  function tokenizeLabelStartLink(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      effects.enter("labelLink");
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelLink");
      return after;
    }
    function after(code2) {
      return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
    }
  }
  const lineEnding = {
    name: "lineEnding",
    tokenize: tokenizeLineEnding
  };
  function tokenizeLineEnding(effects, ok2) {
    return start;
    function start(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, ok2, "linePrefix");
    }
  }
  const thematicBreak$1 = {
    name: "thematicBreak",
    tokenize: tokenizeThematicBreak
  };
  function tokenizeThematicBreak(effects, ok2, nok) {
    let size2 = 0;
    let marker;
    return start;
    function start(code2) {
      effects.enter("thematicBreak");
      return before(code2);
    }
    function before(code2) {
      marker = code2;
      return atBreak(code2);
    }
    function atBreak(code2) {
      if (code2 === marker) {
        effects.enter("thematicBreakSequence");
        return sequence(code2);
      }
      if (size2 >= 3 && (code2 === null || markdownLineEnding(code2))) {
        effects.exit("thematicBreak");
        return ok2(code2);
      }
      return nok(code2);
    }
    function sequence(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        size2++;
        return sequence;
      }
      effects.exit("thematicBreakSequence");
      return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
    }
  }
  const list$1 = {
    continuation: {
      tokenize: tokenizeListContinuation
    },
    exit: tokenizeListEnd,
    name: "list",
    tokenize: tokenizeListStart
  };
  const listItemPrefixWhitespaceConstruct = {
    partial: true,
    tokenize: tokenizeListItemPrefixWhitespace
  };
  const indentConstruct = {
    partial: true,
    tokenize: tokenizeIndent
  };
  function tokenizeListStart(effects, ok2, nok) {
    const self2 = this;
    const tail = self2.events[self2.events.length - 1];
    let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    let size2 = 0;
    return start;
    function start(code2) {
      const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
      if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
        if (!self2.containerState.type) {
          self2.containerState.type = kind;
          effects.enter(kind, {
            _container: true
          });
        }
        if (kind === "listUnordered") {
          effects.enter("listItemPrefix");
          return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code2) : atMarker(code2);
        }
        if (!self2.interrupt || code2 === 49) {
          effects.enter("listItemPrefix");
          effects.enter("listItemValue");
          return inside(code2);
        }
      }
      return nok(code2);
    }
    function inside(code2) {
      if (asciiDigit(code2) && ++size2 < 10) {
        effects.consume(code2);
        return inside;
      }
      if ((!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
        effects.exit("listItemValue");
        return atMarker(code2);
      }
      return nok(code2);
    }
    function atMarker(code2) {
      effects.enter("listItemMarker");
      effects.consume(code2);
      effects.exit("listItemMarker");
      self2.containerState.marker = self2.containerState.marker || code2;
      return effects.check(
        blankLine,
        // Cant be empty when interrupting.
        self2.interrupt ? nok : onBlank,
        effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
      );
    }
    function onBlank(code2) {
      self2.containerState.initialBlankLine = true;
      initialSize++;
      return endOfPrefix(code2);
    }
    function otherPrefix(code2) {
      if (markdownSpace(code2)) {
        effects.enter("listItemPrefixWhitespace");
        effects.consume(code2);
        effects.exit("listItemPrefixWhitespace");
        return endOfPrefix;
      }
      return nok(code2);
    }
    function endOfPrefix(code2) {
      self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
      return ok2(code2);
    }
  }
  function tokenizeListContinuation(effects, ok2, nok) {
    const self2 = this;
    self2.containerState._closeFlow = void 0;
    return effects.check(blankLine, onBlank, notBlank);
    function onBlank(code2) {
      self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
      return factorySpace(effects, ok2, "listItemIndent", self2.containerState.size + 1)(code2);
    }
    function notBlank(code2) {
      if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
        self2.containerState.furtherBlankLines = void 0;
        self2.containerState.initialBlankLine = void 0;
        return notInCurrentItem(code2);
      }
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
    }
    function notInCurrentItem(code2) {
      self2.containerState._closeFlow = true;
      self2.interrupt = void 0;
      return factorySpace(effects, effects.attempt(list$1, ok2, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
    }
  }
  function tokenizeIndent(effects, ok2, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
    }
  }
  function tokenizeListEnd(effects) {
    effects.exit(this.containerState.type);
  }
  function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
    }
  }
  const setextUnderline = {
    name: "setextUnderline",
    resolveTo: resolveToSetextUnderline,
    tokenize: tokenizeSetextUnderline
  };
  function resolveToSetextUnderline(events, context) {
    let index2 = events.length;
    let content2;
    let text2;
    let definition2;
    while (index2--) {
      if (events[index2][0] === "enter") {
        if (events[index2][1].type === "content") {
          content2 = index2;
          break;
        }
        if (events[index2][1].type === "paragraph") {
          text2 = index2;
        }
      } else {
        if (events[index2][1].type === "content") {
          events.splice(index2, 1);
        }
        if (!definition2 && events[index2][1].type === "definition") {
          definition2 = index2;
        }
      }
    }
    const heading2 = {
      type: "setextHeading",
      start: {
        ...events[content2][1].start
      },
      end: {
        ...events[events.length - 1][1].end
      }
    };
    events[text2][1].type = "setextHeadingText";
    if (definition2) {
      events.splice(text2, 0, ["enter", heading2, context]);
      events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
      events[content2][1].end = {
        ...events[definition2][1].end
      };
    } else {
      events[content2][1] = heading2;
    }
    events.push(["exit", heading2, context]);
    return events;
  }
  function tokenizeSetextUnderline(effects, ok2, nok) {
    const self2 = this;
    let marker;
    return start;
    function start(code2) {
      let index2 = self2.events.length;
      let paragraph2;
      while (index2--) {
        if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
          paragraph2 = self2.events[index2][1].type === "paragraph";
          break;
        }
      }
      if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
        effects.enter("setextHeadingLine");
        marker = code2;
        return before(code2);
      }
      return nok(code2);
    }
    function before(code2) {
      effects.enter("setextHeadingLineSequence");
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        return inside;
      }
      effects.exit("setextHeadingLineSequence");
      return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
    }
    function after(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("setextHeadingLine");
        return ok2(code2);
      }
      return nok(code2);
    }
  }
  const flow$1 = {
    tokenize: initializeFlow
  };
  function initializeFlow(effects) {
    const self2 = this;
    const initial = effects.attempt(
      // Try to parse a blank line.
      blankLine,
      atBlankEnding,
      // Try to parse initial flow (essentially, only code).
      effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content, afterConstruct)), "linePrefix"))
    );
    return initial;
    function atBlankEnding(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("lineEndingBlank");
      effects.consume(code2);
      effects.exit("lineEndingBlank");
      self2.currentConstruct = void 0;
      return initial;
    }
    function afterConstruct(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      self2.currentConstruct = void 0;
      return initial;
    }
  }
  const resolver = {
    resolveAll: createResolver()
  };
  const string$1 = initializeFactory("string");
  const text$2 = initializeFactory("text");
  function initializeFactory(field) {
    return {
      resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),
      tokenize: initializeText
    };
    function initializeText(effects) {
      const self2 = this;
      const constructs2 = this.parser.constructs[field];
      const text2 = effects.attempt(constructs2, start, notText);
      return start;
      function start(code2) {
        return atBreak(code2) ? text2(code2) : notText(code2);
      }
      function notText(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("data");
        effects.consume(code2);
        return data;
      }
      function data(code2) {
        if (atBreak(code2)) {
          effects.exit("data");
          return text2(code2);
        }
        effects.consume(code2);
        return data;
      }
      function atBreak(code2) {
        if (code2 === null) {
          return true;
        }
        const list2 = constructs2[code2];
        let index2 = -1;
        if (list2) {
          while (++index2 < list2.length) {
            const item = list2[index2];
            if (!item.previous || item.previous.call(self2, self2.previous)) {
              return true;
            }
          }
        }
        return false;
      }
    }
  }
  function createResolver(extraResolver) {
    return resolveAllText;
    function resolveAllText(events, context) {
      let index2 = -1;
      let enter;
      while (++index2 <= events.length) {
        if (enter === void 0) {
          if (events[index2] && events[index2][1].type === "data") {
            enter = index2;
            index2++;
          }
        } else if (!events[index2] || events[index2][1].type !== "data") {
          if (index2 !== enter + 2) {
            events[enter][1].end = events[index2 - 1][1].end;
            events.splice(enter + 2, index2 - enter - 2);
            index2 = enter + 2;
          }
          enter = void 0;
        }
      }
      return extraResolver ? extraResolver(events, context) : events;
    }
  }
  function resolveAllLineSuffixes(events, context) {
    let eventIndex = 0;
    while (++eventIndex <= events.length) {
      if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
        const data = events[eventIndex - 1][1];
        const chunks = context.sliceStream(data);
        let index2 = chunks.length;
        let bufferIndex = -1;
        let size2 = 0;
        let tabs;
        while (index2--) {
          const chunk = chunks[index2];
          if (typeof chunk === "string") {
            bufferIndex = chunk.length;
            while (chunk.charCodeAt(bufferIndex - 1) === 32) {
              size2++;
              bufferIndex--;
            }
            if (bufferIndex) break;
            bufferIndex = -1;
          } else if (chunk === -2) {
            tabs = true;
            size2++;
          } else if (chunk === -1) ;
          else {
            index2++;
            break;
          }
        }
        if (context._contentTypeTextTrailing && eventIndex === events.length) {
          size2 = 0;
        }
        if (size2) {
          const token = {
            type: eventIndex === events.length || tabs || size2 < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
              _index: data.start._index + index2,
              line: data.end.line,
              column: data.end.column - size2,
              offset: data.end.offset - size2
            },
            end: {
              ...data.end
            }
          };
          data.end = {
            ...token.start
          };
          if (data.start.offset === data.end.offset) {
            Object.assign(data, token);
          } else {
            events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
            eventIndex += 2;
          }
        }
        eventIndex++;
      }
    }
    return events;
  }
  const document$1 = {
    [42]: list$1,
    [43]: list$1,
    [45]: list$1,
    [48]: list$1,
    [49]: list$1,
    [50]: list$1,
    [51]: list$1,
    [52]: list$1,
    [53]: list$1,
    [54]: list$1,
    [55]: list$1,
    [56]: list$1,
    [57]: list$1,
    [62]: blockQuote
  };
  const contentInitial = {
    [91]: definition
  };
  const flowInitial = {
    [-2]: codeIndented,
    [-1]: codeIndented,
    [32]: codeIndented
  };
  const flow = {
    [35]: headingAtx,
    [42]: thematicBreak$1,
    [45]: [setextUnderline, thematicBreak$1],
    [60]: htmlFlow,
    [61]: setextUnderline,
    [95]: thematicBreak$1,
    [96]: codeFenced,
    [126]: codeFenced
  };
  const string = {
    [38]: characterReference,
    [92]: characterEscape
  };
  const text$1 = {
    [-5]: lineEnding,
    [-4]: lineEnding,
    [-3]: lineEnding,
    [33]: labelStartImage,
    [38]: characterReference,
    [42]: attention,
    [60]: [autolink, htmlText],
    [91]: labelStartLink,
    [92]: [hardBreakEscape, characterEscape],
    [93]: labelEnd,
    [95]: attention,
    [96]: codeText
  };
  const insideSpan = {
    null: [attention, resolver]
  };
  const attentionMarkers = {
    null: [42, 95]
  };
  const disable = {
    null: []
  };
  const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    attentionMarkers,
    contentInitial,
    disable,
    document: document$1,
    flow,
    flowInitial,
    insideSpan,
    string,
    text: text$1
  }, Symbol.toStringTag, { value: "Module" }));
  function createTokenizer(parser, initialize, from) {
    let point2 = {
      _bufferIndex: -1,
      _index: 0,
      line: from && from.line || 1,
      column: from && from.column || 1,
      offset: from && from.offset || 0
    };
    const columnStart = {};
    const resolveAllConstructs = [];
    let chunks = [];
    let stack = [];
    const effects = {
      attempt: constructFactory(onsuccessfulconstruct),
      check: constructFactory(onsuccessfulcheck),
      consume,
      enter,
      exit: exit2,
      interrupt: constructFactory(onsuccessfulcheck, {
        interrupt: true
      })
    };
    const context = {
      code: null,
      containerState: {},
      defineSkip,
      events: [],
      now: now2,
      parser,
      previous: null,
      sliceSerialize,
      sliceStream,
      write
    };
    let state = initialize.tokenize.call(context, effects);
    if (initialize.resolveAll) {
      resolveAllConstructs.push(initialize);
    }
    return context;
    function write(slice) {
      chunks = push(chunks, slice);
      main();
      if (chunks[chunks.length - 1] !== null) {
        return [];
      }
      addResult(initialize, 0);
      context.events = resolveAll(resolveAllConstructs, context.events, context);
      return context.events;
    }
    function sliceSerialize(token, expandTabs) {
      return serializeChunks(sliceStream(token), expandTabs);
    }
    function sliceStream(token) {
      return sliceChunks(chunks, token);
    }
    function now2() {
      const {
        _bufferIndex,
        _index,
        line,
        column,
        offset: offset2
      } = point2;
      return {
        _bufferIndex,
        _index,
        line,
        column,
        offset: offset2
      };
    }
    function defineSkip(value) {
      columnStart[value.line] = value.column;
      accountForPotentialSkip();
    }
    function main() {
      let chunkIndex;
      while (point2._index < chunks.length) {
        const chunk = chunks[point2._index];
        if (typeof chunk === "string") {
          chunkIndex = point2._index;
          if (point2._bufferIndex < 0) {
            point2._bufferIndex = 0;
          }
          while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
            go(chunk.charCodeAt(point2._bufferIndex));
          }
        } else {
          go(chunk);
        }
      }
    }
    function go(code2) {
      state = state(code2);
    }
    function consume(code2) {
      if (markdownLineEnding(code2)) {
        point2.line++;
        point2.column = 1;
        point2.offset += code2 === -3 ? 2 : 1;
        accountForPotentialSkip();
      } else if (code2 !== -1) {
        point2.column++;
        point2.offset++;
      }
      if (point2._bufferIndex < 0) {
        point2._index++;
      } else {
        point2._bufferIndex++;
        if (point2._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
        // strings.
        /** @type {string} */
        chunks[point2._index].length) {
          point2._bufferIndex = -1;
          point2._index++;
        }
      }
      context.previous = code2;
    }
    function enter(type, fields) {
      const token = fields || {};
      token.type = type;
      token.start = now2();
      context.events.push(["enter", token, context]);
      stack.push(token);
      return token;
    }
    function exit2(type) {
      const token = stack.pop();
      token.end = now2();
      context.events.push(["exit", token, context]);
      return token;
    }
    function onsuccessfulconstruct(construct, info) {
      addResult(construct, info.from);
    }
    function onsuccessfulcheck(_, info) {
      info.restore();
    }
    function constructFactory(onreturn, fields) {
      return hook;
      function hook(constructs2, returnState, bogusState) {
        let listOfConstructs;
        let constructIndex;
        let currentConstruct;
        let info;
        return Array.isArray(constructs2) ? (
          /* c8 ignore next 1 */
          handleListOfConstructs(constructs2)
        ) : "tokenize" in constructs2 ? (
          // Looks like a construct.
          handleListOfConstructs([
            /** @type {Construct} */
            constructs2
          ])
        ) : handleMapOfConstructs(constructs2);
        function handleMapOfConstructs(map) {
          return start;
          function start(code2) {
            const left = code2 !== null && map[code2];
            const all2 = code2 !== null && map.null;
            const list2 = [
              // To do: add more extension tests.
              /* c8 ignore next 2 */
              ...Array.isArray(left) ? left : left ? [left] : [],
              ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
            ];
            return handleListOfConstructs(list2)(code2);
          }
        }
        function handleListOfConstructs(list2) {
          listOfConstructs = list2;
          constructIndex = 0;
          if (list2.length === 0) {
            return bogusState;
          }
          return handleConstruct(list2[constructIndex]);
        }
        function handleConstruct(construct) {
          return start;
          function start(code2) {
            info = store();
            currentConstruct = construct;
            if (!construct.partial) {
              context.currentConstruct = construct;
            }
            if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
              return nok();
            }
            return construct.tokenize.call(
              // If we do have fields, create an object w/ `context` as its
              // prototype.
              // This allows a live binding, which is needed for `interrupt`.
              fields ? Object.assign(Object.create(context), fields) : context,
              effects,
              ok2,
              nok
            )(code2);
          }
        }
        function ok2(code2) {
          onreturn(currentConstruct, info);
          return returnState;
        }
        function nok(code2) {
          info.restore();
          if (++constructIndex < listOfConstructs.length) {
            return handleConstruct(listOfConstructs[constructIndex]);
          }
          return bogusState;
        }
      }
    }
    function addResult(construct, from2) {
      if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
        resolveAllConstructs.push(construct);
      }
      if (construct.resolve) {
        splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
      }
      if (construct.resolveTo) {
        context.events = construct.resolveTo(context.events, context);
      }
    }
    function store() {
      const startPoint = now2();
      const startPrevious = context.previous;
      const startCurrentConstruct = context.currentConstruct;
      const startEventsIndex = context.events.length;
      const startStack = Array.from(stack);
      return {
        from: startEventsIndex,
        restore
      };
      function restore() {
        point2 = startPoint;
        context.previous = startPrevious;
        context.currentConstruct = startCurrentConstruct;
        context.events.length = startEventsIndex;
        stack = startStack;
        accountForPotentialSkip();
      }
    }
    function accountForPotentialSkip() {
      if (point2.line in columnStart && point2.column < 2) {
        point2.column = columnStart[point2.line];
        point2.offset += columnStart[point2.line] - 1;
      }
    }
  }
  function sliceChunks(chunks, token) {
    const startIndex = token.start._index;
    const startBufferIndex = token.start._bufferIndex;
    const endIndex = token.end._index;
    const endBufferIndex = token.end._bufferIndex;
    let view;
    if (startIndex === endIndex) {
      view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
    } else {
      view = chunks.slice(startIndex, endIndex);
      if (startBufferIndex > -1) {
        const head = view[0];
        if (typeof head === "string") {
          view[0] = head.slice(startBufferIndex);
        } else {
          view.shift();
        }
      }
      if (endBufferIndex > 0) {
        view.push(chunks[endIndex].slice(0, endBufferIndex));
      }
    }
    return view;
  }
  function serializeChunks(chunks, expandTabs) {
    let index2 = -1;
    const result = [];
    let atTab;
    while (++index2 < chunks.length) {
      const chunk = chunks[index2];
      let value;
      if (typeof chunk === "string") {
        value = chunk;
      } else switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab) continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
      atTab = chunk === -2;
      result.push(value);
    }
    return result.join("");
  }
  function parse(options2) {
    const settings = options2 || {};
    const constructs2 = (
      /** @type {FullNormalizedExtension} */
      combineExtensions([defaultConstructs, ...settings.extensions || []])
    );
    const parser = {
      constructs: constructs2,
      content: create2(content$1),
      defined: [],
      document: create2(document$2),
      flow: create2(flow$1),
      lazy: {},
      string: create2(string$1),
      text: create2(text$2)
    };
    return parser;
    function create2(initial) {
      return creator;
      function creator(from) {
        return createTokenizer(parser, initial, from);
      }
    }
  }
  function postprocess(events) {
    while (!subtokenize(events)) {
    }
    return events;
  }
  const search = /[\0\t\n\r]/g;
  function preprocess() {
    let column = 1;
    let buffer = "";
    let start = true;
    let atCarriageReturn;
    return preprocessor;
    function preprocessor(value, encoding, end) {
      const chunks = [];
      let match;
      let next;
      let startPosition;
      let endPosition;
      let code2;
      value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
      startPosition = 0;
      buffer = "";
      if (start) {
        if (value.charCodeAt(0) === 65279) {
          startPosition++;
        }
        start = void 0;
      }
      while (startPosition < value.length) {
        search.lastIndex = startPosition;
        match = search.exec(value);
        endPosition = match && match.index !== void 0 ? match.index : value.length;
        code2 = value.charCodeAt(endPosition);
        if (!match) {
          buffer = value.slice(startPosition);
          break;
        }
        if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
          chunks.push(-3);
          atCarriageReturn = void 0;
        } else {
          if (atCarriageReturn) {
            chunks.push(-5);
            atCarriageReturn = void 0;
          }
          if (startPosition < endPosition) {
            chunks.push(value.slice(startPosition, endPosition));
            column += endPosition - startPosition;
          }
          switch (code2) {
            case 0: {
              chunks.push(65533);
              column++;
              break;
            }
            case 9: {
              next = Math.ceil(column / 4) * 4;
              chunks.push(-2);
              while (column++ < next) chunks.push(-1);
              break;
            }
            case 10: {
              chunks.push(-4);
              column = 1;
              break;
            }
            default: {
              atCarriageReturn = true;
              column = 1;
            }
          }
        }
        startPosition = endPosition + 1;
      }
      if (end) {
        if (atCarriageReturn) chunks.push(-5);
        if (buffer) chunks.push(buffer);
        chunks.push(null);
      }
      return chunks;
    }
  }
  const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function decodeString(value) {
    return value.replace(characterEscapeOrReference, decode);
  }
  function decode($0, $1, $2) {
    if ($1) {
      return $1;
    }
    const head = $2.charCodeAt(0);
    if (head === 35) {
      const head2 = $2.charCodeAt(1);
      const hex2 = head2 === 120 || head2 === 88;
      return decodeNumericCharacterReference($2.slice(hex2 ? 2 : 1), hex2 ? 16 : 10);
    }
    return decodeNamedCharacterReference($2) || $0;
  }
  const own$2 = {}.hasOwnProperty;
  function fromMarkdown(value, encoding, options2) {
    if (typeof encoding !== "string") {
      options2 = encoding;
      encoding = void 0;
    }
    return compiler(options2)(postprocess(parse(options2).document().write(preprocess()(value, encoding, true))));
  }
  function compiler(options2) {
    const config = {
      transforms: [],
      canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
      enter: {
        autolink: opener(link2),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading2),
        blockQuote: opener(blockQuote2),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: opener(codeFlow, buffer),
        codeText: opener(codeText2, buffer),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition2),
        definitionDestinationString: buffer,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: opener(emphasis2),
        hardBreakEscape: opener(hardBreak2),
        hardBreakTrailing: opener(hardBreak2),
        htmlFlow: opener(html2, buffer),
        htmlFlowData: onenterdata,
        htmlText: opener(html2, buffer),
        htmlTextData: onenterdata,
        image: opener(image2),
        label: buffer,
        link: opener(link2),
        listItem: opener(listItem2),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list2, onenterlistordered),
        listUnordered: opener(list2),
        paragraph: opener(paragraph2),
        reference: onenterreference,
        referenceString: buffer,
        resourceDestinationString: buffer,
        resourceTitleString: buffer,
        setextHeading: opener(heading2),
        strong: opener(strong2),
        thematicBreak: opener(thematicBreak2)
      },
      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        characterReference: onexitcharacterreference,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    };
    configure(config, (options2 || {}).mdastExtensions || []);
    const data = {};
    return compile;
    function compile(events) {
      let tree = {
        type: "root",
        children: []
      };
      const context = {
        stack: [tree],
        tokenStack: [],
        config,
        enter,
        exit: exit2,
        buffer,
        resume,
        data
      };
      const listStack = [];
      let index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
          if (events[index2][0] === "enter") {
            listStack.push(index2);
          } else {
            const tail = listStack.pop();
            index2 = prepareList(events, tail, index2);
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        const handler = config[events[index2][0]];
        if (own$2.call(handler, events[index2][1].type)) {
          handler[events[index2][1].type].call(Object.assign({
            sliceSerialize: events[index2][2].sliceSerialize
          }, context), events[index2][1]);
        }
      }
      if (context.tokenStack.length > 0) {
        const tail = context.tokenStack[context.tokenStack.length - 1];
        const handler = tail[1] || defaultOnError;
        handler.call(context, void 0, tail[0]);
      }
      tree.position = {
        start: point(events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }),
        end: point(events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        })
      };
      index2 = -1;
      while (++index2 < config.transforms.length) {
        tree = config.transforms[index2](tree) || tree;
      }
      return tree;
    }
    function prepareList(events, start, length) {
      let index2 = start - 1;
      let containerBalance = -1;
      let listSpread = false;
      let listItem3;
      let lineIndex;
      let firstBlankLineIndex;
      let atMarker;
      while (++index2 <= length) {
        const event = events[index2];
        switch (event[1].type) {
          case "listUnordered":
          case "listOrdered":
          case "blockQuote": {
            if (event[0] === "enter") {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = void 0;
            break;
          }
          case "lineEndingBlank": {
            if (event[0] === "enter") {
              if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                firstBlankLineIndex = index2;
              }
              atMarker = void 0;
            }
            break;
          }
          case "linePrefix":
          case "listItemValue":
          case "listItemMarker":
          case "listItemPrefix":
          case "listItemPrefixWhitespace": {
            break;
          }
          default: {
            atMarker = void 0;
          }
        }
        if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
          if (listItem3) {
            let tailIndex = index2;
            lineIndex = void 0;
            while (tailIndex--) {
              const tailEvent = events[tailIndex];
              if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                if (tailEvent[0] === "exit") continue;
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                  listSpread = true;
                }
                tailEvent[1].type = "lineEnding";
                lineIndex = tailIndex;
              } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") ;
              else {
                break;
              }
            }
            if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
              listItem3._spread = true;
            }
            listItem3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
            events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
            index2++;
            length++;
          }
          if (event[1].type === "listItemPrefix") {
            const item = {
              type: "listItem",
              _spread: false,
              start: Object.assign({}, event[1].start),
              // @ts-expect-error: well add `end` in a second.
              end: void 0
            };
            listItem3 = item;
            events.splice(index2, 0, ["enter", item, event[2]]);
            index2++;
            length++;
            firstBlankLineIndex = void 0;
            atMarker = true;
          }
        }
      }
      events[start][1]._spread = listSpread;
      return length;
    }
    function opener(create2, and) {
      return open;
      function open(token) {
        enter.call(this, create2(token), token);
        if (and) and.call(this, token);
      }
    }
    function buffer() {
      this.stack.push({
        type: "fragment",
        children: []
      });
    }
    function enter(node2, token, errorHandler) {
      const parent = this.stack[this.stack.length - 1];
      const siblings = parent.children;
      siblings.push(node2);
      this.stack.push(node2);
      this.tokenStack.push([token, errorHandler || void 0]);
      node2.position = {
        start: point(token.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      };
    }
    function closer(and) {
      return close;
      function close(token) {
        if (and) and.call(this, token);
        exit2.call(this, token);
      }
    }
    function exit2(token, onExitError) {
      const node2 = this.stack.pop();
      const open = this.tokenStack.pop();
      if (!open) {
        throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
          start: token.start,
          end: token.end
        }) + "): its not open");
      } else if (open[0].type !== token.type) {
        if (onExitError) {
          onExitError.call(this, token, open[0]);
        } else {
          const handler = open[1] || defaultOnError;
          handler.call(this, token, open[0]);
        }
      }
      node2.position.end = point(token.end);
    }
    function resume() {
      return toString$2(this.stack.pop());
    }
    function onenterlistordered() {
      this.data.expectingFirstListItemValue = true;
    }
    function onenterlistitemvalue(token) {
      if (this.data.expectingFirstListItemValue) {
        const ancestor = this.stack[this.stack.length - 2];
        ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
        this.data.expectingFirstListItemValue = void 0;
      }
    }
    function onexitcodefencedfenceinfo() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.lang = data2;
    }
    function onexitcodefencedfencemeta() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.meta = data2;
    }
    function onexitcodefencedfence() {
      if (this.data.flowCodeInside) return;
      this.buffer();
      this.data.flowCodeInside = true;
    }
    function onexitcodefenced() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
      this.data.flowCodeInside = void 0;
    }
    function onexitcodeindented() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2.replace(/(\r?\n|\r)$/g, "");
    }
    function onexitdefinitionlabelstring(token) {
      const label = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.label = label;
      node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    }
    function onexitdefinitiontitlestring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.title = data2;
    }
    function onexitdefinitiondestinationstring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.url = data2;
    }
    function onexitatxheadingsequence(token) {
      const node2 = this.stack[this.stack.length - 1];
      if (!node2.depth) {
        const depth = this.sliceSerialize(token).length;
        node2.depth = depth;
      }
    }
    function onexitsetextheadingtext() {
      this.data.setextHeadingSlurpLineEnding = true;
    }
    function onexitsetextheadinglinesequence(token) {
      const node2 = this.stack[this.stack.length - 1];
      node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
    }
    function onexitsetextheading() {
      this.data.setextHeadingSlurpLineEnding = void 0;
    }
    function onenterdata(token) {
      const node2 = this.stack[this.stack.length - 1];
      const siblings = node2.children;
      let tail = siblings[siblings.length - 1];
      if (!tail || tail.type !== "text") {
        tail = text2();
        tail.position = {
          start: point(token.start),
          // @ts-expect-error: well add `end` later.
          end: void 0
        };
        siblings.push(tail);
      }
      this.stack.push(tail);
    }
    function onexitdata(token) {
      const tail = this.stack.pop();
      tail.value += this.sliceSerialize(token);
      tail.position.end = point(token.end);
    }
    function onexitlineending(token) {
      const context = this.stack[this.stack.length - 1];
      if (this.data.atHardBreak) {
        const tail = context.children[context.children.length - 1];
        tail.position.end = point(token.end);
        this.data.atHardBreak = void 0;
        return;
      }
      if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
        onenterdata.call(this, token);
        onexitdata.call(this, token);
      }
    }
    function onexithardbreak() {
      this.data.atHardBreak = true;
    }
    function onexithtmlflow() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexithtmltext() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexitcodetext() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexitlink() {
      const node2 = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const referenceType = this.data.referenceType || "shortcut";
        node2.type += "Reference";
        node2.referenceType = referenceType;
        delete node2.url;
        delete node2.title;
      } else {
        delete node2.identifier;
        delete node2.label;
      }
      this.data.referenceType = void 0;
    }
    function onexitimage() {
      const node2 = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const referenceType = this.data.referenceType || "shortcut";
        node2.type += "Reference";
        node2.referenceType = referenceType;
        delete node2.url;
        delete node2.title;
      } else {
        delete node2.identifier;
        delete node2.label;
      }
      this.data.referenceType = void 0;
    }
    function onexitlabeltext(token) {
      const string2 = this.sliceSerialize(token);
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.label = decodeString(string2);
      ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
    }
    function onexitlabel() {
      const fragment = this.stack[this.stack.length - 1];
      const value = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      this.data.inReference = true;
      if (node2.type === "link") {
        const children = fragment.children;
        node2.children = children;
      } else {
        node2.alt = value;
      }
    }
    function onexitresourcedestinationstring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.url = data2;
    }
    function onexitresourcetitlestring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.title = data2;
    }
    function onexitresource() {
      this.data.inReference = void 0;
    }
    function onenterreference() {
      this.data.referenceType = "collapsed";
    }
    function onexitreferencestring(token) {
      const label = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.label = label;
      node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
      this.data.referenceType = "full";
    }
    function onexitcharacterreferencemarker(token) {
      this.data.characterReferenceType = token.type;
    }
    function onexitcharacterreferencevalue(token) {
      const data2 = this.sliceSerialize(token);
      const type = this.data.characterReferenceType;
      let value;
      if (type) {
        value = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
        this.data.characterReferenceType = void 0;
      } else {
        const result = decodeNamedCharacterReference(data2);
        value = result;
      }
      const tail = this.stack[this.stack.length - 1];
      tail.value += value;
    }
    function onexitcharacterreference(token) {
      const tail = this.stack.pop();
      tail.position.end = point(token.end);
    }
    function onexitautolinkprotocol(token) {
      onexitdata.call(this, token);
      const node2 = this.stack[this.stack.length - 1];
      node2.url = this.sliceSerialize(token);
    }
    function onexitautolinkemail(token) {
      onexitdata.call(this, token);
      const node2 = this.stack[this.stack.length - 1];
      node2.url = "mailto:" + this.sliceSerialize(token);
    }
    function blockQuote2() {
      return {
        type: "blockquote",
        children: []
      };
    }
    function codeFlow() {
      return {
        type: "code",
        lang: null,
        meta: null,
        value: ""
      };
    }
    function codeText2() {
      return {
        type: "inlineCode",
        value: ""
      };
    }
    function definition2() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: ""
      };
    }
    function emphasis2() {
      return {
        type: "emphasis",
        children: []
      };
    }
    function heading2() {
      return {
        type: "heading",
        // @ts-expect-error `depth` will be set later.
        depth: 0,
        children: []
      };
    }
    function hardBreak2() {
      return {
        type: "break"
      };
    }
    function html2() {
      return {
        type: "html",
        value: ""
      };
    }
    function image2() {
      return {
        type: "image",
        title: null,
        url: "",
        alt: null
      };
    }
    function link2() {
      return {
        type: "link",
        title: null,
        url: "",
        children: []
      };
    }
    function list2(token) {
      return {
        type: "list",
        ordered: token.type === "listOrdered",
        start: null,
        spread: token._spread,
        children: []
      };
    }
    function listItem2(token) {
      return {
        type: "listItem",
        spread: token._spread,
        checked: null,
        children: []
      };
    }
    function paragraph2() {
      return {
        type: "paragraph",
        children: []
      };
    }
    function strong2() {
      return {
        type: "strong",
        children: []
      };
    }
    function text2() {
      return {
        type: "text",
        value: ""
      };
    }
    function thematicBreak2() {
      return {
        type: "thematicBreak"
      };
    }
  }
  function point(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    };
  }
  function configure(combined, extensions) {
    let index2 = -1;
    while (++index2 < extensions.length) {
      const value = extensions[index2];
      if (Array.isArray(value)) {
        configure(combined, value);
      } else {
        extension(combined, value);
      }
    }
  }
  function extension(combined, extension2) {
    let key;
    for (key in extension2) {
      if (own$2.call(extension2, key)) {
        switch (key) {
          case "canContainEols": {
            const right = extension2[key];
            if (right) {
              combined[key].push(...right);
            }
            break;
          }
          case "transforms": {
            const right = extension2[key];
            if (right) {
              combined[key].push(...right);
            }
            break;
          }
          case "enter":
          case "exit": {
            const right = extension2[key];
            if (right) {
              Object.assign(combined[key], right);
            }
            break;
          }
        }
      }
    }
  }
  function defaultOnError(left, right) {
    if (left) {
      throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is open");
    } else {
      throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is still open");
    }
  }
  function remarkParse(options2) {
    const self2 = this;
    self2.parser = parser;
    function parser(doc) {
      return fromMarkdown(doc, {
        ...self2.data("settings"),
        ...options2,
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: self2.data("micromarkExtensions") || [],
        mdastExtensions: self2.data("fromMarkdownExtensions") || []
      });
    }
  }
  function blockquote(state, node2) {
    const result = {
      type: "element",
      tagName: "blockquote",
      properties: {},
      children: state.wrap(state.all(node2), true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function hardBreak(state, node2) {
    const result = { type: "element", tagName: "br", properties: {}, children: [] };
    state.patch(node2, result);
    return [state.applyData(node2, result), { type: "text", value: "\n" }];
  }
  function code(state, node2) {
    const value = node2.value ? node2.value + "\n" : "";
    const properties = {};
    if (node2.lang) {
      properties.className = ["language-" + node2.lang];
    }
    let result = {
      type: "element",
      tagName: "code",
      properties,
      children: [{ type: "text", value }]
    };
    if (node2.meta) {
      result.data = { meta: node2.meta };
    }
    state.patch(node2, result);
    result = state.applyData(node2, result);
    result = { type: "element", tagName: "pre", properties: {}, children: [result] };
    state.patch(node2, result);
    return result;
  }
  function strikethrough(state, node2) {
    const result = {
      type: "element",
      tagName: "del",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function emphasis(state, node2) {
    const result = {
      type: "element",
      tagName: "em",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function footnoteReference(state, node2) {
    const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
    const id2 = String(node2.identifier).toUpperCase();
    const safeId = normalizeUri(id2.toLowerCase());
    const index2 = state.footnoteOrder.indexOf(id2);
    let counter;
    let reuseCounter = state.footnoteCounts.get(id2);
    if (reuseCounter === void 0) {
      reuseCounter = 0;
      state.footnoteOrder.push(id2);
      counter = state.footnoteOrder.length;
    } else {
      counter = index2 + 1;
    }
    reuseCounter += 1;
    state.footnoteCounts.set(id2, reuseCounter);
    const link2 = {
      type: "element",
      tagName: "a",
      properties: {
        href: "#" + clobberPrefix + "fn-" + safeId,
        id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
        dataFootnoteRef: true,
        ariaDescribedBy: ["footnote-label"]
      },
      children: [{ type: "text", value: String(counter) }]
    };
    state.patch(node2, link2);
    const sup = {
      type: "element",
      tagName: "sup",
      properties: {},
      children: [link2]
    };
    state.patch(node2, sup);
    return state.applyData(node2, sup);
  }
  function heading(state, node2) {
    const result = {
      type: "element",
      tagName: "h" + node2.depth,
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function html(state, node2) {
    if (state.options.allowDangerousHtml) {
      const result = { type: "raw", value: node2.value };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    return void 0;
  }
  function revert(state, node2) {
    const subtype = node2.referenceType;
    let suffix = "]";
    if (subtype === "collapsed") {
      suffix += "[]";
    } else if (subtype === "full") {
      suffix += "[" + (node2.label || node2.identifier) + "]";
    }
    if (node2.type === "imageReference") {
      return [{ type: "text", value: "![" + node2.alt + suffix }];
    }
    const contents = state.all(node2);
    const head = contents[0];
    if (head && head.type === "text") {
      head.value = "[" + head.value;
    } else {
      contents.unshift({ type: "text", value: "[" });
    }
    const tail = contents[contents.length - 1];
    if (tail && tail.type === "text") {
      tail.value += suffix;
    } else {
      contents.push({ type: "text", value: suffix });
    }
    return contents;
  }
  function imageReference(state, node2) {
    const id2 = String(node2.identifier).toUpperCase();
    const definition2 = state.definitionById.get(id2);
    if (!definition2) {
      return revert(state, node2);
    }
    const properties = { src: normalizeUri(definition2.url || ""), alt: node2.alt };
    if (definition2.title !== null && definition2.title !== void 0) {
      properties.title = definition2.title;
    }
    const result = { type: "element", tagName: "img", properties, children: [] };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function image(state, node2) {
    const properties = { src: normalizeUri(node2.url) };
    if (node2.alt !== null && node2.alt !== void 0) {
      properties.alt = node2.alt;
    }
    if (node2.title !== null && node2.title !== void 0) {
      properties.title = node2.title;
    }
    const result = { type: "element", tagName: "img", properties, children: [] };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function inlineCode(state, node2) {
    const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
    state.patch(node2, text2);
    const result = {
      type: "element",
      tagName: "code",
      properties: {},
      children: [text2]
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function linkReference(state, node2) {
    const id2 = String(node2.identifier).toUpperCase();
    const definition2 = state.definitionById.get(id2);
    if (!definition2) {
      return revert(state, node2);
    }
    const properties = { href: normalizeUri(definition2.url || "") };
    if (definition2.title !== null && definition2.title !== void 0) {
      properties.title = definition2.title;
    }
    const result = {
      type: "element",
      tagName: "a",
      properties,
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function link(state, node2) {
    const properties = { href: normalizeUri(node2.url) };
    if (node2.title !== null && node2.title !== void 0) {
      properties.title = node2.title;
    }
    const result = {
      type: "element",
      tagName: "a",
      properties,
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function listItem(state, node2, parent) {
    const results = state.all(node2);
    const loose = parent ? listLoose(parent) : listItemLoose(node2);
    const properties = {};
    const children = [];
    if (typeof node2.checked === "boolean") {
      const head = results[0];
      let paragraph2;
      if (head && head.type === "element" && head.tagName === "p") {
        paragraph2 = head;
      } else {
        paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
        results.unshift(paragraph2);
      }
      if (paragraph2.children.length > 0) {
        paragraph2.children.unshift({ type: "text", value: " " });
      }
      paragraph2.children.unshift({
        type: "element",
        tagName: "input",
        properties: { type: "checkbox", checked: node2.checked, disabled: true },
        children: []
      });
      properties.className = ["task-list-item"];
    }
    let index2 = -1;
    while (++index2 < results.length) {
      const child = results[index2];
      if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
        children.push({ type: "text", value: "\n" });
      }
      if (child.type === "element" && child.tagName === "p" && !loose) {
        children.push(...child.children);
      } else {
        children.push(child);
      }
    }
    const tail = results[results.length - 1];
    if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
      children.push({ type: "text", value: "\n" });
    }
    const result = { type: "element", tagName: "li", properties, children };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function listLoose(node2) {
    let loose = false;
    if (node2.type === "list") {
      loose = node2.spread || false;
      const children = node2.children;
      let index2 = -1;
      while (!loose && ++index2 < children.length) {
        loose = listItemLoose(children[index2]);
      }
    }
    return loose;
  }
  function listItemLoose(node2) {
    const spread2 = node2.spread;
    return spread2 === null || spread2 === void 0 ? node2.children.length > 1 : spread2;
  }
  function list(state, node2) {
    const properties = {};
    const results = state.all(node2);
    let index2 = -1;
    if (typeof node2.start === "number" && node2.start !== 1) {
      properties.start = node2.start;
    }
    while (++index2 < results.length) {
      const child = results[index2];
      if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
        properties.className = ["contains-task-list"];
        break;
      }
    }
    const result = {
      type: "element",
      tagName: node2.ordered ? "ol" : "ul",
      properties,
      children: state.wrap(results, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function paragraph(state, node2) {
    const result = {
      type: "element",
      tagName: "p",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function root(state, node2) {
    const result = { type: "root", children: state.wrap(state.all(node2)) };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function strong(state, node2) {
    const result = {
      type: "element",
      tagName: "strong",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function table(state, node2) {
    const rows = state.all(node2);
    const firstRow = rows.shift();
    const tableContent = [];
    if (firstRow) {
      const head = {
        type: "element",
        tagName: "thead",
        properties: {},
        children: state.wrap([firstRow], true)
      };
      state.patch(node2.children[0], head);
      tableContent.push(head);
    }
    if (rows.length > 0) {
      const body = {
        type: "element",
        tagName: "tbody",
        properties: {},
        children: state.wrap(rows, true)
      };
      const start = pointStart(node2.children[1]);
      const end = pointEnd(node2.children[node2.children.length - 1]);
      if (start && end) body.position = { start, end };
      tableContent.push(body);
    }
    const result = {
      type: "element",
      tagName: "table",
      properties: {},
      children: state.wrap(tableContent, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function tableRow(state, node2, parent) {
    const siblings = parent ? parent.children : void 0;
    const rowIndex = siblings ? siblings.indexOf(node2) : 1;
    const tagName = rowIndex === 0 ? "th" : "td";
    const align = parent && parent.type === "table" ? parent.align : void 0;
    const length = align ? align.length : node2.children.length;
    let cellIndex = -1;
    const cells = [];
    while (++cellIndex < length) {
      const cell = node2.children[cellIndex];
      const properties = {};
      const alignValue = align ? align[cellIndex] : void 0;
      if (alignValue) {
        properties.align = alignValue;
      }
      let result2 = { type: "element", tagName, properties, children: [] };
      if (cell) {
        result2.children = state.all(cell);
        state.patch(cell, result2);
        result2 = state.applyData(cell, result2);
      }
      cells.push(result2);
    }
    const result = {
      type: "element",
      tagName: "tr",
      properties: {},
      children: state.wrap(cells, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function tableCell(state, node2) {
    const result = {
      type: "element",
      tagName: "td",
      // Assume body cell.
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  const tab = 9;
  const space = 32;
  function trimLines(value) {
    const source = String(value);
    const search2 = /\r?\n|\r/g;
    let match = search2.exec(source);
    let last = 0;
    const lines = [];
    while (match) {
      lines.push(
        trimLine(source.slice(last, match.index), last > 0, true),
        match[0]
      );
      last = match.index + match[0].length;
      match = search2.exec(source);
    }
    lines.push(trimLine(source.slice(last), last > 0, false));
    return lines.join("");
  }
  function trimLine(value, start, end) {
    let startIndex = 0;
    let endIndex = value.length;
    if (start) {
      let code2 = value.codePointAt(startIndex);
      while (code2 === tab || code2 === space) {
        startIndex++;
        code2 = value.codePointAt(startIndex);
      }
    }
    if (end) {
      let code2 = value.codePointAt(endIndex - 1);
      while (code2 === tab || code2 === space) {
        endIndex--;
        code2 = value.codePointAt(endIndex - 1);
      }
    }
    return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
  }
  function text(state, node2) {
    const result = { type: "text", value: trimLines(String(node2.value)) };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function thematicBreak(state, node2) {
    const result = {
      type: "element",
      tagName: "hr",
      properties: {},
      children: []
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  const handlers = {
    blockquote,
    break: hardBreak,
    code,
    delete: strikethrough,
    emphasis,
    footnoteReference,
    heading,
    html,
    imageReference,
    image,
    inlineCode,
    linkReference,
    link,
    listItem,
    list,
    paragraph,
    // @ts-expect-error: root is different, but hard to type.
    root,
    strong,
    table,
    tableCell,
    tableRow,
    text,
    thematicBreak,
    toml: ignore,
    yaml: ignore,
    definition: ignore,
    footnoteDefinition: ignore
  };
  function ignore() {
    return void 0;
  }
  const VOID = -1;
  const PRIMITIVE = 0;
  const ARRAY = 1;
  const OBJECT = 2;
  const DATE = 3;
  const REGEXP = 4;
  const MAP = 5;
  const SET = 6;
  const ERROR = 7;
  const BIGINT = 8;
  const env = typeof self === "object" ? self : globalThis;
  const deserializer = ($2, _) => {
    const as = (out, index2) => {
      $2.set(index2, out);
      return out;
    };
    const unpair = (index2) => {
      if ($2.has(index2))
        return $2.get(index2);
      const [type, value] = _[index2];
      switch (type) {
        case PRIMITIVE:
        case VOID:
          return as(value, index2);
        case ARRAY: {
          const arr = as([], index2);
          for (const index3 of value)
            arr.push(unpair(index3));
          return arr;
        }
        case OBJECT: {
          const object = as({}, index2);
          for (const [key, index3] of value)
            object[unpair(key)] = unpair(index3);
          return object;
        }
        case DATE:
          return as(new Date(value), index2);
        case REGEXP: {
          const { source, flags } = value;
          return as(new RegExp(source, flags), index2);
        }
        case MAP: {
          const map = as(/* @__PURE__ */ new Map(), index2);
          for (const [key, index3] of value)
            map.set(unpair(key), unpair(index3));
          return map;
        }
        case SET: {
          const set = as(/* @__PURE__ */ new Set(), index2);
          for (const index3 of value)
            set.add(unpair(index3));
          return set;
        }
        case ERROR: {
          const { name: name2, message } = value;
          return as(new env[name2](message), index2);
        }
        case BIGINT:
          return as(BigInt(value), index2);
        case "BigInt":
          return as(Object(BigInt(value)), index2);
        case "ArrayBuffer":
          return as(new Uint8Array(value).buffer, value);
        case "DataView": {
          const { buffer } = new Uint8Array(value);
          return as(new DataView(buffer), value);
        }
      }
      return as(new env[type](value), index2);
    };
    return unpair;
  };
  const deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
  const EMPTY = "";
  const { toString: toString$1 } = {};
  const { keys } = Object;
  const typeOf = (value) => {
    const type = typeof value;
    if (type !== "object" || !value)
      return [PRIMITIVE, type];
    const asString = toString$1.call(value).slice(8, -1);
    switch (asString) {
      case "Array":
        return [ARRAY, EMPTY];
      case "Object":
        return [OBJECT, EMPTY];
      case "Date":
        return [DATE, EMPTY];
      case "RegExp":
        return [REGEXP, EMPTY];
      case "Map":
        return [MAP, EMPTY];
      case "Set":
        return [SET, EMPTY];
      case "DataView":
        return [ARRAY, asString];
    }
    if (asString.includes("Array"))
      return [ARRAY, asString];
    if (asString.includes("Error"))
      return [ERROR, asString];
    return [OBJECT, asString];
  };
  const shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
  const serializer = (strict, json, $2, _) => {
    const as = (out, value) => {
      const index2 = _.push(out) - 1;
      $2.set(value, index2);
      return index2;
    };
    const pair = (value) => {
      if ($2.has(value))
        return $2.get(value);
      let [TYPE, type] = typeOf(value);
      switch (TYPE) {
        case PRIMITIVE: {
          let entry = value;
          switch (type) {
            case "bigint":
              TYPE = BIGINT;
              entry = value.toString();
              break;
            case "function":
            case "symbol":
              if (strict)
                throw new TypeError("unable to serialize " + type);
              entry = null;
              break;
            case "undefined":
              return as([VOID], value);
          }
          return as([TYPE, entry], value);
        }
        case ARRAY: {
          if (type) {
            let spread2 = value;
            if (type === "DataView") {
              spread2 = new Uint8Array(value.buffer);
            } else if (type === "ArrayBuffer") {
              spread2 = new Uint8Array(value);
            }
            return as([type, [...spread2]], value);
          }
          const arr = [];
          const index2 = as([TYPE, arr], value);
          for (const entry of value)
            arr.push(pair(entry));
          return index2;
        }
        case OBJECT: {
          if (type) {
            switch (type) {
              case "BigInt":
                return as([type, value.toString()], value);
              case "Boolean":
              case "Number":
              case "String":
                return as([type, value.valueOf()], value);
            }
          }
          if (json && "toJSON" in value)
            return pair(value.toJSON());
          const entries = [];
          const index2 = as([TYPE, entries], value);
          for (const key of keys(value)) {
            if (strict || !shouldSkip(typeOf(value[key])))
              entries.push([pair(key), pair(value[key])]);
          }
          return index2;
        }
        case DATE:
          return as([TYPE, value.toISOString()], value);
        case REGEXP: {
          const { source, flags } = value;
          return as([TYPE, { source, flags }], value);
        }
        case MAP: {
          const entries = [];
          const index2 = as([TYPE, entries], value);
          for (const [key, entry] of value) {
            if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
              entries.push([pair(key), pair(entry)]);
          }
          return index2;
        }
        case SET: {
          const entries = [];
          const index2 = as([TYPE, entries], value);
          for (const entry of value) {
            if (strict || !shouldSkip(typeOf(entry)))
              entries.push(pair(entry));
          }
          return index2;
        }
      }
      const { message } = value;
      return as([TYPE, { name: type, message }], value);
    };
    return pair;
  };
  const serialize = (value, { json, lossy } = {}) => {
    const _ = [];
    return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
  };
  const structuredClone$1 = typeof structuredClone === "function" ? (
    /* c8 ignore start */
    (any, options2) => options2 && ("json" in options2 || "lossy" in options2) ? deserialize(serialize(any, options2)) : structuredClone(any)
  ) : (any, options2) => deserialize(serialize(any, options2));
  function defaultFootnoteBackContent(_, rereferenceIndex) {
    const result = [{ type: "text", value: "" }];
    if (rereferenceIndex > 1) {
      result.push({
        type: "element",
        tagName: "sup",
        properties: {},
        children: [{ type: "text", value: String(rereferenceIndex) }]
      });
    }
    return result;
  }
  function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
    return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
  }
  function footer(state) {
    const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
    const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
    const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
    const footnoteLabel = state.options.footnoteLabel || "Footnotes";
    const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
    const footnoteLabelProperties = state.options.footnoteLabelProperties || {
      className: ["sr-only"]
    };
    const listItems = [];
    let referenceIndex = -1;
    while (++referenceIndex < state.footnoteOrder.length) {
      const definition2 = state.footnoteById.get(
        state.footnoteOrder[referenceIndex]
      );
      if (!definition2) {
        continue;
      }
      const content2 = state.all(definition2);
      const id2 = String(definition2.identifier).toUpperCase();
      const safeId = normalizeUri(id2.toLowerCase());
      let rereferenceIndex = 0;
      const backReferences = [];
      const counts = state.footnoteCounts.get(id2);
      while (counts !== void 0 && ++rereferenceIndex <= counts) {
        if (backReferences.length > 0) {
          backReferences.push({ type: "text", value: " " });
        }
        let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
        if (typeof children === "string") {
          children = { type: "text", value: children };
        }
        backReferences.push({
          type: "element",
          tagName: "a",
          properties: {
            href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
            dataFootnoteBackref: "",
            ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
            className: ["data-footnote-backref"]
          },
          children: Array.isArray(children) ? children : [children]
        });
      }
      const tail = content2[content2.length - 1];
      if (tail && tail.type === "element" && tail.tagName === "p") {
        const tailTail = tail.children[tail.children.length - 1];
        if (tailTail && tailTail.type === "text") {
          tailTail.value += " ";
        } else {
          tail.children.push({ type: "text", value: " " });
        }
        tail.children.push(...backReferences);
      } else {
        content2.push(...backReferences);
      }
      const listItem2 = {
        type: "element",
        tagName: "li",
        properties: { id: clobberPrefix + "fn-" + safeId },
        children: state.wrap(content2, true)
      };
      state.patch(definition2, listItem2);
      listItems.push(listItem2);
    }
    if (listItems.length === 0) {
      return;
    }
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: true, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: footnoteLabelTagName,
          properties: {
            ...structuredClone$1(footnoteLabelProperties),
            id: "footnote-label"
          },
          children: [{ type: "text", value: footnoteLabel }]
        },
        { type: "text", value: "\n" },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: state.wrap(listItems, true)
        },
        { type: "text", value: "\n" }
      ]
    };
  }
  const convert = (
    // Note: overloads in JSDoc cant yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
     *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
     *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
     *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {Check}
     */
    function(test2) {
      if (test2 === null || test2 === void 0) {
        return ok;
      }
      if (typeof test2 === "function") {
        return castFactory(test2);
      }
      if (typeof test2 === "object") {
        return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
      }
      if (typeof test2 === "string") {
        return typeFactory(test2);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert(tests[index2]);
    }
    return castFactory(any);
    function any(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].apply(this, parameters)) return true;
      }
      return false;
    }
  }
  function propsFactory(check) {
    const checkAsRecord = (
      /** @type {Record<string, unknown>} */
      check
    );
    return castFactory(all2);
    function all2(node2) {
      const nodeAsRecord = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        node2
      );
      let key;
      for (key in check) {
        if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
      }
      return true;
    }
  }
  function typeFactory(check) {
    return castFactory(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory(testFunction) {
    return check;
    function check(value, index2, parent) {
      return Boolean(
        looksLikeANode(value) && testFunction.call(
          this,
          value,
          typeof index2 === "number" ? index2 : void 0,
          parent || void 0
        )
      );
    }
  }
  function ok() {
    return true;
  }
  function looksLikeANode(value) {
    return value !== null && typeof value === "object" && "type" in value;
  }
  function color$1(d) {
    return d;
  }
  const empty = [];
  const CONTINUE = true;
  const EXIT = false;
  const SKIP = "skip";
  function visitParents(tree, test2, visitor, reverse) {
    let check;
    if (typeof test2 === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test2;
    } else {
      check = test2;
    }
    const is = convert(check);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node2, index2, parents) {
      const value = (
        /** @type {Record<string, unknown>} */
        node2 && typeof node2 === "object" ? node2 : {}
      );
      if (typeof value.type === "string") {
        const name2 = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color$1(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = empty;
        let subresult;
        let offset2;
        let grandparents;
        if (!test2 || is(node2, index2, parents[parents.length - 1] || void 0)) {
          result = toResult(visitor(node2, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if ("children" in node2 && node2.children) {
          const nodeAsParent = (
            /** @type {UnistParent} */
            node2
          );
          if (nodeAsParent.children && result[0] !== SKIP) {
            offset2 = (reverse ? nodeAsParent.children.length : -1) + step;
            grandparents = parents.concat(nodeAsParent);
            while (offset2 > -1 && offset2 < nodeAsParent.children.length) {
              const child = nodeAsParent.children[offset2];
              subresult = factory(child, offset2, grandparents)();
              if (subresult[0] === EXIT) {
                return subresult;
              }
              offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
            }
          }
        }
        return result;
      }
    }
  }
  function toResult(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "number") {
      return [CONTINUE, value];
    }
    return value === null || value === void 0 ? empty : [value];
  }
  function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
    let reverse;
    let test2;
    let visitor;
    if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
      test2 = void 0;
      visitor = testOrVisitor;
      reverse = visitorOrReverse;
    } else {
      test2 = testOrVisitor;
      visitor = visitorOrReverse;
      reverse = maybeReverse;
    }
    visitParents(tree, test2, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      const index2 = parent ? parent.children.indexOf(node2) : void 0;
      return visitor(node2, index2, parent);
    }
  }
  const own$1 = {}.hasOwnProperty;
  const emptyOptions = {};
  function createState$1(tree, options2) {
    const settings = options2 || emptyOptions;
    const definitionById = /* @__PURE__ */ new Map();
    const footnoteById = /* @__PURE__ */ new Map();
    const footnoteCounts = /* @__PURE__ */ new Map();
    const handlers$1 = { ...handlers, ...settings.handlers };
    const state = {
      all: all2,
      applyData,
      definitionById,
      footnoteById,
      footnoteCounts,
      footnoteOrder: [],
      handlers: handlers$1,
      one: one2,
      options: settings,
      patch,
      wrap: wrap$2
    };
    visit(tree, function(node2) {
      if (node2.type === "definition" || node2.type === "footnoteDefinition") {
        const map = node2.type === "definition" ? definitionById : footnoteById;
        const id2 = String(node2.identifier).toUpperCase();
        if (!map.has(id2)) {
          map.set(id2, node2);
        }
      }
    });
    return state;
    function one2(node2, parent) {
      const type = node2.type;
      const handle = state.handlers[type];
      if (own$1.call(state.handlers, type) && handle) {
        return handle(state, node2, parent);
      }
      if (state.options.passThrough && state.options.passThrough.includes(type)) {
        if ("children" in node2) {
          const { children, ...shallow } = node2;
          const result = structuredClone$1(shallow);
          result.children = state.all(node2);
          return result;
        }
        return structuredClone$1(node2);
      }
      const unknown = state.options.unknownHandler || defaultUnknownHandler;
      return unknown(state, node2, parent);
    }
    function all2(parent) {
      const values = [];
      if ("children" in parent) {
        const nodes = parent.children;
        let index2 = -1;
        while (++index2 < nodes.length) {
          const result = state.one(nodes[index2], parent);
          if (result) {
            if (index2 && nodes[index2 - 1].type === "break") {
              if (!Array.isArray(result) && result.type === "text") {
                result.value = trimMarkdownSpaceStart(result.value);
              }
              if (!Array.isArray(result) && result.type === "element") {
                const head = result.children[0];
                if (head && head.type === "text") {
                  head.value = trimMarkdownSpaceStart(head.value);
                }
              }
            }
            if (Array.isArray(result)) {
              values.push(...result);
            } else {
              values.push(result);
            }
          }
        }
      }
      return values;
    }
  }
  function patch(from, to) {
    if (from.position) to.position = position$1(from);
  }
  function applyData(from, to) {
    let result = to;
    if (from && from.data) {
      const hName = from.data.hName;
      const hChildren = from.data.hChildren;
      const hProperties = from.data.hProperties;
      if (typeof hName === "string") {
        if (result.type === "element") {
          result.tagName = hName;
        } else {
          const children = "children" in result ? result.children : [result];
          result = { type: "element", tagName: hName, properties: {}, children };
        }
      }
      if (result.type === "element" && hProperties) {
        Object.assign(result.properties, structuredClone$1(hProperties));
      }
      if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
        result.children = hChildren;
      }
    }
    return result;
  }
  function defaultUnknownHandler(state, node2) {
    const data = node2.data || {};
    const result = "value" in node2 && !(own$1.call(data, "hProperties") || own$1.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
      type: "element",
      tagName: "div",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function wrap$2(nodes, loose) {
    const result = [];
    let index2 = -1;
    if (loose) {
      result.push({ type: "text", value: "\n" });
    }
    while (++index2 < nodes.length) {
      if (index2) result.push({ type: "text", value: "\n" });
      result.push(nodes[index2]);
    }
    if (loose && nodes.length > 0) {
      result.push({ type: "text", value: "\n" });
    }
    return result;
  }
  function trimMarkdownSpaceStart(value) {
    let index2 = 0;
    let code2 = value.charCodeAt(index2);
    while (code2 === 9 || code2 === 32) {
      index2++;
      code2 = value.charCodeAt(index2);
    }
    return value.slice(index2);
  }
  function toHast(tree, options2) {
    const state = createState$1(tree, options2);
    const node2 = state.one(tree, void 0);
    const foot = footer(state);
    const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
    if (foot) {
      result.children.push({ type: "text", value: "\n" }, foot);
    }
    return result;
  }
  function remarkRehype(destination, options2) {
    if (destination && "run" in destination) {
      return async function(tree, file) {
        const hastTree = (
          /** @type {HastRoot} */
          toHast(tree, { file, ...options2 })
        );
        await destination.run(hastTree, file);
      };
    }
    return function(tree, file) {
      return (
        /** @type {HastRoot} */
        toHast(tree, { file, ...destination || options2 })
      );
    };
  }
  function bail(error) {
    if (error) {
      throw error;
    }
  }
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray$1 = function isArray2(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject$3 = function isPlainObject2(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key;
    for (key in obj) {
    }
    return typeof key === "undefined" || hasOwn.call(obj, key);
  };
  var setProperty = function setProperty2(target, options2) {
    if (defineProperty && options2.name === "__proto__") {
      defineProperty(target, options2.name, {
        enumerable: true,
        configurable: true,
        value: options2.newValue,
        writable: true
      });
    } else {
      target[options2.name] = options2.newValue;
    }
  };
  var getProperty = function getProperty2(obj, name2) {
    if (name2 === "__proto__") {
      if (!hasOwn.call(obj, name2)) {
        return void 0;
      } else if (gOPD) {
        return gOPD(obj, name2).value;
      }
    }
    return obj[name2];
  };
  var extend$1 = function extend2() {
    var options2, name2, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (; i < length; ++i) {
      options2 = arguments[i];
      if (options2 != null) {
        for (name2 in options2) {
          src = getProperty(target, name2);
          copy = getProperty(options2, name2);
          if (target !== copy) {
            if (deep && copy && (isPlainObject$3(copy) || (copyIsArray = isArray$1(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray$1(src) ? src : [];
              } else {
                clone = src && isPlainObject$3(src) ? src : {};
              }
              setProperty(target, { name: name2, newValue: extend2(deep, clone, copy) });
            } else if (typeof copy !== "undefined") {
              setProperty(target, { name: name2, newValue: copy });
            }
          }
        }
      }
    }
    return target;
  };
  const extend$2 = /* @__PURE__ */ getDefaultExportFromCjs(extend$1);
  function isPlainObject$2(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype2 = Object.getPrototypeOf(value);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  }
  function trough() {
    const fns = [];
    const pipeline = { run, use };
    return pipeline;
    function run(...values) {
      let middlewareIndex = -1;
      const callback = values.pop();
      if (typeof callback !== "function") {
        throw new TypeError("Expected function as last argument, not " + callback);
      }
      next(null, ...values);
      function next(error, ...output) {
        const fn = fns[++middlewareIndex];
        let index2 = -1;
        if (error) {
          callback(error);
          return;
        }
        while (++index2 < values.length) {
          if (output[index2] === null || output[index2] === void 0) {
            output[index2] = values[index2];
          }
        }
        values = output;
        if (fn) {
          wrap$1(fn, next)(...output);
        } else {
          callback(null, ...output);
        }
      }
    }
    function use(middelware) {
      if (typeof middelware !== "function") {
        throw new TypeError(
          "Expected `middelware` to be a function, not " + middelware
        );
      }
      fns.push(middelware);
      return pipeline;
    }
  }
  function wrap$1(middleware, callback) {
    let called;
    return wrapped;
    function wrapped(...parameters) {
      const fnExpectsCallback = middleware.length > parameters.length;
      let result;
      if (fnExpectsCallback) {
        parameters.push(done);
      }
      try {
        result = middleware.apply(this, parameters);
      } catch (error) {
        const exception = (
          /** @type {Error} */
          error
        );
        if (fnExpectsCallback && called) {
          throw exception;
        }
        return done(exception);
      }
      if (!fnExpectsCallback) {
        if (result && result.then && typeof result.then === "function") {
          result.then(then, done);
        } else if (result instanceof Error) {
          done(result);
        } else {
          then(result);
        }
      }
    }
    function done(error, ...output) {
      if (!called) {
        called = true;
        callback(error, ...output);
      }
    }
    function then(value) {
      done(null, value);
    }
  }
  const minpath = { basename, dirname, extname, join, sep: "/" };
  function basename(path, extname2) {
    if (extname2 !== void 0 && typeof extname2 !== "string") {
      throw new TypeError('"ext" argument must be a string');
    }
    assertPath$1(path);
    let start = 0;
    let end = -1;
    let index2 = path.length;
    let seenNonSlash;
    if (extname2 === void 0 || extname2.length === 0 || extname2.length > path.length) {
      while (index2--) {
        if (path.codePointAt(index2) === 47) {
          if (seenNonSlash) {
            start = index2 + 1;
            break;
          }
        } else if (end < 0) {
          seenNonSlash = true;
          end = index2 + 1;
        }
      }
      return end < 0 ? "" : path.slice(start, end);
    }
    if (extname2 === path) {
      return "";
    }
    let firstNonSlashEnd = -1;
    let extnameIndex = extname2.length - 1;
    while (index2--) {
      if (path.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd < 0) {
          seenNonSlash = true;
          firstNonSlashEnd = index2 + 1;
        }
        if (extnameIndex > -1) {
          if (path.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
            if (extnameIndex < 0) {
              end = index2;
            }
          } else {
            extnameIndex = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end) {
      end = firstNonSlashEnd;
    } else if (end < 0) {
      end = path.length;
    }
    return path.slice(start, end);
  }
  function dirname(path) {
    assertPath$1(path);
    if (path.length === 0) {
      return ".";
    }
    let end = -1;
    let index2 = path.length;
    let unmatchedSlash;
    while (--index2) {
      if (path.codePointAt(index2) === 47) {
        if (unmatchedSlash) {
          end = index2;
          break;
        }
      } else if (!unmatchedSlash) {
        unmatchedSlash = true;
      }
    }
    return end < 0 ? path.codePointAt(0) === 47 ? "/" : "." : end === 1 && path.codePointAt(0) === 47 ? "//" : path.slice(0, end);
  }
  function extname(path) {
    assertPath$1(path);
    let index2 = path.length;
    let end = -1;
    let startPart = 0;
    let startDot = -1;
    let preDotState = 0;
    let unmatchedSlash;
    while (index2--) {
      const code2 = path.codePointAt(index2);
      if (code2 === 47) {
        if (unmatchedSlash) {
          startPart = index2 + 1;
          break;
        }
        continue;
      }
      if (end < 0) {
        unmatchedSlash = true;
        end = index2 + 1;
      }
      if (code2 === 46) {
        if (startDot < 0) {
          startDot = index2;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot > -1) {
        preDotState = -1;
      }
    }
    if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
    preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  }
  function join(...segments) {
    let index2 = -1;
    let joined;
    while (++index2 < segments.length) {
      assertPath$1(segments[index2]);
      if (segments[index2]) {
        joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
      }
    }
    return joined === void 0 ? "." : normalize(joined);
  }
  function normalize(path) {
    assertPath$1(path);
    const absolute = path.codePointAt(0) === 47;
    let value = normalizeString(path, !absolute);
    if (value.length === 0 && !absolute) {
      value = ".";
    }
    if (value.length > 0 && path.codePointAt(path.length - 1) === 47) {
      value += "/";
    }
    return absolute ? "/" + value : value;
  }
  function normalizeString(path, allowAboveRoot) {
    let result = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let index2 = -1;
    let code2;
    let lastSlashIndex;
    while (++index2 <= path.length) {
      if (index2 < path.length) {
        code2 = path.codePointAt(index2);
      } else if (code2 === 47) {
        break;
      } else {
        code2 = 47;
      }
      if (code2 === 47) {
        if (lastSlash === index2 - 1 || dots === 1) ;
        else if (lastSlash !== index2 - 1 && dots === 2) {
          if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
            if (result.length > 2) {
              lastSlashIndex = result.lastIndexOf("/");
              if (lastSlashIndex !== result.length - 1) {
                if (lastSlashIndex < 0) {
                  result = "";
                  lastSegmentLength = 0;
                } else {
                  result = result.slice(0, lastSlashIndex);
                  lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                }
                lastSlash = index2;
                dots = 0;
                continue;
              }
            } else if (result.length > 0) {
              result = "";
              lastSegmentLength = 0;
              lastSlash = index2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            result = result.length > 0 ? result + "/.." : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (result.length > 0) {
            result += "/" + path.slice(lastSlash + 1, index2);
          } else {
            result = path.slice(lastSlash + 1, index2);
          }
          lastSegmentLength = index2 - lastSlash - 1;
        }
        lastSlash = index2;
        dots = 0;
      } else if (code2 === 46 && dots > -1) {
        dots++;
      } else {
        dots = -1;
      }
    }
    return result;
  }
  function assertPath$1(path) {
    if (typeof path !== "string") {
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(path)
      );
    }
  }
  const minproc = { cwd };
  function cwd() {
    return "/";
  }
  function isUrl(fileUrlOrPath) {
    return Boolean(
      fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
      fileUrlOrPath.auth === void 0
    );
  }
  function urlToPath(path) {
    if (typeof path === "string") {
      path = new URL(path);
    } else if (!isUrl(path)) {
      const error = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + path + "`"
      );
      error.code = "ERR_INVALID_ARG_TYPE";
      throw error;
    }
    if (path.protocol !== "file:") {
      const error = new TypeError("The URL must be of scheme file");
      error.code = "ERR_INVALID_URL_SCHEME";
      throw error;
    }
    return getPathFromURLPosix(path);
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      const error = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      error.code = "ERR_INVALID_FILE_URL_HOST";
      throw error;
    }
    const pathname = url.pathname;
    let index2 = -1;
    while (++index2 < pathname.length) {
      if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
        const third = pathname.codePointAt(index2 + 2);
        if (third === 70 || third === 102) {
          const error = new TypeError(
            "File URL path must not include encoded / characters"
          );
          error.code = "ERR_INVALID_FILE_URL_PATH";
          throw error;
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  const order = (
    /** @type {const} */
    [
      "history",
      "path",
      "basename",
      "stem",
      "extname",
      "dirname"
    ]
  );
  class VFile {
    /**
     * Create a new virtual file.
     *
     * `options` is treated as:
     *
     * *   `string` or `Uint8Array`  `{value: options}`
     * *   `URL`  `{path: options}`
     * *   `VFile`  shallow copies its data over to the new file
     * *   `object`  all fields are shallow copied over to the new file
     *
     * Path related fields are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * You cannot set `dirname` or `extname` without setting either `history`,
     * `path`, `basename`, or `stem` too.
     *
     * @param {Compatible | null | undefined} [value]
     *   File value.
     * @returns
     *   New instance.
     */
    constructor(value) {
      let options2;
      if (!value) {
        options2 = {};
      } else if (isUrl(value)) {
        options2 = { path: value };
      } else if (typeof value === "string" || isUint8Array$1(value)) {
        options2 = { value };
      } else {
        options2 = value;
      }
      this.cwd = "cwd" in options2 ? "" : minproc.cwd();
      this.data = {};
      this.history = [];
      this.messages = [];
      this.value;
      this.map;
      this.result;
      this.stored;
      let index2 = -1;
      while (++index2 < order.length) {
        const field2 = order[index2];
        if (field2 in options2 && options2[field2] !== void 0 && options2[field2] !== null) {
          this[field2] = field2 === "history" ? [...options2[field2]] : options2[field2];
        }
      }
      let field;
      for (field in options2) {
        if (!order.includes(field)) {
          this[field] = options2[field];
        }
      }
    }
    /**
     * Get the basename (including extname) (example: `'index.min.js'`).
     *
     * @returns {string | undefined}
     *   Basename.
     */
    get basename() {
      return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
    }
    /**
     * Set basename (including extname) (`'index.min.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} basename
     *   Basename.
     * @returns {undefined}
     *   Nothing.
     */
    set basename(basename2) {
      assertNonEmpty(basename2, "basename");
      assertPart(basename2, "basename");
      this.path = minpath.join(this.dirname || "", basename2);
    }
    /**
     * Get the parent path (example: `'~'`).
     *
     * @returns {string | undefined}
     *   Dirname.
     */
    get dirname() {
      return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
    }
    /**
     * Set the parent path (example: `'~'`).
     *
     * Cannot be set if theres no `path` yet.
     *
     * @param {string | undefined} dirname
     *   Dirname.
     * @returns {undefined}
     *   Nothing.
     */
    set dirname(dirname2) {
      assertPath(this.basename, "dirname");
      this.path = minpath.join(dirname2 || "", this.basename);
    }
    /**
     * Get the extname (including dot) (example: `'.js'`).
     *
     * @returns {string | undefined}
     *   Extname.
     */
    get extname() {
      return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
    }
    /**
     * Set the extname (including dot) (example: `'.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be set if theres no `path` yet.
     *
     * @param {string | undefined} extname
     *   Extname.
     * @returns {undefined}
     *   Nothing.
     */
    set extname(extname2) {
      assertPart(extname2, "extname");
      assertPath(this.dirname, "extname");
      if (extname2) {
        if (extname2.codePointAt(0) !== 46) {
          throw new Error("`extname` must start with `.`");
        }
        if (extname2.includes(".", 1)) {
          throw new Error("`extname` cannot contain multiple dots");
        }
      }
      this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
    }
    /**
     * Get the full path (example: `'~/index.min.js'`).
     *
     * @returns {string}
     *   Path.
     */
    get path() {
      return this.history[this.history.length - 1];
    }
    /**
     * Set the full path (example: `'~/index.min.js'`).
     *
     * Cannot be nullified.
     * You can set a file URL (a `URL` object with a `file:` protocol) which will
     * be turned into a path with `url.fileURLToPath`.
     *
     * @param {URL | string} path
     *   Path.
     * @returns {undefined}
     *   Nothing.
     */
    set path(path) {
      if (isUrl(path)) {
        path = urlToPath(path);
      }
      assertNonEmpty(path, "path");
      if (this.path !== path) {
        this.history.push(path);
      }
    }
    /**
     * Get the stem (basename w/o extname) (example: `'index.min'`).
     *
     * @returns {string | undefined}
     *   Stem.
     */
    get stem() {
      return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
    }
    /**
     * Set the stem (basename w/o extname) (example: `'index.min'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} stem
     *   Stem.
     * @returns {undefined}
     *   Nothing.
     */
    set stem(stem) {
      assertNonEmpty(stem, "stem");
      assertPart(stem, "stem");
      this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
    }
    // Normal prototypal methods.
    /**
     * Create a fatal message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `true` (error; file not usable)
     * and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {never}
     *   Never.
     * @throws {VFileMessage}
     *   Message.
     */
    fail(causeOrReason, optionsOrParentOrPlace, origin2) {
      const message = this.message(causeOrReason, optionsOrParentOrPlace, origin2);
      message.fatal = true;
      throw message;
    }
    /**
     * Create an info message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `undefined` (info; change
     * likely not needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    info(causeOrReason, optionsOrParentOrPlace, origin2) {
      const message = this.message(causeOrReason, optionsOrParentOrPlace, origin2);
      message.fatal = void 0;
      return message;
    }
    /**
     * Create a message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `false` (warning; change may be
     * needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    message(causeOrReason, optionsOrParentOrPlace, origin2) {
      const message = new VFileMessage(
        // @ts-expect-error: the overloads are fine.
        causeOrReason,
        optionsOrParentOrPlace,
        origin2
      );
      if (this.path) {
        message.name = this.path + ":" + message.name;
        message.file = this.path;
      }
      message.fatal = false;
      this.messages.push(message);
      return message;
    }
    /**
     * Serialize the file.
     *
     * > **Note**: which encodings are supported depends on the engine.
     * > For info on Node.js, see:
     * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
     *
     * @param {string | null | undefined} [encoding='utf8']
     *   Character encoding to understand `value` as when its a `Uint8Array`
     *   (default: `'utf-8'`).
     * @returns {string}
     *   Serialized file.
     */
    toString(encoding) {
      if (this.value === void 0) {
        return "";
      }
      if (typeof this.value === "string") {
        return this.value;
      }
      const decoder = new TextDecoder(encoding || void 0);
      return decoder.decode(this.value);
    }
  }
  function assertPart(part, name2) {
    if (part && part.includes(minpath.sep)) {
      throw new Error(
        "`" + name2 + "` cannot be a path: did not expect `" + minpath.sep + "`"
      );
    }
  }
  function assertNonEmpty(part, name2) {
    if (!part) {
      throw new Error("`" + name2 + "` cannot be empty");
    }
  }
  function assertPath(path, name2) {
    if (!path) {
      throw new Error("Setting `" + name2 + "` requires `path` to be set too");
    }
  }
  function isUint8Array$1(value) {
    return Boolean(
      value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
    );
  }
  const CallableInstance = (
    /**
     * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
     */
    /** @type {unknown} */
    /**
     * @this {Function}
     * @param {string | symbol} property
     * @returns {(...parameters: Array<unknown>) => unknown}
     */
    function(property) {
      const self2 = this;
      const constr = self2.constructor;
      const proto = (
        /** @type {Record<string | symbol, Function>} */
        // Prototypes do exist.
        // type-coverage:ignore-next-line
        constr.prototype
      );
      const value = proto[property];
      const apply = function() {
        return value.apply(apply, arguments);
      };
      Object.setPrototypeOf(apply, proto);
      return apply;
    }
  );
  const own = {}.hasOwnProperty;
  class Processor extends CallableInstance {
    /**
     * Create a processor.
     */
    constructor() {
      super("copy");
      this.Compiler = void 0;
      this.Parser = void 0;
      this.attachers = [];
      this.compiler = void 0;
      this.freezeIndex = -1;
      this.frozen = void 0;
      this.namespace = {};
      this.parser = void 0;
      this.transformers = trough();
    }
    /**
     * Copy a processor.
     *
     * @deprecated
     *   This is a private internal method and should not be used.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   New *unfrozen* processor ({@linkcode Processor}) that is
     *   configured to work the same as its ancestor.
     *   When the descendant processor is configured in the future it does not
     *   affect the ancestral processor.
     */
    copy() {
      const destination = (
        /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
        new Processor()
      );
      let index2 = -1;
      while (++index2 < this.attachers.length) {
        const attacher = this.attachers[index2];
        destination.use(...attacher);
      }
      destination.data(extend$2(true, {}, this.namespace));
      return destination;
    }
    /**
     * Configure the processor with info available to all plugins.
     * Information is stored in an object.
     *
     * Typically, options can be given to a specific plugin, but sometimes it
     * makes sense to have information shared with several plugins.
     * For example, a list of HTML elements that are self-closing, which is
     * needed during all phases.
     *
     * > **Note**: setting information cannot occur on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * > **Note**: to register custom data in TypeScript, augment the
     * > {@linkcode Data} interface.
     *
     * @example
     *   This example show how to get and set info:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   const processor = unified().data('alpha', 'bravo')
     *
     *   processor.data('alpha') // => 'bravo'
     *
     *   processor.data() // => {alpha: 'bravo'}
     *
     *   processor.data({charlie: 'delta'})
     *
     *   processor.data() // => {charlie: 'delta'}
     *   ```
     *
     * @template {keyof Data} Key
     *
     * @overload
     * @returns {Data}
     *
     * @overload
     * @param {Data} dataset
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Key} key
     * @returns {Data[Key]}
     *
     * @overload
     * @param {Key} key
     * @param {Data[Key]} value
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @param {Data | Key} [key]
     *   Key to get or set, or entire dataset to set, or nothing to get the
     *   entire dataset (optional).
     * @param {Data[Key]} [value]
     *   Value to set (optional).
     * @returns {unknown}
     *   The current processor when setting, the value at `key` when getting, or
     *   the entire dataset when getting without key.
     */
    data(key, value) {
      if (typeof key === "string") {
        if (arguments.length === 2) {
          assertUnfrozen("data", this.frozen);
          this.namespace[key] = value;
          return this;
        }
        return own.call(this.namespace, key) && this.namespace[key] || void 0;
      }
      if (key) {
        assertUnfrozen("data", this.frozen);
        this.namespace = key;
        return this;
      }
      return this.namespace;
    }
    /**
     * Freeze a processor.
     *
     * Frozen processors are meant to be extended and not to be configured
     * directly.
     *
     * When a processor is frozen it cannot be unfrozen.
     * New processors working the same way can be created by calling the
     * processor.
     *
     * Its possible to freeze processors explicitly by calling `.freeze()`.
     * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
     * `.stringify()`, `.process()`, or `.processSync()` are called.
     *
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   The current processor.
     */
    freeze() {
      if (this.frozen) {
        return this;
      }
      const self2 = (
        /** @type {Processor} */
        /** @type {unknown} */
        this
      );
      while (++this.freezeIndex < this.attachers.length) {
        const [attacher, ...options2] = this.attachers[this.freezeIndex];
        if (options2[0] === false) {
          continue;
        }
        if (options2[0] === true) {
          options2[0] = void 0;
        }
        const transformer = attacher.call(self2, ...options2);
        if (typeof transformer === "function") {
          this.transformers.use(transformer);
        }
      }
      this.frozen = true;
      this.freezeIndex = Number.POSITIVE_INFINITY;
      return this;
    }
    /**
     * Parse text to a syntax tree.
     *
     * > **Note**: `parse` freezes the processor if not already *frozen*.
     *
     * > **Note**: `parse` performs the parse phase, not the run phase or other
     * > phases.
     *
     * @param {Compatible | undefined} [file]
     *   file to parse (optional); typically `string` or `VFile`; any value
     *   accepted as `x` in `new VFile(x)`.
     * @returns {ParseTree extends undefined ? Node : ParseTree}
     *   Syntax tree representing `file`.
     */
    parse(file) {
      this.freeze();
      const realFile = vfile(file);
      const parser = this.parser || this.Parser;
      assertParser("parse", parser);
      return parser(String(realFile), realFile);
    }
    /**
     * Process the given file as configured on the processor.
     *
     * > **Note**: `process` freezes the processor if not already *frozen*.
     *
     * > **Note**: `process` performs the parse, run, and stringify phases.
     *
     * @overload
     * @param {Compatible | undefined} file
     * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
     * @returns {undefined}
     *
     * @overload
     * @param {Compatible | undefined} [file]
     * @returns {Promise<VFileWithOutput<CompileResult>>}
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`]; any value accepted as
     *   `x` in `new VFile(x)`.
     * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
     *   Callback (optional).
     * @returns {Promise<VFile> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise a promise, rejected with a fatal error or resolved with the
     *   processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    process(file, done) {
      const self2 = this;
      this.freeze();
      assertParser("process", this.parser || this.Parser);
      assertCompiler("process", this.compiler || this.Compiler);
      return done ? executor(void 0, done) : new Promise(executor);
      function executor(resolve, reject) {
        const realFile = vfile(file);
        const parseTree = (
          /** @type {HeadTree extends undefined ? Node : HeadTree} */
          /** @type {unknown} */
          self2.parse(realFile)
        );
        self2.run(parseTree, realFile, function(error, tree, file2) {
          if (error || !tree || !file2) {
            return realDone(error);
          }
          const compileTree = (
            /** @type {CompileTree extends undefined ? Node : CompileTree} */
            /** @type {unknown} */
            tree
          );
          const compileResult = self2.stringify(compileTree, file2);
          if (looksLikeAValue(compileResult)) {
            file2.value = compileResult;
          } else {
            file2.result = compileResult;
          }
          realDone(
            error,
            /** @type {VFileWithOutput<CompileResult>} */
            file2
          );
        });
        function realDone(error, file2) {
          if (error || !file2) {
            reject(error);
          } else if (resolve) {
            resolve(file2);
          } else {
            done(void 0, file2);
          }
        }
      }
    }
    /**
     * Process the given file as configured on the processor.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `processSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `processSync` performs the parse, run, and stringify phases.
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`; any value accepted as
     *   `x` in `new VFile(x)`.
     * @returns {VFileWithOutput<CompileResult>}
     *   The processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    processSync(file) {
      let complete = false;
      let result;
      this.freeze();
      assertParser("processSync", this.parser || this.Parser);
      assertCompiler("processSync", this.compiler || this.Compiler);
      this.process(file, realDone);
      assertDone("processSync", "process", complete);
      return result;
      function realDone(error, file2) {
        complete = true;
        bail(error);
        result = file2;
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * > **Note**: `run` freezes the processor if not already *frozen*.
     *
     * > **Note**: `run` performs the run phase, not other phases.
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} file
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} [file]
     * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {(
     *   RunCallback<TailTree extends undefined ? Node : TailTree> |
     *   Compatible
     * )} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
     *   Callback (optional).
     * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise, a promise rejected with a fatal error or resolved with the
     *   transformed tree.
     */
    run(tree, file, done) {
      assertNode(tree);
      this.freeze();
      const transformers = this.transformers;
      if (!done && typeof file === "function") {
        done = file;
        file = void 0;
      }
      return done ? executor(void 0, done) : new Promise(executor);
      function executor(resolve, reject) {
        const realFile = vfile(file);
        transformers.run(tree, realFile, realDone);
        function realDone(error, outputTree, file2) {
          const resultingTree = (
            /** @type {TailTree extends undefined ? Node : TailTree} */
            outputTree || tree
          );
          if (error) {
            reject(error);
          } else if (resolve) {
            resolve(resultingTree);
          } else {
            done(void 0, resultingTree, file2);
          }
        }
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `runSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `runSync` performs the run phase, not other phases.
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {TailTree extends undefined ? Node : TailTree}
     *   Transformed tree.
     */
    runSync(tree, file) {
      let complete = false;
      let result;
      this.run(tree, file, realDone);
      assertDone("runSync", "run", complete);
      return result;
      function realDone(error, tree2) {
        bail(error);
        result = tree2;
        complete = true;
      }
    }
    /**
     * Compile a syntax tree.
     *
     * > **Note**: `stringify` freezes the processor if not already *frozen*.
     *
     * > **Note**: `stringify` performs the stringify phase, not the run phase
     * > or other phases.
     *
     * @param {CompileTree extends undefined ? Node : CompileTree} tree
     *   Tree to compile.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {CompileResult extends undefined ? Value : CompileResult}
     *   Textual representation of the tree (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most compilers
     *   > return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    stringify(tree, file) {
      this.freeze();
      const realFile = vfile(file);
      const compiler2 = this.compiler || this.Compiler;
      assertCompiler("stringify", compiler2);
      assertNode(tree);
      return compiler2(tree, realFile);
    }
    /**
     * Configure the processor to use a plugin, a list of usable values, or a
     * preset.
     *
     * If the processor is already using a plugin, the previous plugin
     * configuration is changed based on the options that are passed in.
     * In other words, the plugin is not added a second time.
     *
     * > **Note**: `use` cannot be called on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * @example
     *   There are many ways to pass plugins to `.use()`.
     *   This example gives an overview:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   unified()
     *     // Plugin with options:
     *     .use(pluginA, {x: true, y: true})
     *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
     *     .use(pluginA, {y: false, z: true})
     *     // Plugins:
     *     .use([pluginB, pluginC])
     *     // Two plugins, the second with options:
     *     .use([pluginD, [pluginE, {}]])
     *     // Preset with plugins and settings:
     *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
     *     // Settings only:
     *     .use({settings: {position: false}})
     *   ```
     *
     * @template {Array<unknown>} [Parameters=[]]
     * @template {Node | string | undefined} [Input=undefined]
     * @template [Output=Input]
     *
     * @overload
     * @param {Preset | null | undefined} [preset]
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {PluggableList} list
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Plugin<Parameters, Input, Output>} plugin
     * @param {...(Parameters | [boolean])} parameters
     * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
     *
     * @param {PluggableList | Plugin | Preset | null | undefined} value
     *   Usable value.
     * @param {...unknown} parameters
     *   Parameters, when a plugin is given as a usable value.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   Current processor.
     */
    use(value, ...parameters) {
      const attachers = this.attachers;
      const namespace = this.namespace;
      assertUnfrozen("use", this.frozen);
      if (value === null || value === void 0) ;
      else if (typeof value === "function") {
        addPlugin(value, parameters);
      } else if (typeof value === "object") {
        if (Array.isArray(value)) {
          addList(value);
        } else {
          addPreset(value);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value + "`");
      }
      return this;
      function add(value2) {
        if (typeof value2 === "function") {
          addPlugin(value2, []);
        } else if (typeof value2 === "object") {
          if (Array.isArray(value2)) {
            const [plugin, ...parameters2] = (
              /** @type {PluginTuple<Array<unknown>>} */
              value2
            );
            addPlugin(plugin, parameters2);
          } else {
            addPreset(value2);
          }
        } else {
          throw new TypeError("Expected usable value, not `" + value2 + "`");
        }
      }
      function addPreset(result) {
        if (!("plugins" in result) && !("settings" in result)) {
          throw new Error(
            "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
          );
        }
        addList(result.plugins);
        if (result.settings) {
          namespace.settings = extend$2(true, namespace.settings, result.settings);
        }
      }
      function addList(plugins) {
        let index2 = -1;
        if (plugins === null || plugins === void 0) ;
        else if (Array.isArray(plugins)) {
          while (++index2 < plugins.length) {
            const thing = plugins[index2];
            add(thing);
          }
        } else {
          throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
        }
      }
      function addPlugin(plugin, parameters2) {
        let index2 = -1;
        let entryIndex = -1;
        while (++index2 < attachers.length) {
          if (attachers[index2][0] === plugin) {
            entryIndex = index2;
            break;
          }
        }
        if (entryIndex === -1) {
          attachers.push([plugin, ...parameters2]);
        } else if (parameters2.length > 0) {
          let [primary, ...rest] = parameters2;
          const currentPrimary = attachers[entryIndex][1];
          if (isPlainObject$2(currentPrimary) && isPlainObject$2(primary)) {
            primary = extend$2(true, currentPrimary, primary);
          }
          attachers[entryIndex] = [plugin, primary, ...rest];
        }
      }
    }
  }
  const unified = new Processor().freeze();
  function assertParser(name2, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name2 + "` without `parser`");
    }
  }
  function assertCompiler(name2, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name2 + "` without `compiler`");
    }
  }
  function assertUnfrozen(name2, frozen) {
    if (frozen) {
      throw new Error(
        "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
    }
  }
  function assertNode(node2) {
    if (!isPlainObject$2(node2) || typeof node2.type !== "string") {
      throw new TypeError("Expected node, got `" + node2 + "`");
    }
  }
  function assertDone(name2, asyncName, complete) {
    if (!complete) {
      throw new Error(
        "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
      );
    }
  }
  function vfile(value) {
    return looksLikeAVFile(value) ? value : new VFile(value);
  }
  function looksLikeAVFile(value) {
    return Boolean(
      value && typeof value === "object" && "message" in value && "messages" in value
    );
  }
  function looksLikeAValue(value) {
    return typeof value === "string" || isUint8Array(value);
  }
  function isUint8Array(value) {
    return Boolean(
      value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
    );
  }
  const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
  const emptyPlugins = [];
  const emptyRemarkRehypeOptions = { allowDangerousHtml: true };
  const safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
  const deprecations = [
    { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
    { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
    {
      from: "allowNode",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "allowElement"
    },
    {
      from: "allowedTypes",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "allowedElements"
    },
    { from: "className", id: "remove-classname" },
    {
      from: "disallowedTypes",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "disallowedElements"
    },
    { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
    { from: "includeElementIndex", id: "#remove-includeelementindex" },
    {
      from: "includeNodeIndex",
      id: "change-includenodeindex-to-includeelementindex"
    },
    { from: "linkTarget", id: "remove-linktarget" },
    { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
    { from: "rawSourcePos", id: "#remove-rawsourcepos" },
    { from: "renderers", id: "change-renderers-to-components", to: "components" },
    { from: "source", id: "change-source-to-children", to: "children" },
    { from: "sourcePos", id: "#remove-sourcepos" },
    { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
    { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
  ];
  function Markdown(options2) {
    const processor = createProcessor(options2);
    const file = createFile(options2);
    return post(processor.runSync(processor.parse(file), file), options2);
  }
  function createProcessor(options2) {
    const rehypePlugins = options2.rehypePlugins || emptyPlugins;
    const remarkPlugins = options2.remarkPlugins || emptyPlugins;
    const remarkRehypeOptions = options2.remarkRehypeOptions ? { ...options2.remarkRehypeOptions, ...emptyRemarkRehypeOptions } : emptyRemarkRehypeOptions;
    const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
    return processor;
  }
  function createFile(options2) {
    const children = options2.children || "";
    const file = new VFile();
    if (typeof children === "string") {
      file.value = children;
    }
    return file;
  }
  function post(tree, options2) {
    const allowedElements = options2.allowedElements;
    const allowElement = options2.allowElement;
    const components = options2.components;
    const disallowedElements = options2.disallowedElements;
    const skipHtml = options2.skipHtml;
    const unwrapDisallowed = options2.unwrapDisallowed;
    const urlTransform = options2.urlTransform || defaultUrlTransform;
    for (const deprecation of deprecations) {
      if (Object.hasOwn(options2, deprecation.from)) {
        unreachable(
          "Unexpected `" + deprecation.from + "` prop, " + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation.id + "> for more info)"
        );
      }
    }
    visit(tree, transform);
    return toJsxRuntime(tree, {
      Fragment: jsxRuntimeExports.Fragment,
      components,
      ignoreInvalidStyle: true,
      jsx: jsxRuntimeExports.jsx,
      jsxs: jsxRuntimeExports.jsxs,
      passKeys: true,
      passNode: true
    });
    function transform(node2, index2, parent) {
      if (node2.type === "raw" && parent && typeof index2 === "number") {
        if (skipHtml) {
          parent.children.splice(index2, 1);
        } else {
          parent.children[index2] = { type: "text", value: node2.value };
        }
        return index2;
      }
      if (node2.type === "element") {
        let key;
        for (key in urlAttributes) {
          if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node2.properties, key)) {
            const value = node2.properties[key];
            const test2 = urlAttributes[key];
            if (test2 === null || test2.includes(node2.tagName)) {
              node2.properties[key] = urlTransform(String(value || ""), key, node2);
            }
          }
        }
      }
      if (node2.type === "element") {
        let remove = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
        if (!remove && allowElement && typeof index2 === "number") {
          remove = !allowElement(node2, index2, parent);
        }
        if (remove && parent && typeof index2 === "number") {
          if (unwrapDisallowed && node2.children) {
            parent.children.splice(index2, 1, ...node2.children);
          } else {
            parent.children.splice(index2, 1);
          }
          return index2;
        }
      }
    }
  }
  function defaultUrlTransform(value) {
    const colon = value.indexOf(":");
    const questionMark = value.indexOf("?");
    const numberSign = value.indexOf("#");
    const slash = value.indexOf("/");
    if (
      // If there is no protocol, its relative.
      colon === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
      slash !== -1 && colon > slash || questionMark !== -1 && colon > questionMark || numberSign !== -1 && colon > numberSign || // It is a protocol, it should be allowed.
      safeProtocol.test(value.slice(0, colon))
    ) {
      return value;
    }
    return "";
  }
  var __create = Object.create;
  var __defProp2 = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all2) => {
    for (var name2 in all2)
      __defProp2(target, name2, { get: all2[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var require_prism = __commonJS({
    "../../node_modules/.pnpm/prismjs@1.29.0_patch_hash=vrxx3pzkik6jpmgpayxfjunetu/node_modules/prismjs/prism.js"(exports3, module2) {
      var Prism2 = function() {
        var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
        var uniqueId = 0;
        var plainTextGrammar = {};
        var _ = {
          /**
           * A namespace for utility methods.
           *
           * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
           * change or disappear at any time.
           *
           * @namespace
           * @memberof Prism
           */
          util: {
            encode: function encode2(tokens) {
              if (tokens instanceof Token) {
                return new Token(tokens.type, encode2(tokens.content), tokens.alias);
              } else if (Array.isArray(tokens)) {
                return tokens.map(encode2);
              } else {
                return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
              }
            },
            /**
             * Returns the name of the type of the given value.
             *
             * @param {any} o
             * @returns {string}
             * @example
             * type(null)      === 'Null'
             * type(undefined) === 'Undefined'
             * type(123)       === 'Number'
             * type('foo')     === 'String'
             * type(true)      === 'Boolean'
             * type([1, 2])    === 'Array'
             * type({})        === 'Object'
             * type(String)    === 'Function'
             * type(/abc+/)    === 'RegExp'
             */
            type: function(o) {
              return Object.prototype.toString.call(o).slice(8, -1);
            },
            /**
             * Returns a unique number for the given object. Later calls will still return the same number.
             *
             * @param {Object} obj
             * @returns {number}
             */
            objId: function(obj) {
              if (!obj["__id"]) {
                Object.defineProperty(obj, "__id", { value: ++uniqueId });
              }
              return obj["__id"];
            },
            /**
             * Creates a deep clone of the given object.
             *
             * The main intended use of this function is to clone language definitions.
             *
             * @param {T} o
             * @param {Record<number, any>} [visited]
             * @returns {T}
             * @template T
             */
            clone: function deepClone(o, visited) {
              visited = visited || {};
              var clone;
              var id2;
              switch (_.util.type(o)) {
                case "Object":
                  id2 = _.util.objId(o);
                  if (visited[id2]) {
                    return visited[id2];
                  }
                  clone = /** @type {Record<string, any>} */
                  {};
                  visited[id2] = clone;
                  for (var key in o) {
                    if (o.hasOwnProperty(key)) {
                      clone[key] = deepClone(o[key], visited);
                    }
                  }
                  return (
                    /** @type {any} */
                    clone
                  );
                case "Array":
                  id2 = _.util.objId(o);
                  if (visited[id2]) {
                    return visited[id2];
                  }
                  clone = [];
                  visited[id2] = clone;
                  o.forEach(function(v, i) {
                    clone[i] = deepClone(v, visited);
                  });
                  return (
                    /** @type {any} */
                    clone
                  );
                default:
                  return o;
              }
            },
            /**
             * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
             *
             * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
             *
             * @param {Element} element
             * @returns {string}
             */
            getLanguage: function(element2) {
              while (element2) {
                var m2 = lang.exec(element2.className);
                if (m2) {
                  return m2[1].toLowerCase();
                }
                element2 = element2.parentElement;
              }
              return "none";
            },
            /**
             * Sets the Prism `language-xxxx` class of the given element.
             *
             * @param {Element} element
             * @param {string} language
             * @returns {void}
             */
            setLanguage: function(element2, language) {
              element2.className = element2.className.replace(RegExp(lang, "gi"), "");
              element2.classList.add("language-" + language);
            },
            /**
             * Returns whether a given class is active for `element`.
             *
             * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
             * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
             * given class is just the given class with a `no-` prefix.
             *
             * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
             * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
             * ancestors have the given class or the negated version of it, then the default activation will be returned.
             *
             * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
             * version of it, the class is considered active.
             *
             * @param {Element} element
             * @param {string} className
             * @param {boolean} [defaultActivation=false]
             * @returns {boolean}
             */
            isActive: function(element2, className, defaultActivation) {
              var no = "no-" + className;
              while (element2) {
                var classList = element2.classList;
                if (classList.contains(className)) {
                  return true;
                }
                if (classList.contains(no)) {
                  return false;
                }
                element2 = element2.parentElement;
              }
              return !!defaultActivation;
            }
          },
          /**
           * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
           *
           * @namespace
           * @memberof Prism
           * @public
           */
          languages: {
            /**
             * The grammar for plain, unformatted text.
             */
            plain: plainTextGrammar,
            plaintext: plainTextGrammar,
            text: plainTextGrammar,
            txt: plainTextGrammar,
            /**
             * Creates a deep copy of the language with the given id and appends the given tokens.
             *
             * If a token in `redef` also appears in the copied language, then the existing token in the copied language
             * will be overwritten at its original position.
             *
             * ## Best practices
             *
             * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
             * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
             * understand the language definition because, normally, the order of tokens matters in Prism grammars.
             *
             * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
             * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
             *
             * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
             * @param {Grammar} redef The new tokens to append.
             * @returns {Grammar} The new language created.
             * @public
             * @example
             * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
             *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
             *     // at its original position
             *     'comment': { ... },
             *     // CSS doesn't have a 'color' token, so this token will be appended
             *     'color': /\b(?:red|green|blue)\b/
             * });
             */
            extend: function(id2, redef) {
              var lang2 = _.util.clone(_.languages[id2]);
              for (var key in redef) {
                lang2[key] = redef[key];
              }
              return lang2;
            },
            /**
             * Inserts tokens _before_ another token in a language definition or any other grammar.
             *
             * ## Usage
             *
             * This helper method makes it easy to modify existing languages. For example, the CSS language definition
             * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
             * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
             * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
             * this:
             *
             * ```js
             * Prism.languages.markup.style = {
             *     // token
             * };
             * ```
             *
             * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
             * before existing tokens. For the CSS example above, you would use it like this:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'cdata', {
             *     'style': {
             *         // token
             *     }
             * });
             * ```
             *
             * ## Special cases
             *
             * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
             * will be ignored.
             *
             * This behavior can be used to insert tokens after `before`:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'comment', {
             *     'comment': Prism.languages.markup.comment,
             *     // tokens after 'comment'
             * });
             * ```
             *
             * ## Limitations
             *
             * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
             * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
             * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
             * deleting properties which is necessary to insert at arbitrary positions.
             *
             * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
             * Instead, it will create a new object and replace all references to the target object with the new one. This
             * can be done without temporarily deleting properties, so the iteration order is well-defined.
             *
             * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
             * you hold the target object in a variable, then the value of the variable will not change.
             *
             * ```js
             * var oldMarkup = Prism.languages.markup;
             * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
             *
             * assert(oldMarkup !== Prism.languages.markup);
             * assert(newMarkup === Prism.languages.markup);
             * ```
             *
             * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
             * object to be modified.
             * @param {string} before The key to insert before.
             * @param {Grammar} insert An object containing the key-value pairs to be inserted.
             * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
             * object to be modified.
             *
             * Defaults to `Prism.languages`.
             * @returns {Grammar} The new grammar object.
             * @public
             */
            insertBefore: function(inside, before, insert, root2) {
              root2 = root2 || /** @type {any} */
              _.languages;
              var grammar = root2[inside];
              var ret = {};
              for (var token in grammar) {
                if (grammar.hasOwnProperty(token)) {
                  if (token == before) {
                    for (var newToken in insert) {
                      if (insert.hasOwnProperty(newToken)) {
                        ret[newToken] = insert[newToken];
                      }
                    }
                  }
                  if (!insert.hasOwnProperty(token)) {
                    ret[token] = grammar[token];
                  }
                }
              }
              var old = root2[inside];
              root2[inside] = ret;
              _.languages.DFS(_.languages, function(key, value) {
                if (value === old && key != inside) {
                  this[key] = ret;
                }
              });
              return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o, callback, type, visited) {
              visited = visited || {};
              var objId = _.util.objId;
              for (var i in o) {
                if (o.hasOwnProperty(i)) {
                  callback.call(o, i, o[i], type || i);
                  var property = o[i];
                  var propertyType = _.util.type(property);
                  if (propertyType === "Object" && !visited[objId(property)]) {
                    visited[objId(property)] = true;
                    DFS(property, callback, null, visited);
                  } else if (propertyType === "Array" && !visited[objId(property)]) {
                    visited[objId(property)] = true;
                    DFS(property, callback, i, visited);
                  }
                }
              }
            }
          },
          plugins: {},
          /**
           * Low-level function, only use if you know what youre doing. It accepts a string of text as input
           * and the language definitions to use, and returns a string with the HTML produced.
           *
           * The following hooks will be run:
           * 1. `before-tokenize`
           * 2. `after-tokenize`
           * 3. `wrap`: On each {@link Token}.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @param {string} language The name of the language definition passed to `grammar`.
           * @returns {string} The highlighted HTML.
           * @memberof Prism
           * @public
           * @example
           * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
           */
          highlight: function(text2, grammar, language) {
            var env2 = {
              code: text2,
              grammar,
              language
            };
            _.hooks.run("before-tokenize", env2);
            if (!env2.grammar) {
              throw new Error('The language "' + env2.language + '" has no grammar.');
            }
            env2.tokens = _.tokenize(env2.code, env2.grammar);
            _.hooks.run("after-tokenize", env2);
            return Token.stringify(_.util.encode(env2.tokens), env2.language);
          },
          /**
           * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
           * and the language definitions to use, and returns an array with the tokenized code.
           *
           * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
           *
           * This method could be useful in other contexts as well, as a very crude parser.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @returns {TokenStream} An array of strings and tokens, a token stream.
           * @memberof Prism
           * @public
           * @example
           * let code = `var foo = 0;`;
           * let tokens = Prism.tokenize(code, Prism.languages.javascript);
           * tokens.forEach(token => {
           *     if (token instanceof Prism.Token && token.type === 'number') {
           *         console.log(`Found numeric literal: ${token.content}`);
           *     }
           * });
           */
          tokenize: function(text2, grammar) {
            var rest = grammar.rest;
            if (rest) {
              for (var token in rest) {
                grammar[token] = rest[token];
              }
              delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text2);
            matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
            return toArray2(tokenList);
          },
          /**
           * @namespace
           * @memberof Prism
           * @public
           */
          hooks: {
            all: {},
            /**
             * Adds the given callback to the list of callbacks for the given hook.
             *
             * The callback will be invoked when the hook it is registered for is run.
             * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
             *
             * One callback function can be registered to multiple hooks and the same hook multiple times.
             *
             * @param {string} name The name of the hook.
             * @param {HookCallback} callback The callback function which is given environment variables.
             * @public
             */
            add: function(name2, callback) {
              var hooks2 = _.hooks.all;
              hooks2[name2] = hooks2[name2] || [];
              hooks2[name2].push(callback);
            },
            /**
             * Runs a hook invoking all registered callbacks with the given environment variables.
             *
             * Callbacks will be invoked synchronously and in the order in which they were registered.
             *
             * @param {string} name The name of the hook.
             * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
             * @public
             */
            run: function(name2, env2) {
              var callbacks = _.hooks.all[name2];
              if (!callbacks || !callbacks.length) {
                return;
              }
              for (var i = 0, callback; callback = callbacks[i++]; ) {
                callback(env2);
              }
            }
          },
          Token
        };
        function Token(type, content2, alias, matchedStr) {
          this.type = type;
          this.content = content2;
          this.alias = alias;
          this.length = (matchedStr || "").length | 0;
        }
        Token.stringify = function stringify2(o, language) {
          if (typeof o == "string") {
            return o;
          }
          if (Array.isArray(o)) {
            var s = "";
            o.forEach(function(e) {
              s += stringify2(e, language);
            });
            return s;
          }
          var env2 = {
            type: o.type,
            content: stringify2(o.content, language),
            tag: "span",
            classes: ["token", o.type],
            attributes: {},
            language
          };
          var aliases = o.alias;
          if (aliases) {
            if (Array.isArray(aliases)) {
              Array.prototype.push.apply(env2.classes, aliases);
            } else {
              env2.classes.push(aliases);
            }
          }
          _.hooks.run("wrap", env2);
          var attributes = "";
          for (var name2 in env2.attributes) {
            attributes += " " + name2 + '="' + (env2.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
          }
          return "<" + env2.tag + ' class="' + env2.classes.join(" ") + '"' + attributes + ">" + env2.content + "</" + env2.tag + ">";
        };
        function matchPattern(pattern, pos, text2, lookbehind) {
          pattern.lastIndex = pos;
          var match = pattern.exec(text2);
          if (match && lookbehind && match[1]) {
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
          }
          return match;
        }
        function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
          for (var token in grammar) {
            if (!grammar.hasOwnProperty(token) || !grammar[token]) {
              continue;
            }
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            for (var j = 0; j < patterns.length; ++j) {
              if (rematch && rematch.cause == token + "," + j) {
                return;
              }
              var patternObj = patterns[j];
              var inside = patternObj.inside;
              var lookbehind = !!patternObj.lookbehind;
              var greedy = !!patternObj.greedy;
              var alias = patternObj.alias;
              if (greedy && !patternObj.pattern.global) {
                var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
              }
              var pattern = patternObj.pattern || patternObj;
              for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
                if (rematch && pos >= rematch.reach) {
                  break;
                }
                var str = currentNode.value;
                if (tokenList.length > text2.length) {
                  return;
                }
                if (str instanceof Token) {
                  continue;
                }
                var removeCount = 1;
                var match;
                if (greedy) {
                  match = matchPattern(pattern, pos, text2, lookbehind);
                  if (!match || match.index >= text2.length) {
                    break;
                  }
                  var from = match.index;
                  var to = match.index + match[0].length;
                  var p = pos;
                  p += currentNode.value.length;
                  while (from >= p) {
                    currentNode = currentNode.next;
                    p += currentNode.value.length;
                  }
                  p -= currentNode.value.length;
                  pos = p;
                  if (currentNode.value instanceof Token) {
                    continue;
                  }
                  for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                    removeCount++;
                    p += k.value.length;
                  }
                  removeCount--;
                  str = text2.slice(pos, p);
                  match.index -= pos;
                } else {
                  match = matchPattern(pattern, 0, str, lookbehind);
                  if (!match) {
                    continue;
                  }
                }
                var from = match.index;
                var matchStr = match[0];
                var before = str.slice(0, from);
                var after = str.slice(from + matchStr.length);
                var reach = pos + str.length;
                if (rematch && reach > rematch.reach) {
                  rematch.reach = reach;
                }
                var removeFrom = currentNode.prev;
                if (before) {
                  removeFrom = addAfter(tokenList, removeFrom, before);
                  pos += before.length;
                }
                removeRange(tokenList, removeFrom, removeCount);
                var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                currentNode = addAfter(tokenList, removeFrom, wrapped);
                if (after) {
                  addAfter(tokenList, currentNode, after);
                }
                if (removeCount > 1) {
                  var nestedRematch = {
                    cause: token + "," + j,
                    reach
                  };
                  matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                  if (rematch && nestedRematch.reach > rematch.reach) {
                    rematch.reach = nestedRematch.reach;
                  }
                }
              }
            }
          }
        }
        function LinkedList() {
          var head = { value: null, prev: null, next: null };
          var tail = { value: null, prev: head, next: null };
          head.next = tail;
          this.head = head;
          this.tail = tail;
          this.length = 0;
        }
        function addAfter(list2, node2, value) {
          var next = node2.next;
          var newNode = { value, prev: node2, next };
          node2.next = newNode;
          next.prev = newNode;
          list2.length++;
          return newNode;
        }
        function removeRange(list2, node2, count2) {
          var next = node2.next;
          for (var i = 0; i < count2 && next !== list2.tail; i++) {
            next = next.next;
          }
          node2.next = next;
          next.prev = node2;
          list2.length -= i;
        }
        function toArray2(list2) {
          var array = [];
          var node2 = list2.head.next;
          while (node2 !== list2.tail) {
            array.push(node2.value);
            node2 = node2.next;
          }
          return array;
        }
        return _;
      }();
      module2.exports = Prism2;
      Prism2.default = Prism2;
    }
  });
  var Prism = __toESM(require_prism());
  Prism.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: true }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e) {
    "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", { value: function(e, n) {
    var t = {}, t = (t["language-" + n] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: Prism.languages[n] }, t.cdata = /^<!\[CDATA\[|\]\]>$/i, { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: t } }), n = (t["language-" + n] = { pattern: /[\s\S]+/, inside: Prism.languages[n] }, {});
    n[e] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
      return e;
    }), "i"), lookbehind: true, greedy: true, inside: t }, Prism.languages.insertBefore("markup", "cdata", n);
  } }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", { value: function(e, n) {
    Prism.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [n, "language-" + n], inside: Prism.languages[n] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
  } }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml, function(e) {
    var n = { pattern: /\\[\\(){}[\]^$+*?|.]/, alias: "escape" }, t = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, a = "(?:[^\\\\-]|" + t.source + ")", a = RegExp(a + "-" + a), r2 = { pattern: /(<|')[^<>']+(?=[>']$)/, lookbehind: true, alias: "variable" };
    e.languages.regex = { "char-class": { pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/, lookbehind: true, inside: { "char-class-negation": { pattern: /(^\[)\^/, lookbehind: true, alias: "operator" }, "char-class-punctuation": { pattern: /^\[|\]$/, alias: "punctuation" }, range: { pattern: a, inside: { escape: t, "range-punctuation": { pattern: /-/, alias: "operator" } } }, "special-escape": n, "char-set": { pattern: /\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, escape: t } }, "special-escape": n, "char-set": { pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, backreference: [{ pattern: /\\(?![123][0-7]{2})[1-9]/, alias: "keyword" }, { pattern: /\\k<[^<>']+>/, alias: "keyword", inside: { "group-name": r2 } }], anchor: { pattern: /[$^]|\\[ABbGZz]/, alias: "function" }, escape: t, group: [{ pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/, alias: "punctuation", inside: { "group-name": r2 } }, { pattern: /\)/, alias: "punctuation" }], quantifier: { pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/, alias: "number" }, alternation: { pattern: /\|/, alias: "keyword" } };
  }(Prism), Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.javascript = Prism.languages.extend("clike", { "class-name": [Prism.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: true }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: true }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: { pattern: RegExp(/(^|[^\w$])/.source + "(?:" + /NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source + ")" + /(?![\w$])/.source), lookbehind: true }, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", { regex: { pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source), lookbehind: true, greedy: true, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: true, alias: "language-regex", inside: Prism.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: true, inside: Prism.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), Prism.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: true, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } }, "string-property": { pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m, lookbehind: true, greedy: true, alias: "property" } }), Prism.languages.insertBefore("javascript", "operator", { "literal-property": { pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m, lookbehind: true, alias: "property" } }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), Prism.languages.js = Prism.languages.javascript, Prism.languages.actionscript = Prism.languages.extend("javascript", { keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/, operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/ }), Prism.languages.actionscript["class-name"].alias = "function", delete Prism.languages.actionscript.parameter, delete Prism.languages.actionscript["literal-property"], Prism.languages.markup && Prism.languages.insertBefore("actionscript", "string", { xml: { pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/, lookbehind: true, inside: Prism.languages.markup } }), function(e) {
    var n = /#(?!\{).+/, t = { pattern: /#\{[^}]+\}/, alias: "variable" };
    e.languages.coffeescript = e.languages.extend("javascript", { comment: n, string: [{ pattern: /'(?:\\[\s\S]|[^\\'])*'/, greedy: true }, { pattern: /"(?:\\[\s\S]|[^\\"])*"/, greedy: true, inside: { interpolation: t } }], keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/, "class-member": { pattern: /@(?!\d)\w+/, alias: "variable" } }), e.languages.insertBefore("coffeescript", "comment", { "multiline-comment": { pattern: /###[\s\S]+?###/, alias: "comment" }, "block-regex": { pattern: /\/{3}[\s\S]*?\/{3}/, alias: "regex", inside: { comment: n, interpolation: t } } }), e.languages.insertBefore("coffeescript", "string", { "inline-javascript": { pattern: /`(?:\\[\s\S]|[^\\`])*`/, inside: { delimiter: { pattern: /^`|`$/, alias: "punctuation" }, script: { pattern: /[\s\S]+/, alias: "language-javascript", inside: e.languages.javascript } } }, "multiline-string": [{ pattern: /'''[\s\S]*?'''/, greedy: true, alias: "string" }, { pattern: /"""[\s\S]*?"""/, greedy: true, alias: "string", inside: { interpolation: t } }] }), e.languages.insertBefore("coffeescript", "keyword", { property: /(?!\d)\w+(?=\s*:(?!:))/ }), delete e.languages.coffeescript["template-string"], e.languages.coffee = e.languages.coffeescript;
  }(Prism), function(l) {
    var e = l.languages.javadoclike = { parameter: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m, lookbehind: true }, keyword: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m, lookbehind: true }, punctuation: /[{}]/ };
    Object.defineProperty(e, "addSupport", { value: function(e2, o) {
      (e2 = "string" == typeof e2 ? [e2] : e2).forEach(function(e3) {
        var n = function(e4) {
          e4.inside || (e4.inside = {}), e4.inside.rest = o;
        }, t = "doc-comment";
        if (a = l.languages[e3]) {
          var a, r2 = a[t];
          if ((r2 = r2 ? r2 : (a = l.languages.insertBefore(e3, "comment", { "doc-comment": { pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/, lookbehind: true, alias: "comment" } }))[t]) instanceof RegExp && (r2 = a[t] = { pattern: r2 }), Array.isArray(r2))
            for (var s = 0, i = r2.length; s < i; s++)
              r2[s] instanceof RegExp && (r2[s] = { pattern: r2[s] }), n(r2[s]);
          else
            n(r2);
        }
      });
    } }), e.addSupport(["java", "javascript", "php"], e);
  }(Prism), function(e) {
    var n = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/, n = (e.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + n.source + ")*?" + /(?:;|(?=\s*\{))/.source), inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: true, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: true } } }, url: { pattern: RegExp("\\burl\\((?:" + n.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: true, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + n.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + n.source + ")*(?=\\s*\\{)"), lookbehind: true }, string: { pattern: n, greedy: true }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: true }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: true }, punctuation: /[(){};:,]/ }, e.languages.css.atrule.inside.rest = e.languages.css, e.languages.markup);
    n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
  }(Prism), function(e) {
    var n = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, n = (e.languages.css.selector = { pattern: e.languages.css.selector.pattern, lookbehind: true, inside: n = { "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/, "pseudo-class": /:[-\w]+/, class: /\.[-\w]+/, id: /#[-\w]+/, attribute: { pattern: RegExp(`\\[(?:[^[\\]"']|` + n.source + ")*\\]"), greedy: true, inside: { punctuation: /^\[|\]$/, "case-sensitivity": { pattern: /(\s)[si]$/i, lookbehind: true, alias: "keyword" }, namespace: { pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/, lookbehind: true, inside: { punctuation: /\|$/ } }, "attr-name": { pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/, lookbehind: true }, "attr-value": [n, { pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/, lookbehind: true }], operator: /[|~*^$]?=/ } }, "n-th": [{ pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/, lookbehind: true, inside: { number: /[\dn]+/, operator: /[+-]/ } }, { pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i, lookbehind: true }], combinator: />|\+|~|\|\|/, punctuation: /[(),]/ } }, e.languages.css.atrule.inside["selector-function-argument"].inside = n, e.languages.insertBefore("css", "property", { variable: { pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i, lookbehind: true } }), { pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/, lookbehind: true }), t = { pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/, lookbehind: true };
    e.languages.insertBefore("css", "function", { operator: { pattern: /(\s)[+\-*\/](?=\s)/, lookbehind: true }, hexcode: { pattern: /\B#[\da-f]{3,8}\b/i, alias: "color" }, color: [{ pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i, lookbehind: true }, { pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i, inside: { unit: n, number: t, function: /[\w-]+(?=\()/, punctuation: /[(),]/ } }], entity: /\\[\da-f]{1,8}/i, unit: n, number: t });
  }(Prism), function(e) {
    var n = /[*&][^\s[\]{},]+/, t = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, a = "(?:" + t.source + "(?:[ 	]+" + n.source + ")?|" + n.source + "(?:[ 	]+" + t.source + ")?)", r2 = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
      return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
    }), s = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
    function i(e2, n2) {
      n2 = (n2 || "").replace(/m/g, "") + "m";
      var t2 = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
        return a;
      }).replace(/<<value>>/g, function() {
        return e2;
      });
      return RegExp(t2, n2);
    }
    e.languages.yaml = { scalar: { pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
      return a;
    })), lookbehind: true, alias: "string" }, comment: /#.*/, key: { pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
      return a;
    }).replace(/<<key>>/g, function() {
      return "(?:" + r2 + "|" + s + ")";
    })), lookbehind: true, greedy: true, alias: "atrule" }, directive: { pattern: /(^[ \t]*)%.+/m, lookbehind: true, alias: "important" }, datetime: { pattern: i(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source), lookbehind: true, alias: "number" }, boolean: { pattern: i(/false|true/.source, "i"), lookbehind: true, alias: "important" }, null: { pattern: i(/null|~/.source, "i"), lookbehind: true, alias: "important" }, string: { pattern: i(s), lookbehind: true, greedy: true }, number: { pattern: i(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"), lookbehind: true }, tag: t, important: n, punctuation: /---|[:[\]{}\-,|>?]|\.\.\./ }, e.languages.yml = e.languages.yaml;
  }(Prism), function(o) {
    var n = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    function e(e2) {
      return e2 = e2.replace(/<inner>/g, function() {
        return n;
      }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + e2 + ")");
    }
    var t = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, a = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
      return t;
    }), r2 = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source, l = (o.languages.markdown = o.languages.extend("markup", {}), o.languages.insertBefore("markdown", "prolog", { "front-matter-block": { pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/, lookbehind: true, greedy: true, inside: { punctuation: /^---|---$/, "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: o.languages.yaml } } }, blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, table: { pattern: RegExp("^" + a + r2 + "(?:" + a + ")*", "m"), inside: { "table-data-rows": { pattern: RegExp("^(" + a + r2 + ")(?:" + a + ")*$"), lookbehind: true, inside: { "table-data": { pattern: RegExp(t), inside: o.languages.markdown }, punctuation: /\|/ } }, "table-line": { pattern: RegExp("^(" + a + ")" + r2 + "$"), lookbehind: true, inside: { punctuation: /\||:?-{3,}:?/ } }, "table-header-row": { pattern: RegExp("^" + a + "$"), inside: { "table-header": { pattern: RegExp(t), alias: "important", inside: o.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: true, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: true, inside: { "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: true }, "code-language": { pattern: /^(```).+/, lookbehind: true }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#.+/m, lookbehind: true, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: true, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: true, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: true }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: e(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: true, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: e(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: true, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: e(/(~~?)(?:(?!~)<inner>)+\2/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: true, inside: {} }, punctuation: /~~?/ } }, "code-snippet": { pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/, lookbehind: true, greedy: true, alias: ["code", "keyword"] }, url: { pattern: e(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source), lookbehind: true, greedy: true, inside: { operator: /^!/, content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: true, inside: {} }, variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: true }, url: { pattern: /(^\]\()[^\s)]+/, lookbehind: true }, string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: true } } } }), ["url", "bold", "italic", "strike"].forEach(function(n2) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(e2) {
        n2 !== e2 && (o.languages.markdown[n2].inside.content.inside[e2] = o.languages.markdown[e2]);
      });
    }), o.hooks.add("after-tokenize", function(e2) {
      "markdown" !== e2.language && "md" !== e2.language || !function e3(n2) {
        if (n2 && "string" != typeof n2)
          for (var t2 = 0, a2 = n2.length; t2 < a2; t2++) {
            var r22, s = n2[t2];
            "code" !== s.type ? e3(s.content) : (r22 = s.content[1], s = s.content[3], r22 && s && "code-language" === r22.type && "code-block" === s.type && "string" == typeof r22.content && (r22 = r22.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp"), r22 = "language-" + (r22 = (/[a-z][\w-]*/i.exec(r22) || [""])[0].toLowerCase()), s.alias ? "string" == typeof s.alias ? s.alias = [s.alias, r22] : s.alias.push(r22) : s.alias = [r22]));
          }
      }(e2.tokens);
    }), o.hooks.add("wrap", function(e2) {
      if ("code-block" === e2.type) {
        for (var n2 = "", t2 = 0, a2 = e2.classes.length; t2 < a2; t2++) {
          var r22 = e2.classes[t2], r22 = /language-(.+)/.exec(r22);
          if (r22) {
            n2 = r22[1];
            break;
          }
        }
        var s, i = o.languages[n2];
        i ? e2.content = o.highlight(function(e3) {
          e3 = e3.replace(l, "");
          return e3 = e3.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(e4, n3) {
            var t3;
            return "#" === (n3 = n3.toLowerCase())[0] ? (t3 = "x" === n3[1] ? parseInt(n3.slice(2), 16) : Number(n3.slice(1)), c(t3)) : u[n3] || e4;
          });
        }(e2.content), i, n2) : n2 && "none" !== n2 && o.plugins.autoloader && (s = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(1e16 * Math.random()), e2.attributes.id = s, o.plugins.autoloader.loadLanguages(n2, function() {
          var e3 = document.getElementById(s);
          e3 && (e3.innerHTML = o.highlight(e3.textContent, o.languages[n2], n2));
        }));
      }
    }), RegExp(o.languages.markup.tag.pattern.source, "gi")), u = { amp: "&", lt: "<", gt: ">", quot: '"' }, c = String.fromCodePoint || String.fromCharCode;
    o.languages.md = o.languages.markdown;
  }(Prism), Prism.languages.graphql = { comment: /#.*/, description: { pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i, greedy: true, alias: "string", inside: { "language-markdown": { pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/, lookbehind: true, inside: Prism.languages.markdown } } }, string: { pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/, greedy: true }, number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, boolean: /\b(?:false|true)\b/, variable: /\$[a-z_]\w*/i, directive: { pattern: /@[a-z_]\w*/i, alias: "function" }, "attr-name": { pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i, greedy: true }, "atom-input": { pattern: /\b[A-Z]\w*Input\b/, alias: "class-name" }, scalar: /\b(?:Boolean|Float|ID|Int|String)\b/, constant: /\b[A-Z][A-Z_\d]*\b/, "class-name": { pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/, lookbehind: true }, fragment: { pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-mutation": { pattern: /(\bmutation\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-query": { pattern: /(\bquery\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/, operator: /[!=|&]|\.{3}/, "property-query": /\w+(?=\s*\()/, object: /\w+(?=\s*\{)/, punctuation: /[!(){}\[\]:=,]/, property: /\w+/ }, Prism.hooks.add("after-tokenize", function(e) {
    if ("graphql" === e.language)
      for (var i = e.tokens.filter(function(e2) {
        return "string" != typeof e2 && "comment" !== e2.type && "scalar" !== e2.type;
      }), o = 0; o < i.length; ) {
        var n = i[o++];
        if ("keyword" === n.type && "mutation" === n.content) {
          var t = [];
          if (p(["definition-mutation", "punctuation"]) && "(" === c(1).content) {
            o += 2;
            var a = d(/^\($/, /^\)$/);
            if (-1 === a)
              continue;
            for (; o < a; o++) {
              var r2 = c(0);
              "variable" === r2.type && (g(r2, "variable-input"), t.push(r2.content));
            }
            o = a + 1;
          }
          if (p(["punctuation", "property-query"]) && "{" === c(0).content && (o++, g(c(0), "property-mutation"), 0 < t.length)) {
            var s = d(/^\{$/, /^\}$/);
            if (-1 !== s)
              for (var l = o; l < s; l++) {
                var u = i[l];
                "variable" === u.type && 0 <= t.indexOf(u.content) && g(u, "variable-input");
              }
          }
        }
      }
    function c(e2) {
      return i[o + e2];
    }
    function p(e2, n2) {
      n2 = n2 || 0;
      for (var t2 = 0; t2 < e2.length; t2++) {
        var a2 = c(t2 + n2);
        if (!a2 || a2.type !== e2[t2])
          return;
      }
      return 1;
    }
    function d(e2, n2) {
      for (var t2 = 1, a2 = o; a2 < i.length; a2++) {
        var r22 = i[a2], s2 = r22.content;
        if ("punctuation" === r22.type && "string" == typeof s2) {
          if (e2.test(s2))
            t2++;
          else if (n2.test(s2) && 0 === --t2)
            return a2;
        }
      }
      return -1;
    }
    function g(e2, n2) {
      var t2 = e2.alias;
      t2 ? Array.isArray(t2) || (e2.alias = t2 = [t2]) : e2.alias = t2 = [], t2.push(n2);
    }
  }), Prism.languages.sql = { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: true }, variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: true }, /@[\w.$]+/], string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: true, lookbehind: true }, identifier: { pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/, greedy: true, lookbehind: true, inside: { punctuation: /^`|`$/ } }, function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i, boolean: /\b(?:FALSE|NULL|TRUE)\b/i, number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i, operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i, punctuation: /[;[\]()`,.]/ }, function(b) {
    var e = b.languages.javascript["template-string"], t = e.pattern.source, m2 = e.inside.interpolation, f = m2.inside["interpolation-punctuation"], s = m2.pattern.source;
    function n(e2, n2) {
      if (b.languages[e2])
        return { pattern: RegExp("((?:" + n2 + ")\\s*)" + t), lookbehind: true, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, "embedded-code": { pattern: /[\s\S]+/, alias: e2 } } };
    }
    function h(e2, n2, t2) {
      e2 = { code: e2, grammar: n2, language: t2 };
      return b.hooks.run("before-tokenize", e2), e2.tokens = b.tokenize(e2.code, e2.grammar), b.hooks.run("after-tokenize", e2), e2.tokens;
    }
    function l(a2, e2, r2) {
      var n2 = b.tokenize(a2, { interpolation: { pattern: RegExp(s), lookbehind: true } }), p = 0, d = {}, n2 = h(n2.map(function(e3) {
        if ("string" == typeof e3)
          return e3;
        for (var n3, t2, e3 = e3.content; -1 !== a2.indexOf((t2 = p++, n3 = "___" + r2.toUpperCase() + "_" + t2 + "___")); )
          ;
        return d[n3] = e3, n3;
      }).join(""), e2, r2), g = Object.keys(d);
      return p = 0, function e3(n3) {
        for (var t2 = 0; t2 < n3.length; t2++) {
          if (p >= g.length)
            return;
          var a3, r22, s2, i, o, l2, u2, c = n3[t2];
          "string" == typeof c || "string" == typeof c.content ? (a3 = g[p], -1 !== (u2 = (l2 = "string" == typeof c ? c : c.content).indexOf(a3)) && (++p, r22 = l2.substring(0, u2), o = d[a3], s2 = void 0, (i = {})["interpolation-punctuation"] = f, 3 === (i = b.tokenize(o, i)).length && ((s2 = [1, 1]).push.apply(s2, h(i[1], b.languages.javascript, "javascript")), i.splice.apply(i, s2)), s2 = new b.Token("interpolation", i, m2.alias, o), i = l2.substring(u2 + a3.length), o = [], r22 && o.push(r22), o.push(s2), i && (e3(l2 = [i]), o.push.apply(o, l2)), "string" == typeof c ? (n3.splice.apply(n3, [t2, 1].concat(o)), t2 += o.length - 1) : c.content = o)) : (u2 = c.content, Array.isArray(u2) ? e3(u2) : e3([u2]));
        }
      }(n2), new b.Token(r2, n2, "language-" + r2, a2);
    }
    b.languages.javascript["template-string"] = [n("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), n("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source), n("svg", /\bsvg/.source), n("markdown", /\b(?:markdown|md)/.source), n("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source), n("sql", /\bsql/.source), e].filter(Boolean);
    var a = { javascript: true, js: true, typescript: true, ts: true, jsx: true, tsx: true };
    function u(e2) {
      return "string" == typeof e2 ? e2 : Array.isArray(e2) ? e2.map(u).join("") : u(e2.content);
    }
    b.hooks.add("after-tokenize", function(e2) {
      e2.language in a && !function e3(n2) {
        for (var t2 = 0, a2 = n2.length; t2 < a2; t2++) {
          var r2, s2, i, o = n2[t2];
          "string" != typeof o && (r2 = o.content, Array.isArray(r2) ? "template-string" === o.type ? (o = r2[1], 3 === r2.length && "string" != typeof o && "embedded-code" === o.type && (s2 = u(o), o = o.alias, o = Array.isArray(o) ? o[0] : o, i = b.languages[o]) && (r2[1] = l(s2, i, o))) : e3(r2) : "string" != typeof r2 && e3([r2]));
        }
      }(e2.tokens);
    });
  }(Prism), function(e) {
    e.languages.typescript = e.languages.extend("javascript", { "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/, lookbehind: true, greedy: true, inside: null }, builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/ }), e.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/), delete e.languages.typescript.parameter, delete e.languages.typescript["literal-property"];
    var n = e.languages.extend("typescript", {});
    delete n["class-name"], e.languages.typescript["class-name"].inside = n, e.languages.insertBefore("typescript", "function", { decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } }, "generic-function": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/, greedy: true, inside: { function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: n } } } }), e.languages.ts = e.languages.typescript;
  }(Prism), function(e) {
    var n = e.languages.javascript, t = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, a = "(@(?:arg|argument|param|property)\\s+(?:" + t + "\\s+)?)";
    e.languages.jsdoc = e.languages.extend("javadoclike", { parameter: { pattern: RegExp(a + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source), lookbehind: true, inside: { punctuation: /\./ } } }), e.languages.insertBefore("jsdoc", "keyword", { "optional-parameter": { pattern: RegExp(a + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source), lookbehind: true, inside: { parameter: { pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/, lookbehind: true, inside: { punctuation: /\./ } }, code: { pattern: /(=)[\s\S]*(?=\]$)/, lookbehind: true, inside: n, alias: "language-javascript" }, punctuation: /[=[\]]/ } }, "class-name": [{ pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function() {
      return t;
    })), lookbehind: true, inside: { punctuation: /\./ } }, { pattern: RegExp("(@[a-z]+\\s+)" + t), lookbehind: true, inside: { string: n.string, number: n.number, boolean: n.boolean, keyword: e.languages.typescript.keyword, operator: /=>|\.\.\.|[&|?:*]/, punctuation: /[.,;=<>{}()[\]]/ } }], example: { pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/, lookbehind: true, inside: { code: { pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m, lookbehind: true, inside: n, alias: "language-javascript" } } } }), e.languages.javadoclike.addSupport("javascript", e.languages.jsdoc);
  }(Prism), function(e) {
    e.languages.flow = e.languages.extend("javascript", {}), e.languages.insertBefore("flow", "keyword", { type: [{ pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/, alias: "class-name" }] }), e.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete e.languages.flow.parameter, e.languages.insertBefore("flow", "operator", { "flow-punctuation": { pattern: /\{\||\|\}/, alias: "punctuation" } }), Array.isArray(e.languages.flow.keyword) || (e.languages.flow.keyword = [e.languages.flow.keyword]), e.languages.flow.keyword.unshift({ pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/, lookbehind: true }, { pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/, lookbehind: true });
  }(Prism), Prism.languages.n4js = Prism.languages.extend("javascript", { keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/ }), Prism.languages.insertBefore("n4js", "constant", { annotation: { pattern: /@+\w+/, alias: "operator" } }), Prism.languages.n4jsd = Prism.languages.n4js, function(e) {
    function n(e2, n2) {
      return RegExp(e2.replace(/<ID>/g, function() {
        return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
      }), n2);
    }
    e.languages.insertBefore("javascript", "function-variable", { "method-variable": { pattern: RegExp("(\\.\\s*)" + e.languages.javascript["function-variable"].pattern.source), lookbehind: true, alias: ["function-variable", "method", "function", "property-access"] } }), e.languages.insertBefore("javascript", "function", { method: { pattern: RegExp("(\\.\\s*)" + e.languages.javascript.function.source), lookbehind: true, alias: ["function", "property-access"] } }), e.languages.insertBefore("javascript", "constant", { "known-class-name": [{ pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/, alias: "class-name" }, { pattern: /\b(?:[A-Z]\w*)Error\b/, alias: "class-name" }] }), e.languages.insertBefore("javascript", "keyword", { imports: { pattern: n(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source), lookbehind: true, inside: e.languages.javascript }, exports: { pattern: n(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source), lookbehind: true, inside: e.languages.javascript } }), e.languages.javascript.keyword.unshift({ pattern: /\b(?:as|default|export|from|import)\b/, alias: "module" }, { pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/, alias: "control-flow" }, { pattern: /\bnull\b/, alias: ["null", "nil"] }, { pattern: /\bundefined\b/, alias: "nil" }), e.languages.insertBefore("javascript", "operator", { spread: { pattern: /\.{3}/, alias: "operator" }, arrow: { pattern: /=>/, alias: "operator" } }), e.languages.insertBefore("javascript", "punctuation", { "property-access": { pattern: n(/(\.\s*)#?<ID>/.source), lookbehind: true }, "maybe-class-name": { pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/, lookbehind: true }, dom: { pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/, alias: "variable" }, console: { pattern: /\bconsole(?=\s*\.)/, alias: "class-name" } });
    for (var t = ["function", "function-variable", "method", "method-variable", "property-access"], a = 0; a < t.length; a++) {
      var r2 = t[a], s = e.languages.javascript[r2], r2 = (s = "RegExp" === e.util.type(s) ? e.languages.javascript[r2] = { pattern: s } : s).inside || {};
      (s.inside = r2)["maybe-class-name"] = /^[A-Z][\s\S]*/;
    }
  }(Prism), function(s) {
    var e = s.util.clone(s.languages.javascript), t = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, a = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, r2 = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
    function n(e2, n2) {
      return e2 = e2.replace(/<S>/g, function() {
        return t;
      }).replace(/<BRACES>/g, function() {
        return a;
      }).replace(/<SPREAD>/g, function() {
        return r2;
      }), RegExp(e2, n2);
    }
    r2 = n(r2).source, s.languages.jsx = s.languages.extend("markup", e), s.languages.jsx.tag.pattern = n(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), s.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, s.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, s.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, s.languages.jsx.tag.inside.comment = e.comment, s.languages.insertBefore("inside", "attr-name", { spread: { pattern: n(/<SPREAD>/.source), inside: s.languages.jsx } }, s.languages.jsx.tag), s.languages.insertBefore("inside", "special-attr", { script: { pattern: n(/=<BRACES>/.source), alias: "language-javascript", inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: s.languages.jsx } } }, s.languages.jsx.tag);
    function i(e2) {
      for (var n2 = [], t2 = 0; t2 < e2.length; t2++) {
        var a2 = e2[t2], r22 = false;
        "string" != typeof a2 && ("tag" === a2.type && a2.content[0] && "tag" === a2.content[0].type ? "</" === a2.content[0].content[0].content ? 0 < n2.length && n2[n2.length - 1].tagName === o(a2.content[0].content[1]) && n2.pop() : "/>" !== a2.content[a2.content.length - 1].content && n2.push({ tagName: o(a2.content[0].content[1]), openedBraces: 0 }) : 0 < n2.length && "punctuation" === a2.type && "{" === a2.content ? n2[n2.length - 1].openedBraces++ : 0 < n2.length && 0 < n2[n2.length - 1].openedBraces && "punctuation" === a2.type && "}" === a2.content ? n2[n2.length - 1].openedBraces-- : r22 = true), (r22 || "string" == typeof a2) && 0 < n2.length && 0 === n2[n2.length - 1].openedBraces && (r22 = o(a2), t2 < e2.length - 1 && ("string" == typeof e2[t2 + 1] || "plain-text" === e2[t2 + 1].type) && (r22 += o(e2[t2 + 1]), e2.splice(t2 + 1, 1)), 0 < t2 && ("string" == typeof e2[t2 - 1] || "plain-text" === e2[t2 - 1].type) && (r22 = o(e2[t2 - 1]) + r22, e2.splice(t2 - 1, 1), t2--), e2[t2] = new s.Token("plain-text", r22, null, r22)), a2.content && "string" != typeof a2.content && i(a2.content);
      }
    }
    var o = function(e2) {
      return e2 ? "string" == typeof e2 ? e2 : "string" == typeof e2.content ? e2.content : e2.content.map(o).join("") : "";
    };
    s.hooks.add("after-tokenize", function(e2) {
      "jsx" !== e2.language && "tsx" !== e2.language || i(e2.tokens);
    });
  }(Prism), function(e) {
    var n = e.util.clone(e.languages.typescript), n = (e.languages.tsx = e.languages.extend("jsx", n), delete e.languages.tsx.parameter, delete e.languages.tsx["literal-property"], e.languages.tsx.tag);
    n.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + n.pattern.source + ")", n.pattern.flags), n.lookbehind = true;
  }(Prism), Prism.languages.swift = { comment: { pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/, lookbehind: true, greedy: true }, "string-literal": [{ pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" }, punctuation: /\\(?=[\r\n])/, string: /[\s\S]+/ } }, { pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" }, string: /[\s\S]+/ } }], directive: { pattern: RegExp(/#/.source + "(?:" + /(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+|" + /(?:else|endif)\b/.source + ")"), alias: "property", inside: { "directive-name": /^#\w+/, boolean: /\b(?:false|true)\b/, number: /\b\d+(?:\.\d+)*\b/, operator: /!|&&|\|\||[<>]=?/, punctuation: /[(),]/ } }, literal: { pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/, alias: "constant" }, "other-directive": { pattern: /#\w+\b/, alias: "property" }, attribute: { pattern: /@\w+/, alias: "atrule" }, "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: true, alias: "function" }, label: { pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/, lookbehind: true, alias: "important" }, keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/, boolean: /\b(?:false|true)\b/, nil: { pattern: /\bnil\b/, alias: "constant" }, "short-argument": /\$\d+\b/, omit: { pattern: /\b_\b/, alias: "keyword" }, number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i, "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/, function: /\b[a-z_]\w*(?=\s*\()/i, constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/, operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/, punctuation: /[{}[\]();,.:\\]/ }, Prism.languages.swift["string-literal"].forEach(function(e) {
    e.inside.interpolation.inside = Prism.languages.swift;
  }), function(e) {
    e.languages.kotlin = e.languages.extend("clike", { keyword: { pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/, lookbehind: true }, function: [{ pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/, greedy: true }, { pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/, lookbehind: true, greedy: true }], number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/, operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/ }), delete e.languages.kotlin["class-name"];
    var n = { "interpolation-punctuation": { pattern: /^\$\{?|\}$/, alias: "punctuation" }, expression: { pattern: /[\s\S]+/, inside: e.languages.kotlin } };
    e.languages.insertBefore("kotlin", "string", { "string-literal": [{ pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/, alias: "multiline", inside: { interpolation: { pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i, inside: n }, string: /[\s\S]+/ } }, { pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/, alias: "singleline", inside: { interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i, lookbehind: true, inside: n }, string: /[\s\S]+/ } }], char: { pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/, greedy: true } }), delete e.languages.kotlin.string, e.languages.insertBefore("kotlin", "keyword", { annotation: { pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/, alias: "builtin" } }), e.languages.insertBefore("kotlin", "function", { label: { pattern: /\b\w+@|@\w+\b/, alias: "symbol" } }), e.languages.kt = e.languages.kotlin, e.languages.kts = e.languages.kotlin;
  }(Prism), Prism.languages.c = Prism.languages.extend("clike", { comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, "class-name": { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/, lookbehind: true }, keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/, function: /\b[a-z_]\w*(?=\s*\()/i, number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/ }), Prism.languages.insertBefore("c", "string", { char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: true } }), Prism.languages.insertBefore("c", "string", { macro: { pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im, lookbehind: true, greedy: true, alias: "property", inside: { string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: true }, Prism.languages.c.string], char: Prism.languages.c.char, comment: Prism.languages.c.comment, "macro-name": [{ pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: true }, { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: true, alias: "function" }], directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: true, alias: "keyword" }, "directive-hash": /^#/, punctuation: /##|\\(?=[\r\n])/, expression: { pattern: /\S[\s\S]*/, inside: Prism.languages.c } } } }), Prism.languages.insertBefore("c", "function", { constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/ }), delete Prism.languages.c.boolean, Prism.languages.objectivec = Prism.languages.extend("c", { string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/, operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/ }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec, Prism.languages.reason = Prism.languages.extend("clike", { string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/, greedy: true }, "class-name": /\b[A-Z]\w*/, keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/, operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/ }), Prism.languages.insertBefore("reason", "class-name", { char: { pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/, greedy: true }, constructor: /\b[A-Z]\w*\b(?!\s*\.)/, label: { pattern: /\b[a-z]\w*(?=::)/, alias: "symbol" } }), delete Prism.languages.reason.function, function(e) {
    for (var n = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, t = 0; t < 2; t++)
      n = n.replace(/<self>/g, function() {
        return n;
      });
    n = n.replace(/<self>/g, function() {
      return /[^\s\S]/.source;
    }), e.languages.rust = { comment: [{ pattern: RegExp(/(^|[^\\])/.source + n), lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/, greedy: true }, char: { pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/, greedy: true }, attribute: { pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/, greedy: true, alias: "attr-name", inside: { string: null } }, "closure-params": { pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/, lookbehind: true, greedy: true, inside: { "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" }, rest: null } }, "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" }, "fragment-specifier": { pattern: /(\$\w+:)[a-z]+/, lookbehind: true, alias: "punctuation" }, variable: /\$\w+/, "function-definition": { pattern: /(\bfn\s+)\w+/, lookbehind: true, alias: "function" }, "type-definition": { pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/, lookbehind: true, alias: "class-name" }, "module-declaration": [{ pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/, lookbehind: true, alias: "namespace" }, { pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/, lookbehind: true, alias: "namespace", inside: { punctuation: /::/ } }], keyword: [/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/], function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/, macro: { pattern: /\b\w+!/, alias: "property" }, constant: /\b[A-Z_][A-Z_\d]+\b/, "class-name": /\b[A-Z]\w*\b/, namespace: { pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/, inside: { punctuation: /::/ } }, number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/, boolean: /\b(?:false|true)\b/, punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/, operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/ }, e.languages.rust["closure-params"].inside.rest = e.languages.rust, e.languages.rust.attribute.inside.string = e.languages.rust.string;
  }(Prism), Prism.languages.go = Prism.languages.extend("clike", { string: { pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/, lookbehind: true, greedy: true }, keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/, boolean: /\b(?:_|false|iota|nil|true)\b/, number: [/\b0(?:b[01_]+|o[0-7_]+)i?\b/i, /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i, /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i], operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./, builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/ }), Prism.languages.insertBefore("go", "string", { char: { pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/, greedy: true } }), delete Prism.languages.go["class-name"], function(e) {
    var n = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, t = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return n.source;
    });
    e.languages.cpp = e.languages.extend("c", { "class-name": [{ pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
      return n.source;
    })), lookbehind: true }, /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/], keyword: n, number: { pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i, greedy: true }, operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/, boolean: /\b(?:false|true)\b/ }), e.languages.insertBefore("cpp", "string", { module: { pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
      return t;
    }) + ")"), lookbehind: true, greedy: true, inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ } }, "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: true } }), e.languages.insertBefore("cpp", "keyword", { "generic-function": { pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i, inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e.languages.cpp } } } }), e.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }), e.languages.insertBefore("cpp", "class-name", { "base-clause": { pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/, lookbehind: true, greedy: true, inside: e.languages.extend("cpp", {}) } }), e.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, e.languages.cpp["base-clause"]);
  }(Prism), Prism.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: true, greedy: true }, "string-interpolation": { pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i, greedy: true, inside: { interpolation: { pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/, lookbehind: true, inside: { "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: true }, "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" }, rest: null } }, string: /[\s\S]+/ } }, "triple-quoted-string": { pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i, greedy: true, alias: "string" }, string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: true }, function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: true }, "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: true }, decorator: { pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m, lookbehind: true, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } }, keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/, builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/, boolean: /\b(?:False|None|True)\b/, number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i, operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python, Prism.languages.json = { property: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, lookbehind: true, greedy: true }, string: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, lookbehind: true, greedy: true }, comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:false|true)\b/, null: { pattern: /\bnull\b/, alias: "keyword" } }, Prism.languages.webmanifest = Prism.languages.json;
  var themes_exports = {};
  __export(themes_exports, {
    dracula: () => dracula_default,
    duotoneDark: () => duotoneDark_default,
    duotoneLight: () => duotoneLight_default,
    github: () => github_default,
    gruvboxMaterialDark: () => gruvboxMaterialDark_default,
    gruvboxMaterialLight: () => gruvboxMaterialLight_default,
    jettwaveDark: () => jettwaveDark_default,
    jettwaveLight: () => jettwaveLight_default,
    nightOwl: () => nightOwl_default,
    nightOwlLight: () => nightOwlLight_default,
    oceanicNext: () => oceanicNext_default,
    okaidia: () => okaidia_default,
    oneDark: () => oneDark_default,
    oneLight: () => oneLight_default,
    palenight: () => palenight_default,
    shadesOfPurple: () => shadesOfPurple_default,
    synthwave84: () => synthwave84_default,
    ultramin: () => ultramin_default,
    vsDark: () => vsDark_default,
    vsLight: () => vsLight_default
  });
  var theme = {
    plain: {
      color: "#F8F8F2",
      backgroundColor: "#282A36"
    },
    styles: [
      {
        types: ["prolog", "constant", "builtin"],
        style: {
          color: "rgb(189, 147, 249)"
        }
      },
      {
        types: ["inserted", "function"],
        style: {
          color: "rgb(80, 250, 123)"
        }
      },
      {
        types: ["deleted"],
        style: {
          color: "rgb(255, 85, 85)"
        }
      },
      {
        types: ["changed"],
        style: {
          color: "rgb(255, 184, 108)"
        }
      },
      {
        types: ["punctuation", "symbol"],
        style: {
          color: "rgb(248, 248, 242)"
        }
      },
      {
        types: ["string", "char", "tag", "selector"],
        style: {
          color: "rgb(255, 121, 198)"
        }
      },
      {
        types: ["keyword", "variable"],
        style: {
          color: "rgb(189, 147, 249)",
          fontStyle: "italic"
        }
      },
      {
        types: ["comment"],
        style: {
          color: "rgb(98, 114, 164)"
        }
      },
      {
        types: ["attr-name"],
        style: {
          color: "rgb(241, 250, 140)"
        }
      }
    ]
  };
  var dracula_default = theme;
  var theme2 = {
    plain: {
      backgroundColor: "#2a2734",
      color: "#9a86fd"
    },
    styles: [
      {
        types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
        style: {
          color: "#6c6783"
        }
      },
      {
        types: ["namespace"],
        style: {
          opacity: 0.7
        }
      },
      {
        types: ["tag", "operator", "number"],
        style: {
          color: "#e09142"
        }
      },
      {
        types: ["property", "function"],
        style: {
          color: "#9a86fd"
        }
      },
      {
        types: ["tag-id", "selector", "atrule-id"],
        style: {
          color: "#eeebff"
        }
      },
      {
        types: ["attr-name"],
        style: {
          color: "#c4b9fe"
        }
      },
      {
        types: [
          "boolean",
          "string",
          "entity",
          "url",
          "attr-value",
          "keyword",
          "control",
          "directive",
          "unit",
          "statement",
          "regex",
          "atrule",
          "placeholder",
          "variable"
        ],
        style: {
          color: "#ffcc99"
        }
      },
      {
        types: ["deleted"],
        style: {
          textDecorationLine: "line-through"
        }
      },
      {
        types: ["inserted"],
        style: {
          textDecorationLine: "underline"
        }
      },
      {
        types: ["italic"],
        style: {
          fontStyle: "italic"
        }
      },
      {
        types: ["important", "bold"],
        style: {
          fontWeight: "bold"
        }
      },
      {
        types: ["important"],
        style: {
          color: "#c4b9fe"
        }
      }
    ]
  };
  var duotoneDark_default = theme2;
  var theme3 = {
    plain: {
      backgroundColor: "#faf8f5",
      color: "#728fcb"
    },
    styles: [
      {
        types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
        style: {
          color: "#b6ad9a"
        }
      },
      {
        types: ["namespace"],
        style: {
          opacity: 0.7
        }
      },
      {
        types: ["tag", "operator", "number"],
        style: {
          color: "#063289"
        }
      },
      {
        types: ["property", "function"],
        style: {
          color: "#b29762"
        }
      },
      {
        types: ["tag-id", "selector", "atrule-id"],
        style: {
          color: "#2d2006"
        }
      },
      {
        types: ["attr-name"],
        style: {
          color: "#896724"
        }
      },
      {
        types: [
          "boolean",
          "string",
          "entity",
          "url",
          "attr-value",
          "keyword",
          "control",
          "directive",
          "unit",
          "statement",
          "regex",
          "atrule"
        ],
        style: {
          color: "#728fcb"
        }
      },
      {
        types: ["placeholder", "variable"],
        style: {
          color: "#93abdc"
        }
      },
      {
        types: ["deleted"],
        style: {
          textDecorationLine: "line-through"
        }
      },
      {
        types: ["inserted"],
        style: {
          textDecorationLine: "underline"
        }
      },
      {
        types: ["italic"],
        style: {
          fontStyle: "italic"
        }
      },
      {
        types: ["important", "bold"],
        style: {
          fontWeight: "bold"
        }
      },
      {
        types: ["important"],
        style: {
          color: "#896724"
        }
      }
    ]
  };
  var duotoneLight_default = theme3;
  var theme4 = {
    plain: {
      color: "#393A34",
      backgroundColor: "#f6f8fa"
    },
    styles: [
      {
        types: ["comment", "prolog", "doctype", "cdata"],
        style: {
          color: "#999988",
          fontStyle: "italic"
        }
      },
      {
        types: ["namespace"],
        style: {
          opacity: 0.7
        }
      },
      {
        types: ["string", "attr-value"],
        style: {
          color: "#e3116c"
        }
      },
      {
        types: ["punctuation", "operator"],
        style: {
          color: "#393A34"
        }
      },
      {
        types: [
          "entity",
          "url",
          "symbol",
          "number",
          "boolean",
          "variable",
          "constant",
          "property",
          "regex",
          "inserted"
        ],
        style: {
          color: "#36acaa"
        }
      },
      {
        types: ["atrule", "keyword", "attr-name", "selector"],
        style: {
          color: "#00a4db"
        }
      },
      {
        types: ["function", "deleted", "tag"],
        style: {
          color: "#d73a49"
        }
      },
      {
        types: ["function-variable"],
        style: {
          color: "#6f42c1"
        }
      },
      {
        types: ["tag", "selector", "keyword"],
        style: {
          color: "#00009f"
        }
      }
    ]
  };
  var github_default = theme4;
  var theme5 = {
    plain: {
      color: "#d6deeb",
      backgroundColor: "#011627"
    },
    styles: [
      {
        types: ["changed"],
        style: {
          color: "rgb(162, 191, 252)",
          fontStyle: "italic"
        }
      },
      {
        types: ["deleted"],
        style: {
          color: "rgba(239, 83, 80, 0.56)",
          fontStyle: "italic"
        }
      },
      {
        types: ["inserted", "attr-name"],
        style: {
          color: "rgb(173, 219, 103)",
          fontStyle: "italic"
        }
      },
      {
        types: ["comment"],
        style: {
          color: "rgb(99, 119, 119)",
          fontStyle: "italic"
        }
      },
      {
        types: ["string", "url"],
        style: {
          color: "rgb(173, 219, 103)"
        }
      },
      {
        types: ["variable"],
        style: {
          color: "rgb(214, 222, 235)"
        }
      },
      {
        types: ["number"],
        style: {
          color: "rgb(247, 140, 108)"
        }
      },
      {
        types: ["builtin", "char", "constant", "function"],
        style: {
          color: "rgb(130, 170, 255)"
        }
      },
      {
        // This was manually added after the auto-generation
        // so that punctuations are not italicised
        types: ["punctuation"],
        style: {
          color: "rgb(199, 146, 234)"
        }
      },
      {
        types: ["selector", "doctype"],
        style: {
          color: "rgb(199, 146, 234)",
          fontStyle: "italic"
        }
      },
      {
        types: ["class-name"],
        style: {
          color: "rgb(255, 203, 139)"
        }
      },
      {
        types: ["tag", "operator", "keyword"],
        style: {
          color: "rgb(127, 219, 202)"
        }
      },
      {
        types: ["boolean"],
        style: {
          color: "rgb(255, 88, 116)"
        }
      },
      {
        types: ["property"],
        style: {
          color: "rgb(128, 203, 196)"
        }
      },
      {
        types: ["namespace"],
        style: {
          color: "rgb(178, 204, 214)"
        }
      }
    ]
  };
  var nightOwl_default = theme5;
  var theme6 = {
    plain: {
      color: "#403f53",
      backgroundColor: "#FBFBFB"
    },
    styles: [
      {
        types: ["changed"],
        style: {
          color: "rgb(162, 191, 252)",
          fontStyle: "italic"
        }
      },
      {
        types: ["deleted"],
        style: {
          color: "rgba(239, 83, 80, 0.56)",
          fontStyle: "italic"
        }
      },
      {
        types: ["inserted", "attr-name"],
        style: {
          color: "rgb(72, 118, 214)",
          fontStyle: "italic"
        }
      },
      {
        types: ["comment"],
        style: {
          color: "rgb(152, 159, 177)",
          fontStyle: "italic"
        }
      },
      {
        types: ["string", "builtin", "char", "constant", "url"],
        style: {
          color: "rgb(72, 118, 214)"
        }
      },
      {
        types: ["variable"],
        style: {
          color: "rgb(201, 103, 101)"
        }
      },
      {
        types: ["number"],
        style: {
          color: "rgb(170, 9, 130)"
        }
      },
      {
        // This was manually added after the auto-generation
        // so that punctuations are not italicised
        types: ["punctuation"],
        style: {
          color: "rgb(153, 76, 195)"
        }
      },
      {
        types: ["function", "selector", "doctype"],
        style: {
          color: "rgb(153, 76, 195)",
          fontStyle: "italic"
        }
      },
      {
        types: ["class-name"],
        style: {
          color: "rgb(17, 17, 17)"
        }
      },
      {
        types: ["tag"],
        style: {
          color: "rgb(153, 76, 195)"
        }
      },
      {
        types: ["operator", "property", "keyword", "namespace"],
        style: {
          color: "rgb(12, 150, 155)"
        }
      },
      {
        types: ["boolean"],
        style: {
          color: "rgb(188, 84, 84)"
        }
      }
    ]
  };
  var nightOwlLight_default = theme6;
  var colors = {
    char: "#D8DEE9",
    comment: "#999999",
    keyword: "#c5a5c5",
    primitive: "#5a9bcf",
    string: "#8dc891",
    variable: "#d7deea",
    boolean: "#ff8b50",
    tag: "#fc929e",
    function: "#79b6f2",
    className: "#FAC863"
  };
  var theme7 = {
    plain: {
      backgroundColor: "#282c34",
      color: "#ffffff"
    },
    styles: [
      {
        types: ["attr-name"],
        style: {
          color: colors.keyword
        }
      },
      {
        types: ["attr-value"],
        style: {
          color: colors.string
        }
      },
      {
        types: [
          "comment",
          "block-comment",
          "prolog",
          "doctype",
          "cdata",
          "shebang"
        ],
        style: {
          color: colors.comment
        }
      },
      {
        types: [
          "property",
          "number",
          "function-name",
          "constant",
          "symbol",
          "deleted"
        ],
        style: {
          color: colors.primitive
        }
      },
      {
        types: ["boolean"],
        style: {
          color: colors.boolean
        }
      },
      {
        types: ["tag"],
        style: {
          color: colors.tag
        }
      },
      {
        types: ["string"],
        style: {
          color: colors.string
        }
      },
      {
        types: ["punctuation"],
        style: {
          color: colors.string
        }
      },
      {
        types: ["selector", "char", "builtin", "inserted"],
        style: {
          color: colors.char
        }
      },
      {
        types: ["function"],
        style: {
          color: colors.function
        }
      },
      {
        types: ["operator", "entity", "url", "variable"],
        style: {
          color: colors.variable
        }
      },
      {
        types: ["keyword"],
        style: {
          color: colors.keyword
        }
      },
      {
        types: ["atrule", "class-name"],
        style: {
          color: colors.className
        }
      },
      {
        types: ["important"],
        style: {
          fontWeight: "400"
        }
      },
      {
        types: ["bold"],
        style: {
          fontWeight: "bold"
        }
      },
      {
        types: ["italic"],
        style: {
          fontStyle: "italic"
        }
      },
      {
        types: ["namespace"],
        style: {
          opacity: 0.7
        }
      }
    ]
  };
  var oceanicNext_default = theme7;
  var theme8 = {
    plain: {
      color: "#f8f8f2",
      backgroundColor: "#272822"
    },
    styles: [
      {
        types: ["changed"],
        style: {
          color: "rgb(162, 191, 252)",
          fontStyle: "italic"
        }
      },
      {
        types: ["deleted"],
        style: {
          color: "#f92672",
          fontStyle: "italic"
        }
      },
      {
        types: ["inserted"],
        style: {
          color: "rgb(173, 219, 103)",
          fontStyle: "italic"
        }
      },
      {
        types: ["comment"],
        style: {
          color: "#8292a2",
          fontStyle: "italic"
        }
      },
      {
        types: ["string", "url"],
        style: {
          color: "#a6e22e"
        }
      },
      {
        types: ["variable"],
        style: {
          color: "#f8f8f2"
        }
      },
      {
        types: ["number"],
        style: {
          color: "#ae81ff"
        }
      },
      {
        types: ["builtin", "char", "constant", "function", "class-name"],
        style: {
          color: "#e6db74"
        }
      },
      {
        types: ["punctuation"],
        style: {
          color: "#f8f8f2"
        }
      },
      {
        types: ["selector", "doctype"],
        style: {
          color: "#a6e22e",
          fontStyle: "italic"
        }
      },
      {
        types: ["tag", "operator", "keyword"],
        style: {
          color: "#66d9ef"
        }
      },
      {
        types: ["boolean"],
        style: {
          color: "#ae81ff"
        }
      },
      {
        types: ["namespace"],
        style: {
          color: "rgb(178, 204, 214)",
          opacity: 0.7
        }
      },
      {
        types: ["tag", "property"],
        style: {
          color: "#f92672"
        }
      },
      {
        types: ["attr-name"],
        style: {
          color: "#a6e22e !important"
        }
      },
      {
        types: ["doctype"],
        style: {
          color: "#8292a2"
        }
      },
      {
        types: ["rule"],
        style: {
          color: "#e6db74"
        }
      }
    ]
  };
  var okaidia_default = theme8;
  var theme9 = {
    plain: {
      color: "#bfc7d5",
      backgroundColor: "#292d3e"
    },
    styles: [
      {
        types: ["comment"],
        style: {
          color: "rgb(105, 112, 152)",
          fontStyle: "italic"
        }
      },
      {
        types: ["string", "inserted"],
        style: {
          color: "rgb(195, 232, 141)"
        }
      },
      {
        types: ["number"],
        style: {
          color: "rgb(247, 140, 108)"
        }
      },
      {
        types: ["builtin", "char", "constant", "function"],
        style: {
          color: "rgb(130, 170, 255)"
        }
      },
      {
        types: ["punctuation", "selector"],
        style: {
          color: "rgb(199, 146, 234)"
        }
      },
      {
        types: ["variable"],
        style: {
          color: "rgb(191, 199, 213)"
        }
      },
      {
        types: ["class-name", "attr-name"],
        style: {
          color: "rgb(255, 203, 107)"
        }
      },
      {
        types: ["tag", "deleted"],
        style: {
          color: "rgb(255, 85, 114)"
        }
      },
      {
        types: ["operator"],
        style: {
          color: "rgb(137, 221, 255)"
        }
      },
      {
        types: ["boolean"],
        style: {
          color: "rgb(255, 88, 116)"
        }
      },
      {
        types: ["keyword"],
        style: {
          fontStyle: "italic"
        }
      },
      {
        types: ["doctype"],
        style: {
          color: "rgb(199, 146, 234)",
          fontStyle: "italic"
        }
      },
      {
        types: ["namespace"],
        style: {
          color: "rgb(178, 204, 214)"
        }
      },
      {
        types: ["url"],
        style: {
          color: "rgb(221, 221, 221)"
        }
      }
    ]
  };
  var palenight_default = theme9;
  var theme10 = {
    plain: {
      color: "#9EFEFF",
      backgroundColor: "#2D2A55"
    },
    styles: [
      {
        types: ["changed"],
        style: {
          color: "rgb(255, 238, 128)"
        }
      },
      {
        types: ["deleted"],
        style: {
          color: "rgba(239, 83, 80, 0.56)"
        }
      },
      {
        types: ["inserted"],
        style: {
          color: "rgb(173, 219, 103)"
        }
      },
      {
        types: ["comment"],
        style: {
          color: "rgb(179, 98, 255)",
          fontStyle: "italic"
        }
      },
      {
        types: ["punctuation"],
        style: {
          color: "rgb(255, 255, 255)"
        }
      },
      {
        types: ["constant"],
        style: {
          color: "rgb(255, 98, 140)"
        }
      },
      {
        types: ["string", "url"],
        style: {
          color: "rgb(165, 255, 144)"
        }
      },
      {
        types: ["variable"],
        style: {
          color: "rgb(255, 238, 128)"
        }
      },
      {
        types: ["number", "boolean"],
        style: {
          color: "rgb(255, 98, 140)"
        }
      },
      {
        types: ["attr-name"],
        style: {
          color: "rgb(255, 180, 84)"
        }
      },
      {
        types: [
          "keyword",
          "operator",
          "property",
          "namespace",
          "tag",
          "selector",
          "doctype"
        ],
        style: {
          color: "rgb(255, 157, 0)"
        }
      },
      {
        types: ["builtin", "char", "constant", "function", "class-name"],
        style: {
          color: "rgb(250, 208, 0)"
        }
      }
    ]
  };
  var shadesOfPurple_default = theme10;
  var theme11 = {
    plain: {
      backgroundColor: "linear-gradient(to bottom, #2a2139 75%, #34294f)",
      backgroundImage: "#34294f",
      color: "#f92aad",
      textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
    },
    styles: [
      {
        types: ["comment", "block-comment", "prolog", "doctype", "cdata"],
        style: {
          color: "#495495",
          fontStyle: "italic"
        }
      },
      {
        types: ["punctuation"],
        style: {
          color: "#ccc"
        }
      },
      {
        types: [
          "tag",
          "attr-name",
          "namespace",
          "number",
          "unit",
          "hexcode",
          "deleted"
        ],
        style: {
          color: "#e2777a"
        }
      },
      {
        types: ["property", "selector"],
        style: {
          color: "#72f1b8",
          textShadow: "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
        }
      },
      {
        types: ["function-name"],
        style: {
          color: "#6196cc"
        }
      },
      {
        types: ["boolean", "selector-id", "function"],
        style: {
          color: "#fdfdfd",
          textShadow: "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
        }
      },
      {
        types: ["class-name", "maybe-class-name", "builtin"],
        style: {
          color: "#fff5f6",
          textShadow: "0 0 2px #000, 0 0 10px #fc1f2c75, 0 0 5px #fc1f2c75, 0 0 25px #fc1f2c75"
        }
      },
      {
        types: ["constant", "symbol"],
        style: {
          color: "#f92aad",
          textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
        }
      },
      {
        types: ["important", "atrule", "keyword", "selector-class"],
        style: {
          color: "#f4eee4",
          textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
        }
      },
      {
        types: ["string", "char", "attr-value", "regex", "variable"],
        style: {
          color: "#f87c32"
        }
      },
      {
        types: ["parameter"],
        style: {
          fontStyle: "italic"
        }
      },
      {
        types: ["entity", "url"],
        style: {
          color: "#67cdcc"
        }
      },
      {
        types: ["operator"],
        style: {
          color: "ffffffee"
        }
      },
      {
        types: ["important", "bold"],
        style: {
          fontWeight: "bold"
        }
      },
      {
        types: ["italic"],
        style: {
          fontStyle: "italic"
        }
      },
      {
        types: ["entity"],
        style: {
          cursor: "help"
        }
      },
      {
        types: ["inserted"],
        style: {
          color: "green"
        }
      }
    ]
  };
  var synthwave84_default = theme11;
  var theme12 = {
    plain: {
      color: "#282a2e",
      backgroundColor: "#ffffff"
    },
    styles: [
      {
        types: ["comment"],
        style: {
          color: "rgb(197, 200, 198)"
        }
      },
      {
        types: ["string", "number", "builtin", "variable"],
        style: {
          color: "rgb(150, 152, 150)"
        }
      },
      {
        types: ["class-name", "function", "tag", "attr-name"],
        style: {
          color: "rgb(40, 42, 46)"
        }
      }
    ]
  };
  var ultramin_default = theme12;
  var theme13 = {
    plain: {
      color: "#9CDCFE",
      backgroundColor: "#1E1E1E"
    },
    styles: [
      {
        types: ["prolog"],
        style: {
          color: "rgb(0, 0, 128)"
        }
      },
      {
        types: ["comment"],
        style: {
          color: "rgb(106, 153, 85)"
        }
      },
      {
        types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
        style: {
          color: "rgb(86, 156, 214)"
        }
      },
      {
        types: ["number", "inserted"],
        style: {
          color: "rgb(181, 206, 168)"
        }
      },
      {
        types: ["constant"],
        style: {
          color: "rgb(100, 102, 149)"
        }
      },
      {
        types: ["attr-name", "variable"],
        style: {
          color: "rgb(156, 220, 254)"
        }
      },
      {
        types: ["deleted", "string", "attr-value", "template-punctuation"],
        style: {
          color: "rgb(206, 145, 120)"
        }
      },
      {
        types: ["selector"],
        style: {
          color: "rgb(215, 186, 125)"
        }
      },
      {
        // Fix tag color
        types: ["tag"],
        style: {
          color: "rgb(78, 201, 176)"
        }
      },
      {
        // Fix tag color for HTML
        types: ["tag"],
        languages: ["markup"],
        style: {
          color: "rgb(86, 156, 214)"
        }
      },
      {
        types: ["punctuation", "operator"],
        style: {
          color: "rgb(212, 212, 212)"
        }
      },
      {
        // Fix punctuation color for HTML
        types: ["punctuation"],
        languages: ["markup"],
        style: {
          color: "#808080"
        }
      },
      {
        types: ["function"],
        style: {
          color: "rgb(220, 220, 170)"
        }
      },
      {
        types: ["class-name"],
        style: {
          color: "rgb(78, 201, 176)"
        }
      },
      {
        types: ["char"],
        style: {
          color: "rgb(209, 105, 105)"
        }
      }
    ]
  };
  var vsDark_default = theme13;
  var theme14 = {
    plain: {
      color: "#000000",
      backgroundColor: "#ffffff"
    },
    styles: [
      {
        types: ["comment"],
        style: {
          color: "rgb(0, 128, 0)"
        }
      },
      {
        types: ["builtin"],
        style: {
          color: "rgb(0, 112, 193)"
        }
      },
      {
        types: ["number", "variable", "inserted"],
        style: {
          color: "rgb(9, 134, 88)"
        }
      },
      {
        types: ["operator"],
        style: {
          color: "rgb(0, 0, 0)"
        }
      },
      {
        types: ["constant", "char"],
        style: {
          color: "rgb(129, 31, 63)"
        }
      },
      {
        types: ["tag"],
        style: {
          color: "rgb(128, 0, 0)"
        }
      },
      {
        types: ["attr-name"],
        style: {
          color: "rgb(255, 0, 0)"
        }
      },
      {
        types: ["deleted", "string"],
        style: {
          color: "rgb(163, 21, 21)"
        }
      },
      {
        types: ["changed", "punctuation"],
        style: {
          color: "rgb(4, 81, 165)"
        }
      },
      {
        types: ["function", "keyword"],
        style: {
          color: "rgb(0, 0, 255)"
        }
      },
      {
        types: ["class-name"],
        style: {
          color: "rgb(38, 127, 153)"
        }
      }
    ]
  };
  var vsLight_default = theme14;
  var theme15 = {
    plain: {
      color: "#f8fafc",
      backgroundColor: "#011627"
    },
    styles: [
      {
        types: ["prolog"],
        style: {
          color: "#000080"
        }
      },
      {
        types: ["comment"],
        style: {
          color: "#6A9955"
        }
      },
      {
        types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
        style: {
          color: "#569CD6"
        }
      },
      {
        types: ["number", "inserted"],
        style: {
          color: "#B5CEA8"
        }
      },
      {
        types: ["constant"],
        style: {
          color: "#f8fafc"
        }
      },
      {
        types: ["attr-name", "variable"],
        style: {
          color: "#9CDCFE"
        }
      },
      {
        types: ["deleted", "string", "attr-value", "template-punctuation"],
        style: {
          color: "#cbd5e1"
        }
      },
      {
        types: ["selector"],
        style: {
          color: "#D7BA7D"
        }
      },
      {
        types: ["tag"],
        style: {
          color: "#0ea5e9"
        }
      },
      {
        types: ["tag"],
        languages: ["markup"],
        style: {
          color: "#0ea5e9"
        }
      },
      {
        types: ["punctuation", "operator"],
        style: {
          color: "#D4D4D4"
        }
      },
      {
        types: ["punctuation"],
        languages: ["markup"],
        style: {
          color: "#808080"
        }
      },
      {
        types: ["function"],
        style: {
          color: "#7dd3fc"
        }
      },
      {
        types: ["class-name"],
        style: {
          color: "#0ea5e9"
        }
      },
      {
        types: ["char"],
        style: {
          color: "#D16969"
        }
      }
    ]
  };
  var jettwaveDark_default = theme15;
  var theme16 = {
    plain: {
      color: "#0f172a",
      backgroundColor: "#f1f5f9"
    },
    styles: [
      {
        types: ["prolog"],
        style: {
          color: "#000080"
        }
      },
      {
        types: ["comment"],
        style: {
          color: "#6A9955"
        }
      },
      {
        types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
        style: {
          color: "#0c4a6e"
        }
      },
      {
        types: ["number", "inserted"],
        style: {
          color: "#B5CEA8"
        }
      },
      {
        types: ["constant"],
        style: {
          color: "#0f172a"
        }
      },
      {
        types: ["attr-name", "variable"],
        style: {
          color: "#0c4a6e"
        }
      },
      {
        types: ["deleted", "string", "attr-value", "template-punctuation"],
        style: {
          color: "#64748b"
        }
      },
      {
        types: ["selector"],
        style: {
          color: "#D7BA7D"
        }
      },
      {
        types: ["tag"],
        style: {
          color: "#0ea5e9"
        }
      },
      {
        types: ["tag"],
        languages: ["markup"],
        style: {
          color: "#0ea5e9"
        }
      },
      {
        types: ["punctuation", "operator"],
        style: {
          color: "#475569"
        }
      },
      {
        types: ["punctuation"],
        languages: ["markup"],
        style: {
          color: "#808080"
        }
      },
      {
        types: ["function"],
        style: {
          color: "#0e7490"
        }
      },
      {
        types: ["class-name"],
        style: {
          color: "#0ea5e9"
        }
      },
      {
        types: ["char"],
        style: {
          color: "#D16969"
        }
      }
    ]
  };
  var jettwaveLight_default = theme16;
  var theme17 = {
    plain: {
      backgroundColor: "hsl(220, 13%, 18%)",
      color: "hsl(220, 14%, 71%)",
      textShadow: "0 1px rgba(0, 0, 0, 0.3)"
    },
    styles: [
      {
        types: ["comment", "prolog", "cdata"],
        style: {
          color: "hsl(220, 10%, 40%)"
        }
      },
      {
        types: ["doctype", "punctuation", "entity"],
        style: {
          color: "hsl(220, 14%, 71%)"
        }
      },
      {
        types: [
          "attr-name",
          "class-name",
          "maybe-class-name",
          "boolean",
          "constant",
          "number",
          "atrule"
        ],
        style: { color: "hsl(29, 54%, 61%)" }
      },
      {
        types: ["keyword"],
        style: { color: "hsl(286, 60%, 67%)" }
      },
      {
        types: ["property", "tag", "symbol", "deleted", "important"],
        style: {
          color: "hsl(355, 65%, 65%)"
        }
      },
      {
        types: [
          "selector",
          "string",
          "char",
          "builtin",
          "inserted",
          "regex",
          "attr-value"
        ],
        style: {
          color: "hsl(95, 38%, 62%)"
        }
      },
      {
        types: ["variable", "operator", "function"],
        style: {
          color: "hsl(207, 82%, 66%)"
        }
      },
      {
        types: ["url"],
        style: {
          color: "hsl(187, 47%, 55%)"
        }
      },
      {
        types: ["deleted"],
        style: {
          textDecorationLine: "line-through"
        }
      },
      {
        types: ["inserted"],
        style: {
          textDecorationLine: "underline"
        }
      },
      {
        types: ["italic"],
        style: {
          fontStyle: "italic"
        }
      },
      {
        types: ["important", "bold"],
        style: {
          fontWeight: "bold"
        }
      },
      {
        types: ["important"],
        style: {
          color: "hsl(220, 14%, 71%)"
        }
      }
    ]
  };
  var oneDark_default = theme17;
  var theme18 = {
    plain: {
      backgroundColor: "hsl(230, 1%, 98%)",
      color: "hsl(230, 8%, 24%)"
    },
    styles: [
      {
        types: ["comment", "prolog", "cdata"],
        style: {
          color: "hsl(230, 4%, 64%)"
        }
      },
      {
        types: ["doctype", "punctuation", "entity"],
        style: {
          color: "hsl(230, 8%, 24%)"
        }
      },
      {
        types: [
          "attr-name",
          "class-name",
          "boolean",
          "constant",
          "number",
          "atrule"
        ],
        style: {
          color: "hsl(35, 99%, 36%)"
        }
      },
      {
        types: ["keyword"],
        style: {
          color: "hsl(301, 63%, 40%)"
        }
      },
      {
        types: ["property", "tag", "symbol", "deleted", "important"],
        style: {
          color: "hsl(5, 74%, 59%)"
        }
      },
      {
        types: [
          "selector",
          "string",
          "char",
          "builtin",
          "inserted",
          "regex",
          "attr-value",
          "punctuation"
        ],
        style: {
          color: "hsl(119, 34%, 47%)"
        }
      },
      {
        types: ["variable", "operator", "function"],
        style: {
          color: "hsl(221, 87%, 60%)"
        }
      },
      {
        types: ["url"],
        style: {
          color: "hsl(198, 99%, 37%)"
        }
      },
      {
        types: ["deleted"],
        style: {
          textDecorationLine: "line-through"
        }
      },
      {
        types: ["inserted"],
        style: {
          textDecorationLine: "underline"
        }
      },
      {
        types: ["italic"],
        style: {
          fontStyle: "italic"
        }
      },
      {
        types: ["important", "bold"],
        style: {
          fontWeight: "bold"
        }
      },
      {
        types: ["important"],
        style: {
          color: "hsl(230, 8%, 24%)"
        }
      }
    ]
  };
  var oneLight_default = theme18;
  var theme19 = {
    plain: {
      color: "#ebdbb2",
      backgroundColor: "#292828"
    },
    styles: [
      {
        types: [
          "imports",
          "class-name",
          "maybe-class-name",
          "constant",
          "doctype",
          "builtin",
          "function"
        ],
        style: {
          color: "#d8a657"
        }
      },
      {
        types: ["property-access"],
        style: {
          color: "#7daea3"
        }
      },
      {
        types: ["tag"],
        style: {
          color: "#e78a4e"
        }
      },
      {
        types: ["attr-name", "char", "url", "regex"],
        style: {
          color: "#a9b665"
        }
      },
      {
        types: ["attr-value", "string"],
        style: {
          color: "#89b482"
        }
      },
      {
        types: ["comment", "prolog", "cdata", "operator", "inserted"],
        style: {
          color: "#a89984"
        }
      },
      {
        types: [
          "delimiter",
          "boolean",
          "keyword",
          "selector",
          "important",
          "atrule",
          "property",
          "variable",
          "deleted"
        ],
        style: {
          color: "#ea6962"
        }
      },
      {
        types: ["entity", "number", "symbol"],
        style: {
          color: "#d3869b"
        }
      }
    ]
  };
  var gruvboxMaterialDark_default = theme19;
  var theme20 = {
    plain: {
      color: "#654735",
      backgroundColor: "#f9f5d7"
    },
    styles: [
      {
        types: [
          "delimiter",
          "boolean",
          "keyword",
          "selector",
          "important",
          "atrule",
          "property",
          "variable",
          "deleted"
        ],
        style: {
          color: "#af2528"
        }
      },
      {
        types: [
          "imports",
          "class-name",
          "maybe-class-name",
          "constant",
          "doctype",
          "builtin"
        ],
        style: {
          color: "#b4730e"
        }
      },
      {
        types: ["string", "attr-value"],
        style: {
          color: "#477a5b"
        }
      },
      {
        types: ["property-access"],
        style: {
          color: "#266b79"
        }
      },
      {
        types: ["function", "attr-name", "char", "url"],
        style: {
          color: "#72761e"
        }
      },
      {
        types: ["tag"],
        style: {
          color: "#b94c07"
        }
      },
      {
        types: ["comment", "prolog", "cdata", "operator", "inserted"],
        style: {
          color: "#a89984"
        }
      },
      {
        types: ["entity", "number", "symbol"],
        style: {
          color: "#924f79"
        }
      }
    ]
  };
  var gruvboxMaterialLight_default = theme20;
  var useGetLineProps = (themeDictionary) => reactExports.useCallback(
    (_a2) => {
      var _b2 = _a2, { className, style, line } = _b2, rest = __objRest(_b2, ["className", "style", "line"]);
      const output = __spreadProps(__spreadValues({}, rest), {
        className: clsx("token-line", className)
      });
      if (typeof themeDictionary === "object" && "plain" in themeDictionary)
        output.style = themeDictionary.plain;
      if (typeof style === "object")
        output.style = __spreadValues(__spreadValues({}, output.style || {}), style);
      return output;
    },
    [themeDictionary]
  );
  var useGetTokenProps = (themeDictionary) => {
    const styleForToken = reactExports.useCallback(
      ({ types: types2, empty: empty2 }) => {
        if (themeDictionary == null)
          return void 0;
        else if (types2.length === 1 && types2[0] === "plain") {
          return empty2 != null ? { display: "inline-block" } : void 0;
        } else if (types2.length === 1 && empty2 != null) {
          return themeDictionary[types2[0]];
        }
        return Object.assign(
          empty2 != null ? { display: "inline-block" } : {},
          ...types2.map((type) => themeDictionary[type])
        );
      },
      [themeDictionary]
    );
    return reactExports.useCallback(
      (_a2) => {
        var _b2 = _a2, { token, className, style } = _b2, rest = __objRest(_b2, ["token", "className", "style"]);
        const output = __spreadProps(__spreadValues({}, rest), {
          className: clsx("token", ...token.types, className),
          children: token.content,
          style: styleForToken(token)
        });
        if (style != null) {
          output.style = __spreadValues(__spreadValues({}, output.style || {}), style);
        }
        return output;
      },
      [styleForToken]
    );
  };
  var newlineRe = /\r\n|\r|\n/;
  var normalizeEmptyLines = (line) => {
    if (line.length === 0) {
      line.push({
        types: ["plain"],
        content: "\n",
        empty: true
      });
    } else if (line.length === 1 && line[0].content === "") {
      line[0].content = "\n";
      line[0].empty = true;
    }
  };
  var appendTypes = (types2, add) => {
    const typesSize = types2.length;
    if (typesSize > 0 && types2[typesSize - 1] === add) {
      return types2;
    }
    return types2.concat(add);
  };
  var normalizeTokens = (tokens) => {
    const typeArrStack = [[]];
    const tokenArrStack = [tokens];
    const tokenArrIndexStack = [0];
    const tokenArrSizeStack = [tokens.length];
    let i = 0;
    let stackIndex = 0;
    let currentLine = [];
    const acc = [currentLine];
    while (stackIndex > -1) {
      while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {
        let content2;
        let types2 = typeArrStack[stackIndex];
        const tokenArr = tokenArrStack[stackIndex];
        const token = tokenArr[i];
        if (typeof token === "string") {
          types2 = stackIndex > 0 ? types2 : ["plain"];
          content2 = token;
        } else {
          types2 = appendTypes(types2, token.type);
          if (token.alias) {
            types2 = appendTypes(types2, token.alias);
          }
          content2 = token.content;
        }
        if (typeof content2 !== "string") {
          stackIndex++;
          typeArrStack.push(types2);
          tokenArrStack.push(content2);
          tokenArrIndexStack.push(0);
          tokenArrSizeStack.push(content2.length);
          continue;
        }
        const splitByNewlines = content2.split(newlineRe);
        const newlineCount = splitByNewlines.length;
        currentLine.push({
          types: types2,
          content: splitByNewlines[0]
        });
        for (let i2 = 1; i2 < newlineCount; i2++) {
          normalizeEmptyLines(currentLine);
          acc.push(currentLine = []);
          currentLine.push({
            types: types2,
            content: splitByNewlines[i2]
          });
        }
      }
      stackIndex--;
      typeArrStack.pop();
      tokenArrStack.pop();
      tokenArrIndexStack.pop();
      tokenArrSizeStack.pop();
    }
    normalizeEmptyLines(currentLine);
    return acc;
  };
  var normalizeTokens_default = normalizeTokens;
  var useTokenize = ({ prism, code: code2, grammar, language }) => {
    return reactExports.useMemo(() => {
      if (grammar == null)
        return normalizeTokens_default([code2]);
      const prismConfig = {
        code: code2,
        grammar,
        language,
        tokens: []
      };
      prism.hooks.run("before-tokenize", prismConfig);
      prismConfig.tokens = prism.tokenize(code2, grammar);
      prism.hooks.run("after-tokenize", prismConfig);
      return normalizeTokens_default(prismConfig.tokens);
    }, [
      code2,
      grammar,
      language,
      // prism is a stable import
      prism
    ]);
  };
  var themeToDict = (theme21, language) => {
    const { plain } = theme21;
    const themeDict = theme21.styles.reduce((acc, themeEntry) => {
      const { languages: languages2, style } = themeEntry;
      if (languages2 && !languages2.includes(language)) {
        return acc;
      }
      themeEntry.types.forEach((type) => {
        const accStyle = __spreadValues(__spreadValues({}, acc[type]), style);
        acc[type] = accStyle;
      });
      return acc;
    }, {});
    themeDict.root = plain;
    themeDict.plain = __spreadProps(__spreadValues({}, plain), { backgroundColor: void 0 });
    return themeDict;
  };
  var themeToDict_default = themeToDict;
  var Highlight = ({
    children,
    language: _language,
    code: code2,
    theme: theme21,
    prism
  }) => {
    const language = _language.toLowerCase();
    const themeDictionary = themeToDict_default(theme21, language);
    const getLineProps = useGetLineProps(themeDictionary);
    const getTokenProps = useGetTokenProps(themeDictionary);
    const grammar = prism.languages[language];
    const tokens = useTokenize({ prism, language, code: code2, grammar });
    return children({
      tokens,
      className: `prism-code language-${language}`,
      style: themeDictionary != null ? themeDictionary.root : {},
      getLineProps,
      getTokenProps
    });
  };
  var Highlight2 = (props) => reactExports.createElement(Highlight, __spreadProps(__spreadValues({}, props), {
    prism: props.prism || Prism,
    theme: props.theme || vsDark_default,
    code: props.code,
    language: props.language
  }));
  /*! Bundled license information:
  
  	prismjs/prism.js:
  	  (**
  	   * Prism: Lightweight, robust, elegant syntax highlighting
  	   *
  	   * @license MIT <https://opensource.org/licenses/MIT>
  	   * @author Lea Verou <https://lea.verou.me>
  	   * @namespace
  	   * @public
  	   *)
  	*/
  function useAttribution(map, attribution) {
    const attributionRef = reactExports.useRef(attribution);
    reactExports.useEffect(function updateAttribution() {
      if (attribution !== attributionRef.current && map.attributionControl != null) {
        if (attributionRef.current != null) {
          map.attributionControl.removeAttribution(attributionRef.current);
        }
        if (attribution != null) {
          map.attributionControl.addAttribution(attribution);
        }
      }
      attributionRef.current = attribution;
    }, [
      map,
      attribution
    ]);
  }
  const CONTEXT_VERSION = 1;
  function createLeafletContext(map) {
    return Object.freeze({
      __version: CONTEXT_VERSION,
      map
    });
  }
  function extendContext(source, extra) {
    return Object.freeze({
      ...source,
      ...extra
    });
  }
  const LeafletContext = reactExports.createContext(null);
  const LeafletProvider = LeafletContext.Provider;
  function useLeafletContext() {
    const context = reactExports.useContext(LeafletContext);
    if (context == null) {
      throw new Error("No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>");
    }
    return context;
  }
  function createContainerComponent(useElement) {
    function ContainerComponent(props, forwardedRef) {
      const { instance, context } = useElement(props).current;
      reactExports.useImperativeHandle(forwardedRef, () => instance);
      return props.children == null ? null : /* @__PURE__ */ React.createElement(LeafletProvider, {
        value: context
      }, props.children);
    }
    return /* @__PURE__ */ reactExports.forwardRef(ContainerComponent);
  }
  function createDivOverlayComponent(useElement) {
    function OverlayComponent(props, forwardedRef) {
      const [isOpen, setOpen] = reactExports.useState(false);
      const { instance } = useElement(props, setOpen).current;
      reactExports.useImperativeHandle(forwardedRef, () => instance);
      reactExports.useEffect(function updateOverlay() {
        if (isOpen) {
          instance.update();
        }
      }, [
        instance,
        isOpen,
        props.children
      ]);
      const contentNode = instance._contentNode;
      return contentNode ? /* @__PURE__ */ reactDomExports.createPortal(props.children, contentNode) : null;
    }
    return /* @__PURE__ */ reactExports.forwardRef(OverlayComponent);
  }
  function createLeafComponent(useElement) {
    function LeafComponent(props, forwardedRef) {
      const { instance } = useElement(props).current;
      reactExports.useImperativeHandle(forwardedRef, () => instance);
      return null;
    }
    return /* @__PURE__ */ reactExports.forwardRef(LeafComponent);
  }
  function useEventHandlers(element2, eventHandlers) {
    const eventHandlersRef = reactExports.useRef();
    reactExports.useEffect(function addEventHandlers() {
      if (eventHandlers != null) {
        element2.instance.on(eventHandlers);
      }
      eventHandlersRef.current = eventHandlers;
      return function removeEventHandlers() {
        if (eventHandlersRef.current != null) {
          element2.instance.off(eventHandlersRef.current);
        }
        eventHandlersRef.current = null;
      };
    }, [
      element2,
      eventHandlers
    ]);
  }
  function withPane(props, context) {
    const pane = props.pane ?? context.pane;
    return pane ? {
      ...props,
      pane
    } : props;
  }
  function createDivOverlayHook(useElement, useLifecycle) {
    return function useDivOverlay(props, setOpen) {
      const context = useLeafletContext();
      const elementRef = useElement(withPane(props, context), context);
      useAttribution(context.map, props.attribution);
      useEventHandlers(elementRef.current, props.eventHandlers);
      useLifecycle(elementRef.current, context, props, setOpen);
      return elementRef;
    };
  }
  var leafletSrc = { exports: {} };
  /* @preserve
   * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
   * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
   */
  (function(module2, exports3) {
    (function(global2, factory) {
      factory(exports3);
    })(commonjsGlobal, function(exports4) {
      var version2 = "1.9.4";
      function extend2(dest) {
        var i, j, len, src;
        for (j = 1, len = arguments.length; j < len; j++) {
          src = arguments[j];
          for (i in src) {
            dest[i] = src[i];
          }
        }
        return dest;
      }
      var create$2 = Object.create || /* @__PURE__ */ function() {
        function F() {
        }
        return function(proto) {
          F.prototype = proto;
          return new F();
        };
      }();
      function bind2(fn, obj) {
        var slice = Array.prototype.slice;
        if (fn.bind) {
          return fn.bind.apply(fn, slice.call(arguments, 1));
        }
        var args = slice.call(arguments, 2);
        return function() {
          return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
      }
      var lastId = 0;
      function stamp(obj) {
        if (!("_leaflet_id" in obj)) {
          obj["_leaflet_id"] = ++lastId;
        }
        return obj._leaflet_id;
      }
      function throttle2(fn, time2, context) {
        var lock, args, wrapperFn, later;
        later = function() {
          lock = false;
          if (args) {
            wrapperFn.apply(context, args);
            args = false;
          }
        };
        wrapperFn = function() {
          if (lock) {
            args = arguments;
          } else {
            fn.apply(context, arguments);
            setTimeout(later, time2);
            lock = true;
          }
        };
        return wrapperFn;
      }
      function wrapNum(x, range, includeMax) {
        var max2 = range[1], min2 = range[0], d = max2 - min2;
        return x === max2 && includeMax ? x : ((x - min2) % d + d) % d + min2;
      }
      function falseFn() {
        return false;
      }
      function formatNum(num, precision) {
        if (precision === false) {
          return num;
        }
        var pow = Math.pow(10, precision === void 0 ? 6 : precision);
        return Math.round(num * pow) / pow;
      }
      function trim2(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function splitWords(str) {
        return trim2(str).split(/\s+/);
      }
      function setOptions(obj, options2) {
        if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
          obj.options = obj.options ? create$2(obj.options) : {};
        }
        for (var i in options2) {
          obj.options[i] = options2[i];
        }
        return obj.options;
      }
      function getParamString(obj, existingUrl, uppercase) {
        var params = [];
        for (var i in obj) {
          params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
        }
        return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
      }
      var templateRe = /\{ *([\w_ -]+) *\}/g;
      function template(str, data) {
        return str.replace(templateRe, function(str2, key) {
          var value = data[key];
          if (value === void 0) {
            throw new Error("No value provided for variable " + str2);
          } else if (typeof value === "function") {
            value = value(data);
          }
          return value;
        });
      }
      var isArray2 = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      function indexOf(array, el) {
        for (var i = 0; i < array.length; i++) {
          if (array[i] === el) {
            return i;
          }
        }
        return -1;
      }
      var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function getPrefixed(name2) {
        return window["webkit" + name2] || window["moz" + name2] || window["ms" + name2];
      }
      var lastTime = 0;
      function timeoutDefer(fn) {
        var time2 = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time2 - lastTime));
        lastTime = time2 + timeToCall;
        return window.setTimeout(fn, timeToCall);
      }
      var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
      var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id2) {
        window.clearTimeout(id2);
      };
      function requestAnimFrame(fn, context, immediate) {
        if (immediate && requestFn === timeoutDefer) {
          fn.call(context);
        } else {
          return requestFn.call(window, bind2(fn, context));
        }
      }
      function cancelAnimFrame(id2) {
        if (id2) {
          cancelFn.call(window, id2);
        }
      }
      var Util = {
        __proto__: null,
        extend: extend2,
        create: create$2,
        bind: bind2,
        get lastId() {
          return lastId;
        },
        stamp,
        throttle: throttle2,
        wrapNum,
        falseFn,
        formatNum,
        trim: trim2,
        splitWords,
        setOptions,
        getParamString,
        template,
        isArray: isArray2,
        indexOf,
        emptyImageUrl,
        requestFn,
        cancelFn,
        requestAnimFrame,
        cancelAnimFrame
      };
      function Class() {
      }
      Class.extend = function(props) {
        var NewClass = function() {
          setOptions(this);
          if (this.initialize) {
            this.initialize.apply(this, arguments);
          }
          this.callInitHooks();
        };
        var parentProto = NewClass.__super__ = this.prototype;
        var proto = create$2(parentProto);
        proto.constructor = NewClass;
        NewClass.prototype = proto;
        for (var i in this) {
          if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
            NewClass[i] = this[i];
          }
        }
        if (props.statics) {
          extend2(NewClass, props.statics);
        }
        if (props.includes) {
          checkDeprecatedMixinEvents(props.includes);
          extend2.apply(null, [proto].concat(props.includes));
        }
        extend2(proto, props);
        delete proto.statics;
        delete proto.includes;
        if (proto.options) {
          proto.options = parentProto.options ? create$2(parentProto.options) : {};
          extend2(proto.options, props.options);
        }
        proto._initHooks = [];
        proto.callInitHooks = function() {
          if (this._initHooksCalled) {
            return;
          }
          if (parentProto.callInitHooks) {
            parentProto.callInitHooks.call(this);
          }
          this._initHooksCalled = true;
          for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
            proto._initHooks[i2].call(this);
          }
        };
        return NewClass;
      };
      Class.include = function(props) {
        var parentOptions = this.prototype.options;
        extend2(this.prototype, props);
        if (props.options) {
          this.prototype.options = parentOptions;
          this.mergeOptions(props.options);
        }
        return this;
      };
      Class.mergeOptions = function(options2) {
        extend2(this.prototype.options, options2);
        return this;
      };
      Class.addInitHook = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        var init = typeof fn === "function" ? fn : function() {
          this[fn].apply(this, args);
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
      };
      function checkDeprecatedMixinEvents(includes) {
        if (typeof L === "undefined" || !L || !L.Mixin) {
          return;
        }
        includes = isArray2(includes) ? includes : [includes];
        for (var i = 0; i < includes.length; i++) {
          if (includes[i] === L.Mixin.Events) {
            console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
          }
        }
      }
      var Events = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(types2, fn, context) {
          if (typeof types2 === "object") {
            for (var type in types2) {
              this._on(type, types2[type], fn);
            }
          } else {
            types2 = splitWords(types2);
            for (var i = 0, len = types2.length; i < len; i++) {
              this._on(types2[i], fn, context);
            }
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(types2, fn, context) {
          if (!arguments.length) {
            delete this._events;
          } else if (typeof types2 === "object") {
            for (var type in types2) {
              this._off(type, types2[type], fn);
            }
          } else {
            types2 = splitWords(types2);
            var removeAll = arguments.length === 1;
            for (var i = 0, len = types2.length; i < len; i++) {
              if (removeAll) {
                this._off(types2[i]);
              } else {
                this._off(types2[i], fn, context);
              }
            }
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(type, fn, context, _once) {
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          if (this._listens(type, fn, context) !== false) {
            return;
          }
          if (context === this) {
            context = void 0;
          }
          var newListener = { fn, ctx: context };
          if (_once) {
            newListener.once = true;
          }
          this._events = this._events || {};
          this._events[type] = this._events[type] || [];
          this._events[type].push(newListener);
        },
        _off: function(type, fn, context) {
          var listeners, i, len;
          if (!this._events) {
            return;
          }
          listeners = this._events[type];
          if (!listeners) {
            return;
          }
          if (arguments.length === 1) {
            if (this._firingCount) {
              for (i = 0, len = listeners.length; i < len; i++) {
                listeners[i].fn = falseFn;
              }
            }
            delete this._events[type];
            return;
          }
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          var index3 = this._listens(type, fn, context);
          if (index3 !== false) {
            var listener = listeners[index3];
            if (this._firingCount) {
              listener.fn = falseFn;
              this._events[type] = listeners = listeners.slice();
            }
            listeners.splice(index3, 1);
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object  the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(type, data, propagate) {
          if (!this.listens(type, propagate)) {
            return this;
          }
          var event = extend2({}, data, {
            type,
            target: this,
            sourceTarget: data && data.sourceTarget || this
          });
          if (this._events) {
            var listeners = this._events[type];
            if (listeners) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var i = 0, len = listeners.length; i < len; i++) {
                var l = listeners[i];
                var fn = l.fn;
                if (l.once) {
                  this.off(type, fn, l.ctx);
                }
                fn.call(l.ctx || this, event);
              }
              this._firingCount--;
            }
          }
          if (propagate) {
            this._propagateEvent(event);
          }
          return this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(type, fn, context, propagate) {
          if (typeof type !== "string") {
            console.warn('"string" type argument expected');
          }
          var _fn = fn;
          if (typeof fn !== "function") {
            propagate = !!fn;
            _fn = void 0;
            context = void 0;
          }
          var listeners = this._events && this._events[type];
          if (listeners && listeners.length) {
            if (this._listens(type, _fn, context) !== false) {
              return true;
            }
          }
          if (propagate) {
            for (var id2 in this._eventParents) {
              if (this._eventParents[id2].listens(type, fn, context, propagate)) {
                return true;
              }
            }
          }
          return false;
        },
        // returns the index (number) or false
        _listens: function(type, fn, context) {
          if (!this._events) {
            return false;
          }
          var listeners = this._events[type] || [];
          if (!fn) {
            return !!listeners.length;
          }
          if (context === this) {
            context = void 0;
          }
          for (var i = 0, len = listeners.length; i < len; i++) {
            if (listeners[i].fn === fn && listeners[i].ctx === context) {
              return i;
            }
          }
          return false;
        },
        // @method once(): this
        // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
        once: function(types2, fn, context) {
          if (typeof types2 === "object") {
            for (var type in types2) {
              this._on(type, types2[type], fn, true);
            }
          } else {
            types2 = splitWords(types2);
            for (var i = 0, len = types2.length; i < len; i++) {
              this._on(types2[i], fn, context, true);
            }
          }
          return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(obj) {
          this._eventParents = this._eventParents || {};
          this._eventParents[stamp(obj)] = obj;
          return this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(obj) {
          if (this._eventParents) {
            delete this._eventParents[stamp(obj)];
          }
          return this;
        },
        _propagateEvent: function(e) {
          for (var id2 in this._eventParents) {
            this._eventParents[id2].fire(e.type, extend2({
              layer: e.target,
              propagatedFrom: e.target
            }, e), true);
          }
        }
      };
      Events.addEventListener = Events.on;
      Events.removeEventListener = Events.clearAllEventListeners = Events.off;
      Events.addOneTimeEventListener = Events.once;
      Events.fireEvent = Events.fire;
      Events.hasEventListeners = Events.listens;
      var Evented = Class.extend(Events);
      function Point(x, y, round2) {
        this.x = round2 ? Math.round(x) : x;
        this.y = round2 ? Math.round(y) : y;
      }
      var trunc = Math.trunc || function(v) {
        return v > 0 ? Math.floor(v) : Math.ceil(v);
      };
      Point.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new Point(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(point2) {
          return this.clone()._add(toPoint(point2));
        },
        _add: function(point2) {
          this.x += point2.x;
          this.y += point2.y;
          return this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(point2) {
          return this.clone()._subtract(toPoint(point2));
        },
        _subtract: function(point2) {
          this.x -= point2.x;
          this.y -= point2.y;
          return this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(num) {
          return this.clone()._divideBy(num);
        },
        _divideBy: function(num) {
          this.x /= num;
          this.y /= num;
          return this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(num) {
          return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function(num) {
          this.x *= num;
          this.y *= num;
          return this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(point2) {
          return new Point(this.x * point2.x, this.y * point2.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(point2) {
          return new Point(this.x / point2.x, this.y / point2.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          this.x = trunc(this.x);
          this.y = trunc(this.y);
          return this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(point2) {
          point2 = toPoint(point2);
          var x = point2.x - this.x, y = point2.y - this.y;
          return Math.sqrt(x * x + y * y);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(point2) {
          point2 = toPoint(point2);
          return point2.x === this.x && point2.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(point2) {
          point2 = toPoint(point2);
          return Math.abs(point2.x) <= Math.abs(this.x) && Math.abs(point2.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
        }
      };
      function toPoint(x, y, round2) {
        if (x instanceof Point) {
          return x;
        }
        if (isArray2(x)) {
          return new Point(x[0], x[1]);
        }
        if (x === void 0 || x === null) {
          return x;
        }
        if (typeof x === "object" && "x" in x && "y" in x) {
          return new Point(x.x, x.y);
        }
        return new Point(x, y, round2);
      }
      function Bounds(a, b) {
        if (!a) {
          return;
        }
        var points = b ? [a, b] : a;
        for (var i = 0, len = points.length; i < len; i++) {
          this.extend(points[i]);
        }
      }
      Bounds.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var min2, max2;
          if (!obj) {
            return this;
          }
          if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
            min2 = max2 = toPoint(obj);
          } else {
            obj = toBounds(obj);
            min2 = obj.min;
            max2 = obj.max;
            if (!min2 || !max2) {
              return this;
            }
          }
          if (!this.min && !this.max) {
            this.min = min2.clone();
            this.max = max2.clone();
          } else {
            this.min.x = Math.min(min2.x, this.min.x);
            this.max.x = Math.max(max2.x, this.max.x);
            this.min.y = Math.min(min2.y, this.min.y);
            this.max.y = Math.max(max2.y, this.max.y);
          }
          return this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(round2) {
          return toPoint(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            round2
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return toPoint(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return toPoint(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          var min2, max2;
          if (typeof obj[0] === "number" || obj instanceof Point) {
            obj = toPoint(obj);
          } else {
            obj = toBounds(obj);
          }
          if (obj instanceof Bounds) {
            min2 = obj.min;
            max2 = obj.max;
          } else {
            min2 = max2 = obj;
          }
          return min2.x >= this.min.x && max2.x <= this.max.x && min2.y >= this.min.y && max2.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toBounds(bounds);
          var min2 = this.min, max2 = this.max, min22 = bounds.min, max22 = bounds.max, xIntersects = max22.x >= min2.x && min22.x <= max2.x, yIntersects = max22.y >= min2.y && min22.y <= max2.y;
          return xIntersects && yIntersects;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toBounds(bounds);
          var min2 = this.min, max2 = this.max, min22 = bounds.min, max22 = bounds.max, xOverlaps = max22.x > min2.x && min22.x < max2.x, yOverlaps = max22.y > min2.y && min22.y < max2.y;
          return xOverlaps && yOverlaps;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var min2 = this.min, max2 = this.max, heightBuffer = Math.abs(min2.x - max2.x) * bufferRatio, widthBuffer = Math.abs(min2.y - max2.y) * bufferRatio;
          return toBounds(
            toPoint(min2.x - heightBuffer, min2.y - widthBuffer),
            toPoint(max2.x + heightBuffer, max2.y + widthBuffer)
          );
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function(bounds) {
          if (!bounds) {
            return false;
          }
          bounds = toBounds(bounds);
          return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
        }
      };
      function toBounds(a, b) {
        if (!a || a instanceof Bounds) {
          return a;
        }
        return new Bounds(a, b);
      }
      function LatLngBounds(corner1, corner2) {
        if (!corner1) {
          return;
        }
        var latlngs = corner2 ? [corner1, corner2] : corner1;
        for (var i = 0, len = latlngs.length; i < len; i++) {
          this.extend(latlngs[i]);
        }
      }
      LatLngBounds.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLng) {
            sw2 = obj;
            ne2 = obj;
          } else if (obj instanceof LatLngBounds) {
            sw2 = obj._southWest;
            ne2 = obj._northEast;
            if (!sw2 || !ne2) {
              return this;
            }
          } else {
            return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
          }
          if (!sw && !ne) {
            this._southWest = new LatLng(sw2.lat, sw2.lng);
            this._northEast = new LatLng(ne2.lat, ne2.lng);
          } else {
            sw.lat = Math.min(sw2.lat, sw.lat);
            sw.lng = Math.min(sw2.lng, sw.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
          }
          return this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
          return new LatLngBounds(
            new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
            new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new LatLng(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new LatLng(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new LatLng(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
            obj = toLatLng(obj);
          } else {
            obj = toLatLngBounds(obj);
          }
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLngBounds) {
            sw2 = obj.getSouthWest();
            ne2 = obj.getNorthEast();
          } else {
            sw2 = ne2 = obj;
          }
          return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
          return latIntersects && lngIntersects;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
          return latOverlaps && lngOverlaps;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(bounds, maxMargin) {
          if (!bounds) {
            return false;
          }
          bounds = toLatLngBounds(bounds);
          return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function toLatLngBounds(a, b) {
        if (a instanceof LatLngBounds) {
          return a;
        }
        return new LatLngBounds(a, b);
      }
      function LatLng(lat, lng, alt) {
        if (isNaN(lat) || isNaN(lng)) {
          throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
        }
        this.lat = +lat;
        this.lng = +lng;
        if (alt !== void 0) {
          this.alt = +alt;
        }
      }
      LatLng.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(obj, maxMargin) {
          if (!obj) {
            return false;
          }
          obj = toLatLng(obj);
          var margin = Math.max(
            Math.abs(this.lat - obj.lat),
            Math.abs(this.lng - obj.lng)
          );
          return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(precision) {
          return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(other) {
          return Earth.distance(this, toLatLng(other));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return Earth.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(sizeInMeters) {
          var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
          return toLatLngBounds(
            [this.lat - latAccuracy, this.lng - lngAccuracy],
            [this.lat + latAccuracy, this.lng + lngAccuracy]
          );
        },
        clone: function() {
          return new LatLng(this.lat, this.lng, this.alt);
        }
      };
      function toLatLng(a, b, c) {
        if (a instanceof LatLng) {
          return a;
        }
        if (isArray2(a) && typeof a[0] !== "object") {
          if (a.length === 3) {
            return new LatLng(a[0], a[1], a[2]);
          }
          if (a.length === 2) {
            return new LatLng(a[0], a[1]);
          }
          return null;
        }
        if (a === void 0 || a === null) {
          return a;
        }
        if (typeof a === "object" && "lat" in a) {
          return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
        }
        if (b === void 0) {
          return null;
        }
        return new LatLng(a, b, c);
      }
      var CRS = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(latlng, zoom2) {
          var projectedPoint = this.projection.project(latlng), scale3 = this.scale(zoom2);
          return this.transformation._transform(projectedPoint, scale3);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(point2, zoom2) {
          var scale3 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point2, scale3);
          return this.projection.unproject(untransformedPoint);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(latlng) {
          return this.projection.project(latlng);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(point2) {
          return this.projection.unproject(point2);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(zoom2) {
          return 256 * Math.pow(2, zoom2);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(scale3) {
          return Math.log(scale3 / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(zoom2) {
          if (this.infinite) {
            return null;
          }
          var b = this.projection.bounds, s = this.scale(zoom2), min2 = this.transformation.transform(b.min, s), max2 = this.transformation.transform(b.max, s);
          return new Bounds(min2, max2);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: false,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(latlng) {
          var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
          return new LatLng(lat, lng, alt);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(bounds) {
          var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
          if (latShift === 0 && lngShift === 0) {
            return bounds;
          }
          var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
          return new LatLngBounds(newSw, newNe);
        }
      };
      var Earth = extend2({}, CRS, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(latlng1, latlng2) {
          var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return this.R * c;
        }
      });
      var earthRadius = 6378137;
      var SphericalMercator = {
        R: earthRadius,
        MAX_LATITUDE: 85.0511287798,
        project: function(latlng) {
          var d = Math.PI / 180, max2 = this.MAX_LATITUDE, lat = Math.max(Math.min(max2, latlng.lat), -max2), sin = Math.sin(lat * d);
          return new Point(
            this.R * latlng.lng * d,
            this.R * Math.log((1 + sin) / (1 - sin)) / 2
          );
        },
        unproject: function(point2) {
          var d = 180 / Math.PI;
          return new LatLng(
            (2 * Math.atan(Math.exp(point2.y / this.R)) - Math.PI / 2) * d,
            point2.x * d / this.R
          );
        },
        bounds: function() {
          var d = earthRadius * Math.PI;
          return new Bounds([-d, -d], [d, d]);
        }()
      };
      function Transformation(a, b, c, d) {
        if (isArray2(a)) {
          this._a = a[0];
          this._b = a[1];
          this._c = a[2];
          this._d = a[3];
          return;
        }
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
      }
      Transformation.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(point2, scale3) {
          return this._transform(point2.clone(), scale3);
        },
        // destructive transform (faster)
        _transform: function(point2, scale3) {
          scale3 = scale3 || 1;
          point2.x = scale3 * (this._a * point2.x + this._b);
          point2.y = scale3 * (this._c * point2.y + this._d);
          return point2;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(point2, scale3) {
          scale3 = scale3 || 1;
          return new Point(
            (point2.x / scale3 - this._b) / this._a,
            (point2.y / scale3 - this._d) / this._c
          );
        }
      };
      function toTransformation(a, b, c, d) {
        return new Transformation(a, b, c, d);
      }
      var EPSG3857 = extend2({}, Earth, {
        code: "EPSG:3857",
        projection: SphericalMercator,
        transformation: function() {
          var scale3 = 0.5 / (Math.PI * SphericalMercator.R);
          return toTransformation(scale3, 0.5, -scale3, 0.5);
        }()
      });
      var EPSG900913 = extend2({}, EPSG3857, {
        code: "EPSG:900913"
      });
      function svgCreate(name2) {
        return document.createElementNS("http://www.w3.org/2000/svg", name2);
      }
      function pointsToPath(rings, closed) {
        var str = "", i, j, len, len2, points, p;
        for (i = 0, len = rings.length; i < len; i++) {
          points = rings[i];
          for (j = 0, len2 = points.length; j < len2; j++) {
            p = points[j];
            str += (j ? "L" : "M") + p.x + " " + p.y;
          }
          str += closed ? Browser.svg ? "z" : "x" : "";
        }
        return str || "M0 0";
      }
      var style = document.documentElement.style;
      var ie = "ActiveXObject" in window;
      var ielt9 = ie && !document.addEventListener;
      var edge = "msLaunchUri" in navigator && !("documentMode" in document);
      var webkit = userAgentContains2("webkit");
      var android = userAgentContains2("android");
      var android23 = userAgentContains2("android 2") || userAgentContains2("android 3");
      var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
      var androidStock = android && userAgentContains2("Google") && webkitVer < 537 && !("AudioNode" in window);
      var opera = !!window.opera;
      var chrome2 = !edge && userAgentContains2("chrome");
      var gecko = userAgentContains2("gecko") && !webkit && !opera && !ie;
      var safari = !chrome2 && userAgentContains2("safari");
      var phantom = userAgentContains2("phantom");
      var opera12 = "OTransition" in style;
      var win = navigator.platform.indexOf("Win") === 0;
      var ie3d = ie && "transition" in style;
      var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
      var gecko3d = "MozPerspective" in style;
      var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
      var mobile = typeof orientation !== "undefined" || userAgentContains2("mobile");
      var mobileWebkit = mobile && webkit;
      var mobileWebkit3d = mobile && webkit3d;
      var msPointer = !window.PointerEvent && window.MSPointerEvent;
      var pointer = !!(window.PointerEvent || msPointer);
      var touchNative = "ontouchstart" in window || !!window.TouchEvent;
      var touch = !window.L_NO_TOUCH && (touchNative || pointer);
      var mobileOpera = mobile && opera;
      var mobileGecko = mobile && gecko;
      var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
      var passiveEvents = function() {
        var supportsPassiveOption = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassiveOption = true;
            }
          });
          window.addEventListener("testPassiveEventSupport", falseFn, opts);
          window.removeEventListener("testPassiveEventSupport", falseFn, opts);
        } catch (e) {
        }
        return supportsPassiveOption;
      }();
      var canvas$1 = function() {
        return !!document.createElement("canvas").getContext;
      }();
      var svg$12 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
      var inlineSvg = !!svg$12 && function() {
        var div = document.createElement("div");
        div.innerHTML = "<svg/>";
        return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }();
      var vml = !svg$12 && function() {
        try {
          var div = document.createElement("div");
          div.innerHTML = '<v:shape adj="1"/>';
          var shape = div.firstChild;
          shape.style.behavior = "url(#default#VML)";
          return shape && typeof shape.adj === "object";
        } catch (e) {
          return false;
        }
      }();
      var mac = navigator.platform.indexOf("Mac") === 0;
      var linux = navigator.platform.indexOf("Linux") === 0;
      function userAgentContains2(str) {
        return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
      }
      var Browser = {
        ie,
        ielt9,
        edge,
        webkit,
        android,
        android23,
        androidStock,
        opera,
        chrome: chrome2,
        gecko,
        safari,
        phantom,
        opera12,
        win,
        ie3d,
        webkit3d,
        gecko3d,
        any3d,
        mobile,
        mobileWebkit,
        mobileWebkit3d,
        msPointer,
        pointer,
        touch,
        touchNative,
        mobileOpera,
        mobileGecko,
        retina,
        passiveEvents,
        canvas: canvas$1,
        svg: svg$12,
        vml,
        inlineSvg,
        mac,
        linux
      };
      var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
      var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
      var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
      var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
      var pEvent = {
        touchstart: POINTER_DOWN,
        touchmove: POINTER_MOVE,
        touchend: POINTER_UP,
        touchcancel: POINTER_CANCEL
      };
      var handle = {
        touchstart: _onPointerStart,
        touchmove: _handlePointer,
        touchend: _handlePointer,
        touchcancel: _handlePointer
      };
      var _pointers = {};
      var _pointerDocListener = false;
      function addPointerListener(obj, type, handler) {
        if (type === "touchstart") {
          _addPointerDocListener();
        }
        if (!handle[type]) {
          console.warn("wrong event specified:", type);
          return falseFn;
        }
        handler = handle[type].bind(this, handler);
        obj.addEventListener(pEvent[type], handler, false);
        return handler;
      }
      function removePointerListener(obj, type, handler) {
        if (!pEvent[type]) {
          console.warn("wrong event specified:", type);
          return;
        }
        obj.removeEventListener(pEvent[type], handler, false);
      }
      function _globalPointerDown(e) {
        _pointers[e.pointerId] = e;
      }
      function _globalPointerMove(e) {
        if (_pointers[e.pointerId]) {
          _pointers[e.pointerId] = e;
        }
      }
      function _globalPointerUp(e) {
        delete _pointers[e.pointerId];
      }
      function _addPointerDocListener() {
        if (!_pointerDocListener) {
          document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
          document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
          document.addEventListener(POINTER_UP, _globalPointerUp, true);
          document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
          _pointerDocListener = true;
        }
      }
      function _handlePointer(handler, e) {
        if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
          return;
        }
        e.touches = [];
        for (var i in _pointers) {
          e.touches.push(_pointers[i]);
        }
        e.changedTouches = [e];
        handler(e);
      }
      function _onPointerStart(handler, e) {
        if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
          preventDefault(e);
        }
        _handlePointer(handler, e);
      }
      function makeDblclick(event) {
        var newEvent = {}, prop, i;
        for (i in event) {
          prop = event[i];
          newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
        }
        event = newEvent;
        newEvent.type = "dblclick";
        newEvent.detail = 2;
        newEvent.isTrusted = false;
        newEvent._simulated = true;
        return newEvent;
      }
      var delay2 = 200;
      function addDoubleTapListener(obj, handler) {
        obj.addEventListener("dblclick", handler);
        var last = 0, detail;
        function simDblclick(e) {
          if (e.detail !== 1) {
            detail = e.detail;
            return;
          }
          if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
            return;
          }
          var path = getPropagationPath(e);
          if (path.some(function(el) {
            return el instanceof HTMLLabelElement && el.attributes.for;
          }) && !path.some(function(el) {
            return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
          })) {
            return;
          }
          var now2 = Date.now();
          if (now2 - last <= delay2) {
            detail++;
            if (detail === 2) {
              handler(makeDblclick(e));
            }
          } else {
            detail = 1;
          }
          last = now2;
        }
        obj.addEventListener("click", simDblclick);
        return {
          dblclick: handler,
          simDblclick
        };
      }
      function removeDoubleTapListener(obj, handlers2) {
        obj.removeEventListener("dblclick", handlers2.dblclick);
        obj.removeEventListener("click", handlers2.simDblclick);
      }
      var TRANSFORM = testProp(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      );
      var TRANSITION = testProp(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      );
      var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
      function get(id2) {
        return typeof id2 === "string" ? document.getElementById(id2) : id2;
      }
      function getStyle(el, style2) {
        var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
        if ((!value || value === "auto") && document.defaultView) {
          var css = document.defaultView.getComputedStyle(el, null);
          value = css ? css[style2] : null;
        }
        return value === "auto" ? null : value;
      }
      function create$1(tagName, className, container) {
        var el = document.createElement(tagName);
        el.className = className || "";
        if (container) {
          container.appendChild(el);
        }
        return el;
      }
      function remove(el) {
        var parent = el.parentNode;
        if (parent) {
          parent.removeChild(el);
        }
      }
      function empty2(el) {
        while (el.firstChild) {
          el.removeChild(el.firstChild);
        }
      }
      function toFront(el) {
        var parent = el.parentNode;
        if (parent && parent.lastChild !== el) {
          parent.appendChild(el);
        }
      }
      function toBack(el) {
        var parent = el.parentNode;
        if (parent && parent.firstChild !== el) {
          parent.insertBefore(el, parent.firstChild);
        }
      }
      function hasClass(el, name2) {
        if (el.classList !== void 0) {
          return el.classList.contains(name2);
        }
        var className = getClass(el);
        return className.length > 0 && new RegExp("(^|\\s)" + name2 + "(\\s|$)").test(className);
      }
      function addClass(el, name2) {
        if (el.classList !== void 0) {
          var classes = splitWords(name2);
          for (var i = 0, len = classes.length; i < len; i++) {
            el.classList.add(classes[i]);
          }
        } else if (!hasClass(el, name2)) {
          var className = getClass(el);
          setClass(el, (className ? className + " " : "") + name2);
        }
      }
      function removeClass(el, name2) {
        if (el.classList !== void 0) {
          el.classList.remove(name2);
        } else {
          setClass(el, trim2((" " + getClass(el) + " ").replace(" " + name2 + " ", " ")));
        }
      }
      function setClass(el, name2) {
        if (el.className.baseVal === void 0) {
          el.className = name2;
        } else {
          el.className.baseVal = name2;
        }
      }
      function getClass(el) {
        if (el.correspondingElement) {
          el = el.correspondingElement;
        }
        return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
      }
      function setOpacity(el, value) {
        if ("opacity" in el.style) {
          el.style.opacity = value;
        } else if ("filter" in el.style) {
          _setOpacityIE(el, value);
        }
      }
      function _setOpacityIE(el, value) {
        var filter2 = false, filterName = "DXImageTransform.Microsoft.Alpha";
        try {
          filter2 = el.filters.item(filterName);
        } catch (e) {
          if (value === 1) {
            return;
          }
        }
        value = Math.round(value * 100);
        if (filter2) {
          filter2.Enabled = value !== 100;
          filter2.Opacity = value;
        } else {
          el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
        }
      }
      function testProp(props) {
        var style2 = document.documentElement.style;
        for (var i = 0; i < props.length; i++) {
          if (props[i] in style2) {
            return props[i];
          }
        }
        return false;
      }
      function setTransform(el, offset2, scale3) {
        var pos = offset2 || new Point(0, 0);
        el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale3 ? " scale(" + scale3 + ")" : "");
      }
      function setPosition(el, point2) {
        el._leaflet_pos = point2;
        if (Browser.any3d) {
          setTransform(el, point2);
        } else {
          el.style.left = point2.x + "px";
          el.style.top = point2.y + "px";
        }
      }
      function getPosition(el) {
        return el._leaflet_pos || new Point(0, 0);
      }
      var disableTextSelection;
      var enableTextSelection;
      var _userSelect;
      if ("onselectstart" in document) {
        disableTextSelection = function() {
          on(window, "selectstart", preventDefault);
        };
        enableTextSelection = function() {
          off(window, "selectstart", preventDefault);
        };
      } else {
        var userSelectProperty = testProp(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        disableTextSelection = function() {
          if (userSelectProperty) {
            var style2 = document.documentElement.style;
            _userSelect = style2[userSelectProperty];
            style2[userSelectProperty] = "none";
          }
        };
        enableTextSelection = function() {
          if (userSelectProperty) {
            document.documentElement.style[userSelectProperty] = _userSelect;
            _userSelect = void 0;
          }
        };
      }
      function disableImageDrag() {
        on(window, "dragstart", preventDefault);
      }
      function enableImageDrag() {
        off(window, "dragstart", preventDefault);
      }
      var _outlineElement, _outlineStyle;
      function preventOutline(element2) {
        while (element2.tabIndex === -1) {
          element2 = element2.parentNode;
        }
        if (!element2.style) {
          return;
        }
        restoreOutline();
        _outlineElement = element2;
        _outlineStyle = element2.style.outlineStyle;
        element2.style.outlineStyle = "none";
        on(window, "keydown", restoreOutline);
      }
      function restoreOutline() {
        if (!_outlineElement) {
          return;
        }
        _outlineElement.style.outlineStyle = _outlineStyle;
        _outlineElement = void 0;
        _outlineStyle = void 0;
        off(window, "keydown", restoreOutline);
      }
      function getSizedParentNode(element2) {
        do {
          element2 = element2.parentNode;
        } while ((!element2.offsetWidth || !element2.offsetHeight) && element2 !== document.body);
        return element2;
      }
      function getScale2(element2) {
        var rect = element2.getBoundingClientRect();
        return {
          x: rect.width / element2.offsetWidth || 1,
          y: rect.height / element2.offsetHeight || 1,
          boundingClientRect: rect
        };
      }
      var DomUtil = {
        __proto__: null,
        TRANSFORM,
        TRANSITION,
        TRANSITION_END,
        get,
        getStyle,
        create: create$1,
        remove,
        empty: empty2,
        toFront,
        toBack,
        hasClass,
        addClass,
        removeClass,
        setClass,
        getClass,
        setOpacity,
        testProp,
        setTransform,
        setPosition,
        getPosition,
        get disableTextSelection() {
          return disableTextSelection;
        },
        get enableTextSelection() {
          return enableTextSelection;
        },
        disableImageDrag,
        enableImageDrag,
        preventOutline,
        restoreOutline,
        getSizedParentNode,
        getScale: getScale2
      };
      function on(obj, types2, fn, context) {
        if (types2 && typeof types2 === "object") {
          for (var type in types2) {
            addOne(obj, type, types2[type], fn);
          }
        } else {
          types2 = splitWords(types2);
          for (var i = 0, len = types2.length; i < len; i++) {
            addOne(obj, types2[i], fn, context);
          }
        }
        return this;
      }
      var eventsKey = "_leaflet_events";
      function off(obj, types2, fn, context) {
        if (arguments.length === 1) {
          batchRemove(obj);
          delete obj[eventsKey];
        } else if (types2 && typeof types2 === "object") {
          for (var type in types2) {
            removeOne(obj, type, types2[type], fn);
          }
        } else {
          types2 = splitWords(types2);
          if (arguments.length === 2) {
            batchRemove(obj, function(type2) {
              return indexOf(types2, type2) !== -1;
            });
          } else {
            for (var i = 0, len = types2.length; i < len; i++) {
              removeOne(obj, types2[i], fn, context);
            }
          }
        }
        return this;
      }
      function batchRemove(obj, filterFn) {
        for (var id2 in obj[eventsKey]) {
          var type = id2.split(/\d/)[0];
          if (!filterFn || filterFn(type)) {
            removeOne(obj, type, null, null, id2);
          }
        }
      }
      var mouseSubst = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function addOne(obj, type, fn, context) {
        var id2 = type + stamp(fn) + (context ? "_" + stamp(context) : "");
        if (obj[eventsKey] && obj[eventsKey][id2]) {
          return this;
        }
        var handler = function(e) {
          return fn.call(context || obj, e || window.event);
        };
        var originalHandler = handler;
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
          handler = addPointerListener(obj, type, handler);
        } else if (Browser.touch && type === "dblclick") {
          handler = addDoubleTapListener(obj, handler);
        } else if ("addEventListener" in obj) {
          if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
            obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);
          } else if (type === "mouseenter" || type === "mouseleave") {
            handler = function(e) {
              e = e || window.event;
              if (isExternalTarget(obj, e)) {
                originalHandler(e);
              }
            };
            obj.addEventListener(mouseSubst[type], handler, false);
          } else {
            obj.addEventListener(type, originalHandler, false);
          }
        } else {
          obj.attachEvent("on" + type, handler);
        }
        obj[eventsKey] = obj[eventsKey] || {};
        obj[eventsKey][id2] = handler;
      }
      function removeOne(obj, type, fn, context, id2) {
        id2 = id2 || type + stamp(fn) + (context ? "_" + stamp(context) : "");
        var handler = obj[eventsKey] && obj[eventsKey][id2];
        if (!handler) {
          return this;
        }
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
          removePointerListener(obj, type, handler);
        } else if (Browser.touch && type === "dblclick") {
          removeDoubleTapListener(obj, handler);
        } else if ("removeEventListener" in obj) {
          obj.removeEventListener(mouseSubst[type] || type, handler, false);
        } else {
          obj.detachEvent("on" + type, handler);
        }
        obj[eventsKey][id2] = null;
      }
      function stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else if (e.originalEvent) {
          e.originalEvent._stopped = true;
        } else {
          e.cancelBubble = true;
        }
        return this;
      }
      function disableScrollPropagation(el) {
        addOne(el, "wheel", stopPropagation);
        return this;
      }
      function disableClickPropagation(el) {
        on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
        el["_leaflet_disable_click"] = true;
        return this;
      }
      function preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
        return this;
      }
      function stop(e) {
        preventDefault(e);
        stopPropagation(e);
        return this;
      }
      function getPropagationPath(ev) {
        if (ev.composedPath) {
          return ev.composedPath();
        }
        var path = [];
        var el = ev.target;
        while (el) {
          path.push(el);
          el = el.parentNode;
        }
        return path;
      }
      function getMousePosition(e, container) {
        if (!container) {
          return new Point(e.clientX, e.clientY);
        }
        var scale3 = getScale2(container), offset2 = scale3.boundingClientRect;
        return new Point(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (e.clientX - offset2.left) / scale3.x - container.clientLeft,
          (e.clientY - offset2.top) / scale3.y - container.clientTop
        );
      }
      var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function getWheelDelta(e) {
        return Browser.edge ? e.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : (
            // Pixels
            e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : (
              // Lines
              e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : (
                // Pages
                e.deltaX || e.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : (
                      // Legacy Moz lines
                      e.detail ? e.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function isExternalTarget(el, e) {
        var related = e.relatedTarget;
        if (!related) {
          return true;
        }
        try {
          while (related && related !== el) {
            related = related.parentNode;
          }
        } catch (err) {
          return false;
        }
        return related !== el;
      }
      var DomEvent = {
        __proto__: null,
        on,
        off,
        stopPropagation,
        disableScrollPropagation,
        disableClickPropagation,
        preventDefault,
        stop,
        getPropagationPath,
        getMousePosition,
        getWheelDelta,
        isExternalTarget,
        addListener: on,
        removeListener: off
      };
      var PosAnimation = Evented.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(el, newPos, duration, easeLinearity) {
          this.stop();
          this._el = el;
          this._inProgress = true;
          this._duration = duration || 0.25;
          this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
          this._startPos = getPosition(el);
          this._offset = newPos.subtract(this._startPos);
          this._startTime = +/* @__PURE__ */ new Date();
          this.fire("start");
          this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          if (!this._inProgress) {
            return;
          }
          this._step(true);
          this._complete();
        },
        _animate: function() {
          this._animId = requestAnimFrame(this._animate, this);
          this._step();
        },
        _step: function(round2) {
          var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
          if (elapsed < duration) {
            this._runFrame(this._easeOut(elapsed / duration), round2);
          } else {
            this._runFrame(1);
            this._complete();
          }
        },
        _runFrame: function(progress2, round2) {
          var pos = this._startPos.add(this._offset.multiplyBy(progress2));
          if (round2) {
            pos._round();
          }
          setPosition(this._el, pos);
          this.fire("step");
        },
        _complete: function() {
          cancelAnimFrame(this._animId);
          this._inProgress = false;
          this.fire("end");
        },
        _easeOut: function(t) {
          return 1 - Math.pow(1 - t, this._easeOutPower);
        }
      });
      var Map2 = Evented.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: EPSG3857,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: true,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: true,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: true,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: true
        },
        initialize: function(id2, options2) {
          options2 = setOptions(this, options2);
          this._handlers = [];
          this._layers = {};
          this._zoomBoundLayers = {};
          this._sizeChanged = true;
          this._initContainer(id2);
          this._initLayout();
          this._onResize = bind2(this._onResize, this);
          this._initEvents();
          if (options2.maxBounds) {
            this.setMaxBounds(options2.maxBounds);
          }
          if (options2.zoom !== void 0) {
            this._zoom = this._limitZoom(options2.zoom);
          }
          if (options2.center && options2.zoom !== void 0) {
            this.setView(toLatLng(options2.center), options2.zoom, { reset: true });
          }
          this.callInitHooks();
          this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
          if (this._zoomAnimated) {
            this._createAnimProxy();
            on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
          }
          this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(center, zoom2, options2) {
          zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
          center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
          options2 = options2 || {};
          this._stop();
          if (this._loaded && !options2.reset && options2 !== true) {
            if (options2.animate !== void 0) {
              options2.zoom = extend2({ animate: options2.animate }, options2.zoom);
              options2.pan = extend2({ animate: options2.animate, duration: options2.duration }, options2.pan);
            }
            var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options2.zoom) : this._tryAnimatedPan(center, options2.pan);
            if (moved) {
              clearTimeout(this._sizeTimer);
              return this;
            }
          }
          this._resetView(center, zoom2, options2.pan && options2.pan.noMoveStart);
          return this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(zoom2, options2) {
          if (!this._loaded) {
            this._zoom = zoom2;
            return this;
          }
          return this.setView(this.getCenter(), zoom2, { zoom: options2 });
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(delta, options2) {
          delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom + delta, options2);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(delta, options2) {
          delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom - delta, options2);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(latlng, zoom2, options2) {
          var scale3 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale3), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
          return this.setView(newCenter, zoom2, { zoom: options2 });
        },
        _getBoundsCenterZoom: function(bounds, options2) {
          options2 = options2 || {};
          bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
          var paddingTL = toPoint(options2.paddingTopLeft || options2.padding || [0, 0]), paddingBR = toPoint(options2.paddingBottomRight || options2.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
          zoom2 = typeof options2.maxZoom === "number" ? Math.min(options2.maxZoom, zoom2) : zoom2;
          if (zoom2 === Infinity) {
            return {
              center: bounds.getCenter(),
              zoom: zoom2
            };
          }
          var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
          return {
            center,
            zoom: zoom2
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(bounds, options2) {
          bounds = toLatLngBounds(bounds);
          if (!bounds.isValid()) {
            throw new Error("Bounds are not valid.");
          }
          var target = this._getBoundsCenterZoom(bounds, options2);
          return this.setView(target.center, target.zoom, options2);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(options2) {
          return this.fitBounds([[-90, -180], [90, 180]], options2);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(center, options2) {
          return this.setView(center, this._zoom, { pan: options2 });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(offset2, options2) {
          offset2 = toPoint(offset2).round();
          options2 = options2 || {};
          if (!offset2.x && !offset2.y) {
            return this.fire("moveend");
          }
          if (options2.animate !== true && !this.getSize().contains(offset2)) {
            this._resetView(this.unproject(this.project(this.getCenter()).add(offset2)), this.getZoom());
            return this;
          }
          if (!this._panAnim) {
            this._panAnim = new PosAnimation();
            this._panAnim.on({
              "step": this._onPanTransitionStep,
              "end": this._onPanTransitionEnd
            }, this);
          }
          if (!options2.noMoveStart) {
            this.fire("movestart");
          }
          if (options2.animate !== false) {
            addClass(this._mapPane, "leaflet-pan-anim");
            var newPos = this._getMapPanePos().subtract(offset2).round();
            this._panAnim.run(this._mapPane, newPos, options2.duration || 0.25, options2.easeLinearity);
          } else {
            this._rawPanBy(offset2);
            this.fire("move").fire("moveend");
          }
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(targetCenter, targetZoom, options2) {
          options2 = options2 || {};
          if (options2.animate === false || !Browser.any3d) {
            return this.setView(targetCenter, targetZoom, options2);
          }
          this._stop();
          var from = this.project(this.getCenter()), to = this.project(targetCenter), size2 = this.getSize(), startZoom = this._zoom;
          targetCenter = toLatLng(targetCenter);
          targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
          var w0 = Math.max(size2.x, size2.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
          function r2(i) {
            var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
            var log = sq < 1e-9 ? -18 : Math.log(sq);
            return log;
          }
          function sinh(n) {
            return (Math.exp(n) - Math.exp(-n)) / 2;
          }
          function cosh(n) {
            return (Math.exp(n) + Math.exp(-n)) / 2;
          }
          function tanh(n) {
            return sinh(n) / cosh(n);
          }
          var r0 = r2(0);
          function w(s) {
            return w0 * (cosh(r0) / cosh(r0 + rho * s));
          }
          function u(s) {
            return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
          }
          function easeOut2(t) {
            return 1 - Math.pow(1 - t, 1.5);
          }
          var start = Date.now(), S = (r2(1) - r0) / rho, duration = options2.duration ? 1e3 * options2.duration : 1e3 * S * 0.8;
          function frame2() {
            var t = (Date.now() - start) / duration, s = easeOut2(t) * S;
            if (t <= 1) {
              this._flyToFrame = requestAnimFrame(frame2, this);
              this._move(
                this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
                this.getScaleZoom(w0 / w(s), startZoom),
                { flyTo: true }
              );
            } else {
              this._move(targetCenter, targetZoom)._moveEnd(true);
            }
          }
          this._moveStart(true, options2.noMoveStart);
          frame2.call(this);
          return this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(bounds, options2) {
          var target = this._getBoundsCenterZoom(bounds, options2);
          return this.flyTo(target.center, target.zoom, options2);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(bounds) {
          bounds = toLatLngBounds(bounds);
          if (this.listens("moveend", this._panInsideMaxBounds)) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (!bounds.isValid()) {
            this.options.maxBounds = null;
            return this;
          }
          this.options.maxBounds = bounds;
          if (this._loaded) {
            this._panInsideMaxBounds();
          }
          return this.on("moveend", this._panInsideMaxBounds);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(zoom2) {
          var oldZoom = this.options.minZoom;
          this.options.minZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() < this.options.minZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(zoom2) {
          var oldZoom = this.options.maxZoom;
          this.options.maxZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() > this.options.maxZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(bounds, options2) {
          this._enforcingBounds = true;
          var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
          if (!center.equals(newCenter)) {
            this.panTo(newCenter, options2);
          }
          this._enforcingBounds = false;
          return this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(latlng, options2) {
          options2 = options2 || {};
          var paddingTL = toPoint(options2.paddingTopLeft || options2.padding || [0, 0]), paddingBR = toPoint(options2.paddingBottomRight || options2.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
          if (!paddedBounds.contains(pixelPoint)) {
            this._enforcingBounds = true;
            var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
            var offset2 = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
            pixelCenter.x += centerOffset.x < 0 ? -offset2.x : offset2.x;
            pixelCenter.y += centerOffset.y < 0 ? -offset2.y : offset2.y;
            this.panTo(this.unproject(pixelCenter), options2);
            this._enforcingBounds = false;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(options2) {
          if (!this._loaded) {
            return this;
          }
          options2 = extend2({
            animate: false,
            pan: true
          }, options2 === true ? { animate: true } : options2);
          var oldSize = this.getSize();
          this._sizeChanged = true;
          this._lastCenter = null;
          var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset2 = oldCenter.subtract(newCenter);
          if (!offset2.x && !offset2.y) {
            return this;
          }
          if (options2.animate && options2.pan) {
            this.panBy(offset2);
          } else {
            if (options2.pan) {
              this._rawPanBy(offset2);
            }
            this.fire("move");
            if (options2.debounceMoveend) {
              clearTimeout(this._sizeTimer);
              this._sizeTimer = setTimeout(bind2(this.fire, this, "moveend"), 200);
            } else {
              this.fire("moveend");
            }
          }
          return this.fire("resize", {
            oldSize,
            newSize
          });
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          this.setZoom(this._limitZoom(this._zoom));
          if (!this.options.zoomSnap) {
            this.fire("viewreset");
          }
          return this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(options2) {
          options2 = this._locateOptions = extend2({
            timeout: 1e4,
            watch: false
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, options2);
          if (!("geolocation" in navigator)) {
            this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            });
            return this;
          }
          var onResponse = bind2(this._handleGeolocationResponse, this), onError = bind2(this._handleGeolocationError, this);
          if (options2.watch) {
            this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options2);
          } else {
            navigator.geolocation.getCurrentPosition(onResponse, onError, options2);
          }
          return this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          if (navigator.geolocation && navigator.geolocation.clearWatch) {
            navigator.geolocation.clearWatch(this._locationWatchId);
          }
          if (this._locateOptions) {
            this._locateOptions.setView = false;
          }
          return this;
        },
        _handleGeolocationError: function(error) {
          if (!this._container._leaflet_id) {
            return;
          }
          var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
          if (this._locateOptions.setView && !this._loaded) {
            this.fitWorld();
          }
          this.fire("locationerror", {
            code: c,
            message: "Geolocation error: " + message + "."
          });
        },
        _handleGeolocationResponse: function(pos) {
          if (!this._container._leaflet_id) {
            return;
          }
          var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options2 = this._locateOptions;
          if (options2.setView) {
            var zoom2 = this.getBoundsZoom(bounds);
            this.setView(latlng, options2.maxZoom ? Math.min(zoom2, options2.maxZoom) : zoom2);
          }
          var data = {
            latlng,
            bounds,
            timestamp: pos.timestamp
          };
          for (var i in pos.coords) {
            if (typeof pos.coords[i] === "number") {
              data[i] = pos.coords[i];
            }
          }
          this.fire("locationfound", data);
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(name2, HandlerClass) {
          if (!HandlerClass) {
            return this;
          }
          var handler = this[name2] = new HandlerClass(this);
          this._handlers.push(handler);
          if (this.options[name2]) {
            handler.enable();
          }
          return this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          this._initEvents(true);
          if (this.options.maxBounds) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (this._containerId !== this._container._leaflet_id) {
            throw new Error("Map container is being reused by another instance");
          }
          try {
            delete this._container._leaflet_id;
            delete this._containerId;
          } catch (e) {
            this._container._leaflet_id = void 0;
            this._containerId = void 0;
          }
          if (this._locationWatchId !== void 0) {
            this.stopLocate();
          }
          this._stop();
          remove(this._mapPane);
          if (this._clearControlPos) {
            this._clearControlPos();
          }
          if (this._resizeRequest) {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = null;
          }
          this._clearHandlers();
          if (this._loaded) {
            this.fire("unload");
          }
          var i;
          for (i in this._layers) {
            this._layers[i].remove();
          }
          for (i in this._panes) {
            remove(this._panes[i]);
          }
          this._layers = [];
          this._panes = [];
          delete this._mapPane;
          delete this._renderer;
          return this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(name2, container) {
          var className = "leaflet-pane" + (name2 ? " leaflet-" + name2.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
          if (name2) {
            this._panes[name2] = pane;
          }
          return pane;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          this._checkIfLoaded();
          if (this._lastCenter && !this._moved()) {
            return this._lastCenter.clone();
          }
          return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
          return new LatLngBounds(sw, ne);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(bounds, inside, padding) {
          bounds = toLatLngBounds(bounds);
          padding = toPoint(padding || [0, 0]);
          var zoom2 = this.getZoom() || 0, min2 = this.getMinZoom(), max2 = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size2 = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size2.x / boundsSize.x, scaley = size2.y / boundsSize.y, scale3 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
          zoom2 = this.getScaleZoom(scale3, zoom2);
          if (snap) {
            zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
            zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
          }
          return Math.max(min2, Math.min(max2, zoom2));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          if (!this._size || this._sizeChanged) {
            this._size = new Point(
              this._container.clientWidth || 0,
              this._container.clientHeight || 0
            );
            this._sizeChanged = false;
          }
          return this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(center, zoom2) {
          var topLeftPoint = this._getTopLeftPoint(center, zoom2);
          return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          this._checkIfLoaded();
          return this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(zoom2) {
          return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(pane) {
          return typeof pane === "string" ? this._panes[pane] : pane;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(toZoom, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          return crs.scale(toZoom) / crs.scale(fromZoom);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(scale3, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          var zoom2 = crs.zoom(scale3 * crs.scale(fromZoom));
          return isNaN(zoom2) ? Infinity : zoom2;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(latlng, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(point2, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.pointToLatLng(toPoint(point2), zoom2);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(point2) {
          var projectedPoint = toPoint(point2).add(this.getPixelOrigin());
          return this.unproject(projectedPoint);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(latlng) {
          var projectedPoint = this.project(toLatLng(latlng))._round();
          return projectedPoint._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(latlng) {
          return this.options.crs.wrapLatLng(toLatLng(latlng));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(latlng) {
          return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(latlng1, latlng2) {
          return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(point2) {
          return toPoint(point2).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(point2) {
          return toPoint(point2).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(point2) {
          var layerPoint = this.containerPointToLayerPoint(toPoint(point2));
          return this.layerPointToLatLng(layerPoint);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(latlng) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(e) {
          return getMousePosition(e, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(e) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(e) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },
        // map initialization methods
        _initContainer: function(id2) {
          var container = this._container = get(id2);
          if (!container) {
            throw new Error("Map container not found.");
          } else if (container._leaflet_id) {
            throw new Error("Map container is already initialized.");
          }
          on(container, "scroll", this._onScroll, this);
          this._containerId = stamp(container);
        },
        _initLayout: function() {
          var container = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
          addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var position2 = getStyle(container, "position");
          if (position2 !== "absolute" && position2 !== "relative" && position2 !== "fixed" && position2 !== "sticky") {
            container.style.position = "relative";
          }
          this._initPanes();
          if (this._initControlPos) {
            this._initControlPos();
          }
        },
        _initPanes: function() {
          var panes = this._panes = {};
          this._paneRenderers = {};
          this._mapPane = this.createPane("mapPane", this._container);
          setPosition(this._mapPane, new Point(0, 0));
          this.createPane("tilePane");
          this.createPane("overlayPane");
          this.createPane("shadowPane");
          this.createPane("markerPane");
          this.createPane("tooltipPane");
          this.createPane("popupPane");
          if (!this.options.markerZoomAnimation) {
            addClass(panes.markerPane, "leaflet-zoom-hide");
            addClass(panes.shadowPane, "leaflet-zoom-hide");
          }
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(center, zoom2, noMoveStart) {
          setPosition(this._mapPane, new Point(0, 0));
          var loading = !this._loaded;
          this._loaded = true;
          zoom2 = this._limitZoom(zoom2);
          this.fire("viewprereset");
          var zoomChanged = this._zoom !== zoom2;
          this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
          this.fire("viewreset");
          if (loading) {
            this.fire("load");
          }
        },
        _moveStart: function(zoomChanged, noMoveStart) {
          if (zoomChanged) {
            this.fire("zoomstart");
          }
          if (!noMoveStart) {
            this.fire("movestart");
          }
          return this;
        },
        _move: function(center, zoom2, data, supressEvent) {
          if (zoom2 === void 0) {
            zoom2 = this._zoom;
          }
          var zoomChanged = this._zoom !== zoom2;
          this._zoom = zoom2;
          this._lastCenter = center;
          this._pixelOrigin = this._getNewPixelOrigin(center);
          if (!supressEvent) {
            if (zoomChanged || data && data.pinch) {
              this.fire("zoom", data);
            }
            this.fire("move", data);
          } else if (data && data.pinch) {
            this.fire("zoom", data);
          }
          return this;
        },
        _moveEnd: function(zoomChanged) {
          if (zoomChanged) {
            this.fire("zoomend");
          }
          return this.fire("moveend");
        },
        _stop: function() {
          cancelAnimFrame(this._flyToFrame);
          if (this._panAnim) {
            this._panAnim.stop();
          }
          return this;
        },
        _rawPanBy: function(offset2) {
          setPosition(this._mapPane, this._getMapPanePos().subtract(offset2));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          if (!this._enforcingBounds) {
            this.panInsideBounds(this.options.maxBounds);
          }
        },
        _checkIfLoaded: function() {
          if (!this._loaded) {
            throw new Error("Set map center and zoom first.");
          }
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(remove2) {
          this._targets = {};
          this._targets[stamp(this._container)] = this;
          var onOff = remove2 ? off : on;
          onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
          if (this.options.trackResize) {
            onOff(window, "resize", this._onResize, this);
          }
          if (Browser.any3d && this.options.transform3DLimit) {
            (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
          }
        },
        _onResize: function() {
          cancelAnimFrame(this._resizeRequest);
          this._resizeRequest = requestAnimFrame(
            function() {
              this.invalidateSize({ debounceMoveend: true });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0;
          this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var pos = this._getMapPanePos();
          if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
            this._resetView(this.getCenter(), this.getZoom());
          }
        },
        _findEventTargets: function(e, type) {
          var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
          while (src) {
            target = this._targets[stamp(src)];
            if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
              dragging = true;
              break;
            }
            if (target && target.listens(type, true)) {
              if (isHover && !isExternalTarget(src, e)) {
                break;
              }
              targets.push(target);
              if (isHover) {
                break;
              }
            }
            if (src === this._container) {
              break;
            }
            src = src.parentNode;
          }
          if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
            targets = [this];
          }
          return targets;
        },
        _isClickDisabled: function(el) {
          while (el && el !== this._container) {
            if (el["_leaflet_disable_click"]) {
              return true;
            }
            el = el.parentNode;
          }
        },
        _handleDOMEvent: function(e) {
          var el = e.target || e.srcElement;
          if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
            return;
          }
          var type = e.type;
          if (type === "mousedown") {
            preventOutline(el);
          }
          this._fireDOMEvent(e, type);
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(e, type, canvasTargets) {
          if (e.type === "click") {
            var synth = extend2({}, e);
            synth.type = "preclick";
            this._fireDOMEvent(synth, synth.type, canvasTargets);
          }
          var targets = this._findEventTargets(e, type);
          if (canvasTargets) {
            var filtered = [];
            for (var i = 0; i < canvasTargets.length; i++) {
              if (canvasTargets[i].listens(type, true)) {
                filtered.push(canvasTargets[i]);
              }
            }
            targets = filtered.concat(targets);
          }
          if (!targets.length) {
            return;
          }
          if (type === "contextmenu") {
            preventDefault(e);
          }
          var target = targets[0];
          var data = {
            originalEvent: e
          };
          if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
            var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
            data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
            data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
          }
          for (i = 0; i < targets.length; i++) {
            targets[i].fire(type, data, true);
            if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
              return;
            }
          }
        },
        _draggableMoved: function(obj) {
          obj = obj.dragging && obj.dragging.enabled() ? obj : this;
          return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var i = 0, len = this._handlers.length; i < len; i++) {
            this._handlers[i].disable();
          }
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(callback, context) {
          if (this._loaded) {
            callback.call(context || this, { target: this });
          } else {
            this.on("load", callback, context);
          }
          return this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return getPosition(this._mapPane) || new Point(0, 0);
        },
        _moved: function() {
          var pos = this._getMapPanePos();
          return pos && !pos.equals([0, 0]);
        },
        _getTopLeftPoint: function(center, zoom2) {
          var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
          return pixelOrigin.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(center, zoom2) {
          var viewHalf = this.getSize()._divideBy(2);
          return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(latlng, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return this.project(latlng, zoom2)._subtract(topLeft);
        },
        _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return toBounds([
            this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(latlng) {
          return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(center, zoom2, bounds) {
          if (!bounds) {
            return center;
          }
          var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset2 = this._getBoundsOffset(viewBounds, bounds, zoom2);
          if (Math.abs(offset2.x) <= 1 && Math.abs(offset2.y) <= 1) {
            return center;
          }
          return this.unproject(centerPoint.add(offset2), zoom2);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(offset2, bounds) {
          if (!bounds) {
            return offset2;
          }
          var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset2), viewBounds.max.add(offset2));
          return offset2.add(this._getBoundsOffset(newBounds, bounds));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
          var projectedMaxBounds = toBounds(
            this.project(maxBounds.getNorthEast(), zoom2),
            this.project(maxBounds.getSouthWest(), zoom2)
          ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
          return new Point(dx, dy);
        },
        _rebound: function(left, right) {
          return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function(zoom2) {
          var min2 = this.getMinZoom(), max2 = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
          if (snap) {
            zoom2 = Math.round(zoom2 / snap) * snap;
          }
          return Math.max(min2, Math.min(max2, zoom2));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          removeClass(this._mapPane, "leaflet-pan-anim");
          this.fire("moveend");
        },
        _tryAnimatedPan: function(center, options2) {
          var offset2 = this._getCenterOffset(center)._trunc();
          if ((options2 && options2.animate) !== true && !this.getSize().contains(offset2)) {
            return false;
          }
          this.panBy(offset2, options2);
          return true;
        },
        _createAnimProxy: function() {
          var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(proxy);
          this.on("zoomanim", function(e) {
            var prop = TRANSFORM, transform = this._proxy.style[prop];
            setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
            if (transform === this._proxy.style[prop] && this._animatingZoom) {
              this._onZoomTransitionEnd();
            }
          }, this);
          this.on("load moveend", this._animMoveEnd, this);
          this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          remove(this._proxy);
          this.off("load moveend", this._animMoveEnd, this);
          delete this._proxy;
        },
        _animMoveEnd: function() {
          var c = this.getCenter(), z = this.getZoom();
          setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
        },
        _catchTransitionEnd: function(e) {
          if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
            this._onZoomTransitionEnd();
          }
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(center, zoom2, options2) {
          if (this._animatingZoom) {
            return true;
          }
          options2 = options2 || {};
          if (!this._zoomAnimated || options2.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
            return false;
          }
          var scale3 = this.getZoomScale(zoom2), offset2 = this._getCenterOffset(center)._divideBy(1 - 1 / scale3);
          if (options2.animate !== true && !this.getSize().contains(offset2)) {
            return false;
          }
          requestAnimFrame(function() {
            this._moveStart(true, options2.noMoveStart || false)._animateZoom(center, zoom2, true);
          }, this);
          return true;
        },
        _animateZoom: function(center, zoom2, startAnim, noUpdate) {
          if (!this._mapPane) {
            return;
          }
          if (startAnim) {
            this._animatingZoom = true;
            this._animateToCenter = center;
            this._animateToZoom = zoom2;
            addClass(this._mapPane, "leaflet-zoom-anim");
          }
          this.fire("zoomanim", {
            center,
            zoom: zoom2,
            noUpdate
          });
          if (!this._tempFireZoomEvent) {
            this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
          }
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          setTimeout(bind2(this._onZoomTransitionEnd, this), 250);
        },
        _onZoomTransitionEnd: function() {
          if (!this._animatingZoom) {
            return;
          }
          if (this._mapPane) {
            removeClass(this._mapPane, "leaflet-zoom-anim");
          }
          this._animatingZoom = false;
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          if (this._tempFireZoomEvent) {
            this.fire("zoom");
          }
          delete this._tempFireZoomEvent;
          this.fire("move");
          this._moveEnd(true);
        }
      });
      function createMap(id2, options2) {
        return new Map2(id2, options2);
      }
      var Control = Class.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(options2) {
          setOptions(this, options2);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(position2) {
          var map = this._map;
          if (map) {
            map.removeControl(this);
          }
          this.options.position = position2;
          if (map) {
            map.addControl(this);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(map) {
          this.remove();
          this._map = map;
          var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
          addClass(container, "leaflet-control");
          if (pos.indexOf("bottom") !== -1) {
            corner.insertBefore(container, corner.firstChild);
          } else {
            corner.appendChild(container);
          }
          this._map.on("unload", this.remove, this);
          return this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          if (!this._map) {
            return this;
          }
          remove(this._container);
          if (this.onRemove) {
            this.onRemove(this._map);
          }
          this._map.off("unload", this.remove, this);
          this._map = null;
          return this;
        },
        _refocusOnMap: function(e) {
          if (this._map && e && e.screenX > 0 && e.screenY > 0) {
            this._map.getContainer().focus();
          }
        }
      });
      var control = function(options2) {
        return new Control(options2);
      };
      Map2.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(control2) {
          control2.addTo(this);
          return this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(control2) {
          control2.remove();
          return this;
        },
        _initControlPos: function() {
          var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
          function createCorner(vSide, hSide) {
            var className = l + vSide + " " + l + hSide;
            corners[vSide + hSide] = create$1("div", className, container);
          }
          createCorner("top", "left");
          createCorner("top", "right");
          createCorner("bottom", "left");
          createCorner("bottom", "right");
        },
        _clearControlPos: function() {
          for (var i in this._controlCorners) {
            remove(this._controlCorners[i]);
          }
          remove(this._controlContainer);
          delete this._controlCorners;
          delete this._controlContainer;
        }
      });
      var Layers = Control.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: true,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: true,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: false,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: false,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(layerA, layerB, nameA, nameB) {
            return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
          }
        },
        initialize: function(baseLayers, overlays, options2) {
          setOptions(this, options2);
          this._layerControlInputs = [];
          this._layers = [];
          this._lastZIndex = 0;
          this._handlingClick = false;
          this._preventClick = false;
          for (var i in baseLayers) {
            this._addLayer(baseLayers[i], i);
          }
          for (i in overlays) {
            this._addLayer(overlays[i], i, true);
          }
        },
        onAdd: function(map) {
          this._initLayout();
          this._update();
          this._map = map;
          map.on("zoomend", this._checkDisabledLayers, this);
          for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.on("add remove", this._onLayerChange, this);
          }
          return this._container;
        },
        addTo: function(map) {
          Control.prototype.addTo.call(this, map);
          return this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.off("add remove", this._onLayerChange, this);
          }
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(layer, name2) {
          this._addLayer(layer, name2);
          return this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(layer, name2) {
          this._addLayer(layer, name2, true);
          return this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(layer) {
          layer.off("add remove", this._onLayerChange, this);
          var obj = this._getLayer(stamp(layer));
          if (obj) {
            this._layers.splice(this._layers.indexOf(obj), 1);
          }
          return this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          addClass(this._container, "leaflet-control-layers-expanded");
          this._section.style.height = null;
          var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
          if (acceptableHeight < this._section.clientHeight) {
            addClass(this._section, "leaflet-control-layers-scrollbar");
            this._section.style.height = acceptableHeight + "px";
          } else {
            removeClass(this._section, "leaflet-control-layers-scrollbar");
          }
          this._checkDisabledLayers();
          return this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          removeClass(this._container, "leaflet-control-layers-expanded");
          return this;
        },
        _initLayout: function() {
          var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
          container.setAttribute("aria-haspopup", true);
          disableClickPropagation(container);
          disableScrollPropagation(container);
          var section = this._section = create$1("section", className + "-list");
          if (collapsed) {
            this._map.on("click", this.collapse, this);
            on(container, {
              mouseenter: this._expandSafely,
              mouseleave: this.collapse
            }, this);
          }
          var link2 = this._layersLink = create$1("a", className + "-toggle", container);
          link2.href = "#";
          link2.title = "Layers";
          link2.setAttribute("role", "button");
          on(link2, {
            keydown: function(e) {
              if (e.keyCode === 13) {
                this._expandSafely();
              }
            },
            // Certain screen readers intercept the key event and instead send a click event
            click: function(e) {
              preventDefault(e);
              this._expandSafely();
            }
          }, this);
          if (!collapsed) {
            this.expand();
          }
          this._baseLayersList = create$1("div", className + "-base", section);
          this._separator = create$1("div", className + "-separator", section);
          this._overlaysList = create$1("div", className + "-overlays", section);
          container.appendChild(section);
        },
        _getLayer: function(id2) {
          for (var i = 0; i < this._layers.length; i++) {
            if (this._layers[i] && stamp(this._layers[i].layer) === id2) {
              return this._layers[i];
            }
          }
        },
        _addLayer: function(layer, name2, overlay) {
          if (this._map) {
            layer.on("add remove", this._onLayerChange, this);
          }
          this._layers.push({
            layer,
            name: name2,
            overlay
          });
          if (this.options.sortLayers) {
            this._layers.sort(bind2(function(a, b) {
              return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
            }, this));
          }
          if (this.options.autoZIndex && layer.setZIndex) {
            this._lastZIndex++;
            layer.setZIndex(this._lastZIndex);
          }
          this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container) {
            return this;
          }
          empty2(this._baseLayersList);
          empty2(this._overlaysList);
          this._layerControlInputs = [];
          var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
          for (i = 0; i < this._layers.length; i++) {
            obj = this._layers[i];
            this._addItem(obj);
            overlaysPresent = overlaysPresent || obj.overlay;
            baseLayersPresent = baseLayersPresent || !obj.overlay;
            baseLayersCount += !obj.overlay ? 1 : 0;
          }
          if (this.options.hideSingleBase) {
            baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
            this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
          }
          this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
          return this;
        },
        _onLayerChange: function(e) {
          if (!this._handlingClick) {
            this._update();
          }
          var obj = this._getLayer(stamp(e.target));
          var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
          if (type) {
            this._map.fire(type, obj);
          }
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(name2, checked) {
          var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name2 + '"' + (checked ? ' checked="checked"' : "") + "/>";
          var radioFragment = document.createElement("div");
          radioFragment.innerHTML = radioHtml;
          return radioFragment.firstChild;
        },
        _addItem: function(obj) {
          var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
          if (obj.overlay) {
            input = document.createElement("input");
            input.type = "checkbox";
            input.className = "leaflet-control-layers-selector";
            input.defaultChecked = checked;
          } else {
            input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
          }
          this._layerControlInputs.push(input);
          input.layerId = stamp(obj.layer);
          on(input, "click", this._onInputClick, this);
          var name2 = document.createElement("span");
          name2.innerHTML = " " + obj.name;
          var holder = document.createElement("span");
          label.appendChild(holder);
          holder.appendChild(input);
          holder.appendChild(name2);
          var container = obj.overlay ? this._overlaysList : this._baseLayersList;
          container.appendChild(label);
          this._checkDisabledLayers();
          return label;
        },
        _onInputClick: function() {
          if (this._preventClick) {
            return;
          }
          var inputs = this._layerControlInputs, input, layer;
          var addedLayers = [], removedLayers = [];
          this._handlingClick = true;
          for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            if (input.checked) {
              addedLayers.push(layer);
            } else if (!input.checked) {
              removedLayers.push(layer);
            }
          }
          for (i = 0; i < removedLayers.length; i++) {
            if (this._map.hasLayer(removedLayers[i])) {
              this._map.removeLayer(removedLayers[i]);
            }
          }
          for (i = 0; i < addedLayers.length; i++) {
            if (!this._map.hasLayer(addedLayers[i])) {
              this._map.addLayer(addedLayers[i]);
            }
          }
          this._handlingClick = false;
          this._refocusOnMap();
        },
        _checkDisabledLayers: function() {
          var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
          for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
          }
        },
        _expandIfNotCollapsed: function() {
          if (this._map && !this.options.collapsed) {
            this.expand();
          }
          return this;
        },
        _expandSafely: function() {
          var section = this._section;
          this._preventClick = true;
          on(section, "click", preventDefault);
          this.expand();
          var that = this;
          setTimeout(function() {
            off(section, "click", preventDefault);
            that._preventClick = false;
          });
        }
      });
      var layers = function(baseLayers, overlays, options2) {
        return new Layers(baseLayers, overlays, options2);
      };
      var Zoom = Control.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(map) {
          var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options2 = this.options;
          this._zoomInButton = this._createButton(
            options2.zoomInText,
            options2.zoomInTitle,
            zoomName + "-in",
            container,
            this._zoomIn
          );
          this._zoomOutButton = this._createButton(
            options2.zoomOutText,
            options2.zoomOutTitle,
            zoomName + "-out",
            container,
            this._zoomOut
          );
          this._updateDisabled();
          map.on("zoomend zoomlevelschange", this._updateDisabled, this);
          return container;
        },
        onRemove: function(map) {
          map.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          this._disabled = true;
          this._updateDisabled();
          return this;
        },
        enable: function() {
          this._disabled = false;
          this._updateDisabled();
          return this;
        },
        _zoomIn: function(e) {
          if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
            this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
          }
        },
        _zoomOut: function(e) {
          if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
            this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
          }
        },
        _createButton: function(html2, title, className, container, fn) {
          var link2 = create$1("a", className, container);
          link2.innerHTML = html2;
          link2.href = "#";
          link2.title = title;
          link2.setAttribute("role", "button");
          link2.setAttribute("aria-label", title);
          disableClickPropagation(link2);
          on(link2, "click", stop);
          on(link2, "click", fn, this);
          on(link2, "click", this._refocusOnMap, this);
          return link2;
        },
        _updateDisabled: function() {
          var map = this._map, className = "leaflet-disabled";
          removeClass(this._zoomInButton, className);
          removeClass(this._zoomOutButton, className);
          this._zoomInButton.setAttribute("aria-disabled", "false");
          this._zoomOutButton.setAttribute("aria-disabled", "false");
          if (this._disabled || map._zoom === map.getMinZoom()) {
            addClass(this._zoomOutButton, className);
            this._zoomOutButton.setAttribute("aria-disabled", "true");
          }
          if (this._disabled || map._zoom === map.getMaxZoom()) {
            addClass(this._zoomInButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "true");
          }
        }
      });
      Map2.mergeOptions({
        zoomControl: true
      });
      Map2.addInitHook(function() {
        if (this.options.zoomControl) {
          this.zoomControl = new Zoom();
          this.addControl(this.zoomControl);
        }
      });
      var zoom = function(options2) {
        return new Zoom(options2);
      };
      var Scale = Control.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: true,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: true
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(map) {
          var className = "leaflet-control-scale", container = create$1("div", className), options2 = this.options;
          this._addScales(options2, className + "-line", container);
          map.on(options2.updateWhenIdle ? "moveend" : "move", this._update, this);
          map.whenReady(this._update, this);
          return container;
        },
        onRemove: function(map) {
          map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(options2, className, container) {
          if (options2.metric) {
            this._mScale = create$1("div", className, container);
          }
          if (options2.imperial) {
            this._iScale = create$1("div", className, container);
          }
        },
        _update: function() {
          var map = this._map, y = map.getSize().y / 2;
          var maxMeters = map.distance(
            map.containerPointToLatLng([0, y]),
            map.containerPointToLatLng([this.options.maxWidth, y])
          );
          this._updateScales(maxMeters);
        },
        _updateScales: function(maxMeters) {
          if (this.options.metric && maxMeters) {
            this._updateMetric(maxMeters);
          }
          if (this.options.imperial && maxMeters) {
            this._updateImperial(maxMeters);
          }
        },
        _updateMetric: function(maxMeters) {
          var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
          this._updateScale(this._mScale, label, meters / maxMeters);
        },
        _updateImperial: function(maxMeters) {
          var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
          if (maxFeet > 5280) {
            maxMiles = maxFeet / 5280;
            miles = this._getRoundNum(maxMiles);
            this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
          } else {
            feet = this._getRoundNum(maxFeet);
            this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
          }
        },
        _updateScale: function(scale3, text2, ratio) {
          scale3.style.width = Math.round(this.options.maxWidth * ratio) + "px";
          scale3.innerHTML = text2;
        },
        _getRoundNum: function(num) {
          var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
          d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
          return pow10 * d;
        }
      });
      var scale2 = function(options2) {
        return new Scale(options2);
      };
      var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
      var Attribution = Control.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
        },
        initialize: function(options2) {
          setOptions(this, options2);
          this._attributions = {};
        },
        onAdd: function(map) {
          map.attributionControl = this;
          this._container = create$1("div", "leaflet-control-attribution");
          disableClickPropagation(this._container);
          for (var i in map._layers) {
            if (map._layers[i].getAttribution) {
              this.addAttribution(map._layers[i].getAttribution());
            }
          }
          this._update();
          map.on("layeradd", this._addAttribution, this);
          return this._container;
        },
        onRemove: function(map) {
          map.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(ev) {
          if (ev.layer.getAttribution) {
            this.addAttribution(ev.layer.getAttribution());
            ev.layer.once("remove", function() {
              this.removeAttribution(ev.layer.getAttribution());
            }, this);
          }
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(prefix) {
          this.options.prefix = prefix;
          this._update();
          return this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function(text2) {
          if (!text2) {
            return this;
          }
          if (!this._attributions[text2]) {
            this._attributions[text2] = 0;
          }
          this._attributions[text2]++;
          this._update();
          return this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(text2) {
          if (!text2) {
            return this;
          }
          if (this._attributions[text2]) {
            this._attributions[text2]--;
            this._update();
          }
          return this;
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          var attribs = [];
          for (var i in this._attributions) {
            if (this._attributions[i]) {
              attribs.push(i);
            }
          }
          var prefixAndAttribs = [];
          if (this.options.prefix) {
            prefixAndAttribs.push(this.options.prefix);
          }
          if (attribs.length) {
            prefixAndAttribs.push(attribs.join(", "));
          }
          this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
        }
      });
      Map2.mergeOptions({
        attributionControl: true
      });
      Map2.addInitHook(function() {
        if (this.options.attributionControl) {
          new Attribution().addTo(this);
        }
      });
      var attribution = function(options2) {
        return new Attribution(options2);
      };
      Control.Layers = Layers;
      Control.Zoom = Zoom;
      Control.Scale = Scale;
      Control.Attribution = Attribution;
      control.layers = layers;
      control.zoom = zoom;
      control.scale = scale2;
      control.attribution = attribution;
      var Handler = Class.extend({
        initialize: function(map) {
          this._map = map;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          if (this._enabled) {
            return this;
          }
          this._enabled = true;
          this.addHooks();
          return this;
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          if (!this._enabled) {
            return this;
          }
          this._enabled = false;
          this.removeHooks();
          return this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      Handler.addTo = function(map, name2) {
        map.addHandler(name2, this);
        return this;
      };
      var Mixin = { Events };
      var START = Browser.touch ? "touchstart mousedown" : "mousedown";
      var Draggable = Evented.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(element2, dragStartTarget, preventOutline2, options2) {
          setOptions(this, options2);
          this._element = element2;
          this._dragStartTarget = dragStartTarget || element2;
          this._preventOutline = preventOutline2;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          if (this._enabled) {
            return;
          }
          on(this._dragStartTarget, START, this._onDown, this);
          this._enabled = true;
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          if (!this._enabled) {
            return;
          }
          if (Draggable._dragging === this) {
            this.finishDrag(true);
          }
          off(this._dragStartTarget, START, this._onDown, this);
          this._enabled = false;
          this._moved = false;
        },
        _onDown: function(e) {
          if (!this._enabled) {
            return;
          }
          this._moved = false;
          if (hasClass(this._element, "leaflet-zoom-anim")) {
            return;
          }
          if (e.touches && e.touches.length !== 1) {
            if (Draggable._dragging === this) {
              this.finishDrag();
            }
            return;
          }
          if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
            return;
          }
          Draggable._dragging = this;
          if (this._preventOutline) {
            preventOutline(this._element);
          }
          disableImageDrag();
          disableTextSelection();
          if (this._moving) {
            return;
          }
          this.fire("down");
          var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
          this._startPoint = new Point(first.clientX, first.clientY);
          this._startPos = getPosition(this._element);
          this._parentScale = getScale2(sizedParent);
          var mouseevent = e.type === "mousedown";
          on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
          on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
        },
        _onMove: function(e) {
          if (!this._enabled) {
            return;
          }
          if (e.touches && e.touches.length > 1) {
            this._moved = true;
            return;
          }
          var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset2 = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
          if (!offset2.x && !offset2.y) {
            return;
          }
          if (Math.abs(offset2.x) + Math.abs(offset2.y) < this.options.clickTolerance) {
            return;
          }
          offset2.x /= this._parentScale.x;
          offset2.y /= this._parentScale.y;
          preventDefault(e);
          if (!this._moved) {
            this.fire("dragstart");
            this._moved = true;
            addClass(document.body, "leaflet-dragging");
            this._lastTarget = e.target || e.srcElement;
            if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
              this._lastTarget = this._lastTarget.correspondingUseElement;
            }
            addClass(this._lastTarget, "leaflet-drag-target");
          }
          this._newPos = this._startPos.add(offset2);
          this._moving = true;
          this._lastEvent = e;
          this._updatePosition();
        },
        _updatePosition: function() {
          var e = { originalEvent: this._lastEvent };
          this.fire("predrag", e);
          setPosition(this._element, this._newPos);
          this.fire("drag", e);
        },
        _onUp: function() {
          if (!this._enabled) {
            return;
          }
          this.finishDrag();
        },
        finishDrag: function(noInertia) {
          removeClass(document.body, "leaflet-dragging");
          if (this._lastTarget) {
            removeClass(this._lastTarget, "leaflet-drag-target");
            this._lastTarget = null;
          }
          off(document, "mousemove touchmove", this._onMove, this);
          off(document, "mouseup touchend touchcancel", this._onUp, this);
          enableImageDrag();
          enableTextSelection();
          var fireDragend = this._moved && this._moving;
          this._moving = false;
          Draggable._dragging = false;
          if (fireDragend) {
            this.fire("dragend", {
              noInertia,
              distance: this._newPos.distanceTo(this._startPos)
            });
          }
        }
      });
      function clipPolygon(points, bounds, round2) {
        var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p;
        for (i = 0, len = points.length; i < len; i++) {
          points[i]._code = _getBitCode(points[i], bounds);
        }
        for (k = 0; k < 4; k++) {
          edge2 = edges[k];
          clippedPoints = [];
          for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
            a = points[i];
            b = points[j];
            if (!(a._code & edge2)) {
              if (b._code & edge2) {
                p = _getEdgeIntersection(b, a, edge2, bounds, round2);
                p._code = _getBitCode(p, bounds);
                clippedPoints.push(p);
              }
              clippedPoints.push(a);
            } else if (!(b._code & edge2)) {
              p = _getEdgeIntersection(b, a, edge2, bounds, round2);
              p._code = _getBitCode(p, bounds);
              clippedPoints.push(p);
            }
          }
          points = clippedPoints;
        }
        return points;
      }
      function polygonCenter(latlngs, crs) {
        var i, j, p1, p2, f, area, x, y, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i = 0; i < len; i++) {
          var latlng = toLatLng(latlngs[i]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        area = x = y = 0;
        for (i = 0, j = len - 1; i < len; j = i++) {
          p1 = points[i];
          p2 = points[j];
          f = p1.y * p2.x - p2.y * p1.x;
          x += (p1.x + p2.x) * f;
          y += (p1.y + p2.y) * f;
          area += f * 3;
        }
        if (area === 0) {
          center = points[0];
        } else {
          center = [x / area, y / area];
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      function centroid(coords) {
        var latSum = 0;
        var lngSum = 0;
        var len = 0;
        for (var i = 0; i < coords.length; i++) {
          var latlng = toLatLng(coords[i]);
          latSum += latlng.lat;
          lngSum += latlng.lng;
          len++;
        }
        return toLatLng([latSum / len, lngSum / len]);
      }
      var PolyUtil = {
        __proto__: null,
        clipPolygon,
        polygonCenter,
        centroid
      };
      function simplify(points, tolerance) {
        if (!tolerance || !points.length) {
          return points.slice();
        }
        var sqTolerance = tolerance * tolerance;
        points = _reducePoints(points, sqTolerance);
        points = _simplifyDP(points, sqTolerance);
        return points;
      }
      function pointToSegmentDistance(p, p1, p2) {
        return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
      }
      function closestPointOnSegment(p, p1, p2) {
        return _sqClosestPointOnSegment(p, p1, p2);
      }
      function _simplifyDP(points, sqTolerance) {
        var len = points.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers = new ArrayConstructor(len);
        markers[0] = markers[len - 1] = 1;
        _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
        var i, newPoints = [];
        for (i = 0; i < len; i++) {
          if (markers[i]) {
            newPoints.push(points[i]);
          }
        }
        return newPoints;
      }
      function _simplifyDPStep(points, markers, sqTolerance, first, last) {
        var maxSqDist = 0, index3, i, sqDist;
        for (i = first + 1; i <= last - 1; i++) {
          sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
          if (sqDist > maxSqDist) {
            index3 = i;
            maxSqDist = sqDist;
          }
        }
        if (maxSqDist > sqTolerance) {
          markers[index3] = 1;
          _simplifyDPStep(points, markers, sqTolerance, first, index3);
          _simplifyDPStep(points, markers, sqTolerance, index3, last);
        }
      }
      function _reducePoints(points, sqTolerance) {
        var reducedPoints = [points[0]];
        for (var i = 1, prev = 0, len = points.length; i < len; i++) {
          if (_sqDist(points[i], points[prev]) > sqTolerance) {
            reducedPoints.push(points[i]);
            prev = i;
          }
        }
        if (prev < len - 1) {
          reducedPoints.push(points[len - 1]);
        }
        return reducedPoints;
      }
      var _lastCode;
      function clipSegment(a, b, bounds, useLastCode, round2) {
        var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
        _lastCode = codeB;
        while (true) {
          if (!(codeA | codeB)) {
            return [a, b];
          }
          if (codeA & codeB) {
            return false;
          }
          codeOut = codeA || codeB;
          p = _getEdgeIntersection(a, b, codeOut, bounds, round2);
          newCode = _getBitCode(p, bounds);
          if (codeOut === codeA) {
            a = p;
            codeA = newCode;
          } else {
            b = p;
            codeB = newCode;
          }
        }
      }
      function _getEdgeIntersection(a, b, code2, bounds, round2) {
        var dx = b.x - a.x, dy = b.y - a.y, min2 = bounds.min, max2 = bounds.max, x, y;
        if (code2 & 8) {
          x = a.x + dx * (max2.y - a.y) / dy;
          y = max2.y;
        } else if (code2 & 4) {
          x = a.x + dx * (min2.y - a.y) / dy;
          y = min2.y;
        } else if (code2 & 2) {
          x = max2.x;
          y = a.y + dy * (max2.x - a.x) / dx;
        } else if (code2 & 1) {
          x = min2.x;
          y = a.y + dy * (min2.x - a.x) / dx;
        }
        return new Point(x, y, round2);
      }
      function _getBitCode(p, bounds) {
        var code2 = 0;
        if (p.x < bounds.min.x) {
          code2 |= 1;
        } else if (p.x > bounds.max.x) {
          code2 |= 2;
        }
        if (p.y < bounds.min.y) {
          code2 |= 4;
        } else if (p.y > bounds.max.y) {
          code2 |= 8;
        }
        return code2;
      }
      function _sqDist(p1, p2) {
        var dx = p2.x - p1.x, dy = p2.y - p1.y;
        return dx * dx + dy * dy;
      }
      function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
        var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
        if (dot > 0) {
          t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
          if (t > 1) {
            x = p2.x;
            y = p2.y;
          } else if (t > 0) {
            x += dx * t;
            y += dy * t;
          }
        }
        dx = p.x - x;
        dy = p.y - y;
        return sqDist ? dx * dx + dy * dy : new Point(x, y);
      }
      function isFlat(latlngs) {
        return !isArray2(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
      }
      function _flat(latlngs) {
        console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
        return isFlat(latlngs);
      }
      function polylineCenter(latlngs, crs) {
        var i, halfDist, segDist, dist, p1, p2, ratio, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i = 0; i < len; i++) {
          var latlng = toLatLng(latlngs[i]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        for (i = 0, halfDist = 0; i < len - 1; i++) {
          halfDist += points[i].distanceTo(points[i + 1]) / 2;
        }
        if (halfDist === 0) {
          center = points[0];
        } else {
          for (i = 0, dist = 0; i < len - 1; i++) {
            p1 = points[i];
            p2 = points[i + 1];
            segDist = p1.distanceTo(p2);
            dist += segDist;
            if (dist > halfDist) {
              ratio = (dist - halfDist) / segDist;
              center = [
                p2.x - ratio * (p2.x - p1.x),
                p2.y - ratio * (p2.y - p1.y)
              ];
              break;
            }
          }
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      var LineUtil = {
        __proto__: null,
        simplify,
        pointToSegmentDistance,
        closestPointOnSegment,
        clipSegment,
        _getEdgeIntersection,
        _getBitCode,
        _sqClosestPointOnSegment,
        isFlat,
        _flat,
        polylineCenter
      };
      var LonLat = {
        project: function(latlng) {
          return new Point(latlng.lng, latlng.lat);
        },
        unproject: function(point2) {
          return new LatLng(point2.y, point2.x);
        },
        bounds: new Bounds([-180, -90], [180, 90])
      };
      var Mercator = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(latlng) {
          var d = Math.PI / 180, r2 = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r2, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
          var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
          y = -r2 * Math.log(Math.max(ts, 1e-10));
          return new Point(latlng.lng * d * r2, y);
        },
        unproject: function(point2) {
          var d = 180 / Math.PI, r2 = this.R, tmp = this.R_MINOR / r2, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point2.y / r2), phi = Math.PI / 2 - 2 * Math.atan(ts);
          for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
            con = e * Math.sin(phi);
            con = Math.pow((1 - con) / (1 + con), e / 2);
            dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
            phi += dphi;
          }
          return new LatLng(phi * d, point2.x * d / r2);
        }
      };
      var index2 = {
        __proto__: null,
        LonLat,
        Mercator,
        SphericalMercator
      };
      var EPSG3395 = extend2({}, Earth, {
        code: "EPSG:3395",
        projection: Mercator,
        transformation: function() {
          var scale3 = 0.5 / (Math.PI * Mercator.R);
          return toTransformation(scale3, 0.5, -scale3, 0.5);
        }()
      });
      var EPSG4326 = extend2({}, Earth, {
        code: "EPSG:4326",
        projection: LonLat,
        transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
      });
      var Simple = extend2({}, CRS, {
        projection: LonLat,
        transformation: toTransformation(1, 0, -1, 0),
        scale: function(zoom2) {
          return Math.pow(2, zoom2);
        },
        zoom: function(scale3) {
          return Math.log(scale3) / Math.LN2;
        },
        distance: function(latlng1, latlng2) {
          var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
          return Math.sqrt(dx * dx + dy * dy);
        },
        infinite: true
      });
      CRS.Earth = Earth;
      CRS.EPSG3395 = EPSG3395;
      CRS.EPSG3857 = EPSG3857;
      CRS.EPSG900913 = EPSG900913;
      CRS.EPSG4326 = EPSG4326;
      CRS.Simple = Simple;
      var Layer = Evented.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: true
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(map) {
          map.addLayer(this);
          return this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(obj) {
          if (obj) {
            obj.removeLayer(this);
          }
          return this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(name2) {
          return this._map.getPane(name2 ? this.options[name2] || name2 : this.options.pane);
        },
        addInteractiveTarget: function(targetEl) {
          this._map._targets[stamp(targetEl)] = this;
          return this;
        },
        removeInteractiveTarget: function(targetEl) {
          delete this._map._targets[stamp(targetEl)];
          return this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(e) {
          var map = e.target;
          if (!map.hasLayer(this)) {
            return;
          }
          this._map = map;
          this._zoomAnimated = map._zoomAnimated;
          if (this.getEvents) {
            var events = this.getEvents();
            map.on(events, this);
            this.once("remove", function() {
              map.off(events, this);
            }, this);
          }
          this.onAdd(map);
          this.fire("add");
          map.fire("layeradd", { layer: this });
        }
      });
      Map2.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(layer) {
          if (!layer._layerAdd) {
            throw new Error("The provided object is not a Layer.");
          }
          var id2 = stamp(layer);
          if (this._layers[id2]) {
            return this;
          }
          this._layers[id2] = layer;
          layer._mapToAdd = this;
          if (layer.beforeAdd) {
            layer.beforeAdd(this);
          }
          this.whenReady(layer._layerAdd, layer);
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(layer) {
          var id2 = stamp(layer);
          if (!this._layers[id2]) {
            return this;
          }
          if (this._loaded) {
            layer.onRemove(this);
          }
          delete this._layers[id2];
          if (this._loaded) {
            this.fire("layerremove", { layer });
            layer.fire("remove");
          }
          layer._map = layer._mapToAdd = null;
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(layer) {
          return stamp(layer) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(method, context) {
          for (var i in this._layers) {
            method.call(context, this._layers[i]);
          }
          return this;
        },
        _addLayers: function(layers2) {
          layers2 = layers2 ? isArray2(layers2) ? layers2 : [layers2] : [];
          for (var i = 0, len = layers2.length; i < len; i++) {
            this.addLayer(layers2[i]);
          }
        },
        _addZoomLimit: function(layer) {
          if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
            this._zoomBoundLayers[stamp(layer)] = layer;
            this._updateZoomLevels();
          }
        },
        _removeZoomLimit: function(layer) {
          var id2 = stamp(layer);
          if (this._zoomBoundLayers[id2]) {
            delete this._zoomBoundLayers[id2];
            this._updateZoomLevels();
          }
        },
        _updateZoomLevels: function() {
          var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
          for (var i in this._zoomBoundLayers) {
            var options2 = this._zoomBoundLayers[i].options;
            minZoom = options2.minZoom === void 0 ? minZoom : Math.min(minZoom, options2.minZoom);
            maxZoom = options2.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options2.maxZoom);
          }
          this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
          this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
          if (oldZoomSpan !== this._getZoomSpan()) {
            this.fire("zoomlevelschange");
          }
          if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
            this.setZoom(this._layersMaxZoom);
          }
          if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
            this.setZoom(this._layersMinZoom);
          }
        }
      });
      var LayerGroup = Layer.extend({
        initialize: function(layers2, options2) {
          setOptions(this, options2);
          this._layers = {};
          var i, len;
          if (layers2) {
            for (i = 0, len = layers2.length; i < len; i++) {
              this.addLayer(layers2[i]);
            }
          }
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(layer) {
          var id2 = this.getLayerId(layer);
          this._layers[id2] = layer;
          if (this._map) {
            this._map.addLayer(layer);
          }
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(layer) {
          var id2 = layer in this._layers ? layer : this.getLayerId(layer);
          if (this._map && this._layers[id2]) {
            this._map.removeLayer(this._layers[id2]);
          }
          delete this._layers[id2];
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(layer) {
          var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
          return layerId in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, ): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(methodName) {
          var args = Array.prototype.slice.call(arguments, 1), i, layer;
          for (i in this._layers) {
            layer = this._layers[i];
            if (layer[methodName]) {
              layer[methodName].apply(layer, args);
            }
          }
          return this;
        },
        onAdd: function(map) {
          this.eachLayer(map.addLayer, map);
        },
        onRemove: function(map) {
          this.eachLayer(map.removeLayer, map);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(method, context) {
          for (var i in this._layers) {
            method.call(context, this._layers[i]);
          }
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(id2) {
          return this._layers[id2];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var layers2 = [];
          this.eachLayer(layers2.push, layers2);
          return layers2;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(zIndex) {
          return this.invoke("setZIndex", zIndex);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(layer) {
          return stamp(layer);
        }
      });
      var layerGroup = function(layers2, options2) {
        return new LayerGroup(layers2, options2);
      };
      var FeatureGroup = LayerGroup.extend({
        addLayer: function(layer) {
          if (this.hasLayer(layer)) {
            return this;
          }
          layer.addEventParent(this);
          LayerGroup.prototype.addLayer.call(this, layer);
          return this.fire("layeradd", { layer });
        },
        removeLayer: function(layer) {
          if (!this.hasLayer(layer)) {
            return this;
          }
          if (layer in this._layers) {
            layer = this._layers[layer];
          }
          layer.removeEventParent(this);
          LayerGroup.prototype.removeLayer.call(this, layer);
          return this.fire("layerremove", { layer });
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(style2) {
          return this.invoke("setStyle", style2);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var bounds = new LatLngBounds();
          for (var id2 in this._layers) {
            var layer = this._layers[id2];
            bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
          }
          return bounds;
        }
      });
      var featureGroup = function(layers2, options2) {
        return new FeatureGroup(layers2, options2);
      };
      var Icon2 = Class.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false
        },
        initialize: function(options2) {
          setOptions(this, options2);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(oldIcon) {
          return this._createIcon("icon", oldIcon);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(oldIcon) {
          return this._createIcon("shadow", oldIcon);
        },
        _createIcon: function(name2, oldIcon) {
          var src = this._getIconUrl(name2);
          if (!src) {
            if (name2 === "icon") {
              throw new Error("iconUrl not set in Icon options (see the docs).");
            }
            return null;
          }
          var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
          this._setIconStyles(img, name2);
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          return img;
        },
        _setIconStyles: function(img, name2) {
          var options2 = this.options;
          var sizeOption = options2[name2 + "Size"];
          if (typeof sizeOption === "number") {
            sizeOption = [sizeOption, sizeOption];
          }
          var size2 = toPoint(sizeOption), anchor = toPoint(name2 === "shadow" && options2.shadowAnchor || options2.iconAnchor || size2 && size2.divideBy(2, true));
          img.className = "leaflet-marker-" + name2 + " " + (options2.className || "");
          if (anchor) {
            img.style.marginLeft = -anchor.x + "px";
            img.style.marginTop = -anchor.y + "px";
          }
          if (size2) {
            img.style.width = size2.x + "px";
            img.style.height = size2.y + "px";
          }
        },
        _createImg: function(src, el) {
          el = el || document.createElement("img");
          el.src = src;
          return el;
        },
        _getIconUrl: function(name2) {
          return Browser.retina && this.options[name2 + "RetinaUrl"] || this.options[name2 + "Url"];
        }
      });
      function icon(options2) {
        return new Icon2(options2);
      }
      var IconDefault = Icon2.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(name2) {
          if (typeof IconDefault.imagePath !== "string") {
            IconDefault.imagePath = this._detectIconPath();
          }
          return (this.options.imagePath || IconDefault.imagePath) + Icon2.prototype._getIconUrl.call(this, name2);
        },
        _stripUrl: function(path) {
          var strip = function(str, re2, idx) {
            var match = re2.exec(str);
            return match && match[idx];
          };
          path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
          return path && strip(path, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var el = create$1("div", "leaflet-default-icon-path", document.body);
          var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
          document.body.removeChild(el);
          path = this._stripUrl(path);
          if (path) {
            return path;
          }
          var link2 = document.querySelector('link[href$="leaflet.css"]');
          if (!link2) {
            return "";
          }
          return link2.href.substring(0, link2.href.length - "leaflet.css".length - 1);
        }
      });
      var MarkerDrag = Handler.extend({
        initialize: function(marker2) {
          this._marker = marker2;
        },
        addHooks: function() {
          var icon2 = this._marker._icon;
          if (!this._draggable) {
            this._draggable = new Draggable(icon2, icon2, true);
          }
          this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable();
          addClass(icon2, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable();
          if (this._marker._icon) {
            removeClass(this._marker._icon, "leaflet-marker-draggable");
          }
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(e) {
          var marker2 = this._marker, map = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map.getPixelBounds(), origin2 = map.getPixelOrigin();
          var panBounds = toBounds(
            bounds.min._subtract(origin2).add(padding),
            bounds.max._subtract(origin2).subtract(padding)
          );
          if (!panBounds.contains(iconPos)) {
            var movement = toPoint(
              (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
              (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
            ).multiplyBy(speed);
            map.panBy(movement, { animate: false });
            this._draggable._newPos._add(movement);
            this._draggable._startPos._add(movement);
            setPosition(marker2._icon, this._draggable._newPos);
            this._onDrag(e);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng();
          this._marker.closePopup && this._marker.closePopup();
          this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(e) {
          if (this._marker.options.autoPan) {
            cancelAnimFrame(this._panRequest);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
          }
        },
        _onDrag: function(e) {
          var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
          if (shadow) {
            setPosition(shadow, iconPos);
          }
          marker2._latlng = latlng;
          e.latlng = latlng;
          e.oldLatLng = this._oldLatLng;
          marker2.fire("move", e).fire("drag", e);
        },
        _onDragEnd: function(e) {
          cancelAnimFrame(this._panRequest);
          delete this._oldLatLng;
          this._marker.fire("moveend").fire("dragend", e);
        }
      });
      var Marker2 = Layer.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new IconDefault(),
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: true,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: false,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: false,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: true,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: false,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: false,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(latlng, options2) {
          setOptions(this, options2);
          this._latlng = toLatLng(latlng);
        },
        onAdd: function(map) {
          this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
          if (this._zoomAnimated) {
            map.on("zoomanim", this._animateZoom, this);
          }
          this._initIcon();
          this.update();
        },
        onRemove: function(map) {
          if (this.dragging && this.dragging.enabled()) {
            this.options.draggable = true;
            this.dragging.removeHooks();
          }
          delete this.dragging;
          if (this._zoomAnimated) {
            map.off("zoomanim", this._animateZoom, this);
          }
          this._removeIcon();
          this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.update();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(offset2) {
          this.options.zIndexOffset = offset2;
          return this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(icon2) {
          this.options.icon = icon2;
          if (this._map) {
            this._initIcon();
            this.update();
          }
          if (this._popup) {
            this.bindPopup(this._popup, this._popup.options);
          }
          return this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var pos = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(pos);
          }
          return this;
        },
        _initIcon: function() {
          var options2 = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          var icon2 = options2.icon.createIcon(this._icon), addIcon = false;
          if (icon2 !== this._icon) {
            if (this._icon) {
              this._removeIcon();
            }
            addIcon = true;
            if (options2.title) {
              icon2.title = options2.title;
            }
            if (icon2.tagName === "IMG") {
              icon2.alt = options2.alt || "";
            }
          }
          addClass(icon2, classToAdd);
          if (options2.keyboard) {
            icon2.tabIndex = "0";
            icon2.setAttribute("role", "button");
          }
          this._icon = icon2;
          if (options2.riseOnHover) {
            this.on({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            on(icon2, "focus", this._panOnFocus, this);
          }
          var newShadow = options2.icon.createShadow(this._shadow), addShadow = false;
          if (newShadow !== this._shadow) {
            this._removeShadow();
            addShadow = true;
          }
          if (newShadow) {
            addClass(newShadow, classToAdd);
            newShadow.alt = "";
          }
          this._shadow = newShadow;
          if (options2.opacity < 1) {
            this._updateOpacity();
          }
          if (addIcon) {
            this.getPane().appendChild(this._icon);
          }
          this._initInteraction();
          if (newShadow && addShadow) {
            this.getPane(options2.shadowPane).appendChild(this._shadow);
          }
        },
        _removeIcon: function() {
          if (this.options.riseOnHover) {
            this.off({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            off(this._icon, "focus", this._panOnFocus, this);
          }
          remove(this._icon);
          this.removeInteractiveTarget(this._icon);
          this._icon = null;
        },
        _removeShadow: function() {
          if (this._shadow) {
            remove(this._shadow);
          }
          this._shadow = null;
        },
        _setPos: function(pos) {
          if (this._icon) {
            setPosition(this._icon, pos);
          }
          if (this._shadow) {
            setPosition(this._shadow, pos);
          }
          this._zIndex = pos.y + this.options.zIndexOffset;
          this._resetZIndex();
        },
        _updateZIndex: function(offset2) {
          if (this._icon) {
            this._icon.style.zIndex = this._zIndex + offset2;
          }
        },
        _animateZoom: function(opt) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
          this._setPos(pos);
        },
        _initInteraction: function() {
          if (!this.options.interactive) {
            return;
          }
          addClass(this._icon, "leaflet-interactive");
          this.addInteractiveTarget(this._icon);
          if (MarkerDrag) {
            var draggable = this.options.draggable;
            if (this.dragging) {
              draggable = this.dragging.enabled();
              this.dragging.disable();
            }
            this.dragging = new MarkerDrag(this);
            if (draggable) {
              this.dragging.enable();
            }
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._map) {
            this._updateOpacity();
          }
          return this;
        },
        _updateOpacity: function() {
          var opacity = this.options.opacity;
          if (this._icon) {
            setOpacity(this._icon, opacity);
          }
          if (this._shadow) {
            setOpacity(this._shadow, opacity);
          }
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var map = this._map;
          if (!map) {
            return;
          }
          var iconOpts = this.options.icon.options;
          var size2 = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
          var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
          map.panInside(this._latlng, {
            paddingTopLeft: anchor,
            paddingBottomRight: size2.subtract(anchor)
          });
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function marker(latlng, options2) {
        return new Marker2(latlng, options2);
      }
      var Path = Layer.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: true,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: false,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: true
        },
        beforeAdd: function(map) {
          this._renderer = map.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this);
          this._reset();
          this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          if (this._map) {
            this._renderer._updatePath(this);
          }
          return this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(style2) {
          setOptions(this, style2);
          if (this._renderer) {
            this._renderer._updateStyle(this);
            if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
              this._updateBounds();
            }
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          if (this._renderer) {
            this._renderer._bringToFront(this);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          if (this._renderer) {
            this._renderer._bringToBack(this);
          }
          return this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project();
          this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      });
      var CircleMarker = Path.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: true,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(latlng, options2) {
          setOptions(this, options2);
          this._latlng = toLatLng(latlng);
          this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.redraw();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(radius) {
          this.options.radius = this._radius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(options2) {
          var radius = options2 && options2.radius || this._radius;
          Path.prototype.setStyle.call(this, options2);
          this.setRadius(radius);
          return this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng);
          this._updateBounds();
        },
        _updateBounds: function() {
          var r2 = this._radius, r22 = this._radiusY || r2, w = this._clickTolerance(), p = [r2 + w, r22 + w];
          this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
        },
        _update: function() {
          if (this._map) {
            this._updatePath();
          }
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function circleMarker(latlng, options2) {
        return new CircleMarker(latlng, options2);
      }
      var Circle2 = CircleMarker.extend({
        initialize: function(latlng, options2, legacyOptions) {
          if (typeof options2 === "number") {
            options2 = extend2({}, legacyOptions, { radius: options2 });
          }
          setOptions(this, options2);
          this._latlng = toLatLng(latlng);
          if (isNaN(this.options.radius)) {
            throw new Error("Circle radius cannot be NaN");
          }
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(radius) {
          this._mRadius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var half = [this._radius, this._radiusY || this._radius];
          return new LatLngBounds(
            this._map.layerPointToLatLng(this._point.subtract(half)),
            this._map.layerPointToLatLng(this._point.add(half))
          );
        },
        setStyle: Path.prototype.setStyle,
        _project: function() {
          var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
          if (crs.distance === Earth.distance) {
            var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([lat + latR, lng]), bottom = map.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
            if (isNaN(lngR) || lngR === 0) {
              lngR = latR / Math.cos(Math.PI / 180 * lat);
            }
            this._point = p.subtract(map.getPixelOrigin());
            this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
            this._radiusY = p.y - top.y;
          } else {
            var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = map.latLngToLayerPoint(this._latlng);
            this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
          }
          this._updateBounds();
        }
      });
      function circle(latlng, options2, legacyOptions) {
        return new Circle2(latlng, options2, legacyOptions);
      }
      var Polyline = Path.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: false
        },
        initialize: function(latlngs, options2) {
          setOptions(this, options2);
          this._setLatLngs(latlngs);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(latlngs) {
          this._setLatLngs(latlngs);
          return this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(p) {
          var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
          for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
            var points = this._parts[j];
            for (var i = 1, len = points.length; i < len; i++) {
              p1 = points[i - 1];
              p2 = points[i];
              var sqDist = closest(p, p1, p2, true);
              if (sqDist < minDistance) {
                minDistance = sqDist;
                minPoint = closest(p, p1, p2);
              }
            }
          }
          if (minPoint) {
            minPoint.distance = Math.sqrt(minDistance);
          }
          return minPoint;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polylineCenter(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(latlng, latlngs) {
          latlngs = latlngs || this._defaultShape();
          latlng = toLatLng(latlng);
          latlngs.push(latlng);
          this._bounds.extend(latlng);
          return this.redraw();
        },
        _setLatLngs: function(latlngs) {
          this._bounds = new LatLngBounds();
          this._latlngs = this._convertLatLngs(latlngs);
        },
        _defaultShape: function() {
          return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(latlngs) {
          var result = [], flat = isFlat(latlngs);
          for (var i = 0, len = latlngs.length; i < len; i++) {
            if (flat) {
              result[i] = toLatLng(latlngs[i]);
              this._bounds.extend(result[i]);
            } else {
              result[i] = this._convertLatLngs(latlngs[i]);
            }
          }
          return result;
        },
        _project: function() {
          var pxBounds = new Bounds();
          this._rings = [];
          this._projectLatlngs(this._latlngs, this._rings, pxBounds);
          if (this._bounds.isValid() && pxBounds.isValid()) {
            this._rawPxBounds = pxBounds;
            this._updateBounds();
          }
        },
        _updateBounds: function() {
          var w = this._clickTolerance(), p = new Point(w, w);
          if (!this._rawPxBounds) {
            return;
          }
          this._pxBounds = new Bounds([
            this._rawPxBounds.min.subtract(p),
            this._rawPxBounds.max.add(p)
          ]);
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(latlngs, result, projectedBounds) {
          var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
          if (flat) {
            ring = [];
            for (i = 0; i < len; i++) {
              ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
              projectedBounds.extend(ring[i]);
            }
            result.push(ring);
          } else {
            for (i = 0; i < len; i++) {
              this._projectLatlngs(latlngs[i], result, projectedBounds);
            }
          }
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var bounds = this._renderer._bounds;
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          var parts = this._parts, i, j, k, len, len2, segment, points;
          for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
            points = this._rings[i];
            for (j = 0, len2 = points.length; j < len2 - 1; j++) {
              segment = clipSegment(points[j], points[j + 1], bounds, j, true);
              if (!segment) {
                continue;
              }
              parts[k] = parts[k] || [];
              parts[k].push(segment[0]);
              if (segment[1] !== points[j + 1] || j === len2 - 2) {
                parts[k].push(segment[1]);
                k++;
              }
            }
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          var parts = this._parts, tolerance = this.options.smoothFactor;
          for (var i = 0, len = parts.length; i < len; i++) {
            parts[i] = simplify(parts[i], tolerance);
          }
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          this._clipPoints();
          this._simplifyPoints();
          this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p, closed) {
          var i, j, k, len, len2, part, w = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(p)) {
            return false;
          }
          for (i = 0, len = this._parts.length; i < len; i++) {
            part = this._parts[i];
            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
              if (!closed && j === 0) {
                continue;
              }
              if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                return true;
              }
            }
          }
          return false;
        }
      });
      function polyline(latlngs, options2) {
        return new Polyline(latlngs, options2);
      }
      Polyline._flat = _flat;
      var Polygon = Polyline.extend({
        options: {
          fill: true
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polygonCenter(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(latlngs) {
          var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
          if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
            result.pop();
          }
          return result;
        },
        _setLatLngs: function(latlngs) {
          Polyline.prototype._setLatLngs.call(this, latlngs);
          if (isFlat(this._latlngs)) {
            this._latlngs = [this._latlngs];
          }
        },
        _defaultShape: function() {
          return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
          bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
            clipped = clipPolygon(this._rings[i], bounds, true);
            if (clipped.length) {
              this._parts.push(clipped);
            }
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, true);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          var inside = false, part, p1, p2, i, j, k, len, len2;
          if (!this._pxBounds || !this._pxBounds.contains(p)) {
            return false;
          }
          for (i = 0, len = this._parts.length; i < len; i++) {
            part = this._parts[i];
            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
              p1 = part[j];
              p2 = part[k];
              if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                inside = !inside;
              }
            }
          }
          return inside || Polyline.prototype._containsPoint.call(this, p, true);
        }
      });
      function polygon(latlngs, options2) {
        return new Polygon(latlngs, options2);
      }
      var GeoJSON = FeatureGroup.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(geojson, options2) {
          setOptions(this, options2);
          this._layers = {};
          if (geojson) {
            this.addData(geojson);
          }
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(geojson) {
          var features = isArray2(geojson) ? geojson : geojson.features, i, len, feature;
          if (features) {
            for (i = 0, len = features.length; i < len; i++) {
              feature = features[i];
              if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                this.addData(feature);
              }
            }
            return this;
          }
          var options2 = this.options;
          if (options2.filter && !options2.filter(geojson)) {
            return this;
          }
          var layer = geometryToLayer(geojson, options2);
          if (!layer) {
            return this;
          }
          layer.feature = asFeature(geojson);
          layer.defaultOptions = layer.options;
          this.resetStyle(layer);
          if (options2.onEachFeature) {
            options2.onEachFeature(geojson, layer);
          }
          return this.addLayer(layer);
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(layer) {
          if (layer === void 0) {
            return this.eachLayer(this.resetStyle, this);
          }
          layer.options = extend2({}, layer.defaultOptions);
          this._setLayerStyle(layer, this.options.style);
          return this;
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(style2) {
          return this.eachLayer(function(layer) {
            this._setLayerStyle(layer, style2);
          }, this);
        },
        _setLayerStyle: function(layer, style2) {
          if (layer.setStyle) {
            if (typeof style2 === "function") {
              style2 = style2(layer.feature);
            }
            layer.setStyle(style2);
          }
        }
      });
      function geometryToLayer(geojson, options2) {
        var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options2 && options2.pointToLayer, _coordsToLatLng = options2 && options2.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
        if (!coords && !geometry) {
          return null;
        }
        switch (geometry.type) {
          case "Point":
            latlng = _coordsToLatLng(coords);
            return _pointToLayer(pointToLayer, geojson, latlng, options2);
          case "MultiPoint":
            for (i = 0, len = coords.length; i < len; i++) {
              latlng = _coordsToLatLng(coords[i]);
              layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options2));
            }
            return new FeatureGroup(layers2);
          case "LineString":
          case "MultiLineString":
            latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
            return new Polyline(latlngs, options2);
          case "Polygon":
          case "MultiPolygon":
            latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
            return new Polygon(latlngs, options2);
          case "GeometryCollection":
            for (i = 0, len = geometry.geometries.length; i < len; i++) {
              var geoLayer = geometryToLayer({
                geometry: geometry.geometries[i],
                type: "Feature",
                properties: geojson.properties
              }, options2);
              if (geoLayer) {
                layers2.push(geoLayer);
              }
            }
            return new FeatureGroup(layers2);
          case "FeatureCollection":
            for (i = 0, len = geometry.features.length; i < len; i++) {
              var featureLayer = geometryToLayer(geometry.features[i], options2);
              if (featureLayer) {
                layers2.push(featureLayer);
              }
            }
            return new FeatureGroup(layers2);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function _pointToLayer(pointToLayerFn, geojson, latlng, options2) {
        return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker2(latlng, options2 && options2.markersInheritOptions && options2);
      }
      function coordsToLatLng(coords) {
        return new LatLng(coords[1], coords[0], coords[2]);
      }
      function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
        var latlngs = [];
        for (var i = 0, len = coords.length, latlng; i < len; i++) {
          latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
          latlngs.push(latlng);
        }
        return latlngs;
      }
      function latLngToCoords(latlng, precision) {
        latlng = toLatLng(latlng);
        return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
      }
      function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
        var coords = [];
        for (var i = 0, len = latlngs.length; i < len; i++) {
          coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
        }
        if (!levelsDeep && closed && coords.length > 0) {
          coords.push(coords[0].slice());
        }
        return coords;
      }
      function getFeature(layer, newGeometry) {
        return layer.feature ? extend2({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
      }
      function asFeature(geojson) {
        if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
          return geojson;
        }
        return {
          type: "Feature",
          properties: {},
          geometry: geojson
        };
      }
      var PointToGeoJSON = {
        toGeoJSON: function(precision) {
          return getFeature(this, {
            type: "Point",
            coordinates: latLngToCoords(this.getLatLng(), precision)
          });
        }
      };
      Marker2.include(PointToGeoJSON);
      Circle2.include(PointToGeoJSON);
      CircleMarker.include(PointToGeoJSON);
      Polyline.include({
        toGeoJSON: function(precision) {
          var multi = !isFlat(this._latlngs);
          var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "LineString",
            coordinates: coords
          });
        }
      });
      Polygon.include({
        toGeoJSON: function(precision) {
          var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
          var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
          if (!holes) {
            coords = [coords];
          }
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "Polygon",
            coordinates: coords
          });
        }
      });
      LayerGroup.include({
        toMultiPoint: function(precision) {
          var coords = [];
          this.eachLayer(function(layer) {
            coords.push(layer.toGeoJSON(precision).geometry.coordinates);
          });
          return getFeature(this, {
            type: "MultiPoint",
            coordinates: coords
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(precision) {
          var type = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (type === "MultiPoint") {
            return this.toMultiPoint(precision);
          }
          var isGeometryCollection = type === "GeometryCollection", jsons = [];
          this.eachLayer(function(layer) {
            if (layer.toGeoJSON) {
              var json = layer.toGeoJSON(precision);
              if (isGeometryCollection) {
                jsons.push(json.geometry);
              } else {
                var feature = asFeature(json);
                if (feature.type === "FeatureCollection") {
                  jsons.push.apply(jsons, feature.features);
                } else {
                  jsons.push(feature);
                }
              }
            }
          });
          if (isGeometryCollection) {
            return getFeature(this, {
              geometries: jsons,
              type: "GeometryCollection"
            });
          }
          return {
            type: "FeatureCollection",
            features: jsons
          };
        }
      });
      function geoJSON(geojson, options2) {
        return new GeoJSON(geojson, options2);
      }
      var geoJson = geoJSON;
      var ImageOverlay = Layer.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(url, bounds, options2) {
          this._url = url;
          this._bounds = toLatLngBounds(bounds);
          setOptions(this, options2);
        },
        onAdd: function() {
          if (!this._image) {
            this._initImage();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
          }
          if (this.options.interactive) {
            addClass(this._image, "leaflet-interactive");
            this.addInteractiveTarget(this._image);
          }
          this.getPane().appendChild(this._image);
          this._reset();
        },
        onRemove: function() {
          remove(this._image);
          if (this.options.interactive) {
            this.removeInteractiveTarget(this._image);
          }
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._image) {
            this._updateOpacity();
          }
          return this;
        },
        setStyle: function(styleOpts) {
          if (styleOpts.opacity) {
            this.setOpacity(styleOpts.opacity);
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          if (this._map) {
            toFront(this._image);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          if (this._map) {
            toBack(this._image);
          }
          return this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(url) {
          this._url = url;
          if (this._image) {
            this._image.src = url;
          }
          return this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(bounds) {
          this._bounds = toLatLngBounds(bounds);
          if (this._map) {
            this._reset();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            zoom: this._reset,
            viewreset: this._reset
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(value) {
          this.options.zIndex = value;
          this._updateZIndex();
          return this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "IMG";
          var img = this._image = wasElementSupplied ? this._url : create$1("img");
          addClass(img, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(img, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(img, this.options.className);
          }
          img.onselectstart = falseFn;
          img.onmousemove = falseFn;
          img.onload = bind2(this.fire, this, "load");
          img.onerror = bind2(this._overlayOnError, this, "error");
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (this.options.zIndex) {
            this._updateZIndex();
          }
          if (wasElementSupplied) {
            this._url = img.src;
            return;
          }
          img.src = this._url;
          img.alt = this.options.alt;
        },
        _animateZoom: function(e) {
          var scale3 = this._map.getZoomScale(e.zoom), offset2 = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
          setTransform(this._image, offset2, scale3);
        },
        _reset: function() {
          var image2 = this._image, bounds = new Bounds(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), size2 = bounds.getSize();
          setPosition(image2, bounds.min);
          image2.style.width = size2.x + "px";
          image2.style.height = size2.y + "px";
        },
        _updateOpacity: function() {
          setOpacity(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._image.style.zIndex = this.options.zIndex;
          }
        },
        _overlayOnError: function() {
          this.fire("error");
          var errorUrl = this.options.errorOverlayUrl;
          if (errorUrl && this._url !== errorUrl) {
            this._url = errorUrl;
            this._image.src = errorUrl;
          }
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      });
      var imageOverlay = function(url, bounds, options2) {
        return new ImageOverlay(url, bounds, options2);
      };
      var VideoOverlay = ImageOverlay.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: true,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: true,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: true,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: false,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: true
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "VIDEO";
          var vid = this._image = wasElementSupplied ? this._url : create$1("video");
          addClass(vid, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(vid, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(vid, this.options.className);
          }
          vid.onselectstart = falseFn;
          vid.onmousemove = falseFn;
          vid.onloadeddata = bind2(this.fire, this, "load");
          if (wasElementSupplied) {
            var sourceElements = vid.getElementsByTagName("source");
            var sources = [];
            for (var j = 0; j < sourceElements.length; j++) {
              sources.push(sourceElements[j].src);
            }
            this._url = sourceElements.length > 0 ? sources : [vid.src];
            return;
          }
          if (!isArray2(this._url)) {
            this._url = [this._url];
          }
          if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
            vid.style["objectFit"] = "fill";
          }
          vid.autoplay = !!this.options.autoplay;
          vid.loop = !!this.options.loop;
          vid.muted = !!this.options.muted;
          vid.playsInline = !!this.options.playsInline;
          for (var i = 0; i < this._url.length; i++) {
            var source = create$1("source");
            source.src = this._url[i];
            vid.appendChild(source);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function videoOverlay(video, bounds, options2) {
        return new VideoOverlay(video, bounds, options2);
      }
      var SVGOverlay = ImageOverlay.extend({
        _initImage: function() {
          var el = this._image = this._url;
          addClass(el, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(el, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(el, this.options.className);
          }
          el.onselectstart = falseFn;
          el.onmousemove = falseFn;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function svgOverlay(el, bounds, options2) {
        return new SVGOverlay(el, bounds, options2);
      }
      var DivOverlay = Layer.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: false,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0,
          // @option content: String|HTMLElement|Function = ''
          // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
          // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
          content: ""
        },
        initialize: function(options2, source) {
          if (options2 && (options2 instanceof LatLng || isArray2(options2))) {
            this._latlng = toLatLng(options2);
            setOptions(this, source);
          } else {
            setOptions(this, options2);
            this._source = source;
          }
          if (this.options.content) {
            this._content = this.options.content;
          }
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(map) {
          map = arguments.length ? map : this._source._map;
          if (!map.hasLayer(this)) {
            map.addLayer(this);
          }
          return this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          if (this._map) {
            this._map.removeLayer(this);
          }
          return this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(layer) {
          if (this._map) {
            this.close();
          } else {
            if (arguments.length) {
              this._source = layer;
            } else {
              layer = this._source;
            }
            this._prepareOpen();
            this.openOn(layer._map);
          }
          return this;
        },
        onAdd: function(map) {
          this._zoomAnimated = map._zoomAnimated;
          if (!this._container) {
            this._initLayout();
          }
          if (map._fadeAnimated) {
            setOpacity(this._container, 0);
          }
          clearTimeout(this._removeTimeout);
          this.getPane().appendChild(this._container);
          this.update();
          if (map._fadeAnimated) {
            setOpacity(this._container, 1);
          }
          this.bringToFront();
          if (this.options.interactive) {
            addClass(this._container, "leaflet-interactive");
            this.addInteractiveTarget(this._container);
          }
        },
        onRemove: function(map) {
          if (map._fadeAnimated) {
            setOpacity(this._container, 0);
            this._removeTimeout = setTimeout(bind2(remove, void 0, this._container), 200);
          } else {
            remove(this._container);
          }
          if (this.options.interactive) {
            removeClass(this._container, "leaflet-interactive");
            this.removeInteractiveTarget(this._container);
          }
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(latlng) {
          this._latlng = toLatLng(latlng);
          if (this._map) {
            this._updatePosition();
            this._adjustPan();
          }
          return this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(content2) {
          this._content = content2;
          this.update();
          return this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          if (!this._map) {
            return;
          }
          this._container.style.visibility = "hidden";
          this._updateContent();
          this._updateLayout();
          this._updatePosition();
          this._container.style.visibility = "";
          this._adjustPan();
        },
        getEvents: function() {
          var events = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
          }
          return this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(latlng) {
          var source = this._source;
          if (!source._map) {
            return false;
          }
          if (source instanceof FeatureGroup) {
            source = null;
            var layers2 = this._source._layers;
            for (var id2 in layers2) {
              if (layers2[id2]._map) {
                source = layers2[id2];
                break;
              }
            }
            if (!source) {
              return false;
            }
            this._source = source;
          }
          if (!latlng) {
            if (source.getCenter) {
              latlng = source.getCenter();
            } else if (source.getLatLng) {
              latlng = source.getLatLng();
            } else if (source.getBounds) {
              latlng = source.getBounds().getCenter();
            } else {
              throw new Error("Unable to get source layer LatLng.");
            }
          }
          this.setLatLng(latlng);
          if (this._map) {
            this.update();
          }
          return true;
        },
        _updateContent: function() {
          if (!this._content) {
            return;
          }
          var node2 = this._contentNode;
          var content2 = typeof this._content === "function" ? this._content(this._source || this) : this._content;
          if (typeof content2 === "string") {
            node2.innerHTML = content2;
          } else {
            while (node2.hasChildNodes()) {
              node2.removeChild(node2.firstChild);
            }
            node2.appendChild(content2);
          }
          this.fire("contentupdate");
        },
        _updatePosition: function() {
          if (!this._map) {
            return;
          }
          var pos = this._map.latLngToLayerPoint(this._latlng), offset2 = toPoint(this.options.offset), anchor = this._getAnchor();
          if (this._zoomAnimated) {
            setPosition(this._container, pos.add(anchor));
          } else {
            offset2 = offset2.add(pos).add(anchor);
          }
          var bottom = this._containerBottom = -offset2.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset2.x;
          this._container.style.bottom = bottom + "px";
          this._container.style.left = left + "px";
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      Map2.include({
        _initOverlay: function(OverlayClass, content2, latlng, options2) {
          var overlay = content2;
          if (!(overlay instanceof OverlayClass)) {
            overlay = new OverlayClass(options2).setContent(content2);
          }
          if (latlng) {
            overlay.setLatLng(latlng);
          }
          return overlay;
        }
      });
      Layer.include({
        _initOverlay: function(OverlayClass, old, content2, options2) {
          var overlay = content2;
          if (overlay instanceof OverlayClass) {
            setOptions(overlay, options2);
            overlay._source = this;
          } else {
            overlay = old && !options2 ? old : new OverlayClass(options2, this);
            overlay.setContent(content2);
          }
          return overlay;
        }
      });
      var Popup2 = DivOverlay.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          // The scrollable container can be styled using the
          // `leaflet-popup-scrolled` CSS class selector.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: true,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: false,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: true,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: true,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: true,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(map) {
          map = arguments.length ? map : this._source._map;
          if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
            map.removeLayer(map._popup);
          }
          map._popup = this;
          return DivOverlay.prototype.openOn.call(this, map);
        },
        onAdd: function(map) {
          DivOverlay.prototype.onAdd.call(this, map);
          map.fire("popupopen", { popup: this });
          if (this._source) {
            this._source.fire("popupopen", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.on("preclick", stopPropagation);
            }
          }
        },
        onRemove: function(map) {
          DivOverlay.prototype.onRemove.call(this, map);
          map.fire("popupclose", { popup: this });
          if (this._source) {
            this._source.fire("popupclose", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.off("preclick", stopPropagation);
            }
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
            events.preclick = this.close;
          }
          if (this.options.keepInView) {
            events.moveend = this._adjustPan;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-popup", container = this._container = create$1(
            "div",
            prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
          );
          var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
          this._contentNode = create$1("div", prefix + "-content", wrapper);
          disableClickPropagation(container);
          disableScrollPropagation(this._contentNode);
          on(container, "contextmenu", stopPropagation);
          this._tipContainer = create$1("div", prefix + "-tip-container", container);
          this._tip = create$1("div", prefix + "-tip", this._tipContainer);
          if (this.options.closeButton) {
            var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
            closeButton.setAttribute("role", "button");
            closeButton.setAttribute("aria-label", "Close popup");
            closeButton.href = "#close";
            closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
            on(closeButton, "click", function(ev) {
              preventDefault(ev);
              this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var container = this._contentNode, style2 = container.style;
          style2.width = "";
          style2.whiteSpace = "nowrap";
          var width = container.offsetWidth;
          width = Math.min(width, this.options.maxWidth);
          width = Math.max(width, this.options.minWidth);
          style2.width = width + 1 + "px";
          style2.whiteSpace = "";
          style2.height = "";
          var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
          if (maxHeight && height > maxHeight) {
            style2.height = maxHeight + "px";
            addClass(container, scrolledClass);
          } else {
            removeClass(container, scrolledClass);
          }
          this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(e) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
          setPosition(this._container, pos.add(anchor));
        },
        _adjustPan: function() {
          if (!this.options.autoPan) {
            return;
          }
          if (this._map._panAnim) {
            this._map._panAnim.stop();
          }
          if (this._autopanning) {
            this._autopanning = false;
            return;
          }
          var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
          layerPos._add(getPosition(this._container));
          var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size2 = map.getSize(), dx = 0, dy = 0;
          if (containerPos.x + containerWidth + paddingBR.x > size2.x) {
            dx = containerPos.x + containerWidth - size2.x + paddingBR.x;
          }
          if (containerPos.x - dx - paddingTL.x < 0) {
            dx = containerPos.x - paddingTL.x;
          }
          if (containerPos.y + containerHeight + paddingBR.y > size2.y) {
            dy = containerPos.y + containerHeight - size2.y + paddingBR.y;
          }
          if (containerPos.y - dy - paddingTL.y < 0) {
            dy = containerPos.y - paddingTL.y;
          }
          if (dx || dy) {
            if (this.options.keepInView) {
              this._autopanning = true;
            }
            map.fire("autopanstart").panBy([dx, dy]);
          }
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      });
      var popup = function(options2, source) {
        return new Popup2(options2, source);
      };
      Map2.mergeOptions({
        closePopupOnClick: true
      });
      Map2.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(popup2, latlng, options2) {
          this._initOverlay(Popup2, popup2, latlng, options2).openOn(this);
          return this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(popup2) {
          popup2 = arguments.length ? popup2 : this._popup;
          if (popup2) {
            popup2.close();
          }
          return this;
        }
      });
      Layer.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(content2, options2) {
          this._popup = this._initOverlay(Popup2, this._popup, content2, options2);
          if (!this._popupHandlersAdded) {
            this.on({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = true;
          }
          return this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          if (this._popup) {
            this.off({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = false;
            this._popup = null;
          }
          return this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(latlng) {
          if (this._popup) {
            if (!(this instanceof FeatureGroup)) {
              this._popup._source = this;
            }
            if (this._popup._prepareOpen(latlng || this._latlng)) {
              this._popup.openOn(this._map);
            }
          }
          return this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          if (this._popup) {
            this._popup.close();
          }
          return this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          if (this._popup) {
            this._popup.toggle(this);
          }
          return this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : false;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(content2) {
          if (this._popup) {
            this._popup.setContent(content2);
          }
          return this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(e) {
          if (!this._popup || !this._map) {
            return;
          }
          stop(e);
          var target = e.layer || e.target;
          if (this._popup._source === target && !(target instanceof Path)) {
            if (this._map.hasLayer(this._popup)) {
              this.closePopup();
            } else {
              this.openPopup(e.latlng);
            }
            return;
          }
          this._popup._source = target;
          this.openPopup(e.latlng);
        },
        _movePopup: function(e) {
          this._popup.setLatLng(e.latlng);
        },
        _onKeyPress: function(e) {
          if (e.originalEvent.keyCode === 13) {
            this._openPopup(e);
          }
        }
      });
      var Tooltip = DivOverlay.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: false,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: false,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(map) {
          DivOverlay.prototype.onAdd.call(this, map);
          this.setOpacity(this.options.opacity);
          map.fire("tooltipopen", { tooltip: this });
          if (this._source) {
            this.addEventParent(this._source);
            this._source.fire("tooltipopen", { tooltip: this }, true);
          }
        },
        onRemove: function(map) {
          DivOverlay.prototype.onRemove.call(this, map);
          map.fire("tooltipclose", { tooltip: this });
          if (this._source) {
            this.removeEventParent(this._source);
            this._source.fire("tooltipclose", { tooltip: this }, true);
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (!this.options.permanent) {
            events.preclick = this.close;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = create$1("div", className);
          this._container.setAttribute("role", "tooltip");
          this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(pos) {
          var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset2 = toPoint(this.options.offset), anchor = this._getAnchor();
          if (direction === "top") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight;
          } else if (direction === "bottom") {
            subX = tooltipWidth / 2;
            subY = 0;
          } else if (direction === "center") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight / 2;
          } else if (direction === "right") {
            subX = 0;
            subY = tooltipHeight / 2;
          } else if (direction === "left") {
            subX = tooltipWidth;
            subY = tooltipHeight / 2;
          } else if (tooltipPoint.x < centerPoint.x) {
            direction = "right";
            subX = 0;
            subY = tooltipHeight / 2;
          } else {
            direction = "left";
            subX = tooltipWidth + (offset2.x + anchor.x) * 2;
            subY = tooltipHeight / 2;
          }
          pos = pos.subtract(toPoint(subX, subY, true)).add(offset2).add(anchor);
          removeClass(container, "leaflet-tooltip-right");
          removeClass(container, "leaflet-tooltip-left");
          removeClass(container, "leaflet-tooltip-top");
          removeClass(container, "leaflet-tooltip-bottom");
          addClass(container, "leaflet-tooltip-" + direction);
          setPosition(container, pos);
        },
        _updatePosition: function() {
          var pos = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(pos);
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._container) {
            setOpacity(this._container, opacity);
          }
        },
        _animateZoom: function(e) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
          this._setPosition(pos);
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      });
      var tooltip = function(options2, source) {
        return new Tooltip(options2, source);
      };
      Map2.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(tooltip2, latlng, options2) {
          this._initOverlay(Tooltip, tooltip2, latlng, options2).openOn(this);
          return this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(tooltip2) {
          tooltip2.close();
          return this;
        }
      });
      Layer.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(content2, options2) {
          if (this._tooltip && this.isTooltipOpen()) {
            this.unbindTooltip();
          }
          this._tooltip = this._initOverlay(Tooltip, this._tooltip, content2, options2);
          this._initTooltipInteractions();
          if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
            this.openTooltip();
          }
          return this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          if (this._tooltip) {
            this._initTooltipInteractions(true);
            this.closeTooltip();
            this._tooltip = null;
          }
          return this;
        },
        _initTooltipInteractions: function(remove2) {
          if (!remove2 && this._tooltipHandlersAdded) {
            return;
          }
          var onOff = remove2 ? "off" : "on", events = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
          if (!this._tooltip.options.permanent) {
            events.mouseover = this._openTooltip;
            events.mouseout = this.closeTooltip;
            events.click = this._openTooltip;
            if (this._map) {
              this._addFocusListeners();
            } else {
              events.add = this._addFocusListeners;
            }
          } else {
            events.add = this._openTooltip;
          }
          if (this._tooltip.options.sticky) {
            events.mousemove = this._moveTooltip;
          }
          this[onOff](events);
          this._tooltipHandlersAdded = !remove2;
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(latlng) {
          if (this._tooltip) {
            if (!(this instanceof FeatureGroup)) {
              this._tooltip._source = this;
            }
            if (this._tooltip._prepareOpen(latlng)) {
              this._tooltip.openOn(this._map);
              if (this.getElement) {
                this._setAriaDescribedByOnLayer(this);
              } else if (this.eachLayer) {
                this.eachLayer(this._setAriaDescribedByOnLayer, this);
              }
            }
          }
          return this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip) {
            return this._tooltip.close();
          }
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          if (this._tooltip) {
            this._tooltip.toggle(this);
          }
          return this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(content2) {
          if (this._tooltip) {
            this._tooltip.setContent(content2);
          }
          return this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          if (this.getElement) {
            this._addFocusListenersOnLayer(this);
          } else if (this.eachLayer) {
            this.eachLayer(this._addFocusListenersOnLayer, this);
          }
        },
        _addFocusListenersOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            on(el, "focus", function() {
              this._tooltip._source = layer;
              this.openTooltip();
            }, this);
            on(el, "blur", this.closeTooltip, this);
          }
        },
        _setAriaDescribedByOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            el.setAttribute("aria-describedby", this._tooltip._container.id);
          }
        },
        _openTooltip: function(e) {
          if (!this._tooltip || !this._map) {
            return;
          }
          if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
            this._openOnceFlag = true;
            var that = this;
            this._map.once("moveend", function() {
              that._openOnceFlag = false;
              that._openTooltip(e);
            });
            return;
          }
          this._tooltip._source = e.layer || e.target;
          this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
        },
        _moveTooltip: function(e) {
          var latlng = e.latlng, containerPoint, layerPoint;
          if (this._tooltip.options.sticky && e.originalEvent) {
            containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
            layerPoint = this._map.containerPointToLayerPoint(containerPoint);
            latlng = this._map.layerPointToLatLng(layerPoint);
          }
          this._tooltip.setLatLng(latlng);
        }
      });
      var DivIcon = Icon2.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: false,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(oldIcon) {
          var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options2 = this.options;
          if (options2.html instanceof Element) {
            empty2(div);
            div.appendChild(options2.html);
          } else {
            div.innerHTML = options2.html !== false ? options2.html : "";
          }
          if (options2.bgPos) {
            var bgPos = toPoint(options2.bgPos);
            div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
          }
          this._setIconStyles(div, "icon");
          return div;
        },
        createShadow: function() {
          return null;
        }
      });
      function divIcon(options2) {
        return new DivIcon(options2);
      }
      Icon2.Default = IconDefault;
      var GridLayer = Layer.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: Browser.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: true,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: false,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(options2) {
          setOptions(this, options2);
        },
        onAdd: function() {
          this._initContainer();
          this._levels = {};
          this._tiles = {};
          this._resetView();
        },
        beforeAdd: function(map) {
          map._addZoomLimit(this);
        },
        onRemove: function(map) {
          this._removeAllTiles();
          remove(this._container);
          map._removeZoomLimit(this);
          this._container = null;
          this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
            this._setAutoZIndex(Math.max);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
            this._setAutoZIndex(Math.min);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          this._updateOpacity();
          return this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(zIndex) {
          this.options.zIndex = zIndex;
          this._updateZIndex();
          return this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var tileZoom = this._clampZoom(this._map.getZoom());
            if (tileZoom !== this._tileZoom) {
              this._tileZoom = tileZoom;
              this._updateLevels();
            }
            this._update();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          if (!this.options.updateWhenIdle) {
            if (!this._onMove) {
              this._onMove = throttle2(this._onMoveEnd, this.options.updateInterval, this);
            }
            events.move = this._onMove;
          }
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var s = this.options.tileSize;
          return s instanceof Point ? s : new Point(s, s);
        },
        _updateZIndex: function() {
          if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._container.style.zIndex = this.options.zIndex;
          }
        },
        _setAutoZIndex: function(compare) {
          var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
          for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
            zIndex = layers2[i].style.zIndex;
            if (layers2[i] !== this._container && zIndex) {
              edgeZIndex = compare(edgeZIndex, +zIndex);
            }
          }
          if (isFinite(edgeZIndex)) {
            this.options.zIndex = edgeZIndex + compare(-1, 1);
            this._updateZIndex();
          }
        },
        _updateOpacity: function() {
          if (!this._map) {
            return;
          }
          if (Browser.ielt9) {
            return;
          }
          setOpacity(this._container, this.options.opacity);
          var now2 = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
          for (var key in this._tiles) {
            var tile = this._tiles[key];
            if (!tile.current || !tile.loaded) {
              continue;
            }
            var fade = Math.min(1, (now2 - tile.loaded) / 200);
            setOpacity(tile.el, fade);
            if (fade < 1) {
              nextFrame = true;
            } else {
              if (tile.active) {
                willPrune = true;
              } else {
                this._onOpaqueTile(tile);
              }
              tile.active = true;
            }
          }
          if (willPrune && !this._noPrune) {
            this._pruneTiles();
          }
          if (nextFrame) {
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          }
        },
        _onOpaqueTile: falseFn,
        _initContainer: function() {
          if (this._container) {
            return;
          }
          this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
          this._updateZIndex();
          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
          this.getPane().appendChild(this._container);
        },
        _updateLevels: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
          if (zoom2 === void 0) {
            return void 0;
          }
          for (var z in this._levels) {
            z = Number(z);
            if (this._levels[z].el.children.length || z === zoom2) {
              this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
              this._onUpdateLevel(z);
            } else {
              remove(this._levels[z].el);
              this._removeTilesAtZoom(z);
              this._onRemoveLevel(z);
              delete this._levels[z];
            }
          }
          var level = this._levels[zoom2], map = this._map;
          if (!level) {
            level = this._levels[zoom2] = {};
            level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
            level.el.style.zIndex = maxZoom;
            level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom2).round();
            level.zoom = zoom2;
            this._setZoomTransform(level, map.getCenter(), map.getZoom());
            falseFn(level.el.offsetWidth);
            this._onCreateLevel(level);
          }
          this._level = level;
          return level;
        },
        _onUpdateLevel: falseFn,
        _onRemoveLevel: falseFn,
        _onCreateLevel: falseFn,
        _pruneTiles: function() {
          if (!this._map) {
            return;
          }
          var key, tile;
          var zoom2 = this._map.getZoom();
          if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
            this._removeAllTiles();
            return;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            tile.retain = tile.current;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            if (tile.current && !tile.active) {
              var coords = tile.coords;
              if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
              }
            }
          }
          for (key in this._tiles) {
            if (!this._tiles[key].retain) {
              this._removeTile(key);
            }
          }
        },
        _removeTilesAtZoom: function(zoom2) {
          for (var key in this._tiles) {
            if (this._tiles[key].coords.z !== zoom2) {
              continue;
            }
            this._removeTile(key);
          }
        },
        _removeAllTiles: function() {
          for (var key in this._tiles) {
            this._removeTile(key);
          }
        },
        _invalidateAll: function() {
          for (var z in this._levels) {
            remove(this._levels[z].el);
            this._onRemoveLevel(Number(z));
            delete this._levels[z];
          }
          this._removeAllTiles();
          this._tileZoom = void 0;
        },
        _retainParent: function(x, y, z, minZoom) {
          var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
          coords2.z = +z2;
          var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
          if (tile && tile.active) {
            tile.retain = true;
            return true;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }
          if (z2 > minZoom) {
            return this._retainParent(x2, y2, z2, minZoom);
          }
          return false;
        },
        _retainChildren: function(x, y, z, maxZoom) {
          for (var i = 2 * x; i < 2 * x + 2; i++) {
            for (var j = 2 * y; j < 2 * y + 2; j++) {
              var coords = new Point(i, j);
              coords.z = z + 1;
              var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
              if (tile && tile.active) {
                tile.retain = true;
                continue;
              } else if (tile && tile.loaded) {
                tile.retain = true;
              }
              if (z + 1 < maxZoom) {
                this._retainChildren(i, j, z + 1, maxZoom);
              }
            }
          }
        },
        _resetView: function(e) {
          var animating = e && (e.pinch || e.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
        },
        _animateZoom: function(e) {
          this._setView(e.center, e.zoom, true, e.noUpdate);
        },
        _clampZoom: function(zoom2) {
          var options2 = this.options;
          if (void 0 !== options2.minNativeZoom && zoom2 < options2.minNativeZoom) {
            return options2.minNativeZoom;
          }
          if (void 0 !== options2.maxNativeZoom && options2.maxNativeZoom < zoom2) {
            return options2.maxNativeZoom;
          }
          return zoom2;
        },
        _setView: function(center, zoom2, noPrune, noUpdate) {
          var tileZoom = Math.round(zoom2);
          if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
            tileZoom = void 0;
          } else {
            tileZoom = this._clampZoom(tileZoom);
          }
          var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
          if (!noUpdate || tileZoomChanged) {
            this._tileZoom = tileZoom;
            if (this._abortLoading) {
              this._abortLoading();
            }
            this._updateLevels();
            this._resetGrid();
            if (tileZoom !== void 0) {
              this._update(center);
            }
            if (!noPrune) {
              this._pruneTiles();
            }
            this._noPrune = !!noPrune;
          }
          this._setZoomTransforms(center, zoom2);
        },
        _setZoomTransforms: function(center, zoom2) {
          for (var i in this._levels) {
            this._setZoomTransform(this._levels[i], center, zoom2);
          }
        },
        _setZoomTransform: function(level, center, zoom2) {
          var scale3 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale3).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
          if (Browser.any3d) {
            setTransform(level.el, translate, scale3);
          } else {
            setPosition(level.el, translate);
          }
        },
        _resetGrid: function() {
          var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
          var bounds = this._map.getPixelWorldBounds(this._tileZoom);
          if (bounds) {
            this._globalTileRange = this._pxBoundsToTileRange(bounds);
          }
          this._wrapX = crs.wrapLng && !this.options.noWrap && [
            Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
            Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
          ];
          this._wrapY = crs.wrapLat && !this.options.noWrap && [
            Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
            Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
          ];
        },
        _onMoveEnd: function() {
          if (!this._map || this._map._animatingZoom) {
            return;
          }
          this._update();
        },
        _getTiledPixelBounds: function(center) {
          var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale3 = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale3 * 2);
          return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(center) {
          var map = this._map;
          if (!map) {
            return;
          }
          var zoom2 = this._clampZoom(map.getZoom());
          if (center === void 0) {
            center = map.getCenter();
          }
          if (this._tileZoom === void 0) {
            return;
          }
          var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
            tileRange.getBottomLeft().subtract([margin, -margin]),
            tileRange.getTopRight().add([margin, -margin])
          );
          if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
            throw new Error("Attempted to load an infinite number of tiles");
          }
          for (var key in this._tiles) {
            var c = this._tiles[key].coords;
            if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
              this._tiles[key].current = false;
            }
          }
          if (Math.abs(zoom2 - this._tileZoom) > 1) {
            this._setView(center, zoom2);
            return;
          }
          for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
              var coords = new Point(i, j);
              coords.z = this._tileZoom;
              if (!this._isValidTile(coords)) {
                continue;
              }
              var tile = this._tiles[this._tileCoordsToKey(coords)];
              if (tile) {
                tile.current = true;
              } else {
                queue.push(coords);
              }
            }
          }
          queue.sort(function(a, b) {
            return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
          });
          if (queue.length !== 0) {
            if (!this._loading) {
              this._loading = true;
              this.fire("loading");
            }
            var fragment = document.createDocumentFragment();
            for (i = 0; i < queue.length; i++) {
              this._addTile(queue[i], fragment);
            }
            this._level.el.appendChild(fragment);
          }
        },
        _isValidTile: function(coords) {
          var crs = this._map.options.crs;
          if (!crs.infinite) {
            var bounds = this._globalTileRange;
            if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
              return false;
            }
          }
          if (!this.options.bounds) {
            return true;
          }
          var tileBounds = this._tileCoordsToBounds(coords);
          return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
        },
        _keyToBounds: function(key) {
          return this._tileCoordsToBounds(this._keyToTileCoords(key));
        },
        _tileCoordsToNwSe: function(coords) {
          var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se = map.unproject(sePoint, coords.z);
          return [nw, se];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(coords) {
          var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
          if (!this.options.noWrap) {
            bounds = this._map.wrapLatLngBounds(bounds);
          }
          return bounds;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(coords) {
          return coords.x + ":" + coords.y + ":" + coords.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(key) {
          var k = key.split(":"), coords = new Point(+k[0], +k[1]);
          coords.z = +k[2];
          return coords;
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          remove(tile.el);
          delete this._tiles[key];
          this.fire("tileunload", {
            tile: tile.el,
            coords: this._keyToTileCoords(key)
          });
        },
        _initTile: function(tile) {
          addClass(tile, "leaflet-tile");
          var tileSize = this.getTileSize();
          tile.style.width = tileSize.x + "px";
          tile.style.height = tileSize.y + "px";
          tile.onselectstart = falseFn;
          tile.onmousemove = falseFn;
          if (Browser.ielt9 && this.options.opacity < 1) {
            setOpacity(tile, this.options.opacity);
          }
        },
        _addTile: function(coords, container) {
          var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
          var tile = this.createTile(this._wrapCoords(coords), bind2(this._tileReady, this, coords));
          this._initTile(tile);
          if (this.createTile.length < 2) {
            requestAnimFrame(bind2(this._tileReady, this, coords, null, tile));
          }
          setPosition(tile, tilePos);
          this._tiles[key] = {
            el: tile,
            coords,
            current: true
          };
          container.appendChild(tile);
          this.fire("tileloadstart", {
            tile,
            coords
          });
        },
        _tileReady: function(coords, err, tile) {
          if (err) {
            this.fire("tileerror", {
              error: err,
              tile,
              coords
            });
          }
          var key = this._tileCoordsToKey(coords);
          tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.loaded = +/* @__PURE__ */ new Date();
          if (this._map._fadeAnimated) {
            setOpacity(tile.el, 0);
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          } else {
            tile.active = true;
            this._pruneTiles();
          }
          if (!err) {
            addClass(tile.el, "leaflet-tile-loaded");
            this.fire("tileload", {
              tile: tile.el,
              coords
            });
          }
          if (this._noTilesToLoad()) {
            this._loading = false;
            this.fire("load");
            if (Browser.ielt9 || !this._map._fadeAnimated) {
              requestAnimFrame(this._pruneTiles, this);
            } else {
              setTimeout(bind2(this._pruneTiles, this), 250);
            }
          }
        },
        _getTilePos: function(coords) {
          return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(coords) {
          var newCoords = new Point(
            this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
            this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
          );
          newCoords.z = coords.z;
          return newCoords;
        },
        _pxBoundsToTileRange: function(bounds) {
          var tileSize = this.getTileSize();
          return new Bounds(
            bounds.min.unscaleBy(tileSize).floor(),
            bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var key in this._tiles) {
            if (!this._tiles[key].loaded) {
              return false;
            }
          }
          return true;
        }
      });
      function gridLayer(options2) {
        return new GridLayer(options2);
      }
      var TileLayer2 = GridLayer.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: false,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: false,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: false
        },
        initialize: function(url, options2) {
          this._url = url;
          options2 = setOptions(this, options2);
          if (options2.detectRetina && Browser.retina && options2.maxZoom > 0) {
            options2.tileSize = Math.floor(options2.tileSize / 2);
            if (!options2.zoomReverse) {
              options2.zoomOffset++;
              options2.maxZoom = Math.max(options2.minZoom, options2.maxZoom - 1);
            } else {
              options2.zoomOffset--;
              options2.minZoom = Math.min(options2.maxZoom, options2.minZoom + 1);
            }
            options2.minZoom = Math.max(0, options2.minZoom);
          } else if (!options2.zoomReverse) {
            options2.maxZoom = Math.max(options2.minZoom, options2.maxZoom);
          } else {
            options2.minZoom = Math.min(options2.maxZoom, options2.minZoom);
          }
          if (typeof options2.subdomains === "string") {
            options2.subdomains = options2.subdomains.split("");
          }
          this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(url, noRedraw) {
          if (this._url === url && noRedraw === void 0) {
            noRedraw = true;
          }
          this._url = url;
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(coords, done) {
          var tile = document.createElement("img");
          on(tile, "load", bind2(this._tileOnLoad, this, done, tile));
          on(tile, "error", bind2(this._tileOnError, this, done, tile));
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (typeof this.options.referrerPolicy === "string") {
            tile.referrerPolicy = this.options.referrerPolicy;
          }
          tile.alt = "";
          tile.src = this.getTileUrl(coords);
          return tile;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(coords) {
          var data = {
            r: Browser.retina ? "@2x" : "",
            s: this._getSubdomain(coords),
            x: coords.x,
            y: coords.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var invertedY = this._globalTileRange.max.y - coords.y;
            if (this.options.tms) {
              data["y"] = invertedY;
            }
            data["-y"] = invertedY;
          }
          return template(this._url, extend2(data, this.options));
        },
        _tileOnLoad: function(done, tile) {
          if (Browser.ielt9) {
            setTimeout(bind2(done, this, null, tile), 0);
          } else {
            done(null, tile);
          }
        },
        _tileOnError: function(done, tile, e) {
          var errorUrl = this.options.errorTileUrl;
          if (errorUrl && tile.getAttribute("src") !== errorUrl) {
            tile.src = errorUrl;
          }
          done(e, tile);
        },
        _onTileRemove: function(e) {
          e.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
          if (zoomReverse) {
            zoom2 = maxZoom - zoom2;
          }
          return zoom2 + zoomOffset;
        },
        _getSubdomain: function(tilePoint) {
          var index3 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
          return this.options.subdomains[index3];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var i, tile;
          for (i in this._tiles) {
            if (this._tiles[i].coords.z !== this._tileZoom) {
              tile = this._tiles[i].el;
              tile.onload = falseFn;
              tile.onerror = falseFn;
              if (!tile.complete) {
                tile.src = emptyImageUrl;
                var coords = this._tiles[i].coords;
                remove(tile);
                delete this._tiles[i];
                this.fire("tileabort", {
                  tile,
                  coords
                });
              }
            }
          }
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.el.setAttribute("src", emptyImageUrl);
          return GridLayer.prototype._removeTile.call(this, key);
        },
        _tileReady: function(coords, err, tile) {
          if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
            return;
          }
          return GridLayer.prototype._tileReady.call(this, coords, err, tile);
        }
      });
      function tileLayer(url, options2) {
        return new TileLayer2(url, options2);
      }
      var TileLayerWMS = TileLayer2.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: false,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: false
        },
        initialize: function(url, options2) {
          this._url = url;
          var wmsParams = extend2({}, this.defaultWmsParams);
          for (var i in options2) {
            if (!(i in this.options)) {
              wmsParams[i] = options2[i];
            }
          }
          options2 = setOptions(this, options2);
          var realRetina = options2.detectRetina && Browser.retina ? 2 : 1;
          var tileSize = this.getTileSize();
          wmsParams.width = tileSize.x * realRetina;
          wmsParams.height = tileSize.y * realRetina;
          this.wmsParams = wmsParams;
        },
        onAdd: function(map) {
          this._crs = this.options.crs || map.options.crs;
          this._wmsVersion = parseFloat(this.wmsParams.version);
          var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[projectionKey] = this._crs.code;
          TileLayer2.prototype.onAdd.call(this, map);
        },
        getTileUrl: function(coords) {
          var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min2 = bounds.min, max2 = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min2.y, min2.x, max2.y, max2.x] : [min2.x, min2.y, max2.x, max2.y]).join(","), url = TileLayer2.prototype.getTileUrl.call(this, coords);
          return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(params, noRedraw) {
          extend2(this.wmsParams, params);
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        }
      });
      function tileLayerWMS(url, options2) {
        return new TileLayerWMS(url, options2);
      }
      TileLayer2.WMS = TileLayerWMS;
      tileLayer.wms = tileLayerWMS;
      var Renderer = Layer.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(options2) {
          setOptions(this, options2);
          stamp(this);
          this._layers = this._layers || {};
        },
        onAdd: function() {
          if (!this._container) {
            this._initContainer();
            addClass(this._container, "leaflet-zoom-animated");
          }
          this.getPane().appendChild(this._container);
          this._update();
          this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this);
          this._destroyContainer();
        },
        getEvents: function() {
          var events = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._onAnimZoom;
          }
          return events;
        },
        _onAnimZoom: function(ev) {
          this._updateTransform(ev.center, ev.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(center, zoom2) {
          var scale3 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale3).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
          if (Browser.any3d) {
            setTransform(this._container, topLeftOffset, scale3);
          } else {
            setPosition(this._container, topLeftOffset);
          }
        },
        _reset: function() {
          this._update();
          this._updateTransform(this._center, this._zoom);
          for (var id2 in this._layers) {
            this._layers[id2]._reset();
          }
        },
        _onZoomEnd: function() {
          for (var id2 in this._layers) {
            this._layers[id2]._project();
          }
        },
        _updatePaths: function() {
          for (var id2 in this._layers) {
            this._layers[id2]._update();
          }
        },
        _update: function() {
          var p = this.options.padding, size2 = this._map.getSize(), min2 = this._map.containerPointToLayerPoint(size2.multiplyBy(-p)).round();
          this._bounds = new Bounds(min2, min2.add(size2.multiplyBy(1 + p * 2)).round());
          this._center = this._map.getCenter();
          this._zoom = this._map.getZoom();
        }
      });
      var Canvas = Renderer.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var events = Renderer.prototype.getEvents.call(this);
          events.viewprereset = this._onViewPreReset;
          return events;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = true;
        },
        onAdd: function() {
          Renderer.prototype.onAdd.call(this);
          this._draw();
        },
        _initContainer: function() {
          var container = this._container = document.createElement("canvas");
          on(container, "mousemove", this._onMouseMove, this);
          on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
          on(container, "mouseout", this._handleMouseOut, this);
          container["_leaflet_disable_events"] = true;
          this._ctx = container.getContext("2d");
        },
        _destroyContainer: function() {
          cancelAnimFrame(this._redrawRequest);
          delete this._ctx;
          remove(this._container);
          off(this._container);
          delete this._container;
        },
        _updatePaths: function() {
          if (this._postponeUpdatePaths) {
            return;
          }
          var layer;
          this._redrawBounds = null;
          for (var id2 in this._layers) {
            layer = this._layers[id2];
            layer._update();
          }
          this._redraw();
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b = this._bounds, container = this._container, size2 = b.getSize(), m2 = Browser.retina ? 2 : 1;
          setPosition(container, b.min);
          container.width = m2 * size2.x;
          container.height = m2 * size2.y;
          container.style.width = size2.x + "px";
          container.style.height = size2.y + "px";
          if (Browser.retina) {
            this._ctx.scale(2, 2);
          }
          this._ctx.translate(-b.min.x, -b.min.y);
          this.fire("update");
        },
        _reset: function() {
          Renderer.prototype._reset.call(this);
          if (this._postponeUpdatePaths) {
            this._postponeUpdatePaths = false;
            this._updatePaths();
          }
        },
        _initPath: function(layer) {
          this._updateDashArray(layer);
          this._layers[stamp(layer)] = layer;
          var order2 = layer._order = {
            layer,
            prev: this._drawLast,
            next: null
          };
          if (this._drawLast) {
            this._drawLast.next = order2;
          }
          this._drawLast = order2;
          this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(layer) {
          this._requestRedraw(layer);
        },
        _removePath: function(layer) {
          var order2 = layer._order;
          var next = order2.next;
          var prev = order2.prev;
          if (next) {
            next.prev = prev;
          } else {
            this._drawLast = prev;
          }
          if (prev) {
            prev.next = next;
          } else {
            this._drawFirst = next;
          }
          delete layer._order;
          delete this._layers[stamp(layer)];
          this._requestRedraw(layer);
        },
        _updatePath: function(layer) {
          this._extendRedrawBounds(layer);
          layer._project();
          layer._update();
          this._requestRedraw(layer);
        },
        _updateStyle: function(layer) {
          this._updateDashArray(layer);
          this._requestRedraw(layer);
        },
        _updateDashArray: function(layer) {
          if (typeof layer.options.dashArray === "string") {
            var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
            for (i = 0; i < parts.length; i++) {
              dashValue = Number(parts[i]);
              if (isNaN(dashValue)) {
                return;
              }
              dashArray.push(dashValue);
            }
            layer.options._dashArray = dashArray;
          } else {
            layer.options._dashArray = layer.options.dashArray;
          }
        },
        _requestRedraw: function(layer) {
          if (!this._map) {
            return;
          }
          this._extendRedrawBounds(layer);
          this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
        },
        _extendRedrawBounds: function(layer) {
          if (layer._pxBounds) {
            var padding = (layer.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new Bounds();
            this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
            this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null;
          if (this._redrawBounds) {
            this._redrawBounds.min._floor();
            this._redrawBounds.max._ceil();
          }
          this._clear();
          this._draw();
          this._redrawBounds = null;
        },
        _clear: function() {
          var bounds = this._redrawBounds;
          if (bounds) {
            var size2 = bounds.getSize();
            this._ctx.clearRect(bounds.min.x, bounds.min.y, size2.x, size2.y);
          } else {
            this._ctx.save();
            this._ctx.setTransform(1, 0, 0, 1, 0, 0);
            this._ctx.clearRect(0, 0, this._container.width, this._container.height);
            this._ctx.restore();
          }
        },
        _draw: function() {
          var layer, bounds = this._redrawBounds;
          this._ctx.save();
          if (bounds) {
            var size2 = bounds.getSize();
            this._ctx.beginPath();
            this._ctx.rect(bounds.min.x, bounds.min.y, size2.x, size2.y);
            this._ctx.clip();
          }
          this._drawing = true;
          for (var order2 = this._drawFirst; order2; order2 = order2.next) {
            layer = order2.layer;
            if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
              layer._updatePath();
            }
          }
          this._drawing = false;
          this._ctx.restore();
        },
        _updatePoly: function(layer, closed) {
          if (!this._drawing) {
            return;
          }
          var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
          if (!len) {
            return;
          }
          ctx.beginPath();
          for (i = 0; i < len; i++) {
            for (j = 0, len2 = parts[i].length; j < len2; j++) {
              p = parts[i][j];
              ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
            }
            if (closed) {
              ctx.closePath();
            }
          }
          this._fillStroke(ctx, layer);
        },
        _updateCircle: function(layer) {
          if (!this._drawing || layer._empty()) {
            return;
          }
          var p = layer._point, ctx = this._ctx, r2 = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r2) / r2;
          if (s !== 1) {
            ctx.save();
            ctx.scale(1, s);
          }
          ctx.beginPath();
          ctx.arc(p.x, p.y / s, r2, 0, Math.PI * 2, false);
          if (s !== 1) {
            ctx.restore();
          }
          this._fillStroke(ctx, layer);
        },
        _fillStroke: function(ctx, layer) {
          var options2 = layer.options;
          if (options2.fill) {
            ctx.globalAlpha = options2.fillOpacity;
            ctx.fillStyle = options2.fillColor || options2.color;
            ctx.fill(options2.fillRule || "evenodd");
          }
          if (options2.stroke && options2.weight !== 0) {
            if (ctx.setLineDash) {
              ctx.setLineDash(layer.options && layer.options._dashArray || []);
            }
            ctx.globalAlpha = options2.opacity;
            ctx.lineWidth = options2.weight;
            ctx.strokeStyle = options2.color;
            ctx.lineCap = options2.lineCap;
            ctx.lineJoin = options2.lineJoin;
            ctx.stroke();
          }
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(e) {
          var point2 = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
          for (var order2 = this._drawFirst; order2; order2 = order2.next) {
            layer = order2.layer;
            if (layer.options.interactive && layer._containsPoint(point2)) {
              if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                clickedLayer = layer;
              }
            }
          }
          this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
        },
        _onMouseMove: function(e) {
          if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
            return;
          }
          var point2 = this._map.mouseEventToLayerPoint(e);
          this._handleMouseHover(e, point2);
        },
        _handleMouseOut: function(e) {
          var layer = this._hoveredLayer;
          if (layer) {
            removeClass(this._container, "leaflet-interactive");
            this._fireEvent([layer], e, "mouseout");
            this._hoveredLayer = null;
            this._mouseHoverThrottled = false;
          }
        },
        _handleMouseHover: function(e, point2) {
          if (this._mouseHoverThrottled) {
            return;
          }
          var layer, candidateHoveredLayer;
          for (var order2 = this._drawFirst; order2; order2 = order2.next) {
            layer = order2.layer;
            if (layer.options.interactive && layer._containsPoint(point2)) {
              candidateHoveredLayer = layer;
            }
          }
          if (candidateHoveredLayer !== this._hoveredLayer) {
            this._handleMouseOut(e);
            if (candidateHoveredLayer) {
              addClass(this._container, "leaflet-interactive");
              this._fireEvent([candidateHoveredLayer], e, "mouseover");
              this._hoveredLayer = candidateHoveredLayer;
            }
          }
          this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
          this._mouseHoverThrottled = true;
          setTimeout(bind2(function() {
            this._mouseHoverThrottled = false;
          }, this), 32);
        },
        _fireEvent: function(layers2, e, type) {
          this._map._fireDOMEvent(e, type || e.type, layers2);
        },
        _bringToFront: function(layer) {
          var order2 = layer._order;
          if (!order2) {
            return;
          }
          var next = order2.next;
          var prev = order2.prev;
          if (next) {
            next.prev = prev;
          } else {
            return;
          }
          if (prev) {
            prev.next = next;
          } else if (next) {
            this._drawFirst = next;
          }
          order2.prev = this._drawLast;
          this._drawLast.next = order2;
          order2.next = null;
          this._drawLast = order2;
          this._requestRedraw(layer);
        },
        _bringToBack: function(layer) {
          var order2 = layer._order;
          if (!order2) {
            return;
          }
          var next = order2.next;
          var prev = order2.prev;
          if (prev) {
            prev.next = next;
          } else {
            return;
          }
          if (next) {
            next.prev = prev;
          } else if (prev) {
            this._drawLast = prev;
          }
          order2.prev = null;
          order2.next = this._drawFirst;
          this._drawFirst.prev = order2;
          this._drawFirst = order2;
          this._requestRedraw(layer);
        }
      });
      function canvas(options2) {
        return Browser.canvas ? new Canvas(options2) : null;
      }
      var vmlCreate = function() {
        try {
          document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
          return function(name2) {
            return document.createElement("<lvml:" + name2 + ' class="lvml">');
          };
        } catch (e) {
        }
        return function(name2) {
          return document.createElement("<" + name2 + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }();
      var vmlMixin = {
        _initContainer: function() {
          this._container = create$1("div", "leaflet-vml-container");
        },
        _update: function() {
          if (this._map._animatingZoom) {
            return;
          }
          Renderer.prototype._update.call(this);
          this.fire("update");
        },
        _initPath: function(layer) {
          var container = layer._container = vmlCreate("shape");
          addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
          container.coordsize = "1 1";
          layer._path = vmlCreate("path");
          container.appendChild(layer._path);
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          var container = layer._container;
          this._container.appendChild(container);
          if (layer.options.interactive) {
            layer.addInteractiveTarget(container);
          }
        },
        _removePath: function(layer) {
          var container = layer._container;
          remove(container);
          layer.removeInteractiveTarget(container);
          delete this._layers[stamp(layer)];
        },
        _updateStyle: function(layer) {
          var stroke = layer._stroke, fill = layer._fill, options2 = layer.options, container = layer._container;
          container.stroked = !!options2.stroke;
          container.filled = !!options2.fill;
          if (options2.stroke) {
            if (!stroke) {
              stroke = layer._stroke = vmlCreate("stroke");
            }
            container.appendChild(stroke);
            stroke.weight = options2.weight + "px";
            stroke.color = options2.color;
            stroke.opacity = options2.opacity;
            if (options2.dashArray) {
              stroke.dashStyle = isArray2(options2.dashArray) ? options2.dashArray.join(" ") : options2.dashArray.replace(/( *, *)/g, " ");
            } else {
              stroke.dashStyle = "";
            }
            stroke.endcap = options2.lineCap.replace("butt", "flat");
            stroke.joinstyle = options2.lineJoin;
          } else if (stroke) {
            container.removeChild(stroke);
            layer._stroke = null;
          }
          if (options2.fill) {
            if (!fill) {
              fill = layer._fill = vmlCreate("fill");
            }
            container.appendChild(fill);
            fill.color = options2.fillColor || options2.color;
            fill.opacity = options2.fillOpacity;
          } else if (fill) {
            container.removeChild(fill);
            layer._fill = null;
          }
        },
        _updateCircle: function(layer) {
          var p = layer._point.round(), r2 = Math.round(layer._radius), r22 = Math.round(layer._radiusY || r2);
          this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r2 + "," + r22 + " 0," + 65535 * 360);
        },
        _setPath: function(layer, path) {
          layer._path.v = path;
        },
        _bringToFront: function(layer) {
          toFront(layer._container);
        },
        _bringToBack: function(layer) {
          toBack(layer._container);
        }
      };
      var create2 = Browser.vml ? vmlCreate : svgCreate;
      var SVG2 = Renderer.extend({
        _initContainer: function() {
          this._container = create2("svg");
          this._container.setAttribute("pointer-events", "none");
          this._rootGroup = create2("g");
          this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          remove(this._container);
          off(this._container);
          delete this._container;
          delete this._rootGroup;
          delete this._svgSize;
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b = this._bounds, size2 = b.getSize(), container = this._container;
          if (!this._svgSize || !this._svgSize.equals(size2)) {
            this._svgSize = size2;
            container.setAttribute("width", size2.x);
            container.setAttribute("height", size2.y);
          }
          setPosition(container, b.min);
          container.setAttribute("viewBox", [b.min.x, b.min.y, size2.x, size2.y].join(" "));
          this.fire("update");
        },
        // methods below are called by vector layers implementations
        _initPath: function(layer) {
          var path = layer._path = create2("path");
          if (layer.options.className) {
            addClass(path, layer.options.className);
          }
          if (layer.options.interactive) {
            addClass(path, "leaflet-interactive");
          }
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          if (!this._rootGroup) {
            this._initContainer();
          }
          this._rootGroup.appendChild(layer._path);
          layer.addInteractiveTarget(layer._path);
        },
        _removePath: function(layer) {
          remove(layer._path);
          layer.removeInteractiveTarget(layer._path);
          delete this._layers[stamp(layer)];
        },
        _updatePath: function(layer) {
          layer._project();
          layer._update();
        },
        _updateStyle: function(layer) {
          var path = layer._path, options2 = layer.options;
          if (!path) {
            return;
          }
          if (options2.stroke) {
            path.setAttribute("stroke", options2.color);
            path.setAttribute("stroke-opacity", options2.opacity);
            path.setAttribute("stroke-width", options2.weight);
            path.setAttribute("stroke-linecap", options2.lineCap);
            path.setAttribute("stroke-linejoin", options2.lineJoin);
            if (options2.dashArray) {
              path.setAttribute("stroke-dasharray", options2.dashArray);
            } else {
              path.removeAttribute("stroke-dasharray");
            }
            if (options2.dashOffset) {
              path.setAttribute("stroke-dashoffset", options2.dashOffset);
            } else {
              path.removeAttribute("stroke-dashoffset");
            }
          } else {
            path.setAttribute("stroke", "none");
          }
          if (options2.fill) {
            path.setAttribute("fill", options2.fillColor || options2.color);
            path.setAttribute("fill-opacity", options2.fillOpacity);
            path.setAttribute("fill-rule", options2.fillRule || "evenodd");
          } else {
            path.setAttribute("fill", "none");
          }
        },
        _updatePoly: function(layer, closed) {
          this._setPath(layer, pointsToPath(layer._parts, closed));
        },
        _updateCircle: function(layer) {
          var p = layer._point, r2 = Math.max(Math.round(layer._radius), 1), r22 = Math.max(Math.round(layer._radiusY), 1) || r2, arc = "a" + r2 + "," + r22 + " 0 1,0 ";
          var d = layer._empty() ? "M0 0" : "M" + (p.x - r2) + "," + p.y + arc + r2 * 2 + ",0 " + arc + -r2 * 2 + ",0 ";
          this._setPath(layer, d);
        },
        _setPath: function(layer, path) {
          layer._path.setAttribute("d", path);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(layer) {
          toFront(layer._path);
        },
        _bringToBack: function(layer) {
          toBack(layer._path);
        }
      });
      if (Browser.vml) {
        SVG2.include(vmlMixin);
      }
      function svg2(options2) {
        return Browser.svg || Browser.vml ? new SVG2(options2) : null;
      }
      Map2.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(layer) {
          var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
          if (!renderer) {
            renderer = this._renderer = this._createRenderer();
          }
          if (!this.hasLayer(renderer)) {
            this.addLayer(renderer);
          }
          return renderer;
        },
        _getPaneRenderer: function(name2) {
          if (name2 === "overlayPane" || name2 === void 0) {
            return false;
          }
          var renderer = this._paneRenderers[name2];
          if (renderer === void 0) {
            renderer = this._createRenderer({ pane: name2 });
            this._paneRenderers[name2] = renderer;
          }
          return renderer;
        },
        _createRenderer: function(options2) {
          return this.options.preferCanvas && canvas(options2) || svg2(options2);
        }
      });
      var Rectangle = Polygon.extend({
        initialize: function(latLngBounds, options2) {
          Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options2);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(latLngBounds) {
          return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
        },
        _boundsToLatLngs: function(latLngBounds) {
          latLngBounds = toLatLngBounds(latLngBounds);
          return [
            latLngBounds.getSouthWest(),
            latLngBounds.getNorthWest(),
            latLngBounds.getNorthEast(),
            latLngBounds.getSouthEast()
          ];
        }
      });
      function rectangle(latLngBounds, options2) {
        return new Rectangle(latLngBounds, options2);
      }
      SVG2.create = create2;
      SVG2.pointsToPath = pointsToPath;
      GeoJSON.geometryToLayer = geometryToLayer;
      GeoJSON.coordsToLatLng = coordsToLatLng;
      GeoJSON.coordsToLatLngs = coordsToLatLngs;
      GeoJSON.latLngToCoords = latLngToCoords;
      GeoJSON.latLngsToCoords = latLngsToCoords;
      GeoJSON.getFeature = getFeature;
      GeoJSON.asFeature = asFeature;
      Map2.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: true
      });
      var BoxZoom = Handler.extend({
        initialize: function(map) {
          this._map = map;
          this._container = map._container;
          this._pane = map._panes.overlayPane;
          this._resetStateTimeout = 0;
          map.on("unload", this._destroy, this);
        },
        addHooks: function() {
          on(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          off(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          remove(this._pane);
          delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0;
          this._moved = false;
        },
        _clearDeferredResetState: function() {
          if (this._resetStateTimeout !== 0) {
            clearTimeout(this._resetStateTimeout);
            this._resetStateTimeout = 0;
          }
        },
        _onMouseDown: function(e) {
          if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
            return false;
          }
          this._clearDeferredResetState();
          this._resetState();
          disableTextSelection();
          disableImageDrag();
          this._startPoint = this._map.mouseEventToContainerPoint(e);
          on(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(e) {
          if (!this._moved) {
            this._moved = true;
            this._box = create$1("div", "leaflet-zoom-box", this._container);
            addClass(this._container, "leaflet-crosshair");
            this._map.fire("boxzoomstart");
          }
          this._point = this._map.mouseEventToContainerPoint(e);
          var bounds = new Bounds(this._point, this._startPoint), size2 = bounds.getSize();
          setPosition(this._box, bounds.min);
          this._box.style.width = size2.x + "px";
          this._box.style.height = size2.y + "px";
        },
        _finish: function() {
          if (this._moved) {
            remove(this._box);
            removeClass(this._container, "leaflet-crosshair");
          }
          enableTextSelection();
          enableImageDrag();
          off(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(e) {
          if (e.which !== 1 && e.button !== 1) {
            return;
          }
          this._finish();
          if (!this._moved) {
            return;
          }
          this._clearDeferredResetState();
          this._resetStateTimeout = setTimeout(bind2(this._resetState, this), 0);
          var bounds = new LatLngBounds(
            this._map.containerPointToLatLng(this._startPoint),
            this._map.containerPointToLatLng(this._point)
          );
          this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
        },
        _onKeyDown: function(e) {
          if (e.keyCode === 27) {
            this._finish();
            this._clearDeferredResetState();
            this._resetState();
          }
        }
      });
      Map2.addInitHook("addHandler", "boxZoom", BoxZoom);
      Map2.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: true
      });
      var DoubleClickZoom = Handler.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(e) {
          var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
          if (map.options.doubleClickZoom === "center") {
            map.setZoom(zoom2);
          } else {
            map.setZoomAround(e.containerPoint, zoom2);
          }
        }
      });
      Map2.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
      Map2.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: true,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: true,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second.
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: Infinity,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: false,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var Drag = Handler.extend({
        addHooks: function() {
          if (!this._draggable) {
            var map = this._map;
            this._draggable = new Draggable(map._mapPane, map._container);
            this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this);
            this._draggable.on("predrag", this._onPreDragLimit, this);
            if (map.options.worldCopyJump) {
              this._draggable.on("predrag", this._onPreDragWrap, this);
              map.on("zoomend", this._onZoomEnd, this);
              map.whenReady(this._onZoomEnd, this);
            }
          }
          addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
          this._draggable.enable();
          this._positions = [];
          this._times = [];
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-grab");
          removeClass(this._map._container, "leaflet-touch-drag");
          this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var map = this._map;
          map._stop();
          if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var bounds = toLatLngBounds(this._map.options.maxBounds);
            this._offsetLimit = toBounds(
              this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            );
            this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else {
            this._offsetLimit = null;
          }
          map.fire("movestart").fire("dragstart");
          if (map.options.inertia) {
            this._positions = [];
            this._times = [];
          }
        },
        _onDrag: function(e) {
          if (this._map.options.inertia) {
            var time2 = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(pos);
            this._times.push(time2);
            this._prunePositions(time2);
          }
          this._map.fire("move", e).fire("drag", e);
        },
        _prunePositions: function(time2) {
          while (this._positions.length > 1 && time2 - this._times[0] > 50) {
            this._positions.shift();
            this._times.shift();
          }
        },
        _onZoomEnd: function() {
          var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
          this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(value, threshold) {
          return value - (value - threshold) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!this._viscosity || !this._offsetLimit) {
            return;
          }
          var offset2 = this._draggable._newPos.subtract(this._draggable._startPos);
          var limit = this._offsetLimit;
          if (offset2.x < limit.min.x) {
            offset2.x = this._viscousLimit(offset2.x, limit.min.x);
          }
          if (offset2.y < limit.min.y) {
            offset2.y = this._viscousLimit(offset2.y, limit.min.y);
          }
          if (offset2.x > limit.max.x) {
            offset2.x = this._viscousLimit(offset2.x, limit.max.x);
          }
          if (offset2.y > limit.max.y) {
            offset2.y = this._viscousLimit(offset2.y, limit.max.y);
          }
          this._draggable._newPos = this._draggable._startPos.add(offset2);
        },
        _onPreDragWrap: function() {
          var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
          this._draggable._absPos = this._draggable._newPos.clone();
          this._draggable._newPos.x = newX;
        },
        _onDragEnd: function(e) {
          var map = this._map, options2 = map.options, noInertia = !options2.inertia || e.noInertia || this._times.length < 2;
          map.fire("dragend", e);
          if (noInertia) {
            map.fire("moveend");
          } else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease2 = options2.easeLinearity, speedVector = direction.multiplyBy(ease2 / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options2.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options2.inertiaDeceleration * ease2), offset2 = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
            if (!offset2.x && !offset2.y) {
              map.fire("moveend");
            } else {
              offset2 = map._limitOffset(offset2, map.options.maxBounds);
              requestAnimFrame(function() {
                map.panBy(offset2, {
                  duration: decelerationDuration,
                  easeLinearity: ease2,
                  noMoveStart: true,
                  animate: true
                });
              });
            }
          }
        }
      });
      Map2.addInitHook("addHandler", "dragging", Drag);
      Map2.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: true,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var Keyboard = Handler.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(map) {
          this._map = map;
          this._setPanDelta(map.options.keyboardPanDelta);
          this._setZoomDelta(map.options.zoomDelta);
        },
        addHooks: function() {
          var container = this._map._container;
          if (container.tabIndex <= 0) {
            container.tabIndex = "0";
          }
          on(container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks();
          off(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (this._focused) {
            return;
          }
          var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
          this._map._container.focus();
          window.scrollTo(left, top);
        },
        _onFocus: function() {
          this._focused = true;
          this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = false;
          this._map.fire("blur");
        },
        _setPanDelta: function(panDelta) {
          var keys2 = this._panKeys = {}, codes = this.keyCodes, i, len;
          for (i = 0, len = codes.left.length; i < len; i++) {
            keys2[codes.left[i]] = [-1 * panDelta, 0];
          }
          for (i = 0, len = codes.right.length; i < len; i++) {
            keys2[codes.right[i]] = [panDelta, 0];
          }
          for (i = 0, len = codes.down.length; i < len; i++) {
            keys2[codes.down[i]] = [0, panDelta];
          }
          for (i = 0, len = codes.up.length; i < len; i++) {
            keys2[codes.up[i]] = [0, -1 * panDelta];
          }
        },
        _setZoomDelta: function(zoomDelta) {
          var keys2 = this._zoomKeys = {}, codes = this.keyCodes, i, len;
          for (i = 0, len = codes.zoomIn.length; i < len; i++) {
            keys2[codes.zoomIn[i]] = zoomDelta;
          }
          for (i = 0, len = codes.zoomOut.length; i < len; i++) {
            keys2[codes.zoomOut[i]] = -zoomDelta;
          }
        },
        _addHooks: function() {
          on(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          off(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(e) {
          if (e.altKey || e.ctrlKey || e.metaKey) {
            return;
          }
          var key = e.keyCode, map = this._map, offset2;
          if (key in this._panKeys) {
            if (!map._panAnim || !map._panAnim._inProgress) {
              offset2 = this._panKeys[key];
              if (e.shiftKey) {
                offset2 = toPoint(offset2).multiplyBy(3);
              }
              if (map.options.maxBounds) {
                offset2 = map._limitOffset(toPoint(offset2), map.options.maxBounds);
              }
              if (map.options.worldCopyJump) {
                var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset2)));
                map.panTo(newLatLng);
              } else {
                map.panBy(offset2);
              }
            }
          } else if (key in this._zoomKeys) {
            map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
          } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
            map.closePopup();
          } else {
            return;
          }
          stop(e);
        }
      });
      Map2.addInitHook("addHandler", "keyboard", Keyboard);
      Map2.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: true,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var ScrollWheelZoom = Handler.extend({
        addHooks: function() {
          on(this._map._container, "wheel", this._onWheelScroll, this);
          this._delta = 0;
        },
        removeHooks: function() {
          off(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(e) {
          var delta = getWheelDelta(e);
          var debounce = this._map.options.wheelDebounceTime;
          this._delta += delta;
          this._lastMousePos = this._map.mouseEventToContainerPoint(e);
          if (!this._startTime) {
            this._startTime = +/* @__PURE__ */ new Date();
          }
          var left = Math.max(debounce - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer);
          this._timer = setTimeout(bind2(this._performZoom, this), left);
          stop(e);
        },
        _performZoom: function() {
          var map = this._map, zoom2 = map.getZoom(), snap = this._map.options.zoomSnap || 0;
          map._stop();
          var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
          this._delta = 0;
          this._startTime = null;
          if (!delta) {
            return;
          }
          if (map.options.scrollWheelZoom === "center") {
            map.setZoom(zoom2 + delta);
          } else {
            map.setZoomAround(this._lastMousePos, zoom2 + delta);
          }
        }
      });
      Map2.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
      var tapHoldDelay = 600;
      Map2.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var TapHold = Handler.extend({
        addHooks: function() {
          on(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          off(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(e) {
          clearTimeout(this._holdTimeout);
          if (e.touches.length !== 1) {
            return;
          }
          var first = e.touches[0];
          this._startPos = this._newPos = new Point(first.clientX, first.clientY);
          this._holdTimeout = setTimeout(bind2(function() {
            this._cancel();
            if (!this._isTapValid()) {
              return;
            }
            on(document, "touchend", preventDefault);
            on(document, "touchend touchcancel", this._cancelClickPrevent);
            this._simulateEvent("contextmenu", first);
          }, this), tapHoldDelay);
          on(document, "touchend touchcancel contextmenu", this._cancel, this);
          on(document, "touchmove", this._onMove, this);
        },
        _cancelClickPrevent: function cancelClickPrevent() {
          off(document, "touchend", preventDefault);
          off(document, "touchend touchcancel", cancelClickPrevent);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout);
          off(document, "touchend touchcancel contextmenu", this._cancel, this);
          off(document, "touchmove", this._onMove, this);
        },
        _onMove: function(e) {
          var first = e.touches[0];
          this._newPos = new Point(first.clientX, first.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(type, e) {
          var simulatedEvent = new MouseEvent(type, {
            bubbles: true,
            cancelable: true,
            view: window,
            // detail: 1,
            screenX: e.screenX,
            screenY: e.screenY,
            clientX: e.clientX,
            clientY: e.clientY
            // button: 2,
            // buttons: 2
          });
          simulatedEvent._simulated = true;
          e.target.dispatchEvent(simulatedEvent);
        }
      });
      Map2.addInitHook("addHandler", "tapHold", TapHold);
      Map2.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Browser.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: true
      });
      var TouchZoom = Handler.extend({
        addHooks: function() {
          addClass(this._map._container, "leaflet-touch-zoom");
          on(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-touch-zoom");
          off(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(e) {
          var map = this._map;
          if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
            return;
          }
          var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);
          this._centerPoint = map.getSize()._divideBy(2);
          this._startLatLng = map.containerPointToLatLng(this._centerPoint);
          if (map.options.touchZoom !== "center") {
            this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
          }
          this._startDist = p1.distanceTo(p2);
          this._startZoom = map.getZoom();
          this._moved = false;
          this._zooming = true;
          map._stop();
          on(document, "touchmove", this._onTouchMove, this);
          on(document, "touchend touchcancel", this._onTouchEnd, this);
          preventDefault(e);
        },
        _onTouchMove: function(e) {
          if (!e.touches || e.touches.length !== 2 || !this._zooming) {
            return;
          }
          var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale3 = p1.distanceTo(p2) / this._startDist;
          this._zoom = map.getScaleZoom(scale3, this._startZoom);
          if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale3 < 1 || this._zoom > map.getMaxZoom() && scale3 > 1)) {
            this._zoom = map._limitZoom(this._zoom);
          }
          if (map.options.touchZoom === "center") {
            this._center = this._startLatLng;
            if (scale3 === 1) {
              return;
            }
          } else {
            var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
            if (scale3 === 1 && delta.x === 0 && delta.y === 0) {
              return;
            }
            this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
          }
          if (!this._moved) {
            map._moveStart(true, false);
            this._moved = true;
          }
          cancelAnimFrame(this._animRequest);
          var moveFn = bind2(map._move, map, this._center, this._zoom, { pinch: true, round: false }, void 0);
          this._animRequest = requestAnimFrame(moveFn, this, true);
          preventDefault(e);
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = false;
            return;
          }
          this._zooming = false;
          cancelAnimFrame(this._animRequest);
          off(document, "touchmove", this._onTouchMove, this);
          off(document, "touchend touchcancel", this._onTouchEnd, this);
          if (this._map.options.zoomAnimation) {
            this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
          } else {
            this._map._resetView(this._center, this._map._limitZoom(this._zoom));
          }
        }
      });
      Map2.addInitHook("addHandler", "touchZoom", TouchZoom);
      Map2.BoxZoom = BoxZoom;
      Map2.DoubleClickZoom = DoubleClickZoom;
      Map2.Drag = Drag;
      Map2.Keyboard = Keyboard;
      Map2.ScrollWheelZoom = ScrollWheelZoom;
      Map2.TapHold = TapHold;
      Map2.TouchZoom = TouchZoom;
      exports4.Bounds = Bounds;
      exports4.Browser = Browser;
      exports4.CRS = CRS;
      exports4.Canvas = Canvas;
      exports4.Circle = Circle2;
      exports4.CircleMarker = CircleMarker;
      exports4.Class = Class;
      exports4.Control = Control;
      exports4.DivIcon = DivIcon;
      exports4.DivOverlay = DivOverlay;
      exports4.DomEvent = DomEvent;
      exports4.DomUtil = DomUtil;
      exports4.Draggable = Draggable;
      exports4.Evented = Evented;
      exports4.FeatureGroup = FeatureGroup;
      exports4.GeoJSON = GeoJSON;
      exports4.GridLayer = GridLayer;
      exports4.Handler = Handler;
      exports4.Icon = Icon2;
      exports4.ImageOverlay = ImageOverlay;
      exports4.LatLng = LatLng;
      exports4.LatLngBounds = LatLngBounds;
      exports4.Layer = Layer;
      exports4.LayerGroup = LayerGroup;
      exports4.LineUtil = LineUtil;
      exports4.Map = Map2;
      exports4.Marker = Marker2;
      exports4.Mixin = Mixin;
      exports4.Path = Path;
      exports4.Point = Point;
      exports4.PolyUtil = PolyUtil;
      exports4.Polygon = Polygon;
      exports4.Polyline = Polyline;
      exports4.Popup = Popup2;
      exports4.PosAnimation = PosAnimation;
      exports4.Projection = index2;
      exports4.Rectangle = Rectangle;
      exports4.Renderer = Renderer;
      exports4.SVG = SVG2;
      exports4.SVGOverlay = SVGOverlay;
      exports4.TileLayer = TileLayer2;
      exports4.Tooltip = Tooltip;
      exports4.Transformation = Transformation;
      exports4.Util = Util;
      exports4.VideoOverlay = VideoOverlay;
      exports4.bind = bind2;
      exports4.bounds = toBounds;
      exports4.canvas = canvas;
      exports4.circle = circle;
      exports4.circleMarker = circleMarker;
      exports4.control = control;
      exports4.divIcon = divIcon;
      exports4.extend = extend2;
      exports4.featureGroup = featureGroup;
      exports4.geoJSON = geoJSON;
      exports4.geoJson = geoJson;
      exports4.gridLayer = gridLayer;
      exports4.icon = icon;
      exports4.imageOverlay = imageOverlay;
      exports4.latLng = toLatLng;
      exports4.latLngBounds = toLatLngBounds;
      exports4.layerGroup = layerGroup;
      exports4.map = createMap;
      exports4.marker = marker;
      exports4.point = toPoint;
      exports4.polygon = polygon;
      exports4.polyline = polyline;
      exports4.popup = popup;
      exports4.rectangle = rectangle;
      exports4.setOptions = setOptions;
      exports4.stamp = stamp;
      exports4.svg = svg2;
      exports4.svgOverlay = svgOverlay;
      exports4.tileLayer = tileLayer;
      exports4.tooltip = tooltip;
      exports4.transformation = toTransformation;
      exports4.version = version2;
      exports4.videoOverlay = videoOverlay;
      var oldL = window.L;
      exports4.noConflict = function() {
        window.L = oldL;
        return this;
      };
      window.L = exports4;
    });
  })(leafletSrc, leafletSrc.exports);
  var leafletSrcExports = leafletSrc.exports;
  function createElementObject(instance, context, container) {
    return Object.freeze({
      instance,
      context,
      container
    });
  }
  function createElementHook(createElement, updateElement) {
    if (updateElement == null) {
      return function useImmutableLeafletElement(props, context) {
        const elementRef = reactExports.useRef();
        if (!elementRef.current) elementRef.current = createElement(props, context);
        return elementRef;
      };
    }
    return function useMutableLeafletElement(props, context) {
      const elementRef = reactExports.useRef();
      if (!elementRef.current) elementRef.current = createElement(props, context);
      const propsRef = reactExports.useRef(props);
      const { instance } = elementRef.current;
      reactExports.useEffect(function updateElementProps() {
        if (propsRef.current !== props) {
          updateElement(instance, props, propsRef.current);
          propsRef.current = props;
        }
      }, [
        instance,
        props,
        context
      ]);
      return elementRef;
    };
  }
  function useLayerLifecycle(element2, context) {
    reactExports.useEffect(function addLayer() {
      const container = context.layerContainer ?? context.map;
      container.addLayer(element2.instance);
      return function removeLayer() {
        var _a2;
        (_a2 = context.layerContainer) == null ? void 0 : _a2.removeLayer(element2.instance);
        context.map.removeLayer(element2.instance);
      };
    }, [
      context,
      element2
    ]);
  }
  function createLayerHook(useElement) {
    return function useLayer(props) {
      const context = useLeafletContext();
      const elementRef = useElement(withPane(props, context), context);
      useAttribution(context.map, props.attribution);
      useEventHandlers(elementRef.current, props.eventHandlers);
      useLayerLifecycle(elementRef.current, context);
      return elementRef;
    };
  }
  function createLayerComponent(createElement, updateElement) {
    const useElement = createElementHook(createElement, updateElement);
    const useLayer = createLayerHook(useElement);
    return createContainerComponent(useLayer);
  }
  function createOverlayComponent(createElement, useLifecycle) {
    const useElement = createElementHook(createElement);
    const useOverlay = createDivOverlayHook(useElement, useLifecycle);
    return createDivOverlayComponent(useOverlay);
  }
  function createTileLayerComponent(createElement, updateElement) {
    const useElement = createElementHook(createElement, updateElement);
    const useLayer = createLayerHook(useElement);
    return createLeafComponent(useLayer);
  }
  function updateGridLayer(layer, props, prevProps) {
    const { opacity, zIndex } = props;
    if (opacity != null && opacity !== prevProps.opacity) {
      layer.setOpacity(opacity);
    }
    if (zIndex != null && zIndex !== prevProps.zIndex) {
      layer.setZIndex(zIndex);
    }
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function MapContainerComponent({ bounds, boundsOptions, center, children, className, id: id2, placeholder, style, whenReady, zoom, ...options2 }, forwardedRef) {
    const [props] = reactExports.useState({
      className,
      id: id2,
      style
    });
    const [context, setContext] = reactExports.useState(null);
    reactExports.useImperativeHandle(forwardedRef, () => (context == null ? void 0 : context.map) ?? null, [
      context
    ]);
    const mapRef = reactExports.useCallback((node2) => {
      if (node2 !== null && context === null) {
        const map = new leafletSrcExports.Map(node2, options2);
        if (center != null && zoom != null) {
          map.setView(center, zoom);
        } else if (bounds != null) {
          map.fitBounds(bounds, boundsOptions);
        }
        if (whenReady != null) {
          map.whenReady(whenReady);
        }
        setContext(createLeafletContext(map));
      }
    }, []);
    reactExports.useEffect(() => {
      return () => {
        context == null ? void 0 : context.map.remove();
      };
    }, [
      context
    ]);
    const contents = context ? /* @__PURE__ */ React.createElement(LeafletProvider, {
      value: context
    }, children) : placeholder ?? null;
    return /* @__PURE__ */ React.createElement("div", _extends({}, props, {
      ref: mapRef
    }), contents);
  }
  const MapContainer = /* @__PURE__ */ reactExports.forwardRef(MapContainerComponent);
  const Marker = createLayerComponent(function createMarker({ position: position2, ...options2 }, ctx) {
    const marker = new leafletSrcExports.Marker(position2, options2);
    return createElementObject(marker, extendContext(ctx, {
      overlayContainer: marker
    }));
  }, function updateMarker(marker, props, prevProps) {
    if (props.position !== prevProps.position) {
      marker.setLatLng(props.position);
    }
    if (props.icon != null && props.icon !== prevProps.icon) {
      marker.setIcon(props.icon);
    }
    if (props.zIndexOffset != null && props.zIndexOffset !== prevProps.zIndexOffset) {
      marker.setZIndexOffset(props.zIndexOffset);
    }
    if (props.opacity != null && props.opacity !== prevProps.opacity) {
      marker.setOpacity(props.opacity);
    }
    if (marker.dragging != null && props.draggable !== prevProps.draggable) {
      if (props.draggable === true) {
        marker.dragging.enable();
      } else {
        marker.dragging.disable();
      }
    }
  });
  const Popup = createOverlayComponent(function createPopup(props, context) {
    const popup = new leafletSrcExports.Popup(props, context.overlayContainer);
    return createElementObject(popup, context);
  }, function usePopupLifecycle(element2, context, { position: position2 }, setOpen) {
    reactExports.useEffect(function addPopup() {
      const { instance } = element2;
      function onPopupOpen(event) {
        if (event.popup === instance) {
          instance.update();
          setOpen(true);
        }
      }
      function onPopupClose(event) {
        if (event.popup === instance) {
          setOpen(false);
        }
      }
      context.map.on({
        popupopen: onPopupOpen,
        popupclose: onPopupClose
      });
      if (context.overlayContainer == null) {
        if (position2 != null) {
          instance.setLatLng(position2);
        }
        instance.openOn(context.map);
      } else {
        context.overlayContainer.bindPopup(instance);
      }
      return function removePopup() {
        var _a2;
        context.map.off({
          popupopen: onPopupOpen,
          popupclose: onPopupClose
        });
        (_a2 = context.overlayContainer) == null ? void 0 : _a2.unbindPopup();
        context.map.removeLayer(instance);
      };
    }, [
      element2,
      context,
      setOpen,
      position2
    ]);
  });
  const TileLayer = createTileLayerComponent(function createTileLayer({ url, ...options2 }, context) {
    const layer = new leafletSrcExports.TileLayer(url, withPane(options2, context));
    return createElementObject(layer, context);
  }, function updateTileLayer(layer, props, prevProps) {
    updateGridLayer(layer, props, prevProps);
    const { url } = props;
    if (url != null && url !== prevProps.url) {
      layer.setUrl(url);
    }
  });
  function $l({ onAudioRecorded: t, onClose: e, inputMessage: a }) {
    let [l, r2] = reactExports.useState(false), [s, d] = reactExports.useState(0), [u, n] = reactExports.useState([]), [p, f] = reactExports.useState(null), [o, i] = reactExports.useState(null), h = reactExports.useRef(null), c = reactExports.useRef(null), v = reactExports.useRef([]), g = reactExports.useRef(null), C = reactExports.useRef(null), x = reactExports.useRef(null), N = reactExports.useRef(null), m2 = reactExports.useRef(false), w = reactExports.useRef(false), U = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (!l || !p) return;
      let P = setInterval(() => {
        let k = Math.floor((Date.now() - p) / 1e3);
        d(k);
      }, 1e3);
      return () => clearInterval(P);
    }, [l, p]), reactExports.useEffect(() => ((async () => {
      if (!(m2.current || w.current)) try {
        m2.current = true;
        let k = await navigator.mediaDevices.getUserMedia({ audio: true });
        h.current = k, g.current = new AudioContext(), C.current = g.current.createAnalyser(), C.current.fftSize = 256, g.current.createMediaStreamSource(k).connect(C.current), x.current = new Uint8Array(C.current.frequencyBinCount);
        let q = () => {
          if (!C.current || !x.current) return;
          C.current.getByteFrequencyData(x.current);
          let Wt = Array.from(x.current).map((Xt) => Xt / 255);
          n(Wt), N.current = requestAnimationFrame(q);
        };
        q(), _t2();
      } catch (k) {
        console.error("Error accessing microphone:", k), e();
      } finally {
        m2.current = false;
      }
    })(), () => {
      B();
    }), []);
    let B = () => {
      if (!w.current) try {
        if (w.current = true, l && c.current && (c.current.stop(), r2(false), f(null)), h.current) {
          let P = h.current.getAudioTracks(), k = h.current.getVideoTracks();
          P.forEach((A) => {
            A.stop(), A.enabled = false;
          }), k.forEach((A) => {
            A.stop(), A.enabled = false;
          });
        }
        N.current && cancelAnimationFrame(N.current), g.current && g.current.close(), h.current = null, c.current = null, v.current = [], g.current = null, C.current = null, x.current = null, N.current = null;
      } finally {
        w.current = false;
      }
    }, _t2 = () => {
      if (!h.current) return;
      let k = ["audio/webm", "audio/mp4", "audio/ogg", "audio/wav"].find((q) => MediaRecorder.isTypeSupported(q));
      if (!k) {
        console.error("No supported MIME type found for MediaRecorder"), e();
        return;
      }
      U.current = k;
      let A = new MediaRecorder(h.current, { mimeType: k });
      c.current = A, v.current = [], A.ondataavailable = (q) => {
        q.data.size > 0 && v.current.push(q.data);
      }, A.start(), r2(true), f(Date.now()), d(0);
    }, jt2 = async () => {
      if (!c.current || !h.current) return;
      r2(false), i(s), f(null), c.current.stop(), await new Promise((k) => {
        c.current && (c.current.onstop = () => k());
      });
      let P = new Blob(v.current, { type: U.current || "audio/webm" });
      t(P, a), B(), e();
    }, mt = (P) => {
      let k = Math.floor(P / 60), A = P % 60;
      return `${k.toString().padStart(2, "0")}:${A.toString().padStart(2, "0")}`;
    };
    return jsxRuntimeExports.jsxs("div", { className: "audio-recorder-container lua:bg-gray-100 lua:rounded-lg lua:p-2 lua:flex lua:items-center lua:gap-4", children: [jsxRuntimeExports.jsx(IconButton, { variant: "muted", onClick: async () => {
      B(), e();
    }, className: "audio-recorder-close-button lua:flex-shrink-0", children: jsxRuntimeExports.jsx(XIcon$1, { className: "audio-recorder-close-icon", color: "#00000099" }) }), jsxRuntimeExports.jsxs("div", { className: "audio-recorder-status lua:flex lua:items-center lua:gap-2", children: [jsxRuntimeExports.jsx("div", { className: `audio-recorder-indicator lua:w-3 lua:h-3 lua:rounded-full ${l ? "lua:bg-red-500 lua:animate-pulse" : "lua:bg-gray-400"}` }), jsxRuntimeExports.jsx("span", { className: "audio-recorder-time lua:text-gray-700 lua:text-sm", children: mt(l ? s : o || 0) })] }), jsxRuntimeExports.jsx("div", { className: "audio-recorder-visualizer lua:flex-1", "data-testid": "audio-visualizer-bar", children: u.length > 0 && jsxRuntimeExports.jsx("div", { className: "audio-recorder-bars lua:h-8 lua:flex lua:items-center lua:w-full lua:gap-px sm:lua:gap-0.5 md:lua:gap-1", children: u.slice(0, 50).map((P, k) => jsxRuntimeExports.jsx("div", { className: "audio-recorder-bar lua:flex-1 lua:bg-blue-500", style: { height: `${P * 100}%` } }, k)) }) }), jsxRuntimeExports.jsx(IconButton, { onClick: jt2, className: "audio-recorder-send-button lua:flex-shrink-0 lua:mr-1", "data-testid": "send-audio-button", children: jsxRuntimeExports.jsx(ArrowUp$1, { className: "audio-recorder-send-icon", color: "white" }) })] });
  }
  function vt({ url: t, alt: e, open: a, onClose: l }) {
    return jsxRuntimeExports.jsxs(Dialog, { open: a, onOpenChange: l, children: [jsxRuntimeExports.jsx(VisuallyHidden, { children: jsxRuntimeExports.jsx(DialogTitle, {}) }), jsxRuntimeExports.jsx(DialogContent, { className: "lua:w-full lua:fixed lua:inset-0 lua:h-full lua:max-w-none lua:p-0 lua:bg-transparent lua:shadow-none lua:translate-x-0 lua:translate-y-0 lua:m-0 lua:rounded-none", showClose: false, children: jsxRuntimeExports.jsxs("div", { className: "lua:relative lua:w-full lua:h-full", children: [jsxRuntimeExports.jsx("button", { onClick: l, className: "lua:cursor-pointer lua:absolute lua:top-4 lua:left-4 lua:z-10 lua:p-2 lua:bg-black/50 lua:rounded-full lua:hover:bg-black/70 lua:transition-colors", children: jsxRuntimeExports.jsx(XIcon$1, { color: "white", className: "lua:w-6 lua:h-6" }) }), jsxRuntimeExports.jsx("div", { className: "lua:w-full lua:h-full lua:flex lua:items-center lua:justify-center", children: jsxRuntimeExports.jsx("img", { src: t, alt: e, className: "sm:lua:aspect-[16/9] lua:object-contain lua:rounded-none sm:lua:rounded-lg" }) })] }) })] });
  }
  function yt({ images: t, initialIndex: e = 0, open: a, onClose: l }) {
    let [r2, s] = reactExports.useState(), [d, u] = reactExports.useState(0);
    return reactExports.useEffect(() => {
      if (!r2) return;
      e > 0 && e < t.length && (r2.scrollTo(e), u(e));
      let n = () => {
        u(r2.selectedScrollSnap());
      };
      return r2.on("select", n), n(), () => {
        r2 == null ? void 0 : r2.off("select", n);
      };
    }, [r2, e, t.length]), jsxRuntimeExports.jsxs(Dialog, { open: a, onOpenChange: l, children: [jsxRuntimeExports.jsx(VisuallyHidden, { children: jsxRuntimeExports.jsx(DialogTitle, {}) }), jsxRuntimeExports.jsx(DialogContent, { className: "lua:w-full lua:m-0", showClose: false, children: jsxRuntimeExports.jsxs("div", { className: "lua:relative lua:w-full lua:h-full", children: [jsxRuntimeExports.jsx("button", { onClick: l, className: "lua:cursor-pointer lua:absolute lua:top-4 lua:left-4 lua:z-10 lua:p-2 lua:bg-black/50 lua:rounded-full lua:hover:bg-black/70 lua:transition-colors", children: jsxRuntimeExports.jsx(XIcon$1, { color: "white", className: "lua:w-6 lua:h-6" }) }), t.length > 1 && jsxRuntimeExports.jsxs("div", { className: "lua:absolute lua:top-4 lua:right-4 lua:z-10 lua:px-3 lua:py-1 lua:bg-black/50 lua:rounded-full lua:text-white lua:text-sm", children: [d + 1, " / ", t.length] }), jsxRuntimeExports.jsx("div", { className: "lua:w-full lua:h-full lua:flex lua:items-center lua:justify-center lua:px-16", children: jsxRuntimeExports.jsxs(Carousel, { setApi: s, className: "lua:w-full lua:max-w-5xl", opts: { align: "center", loop: t.length > 1 }, children: [jsxRuntimeExports.jsx(CarouselContent, { children: t.map((n, p) => jsxRuntimeExports.jsx(CarouselItem, { className: "lua:flex lua:items-center lua:justify-center", children: jsxRuntimeExports.jsx("img", { src: n.src, alt: n.alt || `Image ${p + 1}`, className: "lua:max-w-full lua:max-h-screen lua:object-contain lua:rounded-none sm:lua:rounded-lg", draggable: false }) }, p)) }), t.length > 1 && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(CarouselPrevious, { className: "lua:left-4 lua:bg-black/50 lua:border-none lua:text-white lua:hover:bg-black/70 lua:hover:text-white-white/70" }), jsxRuntimeExports.jsx(CarouselNext, { className: "lua:right-4 lua:bg-black/50 lua:border-none lua:text-white lua:hover:bg-black/70 lua:hover:text-white-white/70" })] })] }) })] }) })] });
  }
  function Ct({ children: t, language: e = "" }) {
    let [a, l] = reactExports.useState(false), r2 = typeof t == "string" ? t : String(t), s = e || "javascript";
    return jsxRuntimeExports.jsxs("div", { className: "lua:relative lua:my-4 lua:rounded-lg lua:overflow-hidden lua:mx-4 lua:sm:mx-5 lua:grid", children: [jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:items-center lua:justify-between lua:bg-gray-800 lua:text-gray-200 lua:px-4 lua:py-2", children: [jsxRuntimeExports.jsx("span", { className: "lua:text-xs lua:font-mono", children: s }), jsxRuntimeExports.jsx("button", { onClick: () => {
      navigator.clipboard.writeText(r2), l(true), setTimeout(() => l(false), 2e3);
    }, className: "lua:text-xs lua:bg-gray-700 lua:hover:bg-gray-600 lua:rounded lua:px-2 lua:py-1 lua:transition-colors", "aria-label": "Copy code", children: a ? "Copied!" : "Copy" })] }), jsxRuntimeExports.jsx(Highlight2, { theme: themes_exports.vsDark, code: r2, language: s, children: ({ className: u, style: n, tokens: p, getLineProps: f, getTokenProps: o }) => jsxRuntimeExports.jsx("pre", { className: `${u} lua:p-4 lua:overflow-x-auto`, style: n, children: p.map((i, h) => jsxRuntimeExports.jsx("div", { ...f({ line: i }), children: i.map((c, v) => jsxRuntimeExports.jsx("span", { ...o({ token: c }) }, v)) }, h)) }) })] });
  }
  var L$1 = { p: "lua:mb-2 lua:last:mb-0 lua:mx-4 lua:sm:mx-5 lua-paragraph-markdown", h1: "lua:text-2xl lua:font-bold lua:mb-2 lua:mx-4 lua:sm:mx-5", h2: "lua:text-xl lua:font-semibold lua:mb-2 lua:text-gray-700 lua:mx-4 lua:sm:mx-5", h3: "lua:text-lg lua:font-medium lua:mb-2 lua:mx-4 lua:sm:mx-5", h4: "lua:mx-4 lua:sm:mx-5", ul: "lua:list-disc lua:pl-6 lua:mb-4", ol: "lua:list-decimal lua:pl-6 lua:mb-4 lua:mx-4 lua:sm:mx-5", li: "lua:mb-1 lua:mx-4 lua:sm:mx-5", a: "lua:text-blue-500 lua:hover:underline", blockquote: "lua:border-l-4 lua:border-gray-200 lua:pl-4 lua:italic lua:my-4", code: "lua:bg-gray-100 lua:rounded lua:px-1 lua:mx-4 lua:sm:mx-5", table: "lua:min-w-full lua:border lua:border-gray-200 lua:my-4", th: "lua:bg-gray-100 lua:border lua:border-gray-200 lua:px-4 lua:py-2", td: "lua:border lua:border-gray-200 lua:px-4 lua:py-2" };
  var Ra = (t) => ({ code({ children: e, className: a, ...l }) {
    let r2 = (a == null ? void 0 : a.replace("language-", "")) || "";
    return typeof e == "string" && !e.includes(`
`) ? jsxRuntimeExports.jsx("code", { className: L$1.code, ...l, children: e }) : jsxRuntimeExports.jsx(Ct, { language: r2, className: a, children: e });
  }, p({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("p", { className: L$1.p, ...a, children: e });
  }, h1({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("h1", { className: L$1.h1, ...a, children: e });
  }, h2({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("h2", { className: L$1.h2, ...a, children: e });
  }, h3({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("h3", { className: L$1.h3, ...a, children: e });
  }, h4({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("h4", { className: L$1.h4, ...a, children: e });
  }, img({ src: e, alt: a }) {
    return jsxRuntimeExports.jsx("img", { src: e, alt: a, className: "lua:w-full lua:h-48 lua:object-cover lua:rounded-lg lua:mb-3" });
  }, ul({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("ul", { className: L$1.ul, ...a, children: e });
  }, ol({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("ol", { className: L$1.ol, ...a, children: e });
  }, li({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("li", { className: `${L$1.li} cursor-pointer hover:bg-gray-50 rounded px-2 -mx-2 transition-colors`, onClick: () => t(e), ...a, children: e });
  }, a({ href: e, children: a, ...l }) {
    return jsxRuntimeExports.jsx("a", { href: e, className: L$1.a, target: "_blank", rel: "noopener noreferrer", ...l, children: a });
  }, blockquote({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("blockquote", { className: L$1.blockquote, ...a, children: e });
  }, pre({ children: e }) {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: e });
  }, table({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("table", { className: L$1.table, ...a, children: e });
  }, th({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("th", { className: L$1.th, ...a, children: e });
  }, td({ children: e, ...a }) {
    return jsxRuntimeExports.jsx("td", { className: L$1.td, ...a, children: e });
  } }), be = Ra;
  function Ua(t) {
    let e = new URL(t, "http://lua"), a = decodeURIComponent(e.pathname), l = {};
    for (let [r2, s] of e.searchParams.entries()) l[r2] = decodeURIComponent(s);
    return { pathname: a, queryParams: l };
  }
  var we = Ua;
  function Da(t) {
    let e = t.match(/\[navigate\]\(([^)]+)\)/);
    return e ? e[1] : null;
  }
  var Nt = Da;
  var Fa = reactExports.memo(function({ block: e, onCardClick: a, onListItemClick: l, onNavigate: r2 }) {
    let s = e.content.match(/^#\s+(.+)$/m), d = e.content.match(/!\[.*?]\((.*)\)/), u = s ? s[1] : "", n = d ? d[1] : null, p = Nt(e.content), f = e.content.replace(/^#\s+.+$/m, "").replace(/!\[.*?]\(.*?\)/g, "").replace(/\[.*?]\(.*?\)/g, "").trim(), o = be(l);
    return jsxRuntimeExports.jsxs("div", { onClick: () => {
      if (r2 && p) {
        let h = we(p);
        r2(h.pathname, { ...h.queryParams && { query: h.queryParams } });
      } else a(e.content);
    }, className: "chat-list-item group", children: [jsxRuntimeExports.jsx("div", { className: "lua:absolute lua:inset-0 lua:bg-blue-500 lua:opacity-0 group-hover:lua:opacity-5 lua:rounded-lg lua:transition-opacity lua:duration-200" }), jsxRuntimeExports.jsxs("div", { className: "chat-list-item-content", children: [n ? jsxRuntimeExports.jsx("div", { className: "chat-list-item-image-wrapper", children: jsxRuntimeExports.jsx("img", { className: "chat-list-item-image", src: n, alt: u }) }) : null, jsxRuntimeExports.jsxs("div", { className: "content-container", children: [jsxRuntimeExports.jsx("h1", { className: "lua:text-base lua:leading-6 lua:font-semibold lua:text-gray-900 lua:mb-0", children: u }), jsxRuntimeExports.jsx("div", { className: "lua:text-sm lua:leading-6 lua:font-normal lua:text-gray-600", children: jsxRuntimeExports.jsx(Markdown, { components: o, children: f }) })] })] })] });
  }), re = Fa;
  var Ba = reactExports.memo(function({ group: e, onCardClick: a, onListItemClick: l, onNavigate: r2 }) {
    return jsxRuntimeExports.jsx("div", { className: "lua:w-full", children: jsxRuntimeExports.jsx("div", { className: "chat-list-item-container", children: e.map((s, d) => jsxRuntimeExports.jsx(re, { block: s, onCardClick: a, onListItemClick: l, onNavigate: r2 }, d)) }) });
  }), kt = Ba;
  function Oa(t) {
    return { icon: () => null };
  }
  function Ne({ documents: t }) {
    return t.map((e) => {
      let l = Oa(new File([], "", { type: e.mediaType })).icon;
      return jsxRuntimeExports.jsx("a", { "data-testid": "chat-file-message", href: e.url, target: "_blank", rel: "noopener noreferrer", className: "chat-file-message lua:mx-4 lua:sm:mx-5", children: jsxRuntimeExports.jsx("div", { className: "lua:flex lua:flex-col lua:gap-8", children: jsxRuntimeExports.jsxs("div", { className: "chat-file-card lua:flex lua:items-center lua:justify-start lua:p-3 lua:border lua:border-gray-200 lua:rounded-lg lua:bg-white lua:w-80", children: [jsxRuntimeExports.jsx(l, { className: "lua:w-12 lua:h-12 lua:text-gray-500" }), jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-1 lua:pl-2", children: [e.fileName || "File", jsxRuntimeExports.jsx("span", { className: "lua:text-gray-500 lua:text-sm", children: e.mediaType })] })] }) }) }, e.url);
    });
  }
  function $a(t) {
    let e = [], a = t.split(`
`).filter((l) => l.trim() !== "");
    for (let l of a) {
      let r2 = /\[([^\]]+)\]\(([^)]+)\)\s+filename:([^\s]+)\s+mime:([^\s]+)/g, s;
      for (; (s = r2.exec(l)) !== null; ) {
        let [, d, u, n, p] = s;
        e.push({ fileName: d.trim(), url: u.trim(), filename: n.trim(), mediaType: p.trim() });
      }
    }
    return e;
  }
  var De = $a;
  function Lt({ message: t }) {
    return jsxRuntimeExports.jsx("div", { className: "chat-audio-message lua:flex lua:flex-col lua:mx-4 lua:sm:mx-5", "data-testid": "audio-preview", children: jsxRuntimeExports.jsx("div", { className: "chat-audio-container audio-playback-container lua:relative", children: jsxRuntimeExports.jsxs("div", { className: "chat-audio-controls lua:flex lua:items-center lua:gap-2 lua:min-w-full", children: [jsxRuntimeExports.jsx("audio", { src: t.url, controls: true, className: "chat-audio-player lua:h-8", style: { backgroundColor: "transparent", border: "none" } }), t.isUploading && jsxRuntimeExports.jsx("div", { className: "chat-audio-upload-overlay lua:absolute lua:inset-0 lua:bg-black lua:bg-opacity-50 lua:rounded-lg lua:flex lua:items-center lua:justify-center", children: jsxRuntimeExports.jsx("div", { className: "lua:text-white lua:text-sm", children: "Uploading..." }) })] }) }) });
  }
  function Ee({ url: t }) {
    return jsxRuntimeExports.jsxs(Button, { onClick: (a) => {
      if (a.preventDefault(), /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        window.open(t, "_blank", "noopener,noreferrer");
        return;
      }
      let r2 = 500, s = 600, d = window.screen.width / 2 - r2 / 2, u = window.screen.height / 2 - s / 2, n = window.open(t, "Payment", `width=${r2},height=${s},left=${d},top=${u},toolbar=no,menubar=no,scrollbars=yes,resizable=yes`);
      (!n || n.closed || typeof n.closed > "u") && window.open(t, "_blank", "noopener,noreferrer");
    }, className: "chat-payment-button lua:rounded-xl", children: [jsxRuntimeExports.jsx(CreditCard, { size: 16 }), jsxRuntimeExports.jsx("span", { children: "Open payment" })] });
  }
  var ja = (t) => t.split(`
`).filter((a) => a.trim()).filter((a) => a.trim().startsWith("-")).map((a) => ({ text: a.trim().substring(1).trim(), onClick: a.trim().substring(1).trim() })), Se = ja;
  var Wa = (t) => {
    let e = /!\[(.*?)\]\((.*)\)/g, a = [], l;
    for (; (l = e.exec(t)) !== null; ) l[1] && l[2] && a.push({ alt: l[1], src: l[2] });
    return a;
  }, Fe = Wa;
  var Xa = (t) => {
    let e = /\[.*?\]\((.*?)\)/g, a = [], l;
    for (; (l = e.exec(t)) !== null; ) l[1] && a.push(l[1]);
    return a;
  }, He = Xa;
  function Be(t) {
    let e = t.match(/!\[([^\]]+)\]\(([^)]+)\)/);
    if (!e) return null;
    let [, a, l] = e;
    return { text: a, url: l };
  }
  var Ga = (t) => {
    let e = /\[.*?\]\((.*?)\)/, a = t.match(e);
    return a ? a[1] : null;
  }, Oe = Ga;
  var $e = (t) => typeof t == "string" ? t : Array.isArray(t) ? t.map($e).join("") : typeof t == "object" && t !== null && "props" in t ? $e(t.props.children) : "", Pt = $e;
  function Ka(t) {
    return t.replace(/([^\n]):::/g, `$1
:::`);
  }
  var Qa = (t) => {
    t = t.replace(/\\n/g, `
`);
    let e = [], a = "", l = "", r2 = "", s = "", d = "", u = "", n = "", p = "", f = false, o = false, i = false, h = false, c = false, v = false, g = false, x = Ka(t).split(`
`);
    for (let N = 0; N < x.length; N++) {
      let m2 = x[N];
      if (m2.trim() === "::: list-item" || m2.trim() === ":::list-item") {
        a.trim() && (e.push({ type: "text", content: a.trim() }), a = ""), f = true;
        continue;
      }
      if (m2.trim() === "::: payment" || m2.trim() === ":::payment") {
        a.trim() && (e.push({ type: "text", content: a.trim() }), a = ""), o = true;
        continue;
      }
      if (m2.trim() === "::: actions" || m2.trim() === ":::actions") {
        a.trim() && (e.push({ type: "text", content: a.trim() }), a = ""), i = true;
        continue;
      }
      if (m2.trim() === "::: images" || m2.trim() === ":::images") {
        a.trim() && (e.push({ type: "text", content: a.trim() }), a = ""), h = true;
        continue;
      }
      if (m2.trim() === "::: links" || m2.trim() === ":::links") {
        a.trim() && (e.push({ type: "text", content: a.trim() }), a = ""), c = true;
        continue;
      }
      if (m2.trim() === "::: navigate" || m2.trim() === ":::navigate") {
        a.trim() && (e.push({ type: "text", content: a.trim() }), a = ""), v = true;
        continue;
      }
      if (m2.trim() === "::: documents" || m2.trim() === ":::documents") {
        a.trim() && (e.push({ type: "text", content: a.trim() }), a = ""), g = true;
        continue;
      }
      if (m2.trim() === ":::" && f) {
        e.push({ type: "list-item", content: l.trim(), isComplete: true }), l = "", f = false;
        continue;
      }
      if (m2.trim() === ":::" && o) {
        e.push({ type: "payment", content: r2.trim(), isComplete: true }), r2 = "", o = false;
        continue;
      }
      if (m2.trim() === ":::" && i) {
        e.push({ type: "actions", content: s.trim(), isComplete: true }), s = "", i = false;
        continue;
      }
      if (m2.trim() === ":::" && h) {
        e.push({ type: "images", content: d.trim(), isComplete: true }), d = "", h = false;
        continue;
      }
      if (m2.trim() === ":::" && c) {
        e.push({ type: "links", content: u.trim(), isComplete: true }), u = "", c = false;
        continue;
      }
      if (m2.trim() === ":::" && v) {
        e.push({ type: "navigate", content: n.trim(), isComplete: true }), n = "", v = false;
        continue;
      }
      if (m2.trim() === ":::" && g) {
        e.push({ type: "documents", content: p.trim(), isComplete: true }), p = "", g = false;
        continue;
      }
      f ? l += m2 + `
` : o ? r2 += m2 + `
` : i ? s += m2 + `
` : h ? d += m2 + `
` : c ? u += m2 + `
` : v ? n += m2 + `
` : g ? p += m2 + `
` : a += m2 + `
`;
    }
    return f ? e.push({ type: "list-item", content: l.trim(), isComplete: false }) : o ? e.push({ type: "payment", content: r2.trim(), isComplete: false }) : i ? e.push({ type: "actions", content: s.trim(), isComplete: false }) : h ? e.push({ type: "images", content: d.trim(), isComplete: false }) : c ? e.push({ type: "links", content: u.trim(), isComplete: false }) : v ? e.push({ type: "navigate", content: n.trim(), isComplete: false }) : g ? e.push({ type: "documents", content: p.trim(), isComplete: false }) : a.trim() && e.push({ type: "text", content: a.trim() }), e;
  }, At = Qa;
  function Me({ images: t }) {
    let [e, a] = reactExports.useState(false), [l, r2] = reactExports.useState(0), s = reactExports.useRef(null), [d, u] = reactExports.useState(false), [n, p] = reactExports.useState(0), [f, o] = reactExports.useState(0), [i, h] = reactExports.useState(0), c = reactExports.useCallback((w) => {
      s.current && (u(true), p(w.pageX - s.current.offsetLeft), o(s.current.scrollLeft), h(0), w.preventDefault());
    }, []), v = reactExports.useCallback((w) => {
      if (!d || !s.current) return;
      w.preventDefault();
      let U = w.pageX - s.current.offsetLeft, B = (U - n) * 2;
      s.current.scrollLeft = f - B, h(Math.abs(U - n));
    }, [d, n, f]), g = reactExports.useCallback(() => {
      u(false);
    }, []), C = reactExports.useCallback(() => {
      u(false);
    }, []), x = reactExports.useCallback((w, U) => {
      if (i > 5) {
        U.preventDefault();
        return;
      }
      r2(w), a(true);
    }, [i]);
    return jsxRuntimeExports.jsxs("div", { "data-testid": "image-carousel-message", className: "chat-image-carousel-message lua:w-full", children: [jsxRuntimeExports.jsx("div", { ref: s, className: "chat-image-carousel markdown-image-carousel", style: { cursor: d ? "grabbing" : "grab" }, onMouseDown: c, onMouseMove: v, onMouseUp: g, onMouseLeave: C, onDragStart: (w) => {
      w.preventDefault(), w.stopPropagation();
    }, onDragOver: (w) => {
      w.preventDefault(), w.stopPropagation();
    }, children: t.map((w, U) => jsxRuntimeExports.jsx("div", { className: "chat-carousel-image-item markdown-image-item", onClick: (B) => x(U, B), children: jsxRuntimeExports.jsx("img", { src: w.src, alt: w.alt, draggable: false, style: { userSelect: "none" } }) }, w.src)) }), jsxRuntimeExports.jsx(yt, { images: t, initialIndex: l, open: e, onClose: () => a(false) })] });
  }
  function ze({ message: t }) {
    let [e, a] = reactExports.useState(false);
    return t.url ? jsxRuntimeExports.jsxs("div", { "data-testid": "image-message", className: "chat-image-message lua:flex lua:flex-col lua:w-3/5 lua:mx-4 lua:sm:mx-5", children: [jsxRuntimeExports.jsxs("div", { className: "chat-image-container lua:relative", children: [jsxRuntimeExports.jsx("img", { src: t.url, alt: t.content, className: "chat-image lua:rounded-lg lua:w-full lua:cursor-pointer", onClick: () => a(true) }), t.isUploading && jsxRuntimeExports.jsx("div", { className: "chat-image-upload-overlay lua:absolute lua:inset-0 lua:bg-black lua:bg-opacity-50 lua:rounded-lg lua:flex lua:items-center lua:justify-center", children: jsxRuntimeExports.jsxs("div", { className: "lua:text-white lua:text-sm", children: ["Uploading...", " ", t.uploadProgress ? Math.round(t.uploadProgress) : 0, "%"] }) })] }), !t.isUploading && t.content.length > 0 && jsxRuntimeExports.jsx("div", { className: "chat-image-caption lua:w-full lua:bg-gray-100 lua:text-gray-800 lua:rounded-2xl lua:px-4 lua:p-3 lua:mt-8", children: t.content }), jsxRuntimeExports.jsx(vt, { url: t.url, alt: t.content, open: e, onClose: () => a(false) })] }) : null;
  }
  function _e({ url: t, luaApiUrl: e, authToken: a, disablePreviewOnLinks: l }) {
    let [r2, s] = reactExports.useState(null), [d, u] = reactExports.useState(true), [n, p] = reactExports.useState(null);
    return reactExports.useEffect(() => {
      t && e && !l && (async () => {
        try {
          u(true), p(null);
          let o = a;
          if (!o) throw new Error("No auth token available");
          let i = await fetch(`${e}/chat/url-metadata?url=${encodeURIComponent(t)}`, { headers: { Authorization: `Bearer ${o}` } });
          if (!i.ok) throw new Error(`Failed to fetch preview: ${i.status}`);
          let h = await i.json();
          s(h);
        } catch (o) {
          console.error("Error fetching link preview:", o), p(o instanceof Error ? o.message : "Failed to load preview");
        } finally {
          u(false);
        }
      })();
    }, [t, e]), l ? jsxRuntimeExports.jsx("div", { className: "lua:mb-5 lua:mx-[-30px]", children: jsxRuntimeExports.jsx("a", { href: t, target: "_blank", rel: "noopener noreferrer", children: jsxRuntimeExports.jsx(Button, { variant: "muted", children: t }) }) }) : d ? jsxRuntimeExports.jsxs("div", { className: "lua:animate-pulse", children: [jsxRuntimeExports.jsx("div", { className: "lua:bg-gray-300 lua:h-4 lua:w-3/4 lua:mb-2 lua:rounded" }), jsxRuntimeExports.jsx("div", { className: "lua:bg-gray-300 lua:h-3 lua:w-1/2 lua:rounded" })] }) : n || !r2 ? jsxRuntimeExports.jsx("div", { className: "lua:mb-5 lua:mx-[-30px]", children: jsxRuntimeExports.jsx("a", { href: t, target: "_blank", rel: "noopener noreferrer", children: jsxRuntimeExports.jsx(Button, { variant: "muted", children: t }) }) }) : jsxRuntimeExports.jsxs("a", { href: r2.url || t, target: "_blank", rel: "noopener noreferrer", className: "lua:block lua:border lua:border-gray-200 lua:rounded-lg lua:p-3 lua:hover:bg-gray-50 lua:transition-colors lua:no-underline lua:max-w-sm", children: [r2.image && jsxRuntimeExports.jsx("img", { src: r2.image, alt: r2.title, className: "lua:w-full lua:h-32 lua:object-cover lua:rounded lua:mb-2", onError: (f) => {
      f.currentTarget.style.display = "none";
    } }), jsxRuntimeExports.jsx("div", { className: "lua:text-sm lua:font-medium lua:text-gray-900 lua:mb-1 lua:line-clamp-2", children: r2.title }), r2.description && jsxRuntimeExports.jsx("div", { className: "lua:text-xs lua:text-gray-600 lua:line-clamp-2", children: r2.description }), jsxRuntimeExports.jsx("div", { className: "lua:text-xs lua:text-gray-400 lua:mt-1 lua:truncate", children: new URL(r2.url || t).hostname })] });
  }
  function Te({ links: t, luaApiUrl: e, authToken: a, disablePreviewOnLinks: l }) {
    return jsxRuntimeExports.jsx("div", { "data-testid": "link-list-message", className: "chat-link-list-message lua:w-full", children: jsxRuntimeExports.jsx("div", { className: "chat-links-container lua:space-y-2 lua:mx-4 lua:sm:mx-5", children: t.map((r2) => jsxRuntimeExports.jsx(_e, { url: r2, luaApiUrl: e, authToken: a, disablePreviewOnLinks: l }, r2)) }) });
  }
  function We({ location: t }) {
    let e = [t.latitude, t.longitude];
    return jsxRuntimeExports.jsx("div", { className: "lua:w-full lua:h-48 lua:rounded-lg lua:overflow-hidden lua:border lua:border-gray-200", children: jsxRuntimeExports.jsxs(MapContainer, { center: e, zoom: 15, scrollWheelZoom: false, className: "lua:w-full lua:h-full", children: [jsxRuntimeExports.jsx(TileLayer, { attribution: ' <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors', url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" }), jsxRuntimeExports.jsx(Marker, { position: e, children: t.address && jsxRuntimeExports.jsx(Popup, { children: jsxRuntimeExports.jsx("div", { children: t.address }) }) })] }) });
  }
  function Xe({ location: t }) {
    return jsxRuntimeExports.jsx("div", { className: "lua:w-full lua:h-full lua:bg-gray-200 lua:rounded-lg lua:flex lua:items-center lua:justify-center lua:flex-col", children: t.address && jsxRuntimeExports.jsx(We, { location: t }) });
  }
  function Ge({ location: t }) {
    return jsxRuntimeExports.jsx("div", { className: "lua:w-full lua:h-60 lua:rounded-lg", "data-testid": "location-preview", children: jsxRuntimeExports.jsx(Xe, { location: t }) });
  }
  function Ke({ message: t }) {
    return jsxRuntimeExports.jsx("div", { "data-testid": "location-message", className: "chat-location-message lua:flex lua:flex-col lua:w-11/12 sm:lua:w-3/5 lua:bg-gray-100 lua:text-gray-800 lua:rounded-2xl lua:p-3 lua:mx-4 lua:sm:mx-5", children: jsxRuntimeExports.jsxs("div", { className: "chat-location-preview-container location-preview-container lua:relative", children: [t.location && jsxRuntimeExports.jsx(Ge, { location: t.location }), t.isUploading && jsxRuntimeExports.jsx("div", { className: "chat-location-upload-overlay lua:absolute lua:inset-0 lua:bg-black lua:bg-opacity-50 lua:rounded-lg lua:flex lua:items-center lua:justify-center", children: jsxRuntimeExports.jsx("div", { className: "lua:text-white lua:text-sm", children: "Sharing location..." }) }), jsxRuntimeExports.jsxs("div", { className: "chat-location-info lua:flex lua:items-center lua:gap-2 lua:mt-3", children: [jsxRuntimeExports.jsx(MapPin$1, { fill: "black" }), jsxRuntimeExports.jsx("div", { className: "lua:flex-1", children: jsxRuntimeExports.jsx("div", { className: "lua:text-sm", children: t.content }) })] })] }) });
  }
  function Qe({ url: t, onNavigate: e }) {
    let [a, l] = reactExports.useState(false);
    return reactExports.useEffect(() => {
      if (e && !a) {
        l(true);
        let r2 = we(t);
        e(r2.pathname, { ...r2.queryParams && { query: r2.queryParams } });
      }
    }, [a, e]), null;
  }
  function Ye({ message: t }) {
    return jsxRuntimeExports.jsxs("div", { "data-testid": "video-message", className: "chat-video-message lua:flex lua:flex-col lua:w-3/5 lua:mx-4 lua:sm:mx-5", children: [jsxRuntimeExports.jsxs("div", { className: "chat-video-container lua:relative", children: [jsxRuntimeExports.jsx("video", { src: t.url, controls: true, className: "chat-video lua:rounded-lg lua:w-full" }), t.isUploading && jsxRuntimeExports.jsx("div", { className: "chat-video-upload-overlay lua:absolute lua:inset-0 lua:bg-black lua:bg-opacity-50 lua:rounded-lg lua:flex lua:items-center lua:justify-center", children: jsxRuntimeExports.jsxs("div", { className: "lua:text-white lua:text-sm", children: ["Uploading...", " ", t.uploadProgress ? Math.round(t.uploadProgress) : 0, "%"] }) })] }), !t.isUploading && t.content && jsxRuntimeExports.jsx("div", { className: "chat-video-caption lua:w-full lua:bg-gray-100 lua:text-gray-800 lua:rounded-2xl lua:px-4 lua:p-3 lua:mt-8", children: t.content })] });
  }
  function cl(t) {
    return new Date(t).toLocaleTimeString();
  }
  function dl(t) {
    return { icon: () => null };
  }
  var nn = reactExports.memo(function({ message: e, onSelect: a, luaApiUrl: l, authToken: r2, disablePreviewOnLinks: s = false, onNavigate: d }) {
    let u = reactExports.useCallback((f) => {
      let o = f.match(/^#\s+(.+)$/m), i = f.match(/^##\s+(.+)$/m), h = o ? o[1] : "", c = i ? i[1] : "", v = `${h}. ${c}`;
      a && a(v);
    }, [a]), n = reactExports.useCallback((f) => {
      if (!a) return;
      let o = Pt(f).trim();
      a(o);
    }, [a]), p = reactExports.useCallback(() => {
      var _a2, _b2, _c2;
      if (e.type === "location") return jsxRuntimeExports.jsx(Ke, { message: e });
      if ((_a2 = e.mediaType) == null ? void 0 : _a2.startsWith("video")) return e.url ? jsxRuntimeExports.jsx(Ye, { message: { url: e.url, content: e.content || "", isUploading: e.isUploading, uploadProgress: e.uploadProgress } }) : null;
      if ((_b2 = e.mediaType) == null ? void 0 : _b2.startsWith("image")) return e.url ? jsxRuntimeExports.jsx(ze, { message: { url: e.url, content: e.content || "", isUploading: e.isUploading, uploadProgress: e.uploadProgress } }) : null;
      if ((_c2 = e.mediaType) == null ? void 0 : _c2.startsWith("audio")) return jsxRuntimeExports.jsx(Lt, { message: e });
      if (e.type === "file" && e.mediaType) {
        let h = dl(new File([], "", { type: e.mediaType })).icon;
        return jsxRuntimeExports.jsx("a", { "data-testid": "chat-file-message", href: e.url, target: "_blank", rel: "noopener noreferrer", className: "chat-file-message lua:mx-4 lua:sm:mx-5", children: jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-8", children: [jsxRuntimeExports.jsxs("div", { className: "chat-file-card lua:flex lua:items-center lua:justify-start lua:p-3 lua:border lua:border-gray-200 lua:rounded-lg lua:bg-white lua:w-80", children: [jsxRuntimeExports.jsx(h, { className: "lua:w-12 lua:h-12 lua:text-gray-500" }), jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-1 lua:pl-2", children: ["File", jsxRuntimeExports.jsx("span", { className: "lua:text-gray-500 lua:text-sm", children: e.mediaType })] })] }), e.content && jsxRuntimeExports.jsx("div", { className: "chat-file-content lua:bg-gray-100 lua:rounded-2xl lua:px-4 lua:py-2 lua:w-80", children: jsxRuntimeExports.jsx("div", { className: "lua:text-sm lua:text-gray-900", children: e.content }) })] }) });
      }
      if (e.role === "user") return e.content;
      if (e.content === "...") return null;
      let f = At(e.content), o = be(n);
      return jsxRuntimeExports.jsx("div", { className: "chat-markdown-content lua:prose lua:prose-sm lua:max-w-none", children: jsxRuntimeExports.jsx("div", { className: "lua:flex lua:flex-wrap lua:gap-4", children: (() => {
        if (f.filter((c) => c.type === "list-item").length > 1) {
          let c = [], v = [];
          return f.forEach((g) => {
            g.type === "list-item" ? v.push(g) : (v.length > 0 && (c.push(v), v = []), c.push([g]));
          }), v.length > 0 && c.push(v), c.map((g, C) => g.length > 1 && g[0].type === "list-item" ? jsxRuntimeExports.jsx(kt, { group: g, onCardClick: u, onListItemClick: n, onNavigate: d }, C) : g.map((x, N) => {
            if (x.type === "list-item") return jsxRuntimeExports.jsx(re, { block: x, onCardClick: u, onListItemClick: n, onNavigate: d }, N);
            if (x.type === "actions") return Se(x.content).length > 0 && x.isComplete, null;
            if (x.type === "images") {
              let m2 = Fe(x.content);
              if (m2.length > 0) return jsxRuntimeExports.jsx(Me, { images: m2 }, N);
            }
            if (x.type === "links") {
              let m2 = He(x.content);
              return m2.length > 0 && x.isComplete ? jsxRuntimeExports.jsx(Te, { links: m2, luaApiUrl: l || "", authToken: r2 || "", disablePreviewOnLinks: s }, N) : null;
            }
            if (x.type === "navigate") {
              let m2 = Be(x.content);
              return m2 && x.isComplete ? jsxRuntimeExports.jsx(Qe, { text: m2.text, url: m2.url, onNavigate: d }, N) : null;
            }
            if (x.type === "documents") {
              let m2 = De(x.content);
              return jsxRuntimeExports.jsx(Ne, { documents: m2 }, N);
            }
            if (x.type === "payment") {
              let m2 = Oe(x.content);
              return m2 ? jsxRuntimeExports.jsx("div", { className: "chat-payment-message lua:w-full lua:mx-4 lua:sm:mx-5", children: jsxRuntimeExports.jsx(Ee, { url: m2 }) }, N) : null;
            }
            return jsxRuntimeExports.jsx("div", { className: "chat-markdown-block lua:w-full", children: jsxRuntimeExports.jsx(Markdown, { components: o, children: x.content }) }, N);
          }));
        }
        return f.map((c, v) => {
          if (c.type === "list-item") return jsxRuntimeExports.jsx(re, { block: c, onCardClick: u, onListItemClick: n, onNavigate: d }, v);
          if (c.type === "actions") return Se(c.content).length > 0 && c.isComplete, null;
          if (c.type === "images") {
            let g = Fe(c.content);
            if (g.length > 0) return jsxRuntimeExports.jsx(Me, { images: g }, v);
          }
          if (c.type === "navigate") {
            let g = Be(c.content);
            return g && c.isComplete ? jsxRuntimeExports.jsx(Qe, { text: g.text, url: g.url, onNavigate: d }, v) : null;
          }
          if (c.type === "documents") {
            let g = De(c.content);
            return jsxRuntimeExports.jsx(Ne, { documents: g }, v);
          }
          if (c.type === "links") {
            let g = He(c.content);
            return g.length > 0 && c.isComplete ? jsxRuntimeExports.jsx(Te, { links: g, luaApiUrl: l || "", authToken: r2 || "", disablePreviewOnLinks: s }, v) : null;
          }
          if (c.type === "payment") {
            let g = Oe(c.content);
            return g ? jsxRuntimeExports.jsx("div", { className: "chat-payment-message lua:w-full lua:mx-4 lua:sm:mx-5 lua:mb-5", children: jsxRuntimeExports.jsx(Ee, { url: g }) }, v) : null;
          }
          return jsxRuntimeExports.jsx("div", { className: "chat-markdown-block lua:w-full", children: jsxRuntimeExports.jsx(Markdown, { components: o, children: c.content }) }, v);
        });
      })() }) });
    }, [e, u, n]);
    return jsxRuntimeExports.jsxs("div", { className: `chat-message-container lua:flex lua:flex-col ${e.role === "user" ? "lua:items-end" : "lua:items-start"} lua:gap-1`, children: [jsxRuntimeExports.jsxs("div", { className: `lua:flex ${e.role === "user" ? "lua:justify-end" : "lua:justify-start"} lua:items-start lua:gap-2 lua:w-full`, children: [!["file", "image", "video", "tool", "location"].includes(e.type || "") && e.content !== "..." && jsxRuntimeExports.jsx("div", { className: `chat-message-bubble ${e.role === "user" ? "chat-message-bubble-user lua:max-w-full md:lua:max-w-3/5 lua:bg-gray-100 lua:text-gray-800 lua:rounded-2xl lua:px-4 lua:py-3 lua:mx-4 lua:sm:mx-5 lua:whitespace-pre-wrap" : "chat-message-bubble-agent lua:w-full lua:bg-white lua:text-gray-800 lua:rounded-lg lua:py-3 lua:rounded-bl-none"}`, style: { wordBreak: "break-word" }, children: p() }), ["file", "image", "video", "location"].includes(e.type || "") && p()] }), jsxRuntimeExports.jsx("div", { className: `lua-message-timestamp lua:text-xs lua:text-gray-400 lua:px-1 ${e.role === "user" ? "lua:mr-4 sm:lua:mr-5" : "lua:ml-4 sm:lua:ml-5"}`, children: cl(e.createdAt) })] });
  });
  var tt = reactExports.createContext(void 0), at = reactExports.createContext(void 0), lt = reactExports.createContext(void 0), rt = reactExports.createContext(void 0), ot = reactExports.createContext(void 0);
  function mn({ children: t }) {
    let [e, a] = reactExports.useState([]), [l, r2] = reactExports.useState(""), [s, d] = reactExports.useState(null), [u, n] = reactExports.useState(false), [p] = reactExports.useState(/* @__PURE__ */ new Map()), f = reactExports.useCallback((i) => {
      if (!p.has(i)) {
        let h = URL.createObjectURL(i);
        p.set(i, h);
      }
      return p.get(i);
    }, [p]), o = reactExports.useCallback((i) => {
      let h = p.get(i);
      h && (URL.revokeObjectURL(h), p.delete(i));
    }, [p]);
    return reactExports.useEffect(() => () => {
      e.forEach((i) => {
        i.url && i.url.startsWith("blob:") && URL.revokeObjectURL(i.url);
      }), p.forEach((i) => URL.revokeObjectURL(i));
    }, [e, p]), jsxRuntimeExports.jsx(tt.Provider, { value: { messages: e, setMessages: a }, children: jsxRuntimeExports.jsx(at.Provider, { value: { inputMessage: l, setInputMessage: r2 }, children: jsxRuntimeExports.jsx(lt.Provider, { value: { loadingMessage: s, setLoadingMessage: d }, children: jsxRuntimeExports.jsx(rt.Provider, { value: { hasUnreadMessages: u, setHasUnreadMessages: n }, children: jsxRuntimeExports.jsx(ot.Provider, { value: { getFileUrl: f, removeFileUrl: o }, children: t }) }) }) }) });
  }
  function pn() {
    let t = reactExports.useContext(tt);
    if (t === void 0) throw new Error("useMessages must be used within a ChatProvider");
    return t;
  }
  function Ht() {
    let t = reactExports.useContext(at);
    if (t === void 0) throw new Error("useInput must be used within a ChatProvider");
    return t;
  }
  function gn() {
    let t = reactExports.useContext(lt);
    if (t === void 0) throw new Error("useLoadingMessage must be used within a ChatProvider");
    return t;
  }
  function hn() {
    let t = reactExports.useContext(rt);
    if (t === void 0) throw new Error("useUnreadMessages must be used within a ChatProvider");
    return t;
  }
  function $() {
    let t = reactExports.useContext(tt), e = reactExports.useContext(at), a = reactExports.useContext(lt), l = reactExports.useContext(rt), r2 = reactExports.useContext(ot);
    if (t === void 0 || e === void 0 || a === void 0 || l === void 0 || r2 === void 0) throw new Error("useChat must be used within a ChatProvider");
    return { ...t, ...e, ...a, ...l, ...r2 };
  }
  function wn() {
    let { loadingMessage: t } = $();
    return t ? jsxRuntimeExports.jsxs("div", { className: "chat-loading-message lua:flex lua:items-center lua:gap-2 lua:mx-4 lua:sm:mx-5", children: [jsxRuntimeExports.jsx(Logo$1, { size: 24, className: "chat-loading-logo lua:w-6 lua:h-6 lua:rounded-full lua:flex-shrink-0 lua:animate-spin", style: { animationDuration: "3s" } }), jsxRuntimeExports.jsx("div", { className: "chat-loading-text lua:text-sm lua:opacity-40", children: t || "Lua is typing..." })] }) : null;
  }
  function Ot({ buttons: t, onClick: e }) {
    return jsxRuntimeExports.jsx("div", { className: "chat-action-message lua:w-full", children: jsxRuntimeExports.jsx("div", { className: "chat-action-buttons lua:flex lua:gap-2 lua:flex-wrap lua:mx-4 lua:sm:mx-5", children: t.map((a, l) => jsxRuntimeExports.jsx(Button, { variant: "tertiary", className: "chat-action-button lua:font-normal lua:rounded-lg lua:py-2 lua:h-auto", onClick: () => e(a.text), children: a.text }, l)) }) });
  }
  var $t = (t) => {
    let e = "::: actions", l = t.indexOf(e);
    if (l === -1) return [];
    let r2 = t.indexOf(":::", l + e.length);
    return r2 === -1 ? [] : t.slice(l + e.length, r2).trim().replace(/\\n/g, `
`).split(`
`).map((f) => f.trim()).filter((f) => f && f.startsWith("-")).map((f) => ({ text: f.replace(/^-[\s]?/, "").trim(), onClick: f.replace(/^-[\s]?/, "").trim() }));
  };
  function In({ onSelect: t }) {
    let { messages: e } = $();
    if (e.length === 0) return null;
    let a = e[e.length - 1], l = $t(a.content);
    return l.length === 0 ? null : jsxRuntimeExports.jsx(Ot, { buttons: l, onClick: t });
  }
  reactExports.memo(function({ onSend: e, disabled: a = false, onFilePaste: l }) {
    let { inputMessage: r2, setInputMessage: s } = Ht(), [d, u] = reactExports.useState(false), n = reactExports.useRef(null);
    reactExports.useEffect(() => {
      let o = () => {
        u(window.matchMedia("(max-width: 768px)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
      };
      return o(), window.addEventListener("resize", o), () => {
        window.removeEventListener("resize", o);
      };
    }, []), reactExports.useEffect(() => {
      let o = n.current;
      o && (a || (o.style.height = "auto", o.style.height = `${o.scrollHeight}px`));
    }, [r2]);
    let p = (o) => {
      if (o.key === "Enter") {
        if (d || o.shiftKey || o.metaKey || o.ctrlKey) return;
        o.preventDefault(), e();
      }
    }, f = reactExports.useCallback((o) => {
      let { items: i } = o.clipboardData;
      if (!i || !l) return;
      let h = [];
      for (let c = 0; c < i.length; c++) {
        let v = i[c];
        if (v.kind === "file") {
          let g = v.getAsFile();
          g && h.push(g);
        }
      }
      h.length > 0 && (o.preventDefault(), l(h));
    }, [l]);
    return jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:gap-3 lua:py-2 lua:px-3 lua:items-start", children: [jsxRuntimeExports.jsx(Logo$1, { size: 32, className: "lua:w-8 lua:h-8 lua:rounded-full lua:flex-shrink-0 lua:m-1" }), jsxRuntimeExports.jsx("div", { className: "lua:flex-1 lua:flex", children: jsxRuntimeExports.jsx("textarea", { ref: n, disabled: a, value: r2, onChange: (o) => s(o.target.value), onKeyDown: p, onPaste: f, placeholder: a ? "This conversation's chat window has already been closed" : "Reply to user", className: `lua:w-full lua:pl-0 lua:pr-4 lua:py-2 lua:resize-none lua:overflow-y-auto lua:border-none lua:focus:outline-none lua:focus:ring-0 lua:text-gray-700 lua:min-h-10 lua:max-h-48 lua:bg-white${a ? " lua:cursor-not-allowed lua:h-14" : ""}`, rows: 1 }) })] });
  });
  function Nl() {
    return localStorage.getItem("authToken");
  }
  async function Q(t, e, a) {
    let l = Nl();
    if (!l) throw new Error("No auth token found");
    return new Promise((r2, s) => {
      let d = new XMLHttpRequest(), u = new FormData();
      u.append("file", t), d.upload.addEventListener("progress", (n) => {
        if (n.lengthComputable && a) {
          let p = n.loaded / n.total * 100;
          a(p);
        }
      }), d.addEventListener("load", () => {
        if (d.status >= 200 && d.status < 300) try {
          let n = JSON.parse(d.responseText);
          r2(n);
        } catch {
          s(new Error("Failed to parse response"));
        }
        else s(new Error(`Failed to upload file: ${d.status}`));
      }), d.addEventListener("error", () => {
        s(new Error("Network error occurred"));
      }), d.open("POST", `${e}/upload`), d.setRequestHeader("Authorization", `Bearer ${l}`), d.send(u);
    });
  }
  function Tl(t) {
    let e = t.type, a = "File";
    return e.startsWith("image/") ? a = "Image" : e.startsWith("video/") ? a = "Video" : e.startsWith("audio/") && (a = "Audio"), { icon: () => null, label: a };
  }
  function ut({ file: t, onRemove: e, cdnUrl: a, initialUrl: l, onUploadComplete: r2 }) {
    let s = Tl(t), d = s.icon, [u, n] = reactExports.useState(false), [p, f] = reactExports.useState(0), [o, i] = reactExports.useState(l || null), h = reactExports.useRef(false);
    return reactExports.useEffect(() => {
      if (o || h.current) return;
      (async () => {
        n(true), h.current = true;
        try {
          let { fileId: v } = await Q(t, a, (C) => {
            f(C);
          }), g = `${a}/${v}`;
          i(g), n(false), r2 && r2(t, g);
        } catch (v) {
          console.error("Upload failed for file:", t.name, v), n(false), h.current = false;
        }
      })();
    }, [t, a, r2, o]), jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:items-center lua:gap-4 lua:p-3 lua:bg-white lua:border lua:border-gray-200 lua:rounded-lg", children: [jsxRuntimeExports.jsx("div", { className: "lua:flex-shrink-0", children: u ? jsxRuntimeExports.jsxs("div", { className: "lua:w-8 lua:h-8 lua:flex lua:flex-col lua:items-center lua:justify-center", children: [jsxRuntimeExports.jsx("div", { className: "lua:w-6 lua:h-6 lua:border-2 lua:border-t-blue-500 lua:border-r-transparent lua:border-b-transparent lua:border-l-transparent lua:rounded-full lua:animate-spin" }), jsxRuntimeExports.jsxs("div", { className: "lua:mt-1 lua:text-xs lua:text-gray-600 lua:font-medium", children: [Math.round(p), "%"] })] }) : jsxRuntimeExports.jsx(d, { className: "lua:w-8 lua:h-8 lua:text-gray-600" }) }), jsxRuntimeExports.jsxs("div", { className: "lua:flex-grow lua:min-w-0", children: [jsxRuntimeExports.jsx("p", { className: "lua:text-sm lua:font-medium lua:text-gray-900 lua:truncate", children: t.name }), jsxRuntimeExports.jsx("p", { className: "lua:text-xs lua:text-gray-500", children: s.label })] }), jsxRuntimeExports.jsx("button", { onClick: e, className: "lua:flex-shrink-0 lua:w-6 lua:h-6 lua:flex lua:items-center lua:justify-center lua:rounded-full lua:bg-black lua:text-white lua:hover:bg-gray-800 lua:transition-colors", children: jsxRuntimeExports.jsx(XIcon$1, { className: "lua:w-4 lua:h-4" }) })] });
  }
  function ct({ file: t, onRemove: e, cdnUrl: a, initialUrl: l, onUploadComplete: r2 }) {
    let { getFileUrl: s } = $(), [d, u] = reactExports.useState(false), [n, p] = reactExports.useState(0), [f, o] = reactExports.useState(l || null), [i, h] = reactExports.useState(false);
    reactExports.useEffect(() => {
      if (l || i) return;
      (async () => {
        u(true), h(true);
        try {
          let { fileId: g } = await Q(t, a, (x) => {
            p(x);
          }), C = `${a}/${g}`;
          o(C), u(false), r2 && r2(t, C);
        } catch (g) {
          console.error("Upload failed:", g), u(false);
        }
      })();
    }, [t, l, a, i, r2]);
    let c = f || (d ? void 0 : s(t));
    return jsxRuntimeExports.jsxs("div", { className: "lua:relative lua:flex-shrink-0", children: [d ? jsxRuntimeExports.jsxs("div", { className: "lua:w-32 lua:h-32 lua:bg-gray-100 lua:rounded-lg lua:flex lua:flex-col lua:items-center lua:justify-center", children: [jsxRuntimeExports.jsx("div", { className: "lua:w-8 lua:h-8 lua:border-2 lua:border-t-blue-500 lua:border-r-transparent lua:border-b-transparent lua:border-l-transparent lua:rounded-full lua:animate-spin" }), jsxRuntimeExports.jsxs("div", { className: "lua:mt-2 lua:text-xs lua:text-gray-600 lua:font-medium", children: [Math.round(n), "%"] })] }) : c ? jsxRuntimeExports.jsx("img", { "data-testid": "image-thumbnail", src: c, alt: t.name, className: "lua:w-32 lua:h-32 lua:object-cover lua:rounded-lg" }) : jsxRuntimeExports.jsx("div", { className: "lua:w-32 lua:h-32 lua:bg-gray-200 lua:rounded-lg lua:flex lua:items-center lua:justify-center", children: jsxRuntimeExports.jsx("span", { className: "lua:text-gray-500", children: "No preview" }) }), jsxRuntimeExports.jsxs("div", { className: "lua:absolute lua:bottom-1 lua:left-1 lua:px-1.5 lua:py-0.5 lua:rounded lua:bg-black/50 lua:text-white lua:text-xs", children: [Math.floor(t.size / 1024 / 1024), "MB"] }), jsxRuntimeExports.jsx("button", { onClick: () => e(), className: "lua:absolute lua:top-1 lua:right-1 lua:w-6 lua:h-6 lua:flex lua:items-center lua:justify-center lua:rounded-full lua:bg-black lua:text-white lua:hover:bg-gray-800 lua:transition-colors", children: jsxRuntimeExports.jsx("span", { className: "lua:text-sm", children: "" }) })] });
  }
  function dt({ file: t, onRemove: e, cdnUrl: a, initialUrl: l, thumbnailUrl: r2, onUploadComplete: s }) {
    let { getFileUrl: d } = $(), [u, n] = reactExports.useState(false), [p, f] = reactExports.useState(0), [o, i] = reactExports.useState(l || null), [h, c] = reactExports.useState(false), [v, g] = reactExports.useState(r2 || null);
    return reactExports.useEffect(() => {
      if (!r2 && !v) {
        let C = d(t), x = document.createElement("video");
        x.src = C;
        let N = () => {
          try {
            x.currentTime = 0, setTimeout(() => {
              let m2 = document.createElement("canvas");
              m2.width = x.videoWidth, m2.height = x.videoHeight;
              let w = m2.getContext("2d");
              if (!w) {
                console.error("Could not get canvas context");
                return;
              }
              w.drawImage(x, 0, 0);
              let U = m2.toDataURL("image/jpeg", 0.8);
              g(U);
            }, 100);
          } catch (m2) {
            console.error("Error generating thumbnail:", m2);
          } finally {
            URL.revokeObjectURL(C), x.removeEventListener("canplay", N);
          }
        };
        x.addEventListener("canplay", N), x.load();
      }
    }, [t, r2, v]), reactExports.useEffect(() => {
      if (l || h) return;
      (async () => {
        n(true), c(true);
        try {
          let { fileId: x } = await Q(t, a, (m2) => {
            f(m2);
          }), N = `${a}/${x}`;
          i(N), n(false), s && s(t, N);
        } catch (x) {
          console.error("Upload failed:", x), n(false);
        }
      })();
    }, [t, l, a, h, s]), jsxRuntimeExports.jsxs("div", { className: "lua:relative lua:flex-shrink-0", children: [u ? jsxRuntimeExports.jsxs("div", { className: "lua:w-32 lua:h-32 lua:bg-gray-100 lua:rounded-lg lua:flex lua:flex-col lua:items-center lua:justify-center", children: [jsxRuntimeExports.jsx("div", { className: "lua:w-8 lua:h-8 lua:border-2 lua:border-t-blue-500 lua:border-r-transparent lua:border-b-transparent lua:border-l-transparent lua:rounded-full lua:animate-spin" }), jsxRuntimeExports.jsxs("div", { className: "lua:mt-2 lua:text-xs lua:text-gray-600 lua:font-medium", children: [Math.round(p), "%"] })] }) : jsxRuntimeExports.jsxs("div", { className: "lua:relative", children: [jsxRuntimeExports.jsx("img", { "data-testid": "video-thumbnail", src: v || o || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", alt: t.name, className: "lua:w-32 lua:h-32 lua:object-cover lua:rounded-lg lua:bg-gray-100" }), jsxRuntimeExports.jsx("div", { className: "lua:absolute lua:inset-0 lua:flex lua:items-center lua:justify-center", children: jsxRuntimeExports.jsx("div", { className: "lua:w-10 lua:h-10 lua:rounded-full lua:bg-black/50 lua:flex lua:items-center lua:justify-center", children: jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsxRuntimeExports.jsx("path", { d: "M5 3L19 12L5 21V3Z", fill: "white" }) }) }) })] }), jsxRuntimeExports.jsxs("div", { className: "lua:absolute lua:bottom-1 lua:left-1 lua:px-1.5 lua:py-0.5 lua:rounded lua:bg-black/50 lua:text-white lua:text-xs", children: [Math.floor(t.size / 1024 / 1024), "MB"] }), jsxRuntimeExports.jsx("button", { onClick: () => e(), className: "lua:absolute lua:top-1 lua:right-1 lua:w-6 lua:h-6 lua:flex lua:items-center lua:justify-center lua:rounded-full lua:bg-black lua:text-white lua:hover:bg-gray-800 lua:transition-colors", children: jsxRuntimeExports.jsx("span", { className: "lua:text-sm", children: "" }) })] });
  }
  function qt(t) {
    let e = t.type, a = "other", l = "File";
    return e.startsWith("image/") ? (a = "image", l = "Image") : e.startsWith("video/") ? (a = "video", l = "Video") : e.startsWith("audio/") && (a = "audio", l = "Audio"), { category: a, icon: () => null, label: l };
  }
  function Ni({ files: t, onRemove: e, cdnUrl: a, fileMetadata: l = [], onFileUploadComplete: r2 }) {
    let [s, d] = reactExports.useState({});
    return reactExports.useEffect(() => {
      t.forEach((u, n) => {
        let p = qt(u), f = l.find((o) => o.file === u);
        if (p.category === "video" && !s[n] && !f) {
          let o = URL.createObjectURL(u), i = document.createElement("video");
          i.src = o;
          let h = () => {
            try {
              i.currentTime = 0, setTimeout(() => {
                let c = document.createElement("canvas");
                c.width = i.videoWidth, c.height = i.videoHeight;
                let v = c.getContext("2d");
                if (!v) {
                  console.error("Could not get canvas context");
                  return;
                }
                v.drawImage(i, 0, 0);
                let g = c.toDataURL("image/jpeg", 0.8);
                d((C) => ({ ...C, [n]: g }));
              }, 100);
            } catch (c) {
              console.error("Error generating thumbnail:", c);
            } finally {
              URL.revokeObjectURL(o), i.removeEventListener("canplay", h);
            }
          };
          i.addEventListener("canplay", h), i.load();
        }
      });
    }, [t, l]), t.length === 0 ? null : jsxRuntimeExports.jsx("div", { className: "lua:px-4 lua:py-2 lua:border-b lua:border-gray-200", children: jsxRuntimeExports.jsx("div", { className: "lua:flex lua:gap-2 lua:overflow-x-auto scrollbar-hide", children: t.map((u, n) => {
      let p = qt(u), f = l.find((o) => o.file === u);
      return t.length > 1 ? jsxRuntimeExports.jsx("div", { className: "lua:flex-shrink-0 lua:w-64", children: jsxRuntimeExports.jsx(ut, { file: u, onRemove: () => e(n), cdnUrl: a, onUploadComplete: (o, i) => {
        r2 && r2(o, i);
      } }) }, n) : p.category === "image" ? jsxRuntimeExports.jsx(ct, { file: u, onRemove: () => e(n), cdnUrl: a, initialUrl: f == null ? void 0 : f.url, onUploadComplete: (o, i) => {
        r2 && r2(o, i);
      } }, u.name) : p.category === "video" ? jsxRuntimeExports.jsx(dt, { file: u, onRemove: () => e(n), cdnUrl: a, initialUrl: f == null ? void 0 : f.url, thumbnailUrl: s[n], onUploadComplete: (o, i) => {
        r2 && r2(o, i);
      } }, u.name) : jsxRuntimeExports.jsx("div", { className: "lua:flex-shrink-0 lua:w-64", children: jsxRuntimeExports.jsx(ut, { file: u, onRemove: () => e(n), cdnUrl: a, onUploadComplete: (o, i) => {
        r2 && r2(o, i);
      } }) }, n);
    }) }) });
  }
  var client = {};
  var m = reactDomExports;
  {
    client.createRoot = m.createRoot;
    client.hydrateRoot = m.hydrateRoot;
  }
  function bind(fn, thisArg) {
    return function wrap2() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const { iterator, toStringTag } = Symbol;
  const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject$2 = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject$1 = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject$2(val) && isFunction(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys2[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys2 = Object.keys(obj);
    let i = keys2.length;
    let _key;
    while (i-- > 0) {
      _key = keys2[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject$1(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach(b, (val, key) => {
      if (thisArg && isFunction(val)) {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content2) => {
    if (content2.charCodeAt(0) === 65279) {
      content2 = content2.slice(1);
    }
    return content2;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position2) => {
    str = String(str);
    if (position2 === void 0 || position2 > str.length) {
      position2 = str.length;
    }
    position2 -= searchString.length;
    const lastIndex = str.indexOf(searchString, position2);
    return lastIndex !== -1 && lastIndex === position2;
  };
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[iterator];
    const _iterator = generator.call(obj);
    let result;
    while ((result = _iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name2) => {
      let ret;
      if ((ret = reducer(descriptor, name2, obj)) !== false) {
        reducedDescriptors[name2] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name2) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
        return false;
      }
      const value = obj[name2];
      if (!isFunction(value)) return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name2 + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define2 = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
    return obj;
  };
  const noop$3 = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit2 = (source, i) => {
      if (isObject$2(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit2(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit2(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject$2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction(_global.postMessage)
  );
  const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  const isIterable = (thing) => thing != null && isFunction(thing[iterator]);
  const utils$1 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject: isObject$2,
    isPlainObject: isPlainObject$1,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop$3,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap,
    isIterable
  };
  function AxiosError$1(message, code2, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code2 && (this.code = code2);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$1.inherits(AxiosError$1, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const prototype$1 = AxiosError$1.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code2) => {
    descriptors[code2] = { value: code2 };
  });
  Object.defineProperties(AxiosError$1, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError$1.from = (error, code2, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$1.toFlatObject(error, axiosError, function filter2(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError$1.call(axiosError, error.message, code2, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key) {
    return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
      token = removeBrackets(token);
      return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter2(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData$1(obj, formData, options2) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options2 = utils$1.toFlatObject(options2, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options2.metaTokens;
    const visitor = options2.visitor || defaultVisitor;
    const dots = options2.dots;
    const indexes = options2.indexes;
    const _Blob = options2.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (utils$1.isBoolean(value)) {
        return value.toString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index2) {
            !(utils$1.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils$1.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils$1.forEach(value, function each(el, key) {
        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$1.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options2) {
    this._pairs = [];
    params && toFormData$1(params, this, options2);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name2, value) {
    this._pairs.push([name2, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options2) {
    if (!params) {
      return url;
    }
    const _encode = options2 && options2.encode || encode;
    if (utils$1.isFunction(options2)) {
      options2 = {
        serialize: options2
      };
    }
    const serializeFn = options2 && options2.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options2);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options2).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options2) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options2 ? options2.synchronous : false,
        runWhen: options2 ? options2.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id2) {
      if (this.handlers[id2]) {
        this.handlers[id2] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const _navigator = typeof navigator === "object" && navigator || void 0;
  const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin
  }, Symbol.toStringTag, { value: "Module" }));
  const platform = {
    ...utils,
    ...platform$1
  };
  function toURLEncodedForm(data, options2) {
    return toFormData$1(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform.isNode && utils$1.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options2));
  }
  function parsePropPath(name2) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i;
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index2) {
      let name2 = path[index2++];
      if (name2 === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name2);
      const isLast = index2 >= path.length;
      name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name2)) {
          target[name2] = [target[name2], value];
        } else {
          target[name2] = value;
        }
        return !isNumericKey;
      }
      if (!target[name2] || !utils$1.isObject(target[name2])) {
        target[name2] = [];
      }
      const result = buildPath(path, value, target[name2], index2);
      if (result && utils$1.isArray(target[name2])) {
        target[name2] = arrayToObject(target[name2]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name2, value) => {
        buildPath(parsePropPath(name2), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData$1(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  const ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
      i = line.indexOf(":");
      key = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils$1.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1.isString(value)) return;
    if (utils$1.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils$1.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  let AxiosHeaders$1 = class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils$1.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
        let obj = {}, dest, key;
        for (const entry of header) {
          if (!utils$1.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(obj, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils$1.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i = keys2.length;
      let deleted = false;
      while (i--) {
        const key = keys2[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value, header) => {
        const key = utils$1.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1.freezeMethods(AxiosHeaders$1);
  function transformData(fns, response) {
    const config = this || defaults;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel$1(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError$1(message, config, request) {
    AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils$1.inherits(CanceledError$1, AxiosError$1, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError$1(
        "Request failed with status code " + response.status,
        [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  function speedometer(samplesCount, min2) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min2 = min2 !== void 0 ? min2 : 1e3;
    return function push2(chunkLength) {
      const now2 = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now2;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now2;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now2 - firstSampleTS < min2) {
        return;
      }
      const passed = startedAt && now2 - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle(fn, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now2 = Date.now()) => {
      timestamp = now2;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn.apply(null, args);
    };
    const throttled = (...args) => {
      const now2 = Date.now();
      const passed = now2 - timestamp;
      if (passed >= threshold) {
        invoke(args, now2);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
  const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
    url = new URL(url, platform.origin);
    return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
  })(
    new URL(platform.origin),
    platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
  ) : () => true;
  const cookies = platform.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name2, value, expires, path, domain, secure) {
        const cookie = [name2 + "=" + encodeURIComponent(value)];
        utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils$1.isString(path) && cookie.push("path=" + path);
        utils$1.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name2) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
  function mergeConfig$1(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
    };
    utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  const resolveConfig = (config) => {
    const newConfig = mergeConfig$1({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils$1.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError$1(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$1.asap(unsubscribe);
      return signal;
    }
  };
  const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
      end = pos + chunkSize;
      yield chunk.slice(pos, end);
      pos = end;
    }
  };
  const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  const readStream = async function* (stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
      return;
    }
    const reader = stream.getReader();
    try {
      for (; ; ) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader.cancel();
    }
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator2 = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator2.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator2.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  const test$1 = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e) {
      return false;
    }
  };
  const supportsRequestStream = isReadableStreamSupported && test$1(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const supportsResponseStream = isReadableStreamSupported && test$1(() => utils$1.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
        throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
      });
    });
  })(new Response());
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils$1.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  const fetchAdapter = isFetchSupported && (async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      });
      let response = await fetch(request, fetchOptions);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options2 = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options2[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options2
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError$1.from(err, err && err.code, config, request);
    }
  });
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id2;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError$1(`Unknown adapter '${id2}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id2 || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError$1(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError$1(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel$1(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION$1 = "1.10.0";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError$1(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError$1.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  validators$1.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options2, schema, allowUnknown) {
    if (typeof options2 !== "object") {
      throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options2);
    let i = keys2.length;
    while (i-- > 0) {
      const opt = keys2[i];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options2[opt];
        const result = value === void 0 || validator2(value, opt, options2);
        if (result !== true) {
          throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  let Axios$1 = class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy = {};
          Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig$1(this.defaults, config);
      const { transitional, paramsSerializer, headers } = config;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      if (config.allowAbsoluteUrls !== void 0) ;
      else if (this.defaults.allowAbsoluteUrls !== void 0) {
        config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config.allowAbsoluteUrls = true;
      }
      validator.assertOptions(config, {
        baseUrl: validators.spelling("baseURL"),
        withXsrfToken: validators.spelling("withXSRFToken")
      }, true);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils$1.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      i = 0;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig$1(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  };
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios$1.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios$1.prototype[method] = generateHTTPMethod();
    Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  let CancelToken$1 = class CancelToken2 {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners) return;
        let i = token._listeners.length;
        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError$1(message, config, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken2(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  };
  function spread$1(callback) {
    return function wrap2(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError$1(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode$1 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
    HttpStatusCode$1[value] = key;
  });
  function createInstance(defaultConfig2) {
    const context = new Axios$1(defaultConfig2);
    const instance = bind(Axios$1.prototype.request, context);
    utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create2(instanceConfig) {
      return createInstance(mergeConfig$1(defaultConfig2, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError$1;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel$1;
  axios.VERSION = VERSION$1;
  axios.toFormData = toFormData$1;
  axios.AxiosError = AxiosError$1;
  axios.Cancel = axios.CanceledError;
  axios.all = function all2(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread$1;
  axios.isAxiosError = isAxiosError$1;
  axios.mergeConfig = mergeConfig$1;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  const {
    Axios,
    AxiosError,
    CanceledError,
    isCancel,
    CancelToken,
    VERSION,
    all,
    Cancel,
    isAxiosError,
    spread,
    toFormData,
    AxiosHeaders,
    HttpStatusCode,
    formToJSON,
    getAdapter,
    mergeConfig
  } = axios;
  const DEFAULT_TIMEOUT = 3e4;
  class ApiClient {
    constructor(config) {
      __publicField(this, "client");
      __publicField(this, "baseURL");
      __publicField(this, "authToken");
      this.baseURL = config.baseURL;
      this.authToken = config.authToken;
      this.client = axios.create({
        baseURL: this.baseURL,
        timeout: config.timeout || DEFAULT_TIMEOUT,
        headers: {
          "Content-Type": "application/json",
          ...this.authToken && { Authorization: `Bearer ${this.authToken}` }
        }
      });
      this.setupRequestInterceptors();
      this.setupResponseInterceptors();
    }
    setAuthToken(token) {
      this.authToken = token;
      this.client.defaults.headers.common["Authorization"] = `Bearer ${token}`;
    }
    clearAuthToken() {
      this.authToken = void 0;
      delete this.client.defaults.headers.common["Authorization"];
    }
    setupRequestInterceptors() {
      this.client.interceptors.request.use(
        (config) => {
          if (this.authToken && config.headers) {
            config.headers["Authorization"] = `Bearer ${this.authToken}`;
          }
          return config;
        },
        (error) => {
          return Promise.reject(error);
        }
      );
    }
    setupResponseInterceptors() {
      this.client.interceptors.response.use(
        (response) => {
          return response;
        },
        (error) => {
          if (error.response) {
            switch (error.response.status) {
              case 401:
                console.warn("Authentication error (401)");
                break;
              case 403:
                console.warn("Forbidden (403)");
                break;
              case 404:
                console.warn("Resource not found (404)");
                break;
              case 429:
                console.warn("Rate limited (429)");
                break;
              case 500:
              case 502:
              case 503:
              case 504:
                console.error(`Server error (${error.response.status})`);
                break;
            }
          } else if (error.request) {
            console.error("No response received from server");
          } else {
            console.error("Error setting up request:", error.message);
          }
          return Promise.reject(error);
        }
      );
    }
    get(url, config) {
      return this.client.get(url, config).then((response) => response.data);
    }
    post(url, data, config) {
      return this.client.post(url, data, config).then((response) => response.data);
    }
    put(url, data, config) {
      return this.client.put(url, data, config).then((response) => response.data);
    }
    patch(url, data, config) {
      return this.client.patch(url, data, config).then((response) => response.data);
    }
    delete(url, config) {
      return this.client.delete(url, config).then((response) => response.data);
    }
    uploadFile(url, file, fieldName = "file", onProgress, config) {
      const formData = new FormData();
      formData.append(fieldName, file);
      const requestConfig = {
        ...config,
        headers: {
          "Content-Type": "multipart/form-data",
          ...(config == null ? void 0 : config.headers) || {}
        },
        onUploadProgress: (progressEvent) => {
          const percentCompleted = Math.round(
            progressEvent.loaded * 100 / (progressEvent.total || 1)
          );
          if (onProgress) {
            onProgress(percentCompleted);
          }
        }
      };
      return this.client.post(url, formData, requestConfig).then((response) => response.data);
    }
    async stream(url, data, config) {
      try {
        const headers = {
          "Content-Type": "application/json"
        };
        if (this.authToken) {
          headers["Authorization"] = `Bearer ${this.authToken}`;
        }
        const response = await fetch(`${this.baseURL}${url}`, {
          method: "POST",
          headers,
          body: JSON.stringify(data),
          ...config
          // Cast AxiosRequestConfig to RequestInit
        });
        if (!response.ok || !response.body) {
          if (response.status === 423) {
            const stream = new ReadableStream({
              start(controller) {
                const encoder = new TextEncoder();
                controller.enqueue(encoder.encode('{"type":"system","data":"{\\"status423\\":true}"}'));
                controller.close();
              }
            });
            return stream.getReader();
          }
          const error = new Error(
            `Streaming request failed with status: ${response.status}`
          );
          error.status = response.status;
          throw error;
        }
        return response.body.getReader();
      } catch (error) {
        console.error("Error in streaming request:", error);
        throw error;
      }
    }
  }
  let apiClientInstance = null;
  function createApiClient(config) {
    apiClientInstance = new ApiClient(config);
    return apiClientInstance;
  }
  function getApiClient() {
    if (!apiClientInstance) {
      throw new Error("API Client not initialized. Call createApiClient first.");
    }
    return apiClientInstance;
  }
  const webchatApi = {
    getWebchatConfig: async (website, isDev = false) => {
      const apiClient = getApiClient();
      const queryParams = new URLSearchParams({
        website
      });
      if (isDev) {
        queryParams.append("channelIdentifier", "tzqq9z");
      }
      return apiClient.get(
        `/webchat/config?${queryParams.toString()}`
      );
    }
  };
  const LayoutGroupContext = reactExports.createContext({});
  function useConstant(init) {
    const ref = reactExports.useRef(null);
    if (ref.current === null) {
      ref.current = init();
    }
    return ref.current;
  }
  const isBrowser = typeof window !== "undefined";
  const useIsomorphicLayoutEffect$1 = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
  const PresenceContext = /* @__PURE__ */ reactExports.createContext(null);
  function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1)
      arr.push(item);
  }
  function removeItem(arr, item) {
    const index2 = arr.indexOf(item);
    if (index2 > -1)
      arr.splice(index2, 1);
  }
  const clamp = (min2, max2, v) => {
    if (v > max2)
      return max2;
    if (v < min2)
      return min2;
    return v;
  };
  let invariant = () => {
  };
  const MotionGlobalConfig = {};
  const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
  function isObject$1(value) {
    return typeof value === "object" && value !== null;
  }
  const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);
  // @__NO_SIDE_EFFECTS__
  function memo(callback) {
    let result;
    return () => {
      if (result === void 0)
        result = callback();
      return result;
    };
  }
  const noop$2 = /* @__NO_SIDE_EFFECTS__ */ (any) => any;
  const combineFunctions = (a, b) => (v) => b(a(v));
  const pipe = (...transformers) => transformers.reduce(combineFunctions);
  const progress = /* @__NO_SIDE_EFFECTS__ */ (from, to, value) => {
    const toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
  };
  class SubscriptionManager {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a, b, c) {
      const numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a, b, c);
      } else {
        for (let i = 0; i < numSubscriptions; i++) {
          const handler = this.subscriptions[i];
          handler && handler(a, b, c);
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  }
  const secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3;
  const millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1e3 / frameDuration) : 0;
  }
  const calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
  const subdivisionPrecision = 1e-7;
  const subdivisionMaxIterations = 12;
  function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i = 0;
    do {
      currentT = lowerBound + (upperBound - lowerBound) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - x;
      if (currentX > 0) {
        upperBound = currentT;
      } else {
        lowerBound = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
      return noop$2;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
  }
  const mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
  const reverseEasing = (easing) => (p) => 1 - easing(1 - p);
  const backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
  const backIn = /* @__PURE__ */ reverseEasing(backOut);
  const backInOut = /* @__PURE__ */ mirrorEasing(backIn);
  const anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
  const circIn = (p) => 1 - Math.sin(Math.acos(p));
  const circOut = reverseEasing(circIn);
  const circInOut = mirrorEasing(circIn);
  const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
  const easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
  const easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);
  const isEasingArray = (ease2) => {
    return Array.isArray(ease2) && typeof ease2[0] !== "number";
  };
  const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
  const easingLookup = {
    linear: noop$2,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
  };
  const isValidEasing = (easing) => {
    return typeof easing === "string";
  };
  const easingDefinitionToFunction = (definition2) => {
    if (isBezierDefinition(definition2)) {
      invariant(definition2.length === 4);
      const [x1, y1, x2, y2] = definition2;
      return cubicBezier(x1, y1, x2, y2);
    } else if (isValidEasing(definition2)) {
      return easingLookup[definition2];
    }
    return definition2;
  };
  const stepsOrder = [
    "setup",
    // Compute
    "read",
    // Read
    "resolveKeyframes",
    // Write/Read/Write/Read
    "preUpdate",
    // Compute
    "update",
    // Compute
    "preRender",
    // Compute
    "render",
    // Write
    "postRender"
    // Compute
  ];
  function createRenderStep(runNextFrame, stepName) {
    let thisFrame = /* @__PURE__ */ new Set();
    let nextFrame = /* @__PURE__ */ new Set();
    let isProcessing = false;
    let flushNextFrame = false;
    const toKeepAlive = /* @__PURE__ */ new WeakSet();
    let latestFrameData = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    function triggerCallback(callback) {
      if (toKeepAlive.has(callback)) {
        step.schedule(callback);
        runNextFrame();
      }
      callback(latestFrameData);
    }
    const step = {
      /**
       * Schedule a process to run on the next frame.
       */
      schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing;
        const queue = addToCurrentFrame ? thisFrame : nextFrame;
        if (keepAlive)
          toKeepAlive.add(callback);
        if (!queue.has(callback))
          queue.add(callback);
        return callback;
      },
      /**
       * Cancel the provided callback from running on the next frame.
       */
      cancel: (callback) => {
        nextFrame.delete(callback);
        toKeepAlive.delete(callback);
      },
      /**
       * Execute all schedule callbacks.
       */
      process: (frameData2) => {
        latestFrameData = frameData2;
        if (isProcessing) {
          flushNextFrame = true;
          return;
        }
        isProcessing = true;
        [thisFrame, nextFrame] = [nextFrame, thisFrame];
        thisFrame.forEach(triggerCallback);
        thisFrame.clear();
        isProcessing = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData2);
        }
      }
    };
    return step;
  }
  const maxElapsed = 40;
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    const flagRunNextFrame = () => runNextFrame = true;
    const steps = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(flagRunNextFrame);
      return acc;
    }, {});
    const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender } = steps;
    const processBatch = () => {
      const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
      runNextFrame = false;
      if (!MotionGlobalConfig.useManualTiming) {
        state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
      }
      state.timestamp = timestamp;
      state.isProcessing = true;
      setup.process(state);
      read.process(state);
      resolveKeyframes.process(state);
      preUpdate.process(state);
      update.process(state);
      preRender.process(state);
      render.process(state);
      postRender.process(state);
      state.isProcessing = false;
      if (runNextFrame && allowKeepAlive) {
        useDefaultElapsed = false;
        scheduleNextBatch(processBatch);
      }
    };
    const wake = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!state.isProcessing) {
        scheduleNextBatch(processBatch);
      }
    };
    const schedule = stepsOrder.reduce((acc, key) => {
      const step = steps[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame)
          wake();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    const cancel = (process2) => {
      for (let i = 0; i < stepsOrder.length; i++) {
        steps[stepsOrder[i]].cancel(process2);
      }
    };
    return { schedule, cancel, state, steps };
  }
  const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$2, true);
  let now;
  function clearTime() {
    now = void 0;
  }
  const time = {
    now: () => {
      if (now === void 0) {
        time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
      }
      return now;
    },
    set: (newTime) => {
      now = newTime;
      queueMicrotask(clearTime);
    }
  };
  const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
  const isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
  const startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
  const isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken)
      return false;
    return singleCssVariableRegex.test(value.split("/*")[0].trim());
  };
  const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
  const number = {
    test: (v) => typeof v === "number",
    parse: parseFloat,
    transform: (v) => v
  };
  const alpha = {
    ...number,
    transform: (v) => clamp(0, 1, v)
  };
  const scale = {
    ...number,
    default: 1
  };
  const sanitize = (v) => Math.round(v * 1e5) / 1e5;
  const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
  function isNullish(v) {
    return v == null;
  }
  const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
  const isColorString = (type, testProp) => (v) => {
    return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
  };
  const splitColor = (aName, bName, cName) => (v) => {
    if (typeof v !== "string")
      return v;
    const [a, b, c, alpha2] = v.match(floatRegex);
    return {
      [aName]: parseFloat(a),
      [bName]: parseFloat(b),
      [cName]: parseFloat(c),
      alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
    };
  };
  const clampRgbUnit = (v) => clamp(0, 255, v);
  const rgbUnit = {
    ...number,
    transform: (v) => Math.round(clampRgbUnit(v))
  };
  const rgba = {
    test: /* @__PURE__ */ isColorString("rgb", "red"),
    parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
  };
  function parseHex(v) {
    let r2 = "";
    let g = "";
    let b = "";
    let a = "";
    if (v.length > 5) {
      r2 = v.substring(1, 3);
      g = v.substring(3, 5);
      b = v.substring(5, 7);
      a = v.substring(7, 9);
    } else {
      r2 = v.substring(1, 2);
      g = v.substring(2, 3);
      b = v.substring(3, 4);
      a = v.substring(4, 5);
      r2 += r2;
      g += g;
      b += b;
      a += a;
    }
    return {
      red: parseInt(r2, 16),
      green: parseInt(g, 16),
      blue: parseInt(b, 16),
      alpha: a ? parseInt(a, 16) / 255 : 1
    };
  }
  const hex = {
    test: /* @__PURE__ */ isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
  };
  const createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
    test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
    parse: parseFloat,
    transform: (v) => `${v}${unit}`
  });
  const degrees = /* @__PURE__ */ createUnitType("deg");
  const percent = /* @__PURE__ */ createUnitType("%");
  const px = /* @__PURE__ */ createUnitType("px");
  const vh = /* @__PURE__ */ createUnitType("vh");
  const vw = /* @__PURE__ */ createUnitType("vw");
  const progressPercentage = /* @__PURE__ */ (() => ({
    ...percent,
    parse: (v) => percent.parse(v) / 100,
    transform: (v) => percent.transform(v * 100)
  }))();
  const hsla = {
    test: /* @__PURE__ */ isColorString("hsl", "hue"),
    parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
    }
  };
  const color = {
    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
    parse: (v) => {
      if (rgba.test(v)) {
        return rgba.parse(v);
      } else if (hsla.test(v)) {
        return hsla.parse(v);
      } else {
        return hex.parse(v);
      }
    },
    transform: (v) => {
      return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
    },
    getAnimatableNone: (v) => {
      const parsed = color.parse(v);
      parsed.alpha = 0;
      return color.transform(parsed);
    }
  };
  const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
  function test(v) {
    var _a2, _b2;
    return isNaN(v) && typeof v === "string" && (((_a2 = v.match(floatRegex)) == null ? void 0 : _a2.length) || 0) + (((_b2 = v.match(colorRegex)) == null ? void 0 : _b2.length) || 0) > 0;
  }
  const NUMBER_TOKEN = "number";
  const COLOR_TOKEN = "color";
  const VAR_TOKEN = "var";
  const VAR_FUNCTION_TOKEN = "var(";
  const SPLIT_TOKEN = "${}";
  const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function analyseComplexValue(value) {
    const originalValue = value.toString();
    const values = [];
    const indexes = {
      color: [],
      number: [],
      var: []
    };
    const types2 = [];
    let i = 0;
    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
      if (color.test(parsedValue)) {
        indexes.color.push(i);
        types2.push(COLOR_TOKEN);
        values.push(color.parse(parsedValue));
      } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
        indexes.var.push(i);
        types2.push(VAR_TOKEN);
        values.push(parsedValue);
      } else {
        indexes.number.push(i);
        types2.push(NUMBER_TOKEN);
        values.push(parseFloat(parsedValue));
      }
      ++i;
      return SPLIT_TOKEN;
    });
    const split = tokenised.split(SPLIT_TOKEN);
    return { values, split, indexes, types: types2 };
  }
  function parseComplexValue(v) {
    return analyseComplexValue(v).values;
  }
  function createTransformer(source) {
    const { split, types: types2 } = analyseComplexValue(source);
    const numSections = split.length;
    return (v) => {
      let output = "";
      for (let i = 0; i < numSections; i++) {
        output += split[i];
        if (v[i] !== void 0) {
          const type = types2[i];
          if (type === NUMBER_TOKEN) {
            output += sanitize(v[i]);
          } else if (type === COLOR_TOKEN) {
            output += color.transform(v[i]);
          } else {
            output += v[i];
          }
        }
      }
      return output;
    };
  }
  const convertNumbersToZero = (v) => typeof v === "number" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;
  function getAnimatableNone$1(v) {
    const parsed = parseComplexValue(v);
    const transformer = createTransformer(v);
    return transformer(parsed.map(convertNumbersToZero));
  }
  const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1
  };
  function hueToRgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
      red = green = blue = lightness;
    } else {
      const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
      const p = 2 * lightness - q;
      red = hueToRgb(p, q, hue + 1 / 3);
      green = hueToRgb(p, q, hue);
      blue = hueToRgb(p, q, hue - 1 / 3);
    }
    return {
      red: Math.round(red * 255),
      green: Math.round(green * 255),
      blue: Math.round(blue * 255),
      alpha: alpha2
    };
  }
  function mixImmediate(a, b) {
    return (p) => p > 0 ? b : a;
  }
  const mixNumber$1 = (from, to, progress2) => {
    return from + (to - from) * progress2;
  };
  const mixLinearColor = (from, to, v) => {
    const fromExpo = from * from;
    const expo = v * (to * to - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
  };
  const colorTypes = [hex, rgba, hsla];
  const getColorType = (v) => colorTypes.find((type) => type.test(v));
  function asRGBA(color2) {
    const type = getColorType(color2);
    if (!Boolean(type))
      return false;
    let model = type.parse(color2);
    if (type === hsla) {
      model = hslaToRgba(model);
    }
    return model;
  }
  const mixColor = (from, to) => {
    const fromRGBA = asRGBA(from);
    const toRGBA = asRGBA(to);
    if (!fromRGBA || !toRGBA) {
      return mixImmediate(from, to);
    }
    const blended = { ...fromRGBA };
    return (v) => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
      blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
      return rgba.transform(blended);
    };
  };
  const invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
  function mixVisibility(origin2, target) {
    if (invisibleValues.has(origin2)) {
      return (p) => p <= 0 ? origin2 : target;
    } else {
      return (p) => p >= 1 ? target : origin2;
    }
  }
  function mixNumber(a, b) {
    return (p) => mixNumber$1(a, b, p);
  }
  function getMixer(a) {
    if (typeof a === "number") {
      return mixNumber;
    } else if (typeof a === "string") {
      return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
    } else if (Array.isArray(a)) {
      return mixArray;
    } else if (typeof a === "object") {
      return color.test(a) ? mixColor : mixObject;
    }
    return mixImmediate;
  }
  function mixArray(a, b) {
    const output = [...a];
    const numValues = output.length;
    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
    return (p) => {
      for (let i = 0; i < numValues; i++) {
        output[i] = blendValue[i](p);
      }
      return output;
    };
  }
  function mixObject(a, b) {
    const output = { ...a, ...b };
    const blendValue = {};
    for (const key in output) {
      if (a[key] !== void 0 && b[key] !== void 0) {
        blendValue[key] = getMixer(a[key])(a[key], b[key]);
      }
    }
    return (v) => {
      for (const key in blendValue) {
        output[key] = blendValue[key](v);
      }
      return output;
    };
  }
  function matchOrder(origin2, target) {
    const orderedOrigin = [];
    const pointers = { color: 0, var: 0, number: 0 };
    for (let i = 0; i < target.values.length; i++) {
      const type = target.types[i];
      const originIndex = origin2.indexes[type][pointers[type]];
      const originValue = origin2.values[originIndex] ?? 0;
      orderedOrigin[i] = originValue;
      pointers[type]++;
    }
    return orderedOrigin;
  }
  const mixComplex = (origin2, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin2);
    const targetStats = analyseComplexValue(target);
    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
      if (invisibleValues.has(origin2) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
        return mixVisibility(origin2, target);
      }
      return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    } else {
      return mixImmediate(origin2, target);
    }
  };
  function mix(from, to, p) {
    if (typeof from === "number" && typeof to === "number" && typeof p === "number") {
      return mixNumber$1(from, to, p);
    }
    const mixer = getMixer(from);
    return mixer(from, to);
  }
  const frameloopDriver = (update) => {
    const passTimestamp = ({ timestamp }) => update(timestamp);
    return {
      start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
      stop: () => cancelFrame(passTimestamp),
      /**
       * If we're processing this frame we can use the
       * framelocked timestamp to keep things in sync.
       */
      now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    };
  };
  const generateLinearEasing = (easing, duration, resolution = 10) => {
    let points = "";
    const numPoints = Math.max(Math.round(duration / resolution), 2);
    for (let i = 0; i < numPoints; i++) {
      points += Math.round(easing(i / (numPoints - 1)) * 1e4) / 1e4 + ", ";
    }
    return `linear(${points.substring(0, points.length - 2)})`;
  };
  const maxGeneratorDuration = 2e4;
  function calcGeneratorDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state = generator.next(duration);
    while (!state.done && duration < maxGeneratorDuration) {
      duration += timeStep;
      state = generator.next(duration);
    }
    return duration >= maxGeneratorDuration ? Infinity : duration;
  }
  function createGeneratorEasing(options2, scale2 = 100, createGenerator) {
    const generator = createGenerator({ ...options2, keyframes: [0, scale2] });
    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
    return {
      type: "keyframes",
      ease: (progress2) => {
        return generator.next(duration * progress2).value / scale2;
      },
      duration: /* @__PURE__ */ millisecondsToSeconds(duration)
    };
  }
  const velocitySampleDuration = 5;
  function calcGeneratorVelocity(resolveValue, t, current) {
    const prevT = Math.max(t - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t - prevT);
  }
  const springDefaults = {
    // Default spring physics
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    // Default duration/bounce-based options
    duration: 800,
    // in ms
    bounce: 0.3,
    visualDuration: 0.3,
    // in seconds
    // Rest thresholds
    restSpeed: {
      granular: 0.01,
      default: 2
    },
    restDelta: {
      granular: 5e-3,
      default: 0.5
    },
    // Limits
    minDuration: 0.01,
    // in seconds
    maxDuration: 10,
    // in seconds
    minDamping: 0.05,
    maxDamping: 1
  };
  const safeMin = 1e-3;
  function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
    let envelope;
    let derivative;
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(duration));
    if (dampingRatio < 1) {
      envelope = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const a = exponentialDecay - velocity;
        const b = calcAngularFreq(undampedFreq2, dampingRatio);
        const c = Math.exp(-delta);
        return safeMin - a / b * c;
      };
      derivative = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const d = delta * velocity + velocity;
        const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
        const f = Math.exp(-delta);
        const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
        const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
        return factor * ((d - e) * f) / g;
      };
    } else {
      envelope = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b = (undampedFreq2 - velocity) * duration + 1;
        return -safeMin + a * b;
      };
      derivative = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b = (velocity - undampedFreq2) * (duration * duration);
        return a * b;
      };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = /* @__PURE__ */ secondsToMilliseconds(duration);
    if (isNaN(undampedFreq)) {
      return {
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        duration
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration
      };
    }
  }
  const rootIterations = 12;
  function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i = 1; i < rootIterations; i++) {
      result = result - envelope(result) / derivative(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  }
  const durationKeys = ["duration", "bounce"];
  const physicsKeys = ["stiffness", "damping", "mass"];
  function isSpringType(options2, keys2) {
    return keys2.some((key) => options2[key] !== void 0);
  }
  function getSpringOptions(options2) {
    let springOptions = {
      velocity: springDefaults.velocity,
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      mass: springDefaults.mass,
      isResolvedFromDuration: false,
      ...options2
    };
    if (!isSpringType(options2, physicsKeys) && isSpringType(options2, durationKeys)) {
      if (options2.visualDuration) {
        const visualDuration = options2.visualDuration;
        const root2 = 2 * Math.PI / (visualDuration * 1.2);
        const stiffness = root2 * root2;
        const damping = 2 * clamp(0.05, 1, 1 - (options2.bounce || 0)) * Math.sqrt(stiffness);
        springOptions = {
          ...springOptions,
          mass: springDefaults.mass,
          stiffness,
          damping
        };
      } else {
        const derived = findSpring(options2);
        springOptions = {
          ...springOptions,
          ...derived,
          mass: springDefaults.mass
        };
        springOptions.isResolvedFromDuration = true;
      }
    }
    return springOptions;
  }
  function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
    const options2 = typeof optionsOrVisualDuration !== "object" ? {
      visualDuration: optionsOrVisualDuration,
      keyframes: [0, 1],
      bounce
    } : optionsOrVisualDuration;
    let { restSpeed, restDelta } = options2;
    const origin2 = options2.keyframes[0];
    const target = options2.keyframes[options2.keyframes.length - 1];
    const state = { done: false, value: origin2 };
    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
      ...options2,
      velocity: -/* @__PURE__ */ millisecondsToSeconds(options2.velocity || 0)
    });
    const initialVelocity = velocity || 0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin2;
    const undampedAngularFreq = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(stiffness / mass));
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
    restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
    let resolveSpring;
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        const freqForT = Math.min(dampedAngularFreq * t, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
    const generator = {
      calculatedDuration: isResolvedFromDuration ? duration || null : null,
      next: (t) => {
        const current = resolveSpring(t);
        if (!isResolvedFromDuration) {
          let currentVelocity = t === 0 ? initialVelocity : 0;
          if (dampingRatio < 1) {
            currentVelocity = t === 0 ? /* @__PURE__ */ secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
          }
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
          state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state.done = t >= duration;
        }
        state.value = state.done ? target : current;
        return state;
      },
      toString: () => {
        const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
        const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
        return calculatedDuration + "ms " + easing;
      },
      toTransition: () => {
      }
    };
    return generator;
  }
  spring.applyToOptions = (options2) => {
    const generatorOptions = createGeneratorEasing(options2, 100, spring);
    options2.ease = generatorOptions.ease;
    options2.duration = /* @__PURE__ */ secondsToMilliseconds(generatorOptions.duration);
    options2.type = "keyframes";
    return options2;
  };
  function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
    const origin2 = keyframes2[0];
    const state = {
      done: false,
      value: origin2
    };
    const isOutOfBounds = (v) => min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2;
    const nearestBoundary = (v) => {
      if (min2 === void 0)
        return max2;
      if (max2 === void 0)
        return min2;
      return Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
    };
    let amplitude = power * velocity;
    const ideal = origin2 + amplitude;
    const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
    if (target !== ideal)
      amplitude = target - origin2;
    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
    const calcLatest = (t) => target + calcDelta(t);
    const applyFriction = (t) => {
      const delta = calcDelta(t);
      const latest = calcLatest(t);
      state.done = Math.abs(delta) <= restDelta;
      state.value = state.done ? target : latest;
    };
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t) => {
      if (!isOutOfBounds(state.value))
        return;
      timeReachedBoundary = t;
      spring$1 = spring({
        keyframes: [state.value, nearestBoundary(state.value)],
        velocity: calcGeneratorVelocity(calcLatest, t, state.value),
        // TODO: This should be passing * 1000
        damping: bounceDamping,
        stiffness: bounceStiffness,
        restDelta,
        restSpeed
      });
    };
    checkCatchBoundary(0);
    return {
      calculatedDuration: null,
      next: (t) => {
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === void 0) {
          hasUpdatedFrame = true;
          applyFriction(t);
          checkCatchBoundary(t);
        }
        if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
          return spring$1.next(t - timeReachedBoundary);
        } else {
          !hasUpdatedFrame && applyFriction(t);
          return state;
        }
      }
    };
  }
  function createMixers(output, ease2, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
    const numMixers = output.length - 1;
    for (let i = 0; i < numMixers; i++) {
      let mixer = mixerFactory(output[i], output[i + 1]);
      if (ease2) {
        const easingFunction = Array.isArray(ease2) ? ease2[i] || noop$2 : ease2;
        mixer = pipe(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
    const inputLength = input.length;
    invariant(inputLength === output.length);
    if (inputLength === 1)
      return () => output[0];
    if (inputLength === 2 && output[0] === output[1])
      return () => output[1];
    const isZeroDeltaRange = input[0] === input[1];
    if (input[0] > input[inputLength - 1]) {
      input = [...input].reverse();
      output = [...output].reverse();
    }
    const mixers = createMixers(output, ease2, mixer);
    const numMixers = mixers.length;
    const interpolator = (v) => {
      if (isZeroDeltaRange && v < input[0])
        return output[0];
      let i = 0;
      if (numMixers > 1) {
        for (; i < input.length - 2; i++) {
          if (v < input[i + 1])
            break;
        }
      }
      const progressInRange = /* @__PURE__ */ progress(input[i], input[i + 1], v);
      return mixers[i](progressInRange);
    };
    return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
  }
  function fillOffset(offset2, remaining) {
    const min2 = offset2[offset2.length - 1];
    for (let i = 1; i <= remaining; i++) {
      const offsetProgress = /* @__PURE__ */ progress(0, remaining, i);
      offset2.push(mixNumber$1(min2, 1, offsetProgress));
    }
  }
  function defaultOffset(arr) {
    const offset2 = [0];
    fillOffset(offset2, arr.length - 1);
    return offset2;
  }
  function convertOffsetToTimes(offset2, duration) {
    return offset2.map((o) => o * duration);
  }
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
    const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
    const state = {
      done: false,
      value: keyframeValues[0]
    };
    const absoluteTimes = convertOffsetToTimes(
      // Only use the provided offsets if they're the correct length
      // TODO Maybe we should warn here if there's a length mismatch
      times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
      duration
    );
    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
    return {
      calculatedDuration: duration,
      next: (t) => {
        state.value = mapTimeToKeyframe(t);
        state.done = t >= duration;
        return state;
      }
    };
  }
  const isNotNull$1 = (value) => value !== null;
  function getFinalKeyframe$1(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
    const resolvedKeyframes = keyframes2.filter(isNotNull$1);
    const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
    const index2 = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
    return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
  }
  const transitionTypeMap = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
  };
  function replaceTransitionType(transition) {
    if (typeof transition.type === "string") {
      transition.type = transitionTypeMap[transition.type];
    }
  }
  class WithPromise {
    constructor() {
      this.updateFinished();
    }
    get finished() {
      return this._finished;
    }
    updateFinished() {
      this._finished = new Promise((resolve) => {
        this.resolve = resolve;
      });
    }
    notifyFinished() {
      this.resolve();
    }
    /**
     * Allows the animation to be awaited.
     *
     * @deprecated Use `finished` instead.
     */
    then(onResolve, onReject) {
      return this.finished.then(onResolve, onReject);
    }
  }
  const percentToProgress = (percent2) => percent2 / 100;
  class JSAnimation extends WithPromise {
    constructor(options2) {
      super();
      this.state = "idle";
      this.startTime = null;
      this.isStopped = false;
      this.currentTime = 0;
      this.holdTime = null;
      this.playbackSpeed = 1;
      this.stop = () => {
        var _a2, _b2;
        const { motionValue: motionValue2 } = this.options;
        if (motionValue2 && motionValue2.updatedAt !== time.now()) {
          this.tick(time.now());
        }
        this.isStopped = true;
        if (this.state === "idle")
          return;
        this.teardown();
        (_b2 = (_a2 = this.options).onStop) == null ? void 0 : _b2.call(_a2);
      };
      this.options = options2;
      this.initAnimation();
      this.play();
      if (options2.autoplay === false)
        this.pause();
    }
    initAnimation() {
      const { options: options2 } = this;
      replaceTransitionType(options2);
      const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options2;
      let { keyframes: keyframes$1 } = options2;
      const generatorFactory = type || keyframes;
      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
        this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
        keyframes$1 = [0, 100];
      }
      const generator = generatorFactory({ ...options2, keyframes: keyframes$1 });
      if (repeatType === "mirror") {
        this.mirroredGenerator = generatorFactory({
          ...options2,
          keyframes: [...keyframes$1].reverse(),
          velocity: -velocity
        });
      }
      if (generator.calculatedDuration === null) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      this.calculatedDuration = calculatedDuration;
      this.resolvedDuration = calculatedDuration + repeatDelay;
      this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
      this.generator = generator;
    }
    updateTime(timestamp) {
      const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
      if (this.holdTime !== null) {
        this.currentTime = this.holdTime;
      } else {
        this.currentTime = animationTime;
      }
    }
    tick(timestamp, sample = false) {
      const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
      if (this.startTime === null)
        return generator.next(0);
      const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
      if (this.speed > 0) {
        this.startTime = Math.min(this.startTime, timestamp);
      } else if (this.speed < 0) {
        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
      }
      if (sample) {
        this.currentTime = timestamp;
      } else {
        this.updateTime(timestamp);
      }
      const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
      const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
      this.currentTime = Math.max(timeWithoutDelay, 0);
      if (this.state === "finished" && this.holdTime === null) {
        this.currentTime = totalDuration;
      }
      let elapsed = this.currentTime;
      let frameGenerator = generator;
      if (repeat) {
        const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
        let currentIteration = Math.floor(progress2);
        let iterationProgress = progress2 % 1;
        if (!iterationProgress && progress2 >= 1) {
          iterationProgress = 1;
        }
        iterationProgress === 1 && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        const isOddIteration = Boolean(currentIteration % 2);
        if (isOddIteration) {
          if (repeatType === "reverse") {
            iterationProgress = 1 - iterationProgress;
            if (repeatDelay) {
              iterationProgress -= repeatDelay / resolvedDuration;
            }
          } else if (repeatType === "mirror") {
            frameGenerator = mirroredGenerator;
          }
        }
        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
      }
      const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
      if (mixKeyframes) {
        state.value = mixKeyframes(state.value);
      }
      let { done } = state;
      if (!isInDelayPhase && calculatedDuration !== null) {
        done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
      }
      const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
      if (isAnimationFinished && type !== inertia) {
        state.value = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
      }
      if (onUpdate) {
        onUpdate(state.value);
      }
      if (isAnimationFinished) {
        this.finish();
      }
      return state;
    }
    /**
     * Allows the returned animation to be awaited or promise-chained. Currently
     * resolves when the animation finishes at all but in a future update could/should
     * reject if its cancels.
     */
    then(resolve, reject) {
      return this.finished.then(resolve, reject);
    }
    get duration() {
      return /* @__PURE__ */ millisecondsToSeconds(this.calculatedDuration);
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + /* @__PURE__ */ millisecondsToSeconds(delay2);
    }
    get time() {
      return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
    }
    set time(newTime) {
      var _a2;
      newTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
      this.currentTime = newTime;
      if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
        this.holdTime = newTime;
      } else if (this.driver) {
        this.startTime = this.driver.now() - newTime / this.playbackSpeed;
      }
      (_a2 = this.driver) == null ? void 0 : _a2.start(false);
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(newSpeed) {
      this.updateTime(time.now());
      const hasChanged = this.playbackSpeed !== newSpeed;
      this.playbackSpeed = newSpeed;
      if (hasChanged) {
        this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
      }
    }
    play() {
      var _a2, _b2;
      if (this.isStopped)
        return;
      const { driver = frameloopDriver, startTime } = this.options;
      if (!this.driver) {
        this.driver = driver((timestamp) => this.tick(timestamp));
      }
      (_b2 = (_a2 = this.options).onPlay) == null ? void 0 : _b2.call(_a2);
      const now2 = this.driver.now();
      if (this.state === "finished") {
        this.updateFinished();
        this.startTime = now2;
      } else if (this.holdTime !== null) {
        this.startTime = now2 - this.holdTime;
      } else if (!this.startTime) {
        this.startTime = startTime ?? now2;
      }
      if (this.state === "finished" && this.speed < 0) {
        this.startTime += this.calculatedDuration;
      }
      this.holdTime = null;
      this.state = "running";
      this.driver.start();
    }
    pause() {
      this.state = "paused";
      this.updateTime(time.now());
      this.holdTime = this.currentTime;
    }
    complete() {
      if (this.state !== "running") {
        this.play();
      }
      this.state = "finished";
      this.holdTime = null;
    }
    finish() {
      var _a2, _b2;
      this.notifyFinished();
      this.teardown();
      this.state = "finished";
      (_b2 = (_a2 = this.options).onComplete) == null ? void 0 : _b2.call(_a2);
    }
    cancel() {
      var _a2, _b2;
      this.holdTime = null;
      this.startTime = 0;
      this.tick(0);
      this.teardown();
      (_b2 = (_a2 = this.options).onCancel) == null ? void 0 : _b2.call(_a2);
    }
    teardown() {
      this.state = "idle";
      this.stopDriver();
      this.startTime = this.holdTime = null;
    }
    stopDriver() {
      if (!this.driver)
        return;
      this.driver.stop();
      this.driver = void 0;
    }
    sample(sampleTime) {
      this.startTime = 0;
      return this.tick(sampleTime, true);
    }
    attachTimeline(timeline) {
      var _a2;
      if (this.options.allowFlatten) {
        this.options.type = "keyframes";
        this.options.ease = "linear";
        this.initAnimation();
      }
      (_a2 = this.driver) == null ? void 0 : _a2.stop();
      return timeline.observe(this);
    }
  }
  function fillWildcards(keyframes2) {
    for (let i = 1; i < keyframes2.length; i++) {
      keyframes2[i] ?? (keyframes2[i] = keyframes2[i - 1]);
    }
  }
  const radToDeg = (rad) => rad * 180 / Math.PI;
  const rotate = (v) => {
    const angle = radToDeg(Math.atan2(v[1], v[0]));
    return rebaseAngle(angle);
  };
  const matrix2dParsers = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
    rotate,
    rotateZ: rotate,
    skewX: (v) => radToDeg(Math.atan(v[1])),
    skewY: (v) => radToDeg(Math.atan(v[2])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2
  };
  const rebaseAngle = (angle) => {
    angle = angle % 360;
    if (angle < 0)
      angle += 360;
    return angle;
  };
  const rotateZ = rotate;
  const scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  const scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
  const matrix3dParsers = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX,
    scaleY,
    scale: (v) => (scaleX(v) + scaleY(v)) / 2,
    rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
    rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
    rotateZ,
    rotate: rotateZ,
    skewX: (v) => radToDeg(Math.atan(v[4])),
    skewY: (v) => radToDeg(Math.atan(v[1])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2
  };
  function defaultTransformValue(name2) {
    return name2.includes("scale") ? 1 : 0;
  }
  function parseValueFromTransform(transform, name2) {
    if (!transform || transform === "none") {
      return defaultTransformValue(name2);
    }
    const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let parsers;
    let match;
    if (matrix3dMatch) {
      parsers = matrix3dParsers;
      match = matrix3dMatch;
    } else {
      const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      parsers = matrix2dParsers;
      match = matrix2dMatch;
    }
    if (!match) {
      return defaultTransformValue(name2);
    }
    const valueParser = parsers[name2];
    const values = match[1].split(",").map(convertTransformToNumber);
    return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
  }
  const readTransformValue = (instance, name2) => {
    const { transform = "none" } = getComputedStyle(instance);
    return parseValueFromTransform(transform, name2);
  };
  function convertTransformToNumber(value) {
    return parseFloat(value.trim());
  }
  const transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ];
  const transformProps = /* @__PURE__ */ (() => new Set(transformPropOrder))();
  const isNumOrPxType = (v) => v === number || v === px;
  const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
  const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (value !== void 0) {
        removedTransforms.push([key, value.get()]);
        value.set(key.startsWith("scale") ? 1 : 0);
      }
    });
    return removedTransforms;
  }
  const positionalValues = {
    // Dimensions
    width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top }) => parseFloat(top),
    left: (_bbox, { left }) => parseFloat(left),
    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
    // Transform
    x: (_bbox, { transform }) => parseValueFromTransform(transform, "x"),
    y: (_bbox, { transform }) => parseValueFromTransform(transform, "y")
  };
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y;
  const toResolve = /* @__PURE__ */ new Set();
  let isScheduled = false;
  let anyNeedsMeasurement = false;
  let isForced = false;
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const resolversToMeasure = Array.from(toResolve).filter((resolver2) => resolver2.needsMeasurement);
      const elementsToMeasure = new Set(resolversToMeasure.map((resolver2) => resolver2.element));
      const transformsToRestore = /* @__PURE__ */ new Map();
      elementsToMeasure.forEach((element2) => {
        const removedTransforms = removeNonTranslationalTransform(element2);
        if (!removedTransforms.length)
          return;
        transformsToRestore.set(element2, removedTransforms);
        element2.render();
      });
      resolversToMeasure.forEach((resolver2) => resolver2.measureInitialState());
      elementsToMeasure.forEach((element2) => {
        element2.render();
        const restore = transformsToRestore.get(element2);
        if (restore) {
          restore.forEach(([key, value]) => {
            var _a2;
            (_a2 = element2.getValue(key)) == null ? void 0 : _a2.set(value);
          });
        }
      });
      resolversToMeasure.forEach((resolver2) => resolver2.measureEndState());
      resolversToMeasure.forEach((resolver2) => {
        if (resolver2.suspendedScrollY !== void 0) {
          window.scrollTo(0, resolver2.suspendedScrollY);
        }
      });
    }
    anyNeedsMeasurement = false;
    isScheduled = false;
    toResolve.forEach((resolver2) => resolver2.complete(isForced));
    toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach((resolver2) => {
      resolver2.readKeyframes();
      if (resolver2.needsMeasurement) {
        anyNeedsMeasurement = true;
      }
    });
  }
  function flushKeyframeResolvers() {
    isForced = true;
    readAllKeyframes();
    measureAllKeyframes();
    isForced = false;
  }
  class KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name2, motionValue2, element2, isAsync = false) {
      this.state = "pending";
      this.isAsync = false;
      this.needsMeasurement = false;
      this.unresolvedKeyframes = [...unresolvedKeyframes];
      this.onComplete = onComplete;
      this.name = name2;
      this.motionValue = motionValue2;
      this.element = element2;
      this.isAsync = isAsync;
    }
    scheduleResolve() {
      this.state = "scheduled";
      if (this.isAsync) {
        toResolve.add(this);
        if (!isScheduled) {
          isScheduled = true;
          frame.read(readAllKeyframes);
          frame.resolveKeyframes(measureAllKeyframes);
        }
      } else {
        this.readKeyframes();
        this.complete();
      }
    }
    readKeyframes() {
      const { unresolvedKeyframes, name: name2, element: element2, motionValue: motionValue2 } = this;
      if (unresolvedKeyframes[0] === null) {
        const currentValue = motionValue2 == null ? void 0 : motionValue2.get();
        const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        if (currentValue !== void 0) {
          unresolvedKeyframes[0] = currentValue;
        } else if (element2 && name2) {
          const valueAsRead = element2.readValue(name2, finalKeyframe);
          if (valueAsRead !== void 0 && valueAsRead !== null) {
            unresolvedKeyframes[0] = valueAsRead;
          }
        }
        if (unresolvedKeyframes[0] === void 0) {
          unresolvedKeyframes[0] = finalKeyframe;
        }
        if (motionValue2 && currentValue === void 0) {
          motionValue2.set(unresolvedKeyframes[0]);
        }
      }
      fillWildcards(unresolvedKeyframes);
    }
    setFinalKeyframe() {
    }
    measureInitialState() {
    }
    renderEndStyles() {
    }
    measureEndState() {
    }
    complete(isForcedComplete = false) {
      this.state = "complete";
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
      toResolve.delete(this);
    }
    cancel() {
      if (this.state === "scheduled") {
        toResolve.delete(this);
        this.state = "pending";
      }
    }
    resume() {
      if (this.state === "pending")
        this.scheduleResolve();
    }
  }
  const isCSSVar = (name2) => name2.startsWith("--");
  function setStyle(element2, name2, value) {
    isCSSVar(name2) ? element2.style.setProperty(name2, value) : element2.style[name2] = value;
  }
  const supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== void 0);
  const supportsFlags = {};
  function memoSupports(callback, supportsFlag) {
    const memoized = /* @__PURE__ */ memo(callback);
    return () => supportsFlags[supportsFlag] ?? memoized();
  }
  const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
    try {
      document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch (e) {
      return false;
    }
    return true;
  }, "linearEasing");
  const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
  const supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
  };
  function mapEasingToNativeEasing(easing, duration) {
    if (!easing) {
      return void 0;
    } else if (typeof easing === "function") {
      return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out";
    } else if (isBezierDefinition(easing)) {
      return cubicBezierAsString(easing);
    } else if (Array.isArray(easing)) {
      return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
    } else {
      return supportedWaapiEasing[easing];
    }
  }
  function startWaapiAnimation(element2, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
    const keyframeOptions = {
      [valueName]: keyframes2
    };
    if (times)
      keyframeOptions.offset = times;
    const easing = mapEasingToNativeEasing(ease2, duration);
    if (Array.isArray(easing))
      keyframeOptions.easing = easing;
    const options2 = {
      delay: delay2,
      duration,
      easing: !Array.isArray(easing) ? easing : "linear",
      fill: "both",
      iterations: repeat + 1,
      direction: repeatType === "reverse" ? "alternate" : "normal"
    };
    if (pseudoElement)
      options2.pseudoElement = pseudoElement;
    const animation = element2.animate(keyframeOptions, options2);
    return animation;
  }
  function isGenerator(type) {
    return typeof type === "function" && "applyToOptions" in type;
  }
  function applyGeneratorOptions({ type, ...options2 }) {
    if (isGenerator(type) && supportsLinearEasing()) {
      return type.applyToOptions(options2);
    } else {
      options2.duration ?? (options2.duration = 300);
      options2.ease ?? (options2.ease = "easeOut");
    }
    return options2;
  }
  class NativeAnimation extends WithPromise {
    constructor(options2) {
      super();
      this.finishedTime = null;
      this.isStopped = false;
      if (!options2)
        return;
      const { element: element2, name: name2, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options2;
      this.isPseudoElement = Boolean(pseudoElement);
      this.allowFlatten = allowFlatten;
      this.options = options2;
      invariant(typeof options2.type !== "string");
      const transition = applyGeneratorOptions(options2);
      this.animation = startWaapiAnimation(element2, name2, keyframes2, transition, pseudoElement);
      if (transition.autoplay === false) {
        this.animation.pause();
      }
      this.animation.onfinish = () => {
        this.finishedTime = this.time;
        if (!pseudoElement) {
          const keyframe = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
          if (this.updateMotionValue) {
            this.updateMotionValue(keyframe);
          } else {
            setStyle(element2, name2, keyframe);
          }
          this.animation.cancel();
        }
        onComplete == null ? void 0 : onComplete();
        this.notifyFinished();
      };
    }
    play() {
      if (this.isStopped)
        return;
      this.animation.play();
      if (this.state === "finished") {
        this.updateFinished();
      }
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      var _a2, _b2;
      (_b2 = (_a2 = this.animation).finish) == null ? void 0 : _b2.call(_a2);
    }
    cancel() {
      try {
        this.animation.cancel();
      } catch (e) {
      }
    }
    stop() {
      if (this.isStopped)
        return;
      this.isStopped = true;
      const { state } = this;
      if (state === "idle" || state === "finished") {
        return;
      }
      if (this.updateMotionValue) {
        this.updateMotionValue();
      } else {
        this.commitStyles();
      }
      if (!this.isPseudoElement)
        this.cancel();
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * In this method, we commit styles back to the DOM before cancelling
     * the animation.
     *
     * This is designed to be overridden by NativeAnimationExtended, which
     * will create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to also correctly calculate velocity for any subsequent animation
     * while deferring the commit until the next animation frame.
     */
    commitStyles() {
      var _a2, _b2;
      if (!this.isPseudoElement) {
        (_b2 = (_a2 = this.animation).commitStyles) == null ? void 0 : _b2.call(_a2);
      }
    }
    get duration() {
      var _a2, _b2;
      const duration = ((_b2 = (_a2 = this.animation.effect) == null ? void 0 : _a2.getComputedTiming) == null ? void 0 : _b2.call(_a2).duration) || 0;
      return /* @__PURE__ */ millisecondsToSeconds(Number(duration));
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + /* @__PURE__ */ millisecondsToSeconds(delay2);
    }
    get time() {
      return /* @__PURE__ */ millisecondsToSeconds(Number(this.animation.currentTime) || 0);
    }
    set time(newTime) {
      this.finishedTime = null;
      this.animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
    }
    /**
     * The playback speed of the animation.
     * 1 = normal speed, 2 = double speed, 0.5 = half speed.
     */
    get speed() {
      return this.animation.playbackRate;
    }
    set speed(newSpeed) {
      if (newSpeed < 0)
        this.finishedTime = null;
      this.animation.playbackRate = newSpeed;
    }
    get state() {
      return this.finishedTime !== null ? "finished" : this.animation.playState;
    }
    get startTime() {
      return Number(this.animation.startTime);
    }
    set startTime(newStartTime) {
      this.animation.startTime = newStartTime;
    }
    /**
     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
     */
    attachTimeline({ timeline, observe }) {
      var _a2;
      if (this.allowFlatten) {
        (_a2 = this.animation.effect) == null ? void 0 : _a2.updateTiming({ easing: "linear" });
      }
      this.animation.onfinish = null;
      if (timeline && supportsScrollTimeline()) {
        this.animation.timeline = timeline;
        return noop$2;
      } else {
        return observe(this);
      }
    }
  }
  const unsupportedEasingFunctions = {
    anticipate,
    backInOut,
    circInOut
  };
  function isUnsupportedEase(key) {
    return key in unsupportedEasingFunctions;
  }
  function replaceStringEasing(transition) {
    if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
      transition.ease = unsupportedEasingFunctions[transition.ease];
    }
  }
  const sampleDelta = 10;
  class NativeAnimationExtended extends NativeAnimation {
    constructor(options2) {
      replaceStringEasing(options2);
      replaceTransitionType(options2);
      super(options2);
      if (options2.startTime) {
        this.startTime = options2.startTime;
      }
      this.options = options2;
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * Rather than read commited styles back out of the DOM, we can
     * create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to calculate velocity for any subsequent animation.
     */
    updateMotionValue(value) {
      const { motionValue: motionValue2, onUpdate, onComplete, element: element2, ...options2 } = this.options;
      if (!motionValue2)
        return;
      if (value !== void 0) {
        motionValue2.set(value);
        return;
      }
      const sampleAnimation = new JSAnimation({
        ...options2,
        autoplay: false
      });
      const sampleTime = /* @__PURE__ */ secondsToMilliseconds(this.finishedTime ?? this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
      sampleAnimation.stop();
    }
  }
  const isAnimatable = (value, name2) => {
    if (name2 === "zIndex")
      return false;
    if (typeof value === "number" || Array.isArray(value))
      return true;
    if (typeof value === "string" && // It's animatable if we have a string
    (complex.test(value) || value === "0") && // And it contains numbers and/or colors
    !value.startsWith("url(")) {
      return true;
    }
    return false;
  };
  function hasKeyframesChanged(keyframes2) {
    const current = keyframes2[0];
    if (keyframes2.length === 1)
      return true;
    for (let i = 0; i < keyframes2.length; i++) {
      if (keyframes2[i] !== current)
        return true;
    }
  }
  function canAnimate(keyframes2, name2, type, velocity) {
    const originKeyframe = keyframes2[0];
    if (originKeyframe === null)
      return false;
    if (name2 === "display" || name2 === "visibility")
      return true;
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(originKeyframe, name2);
    const isTargetAnimatable = isAnimatable(targetKeyframe, name2);
    if (!isOriginAnimatable || !isTargetAnimatable) {
      return false;
    }
    return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
  }
  function makeAnimationInstant(options2) {
    options2.duration = 0;
    options2.type = "keyframes";
  }
  const acceleratedValues = /* @__PURE__ */ new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"
    // TODO: Could be re-enabled now we have support for linear() easing
    // "background-color"
  ]);
  const supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
  function supportsBrowserAnimation(options2) {
    var _a2;
    const { motionValue: motionValue2, name: name2, repeatDelay, repeatType, damping, type } = options2;
    const subject = (_a2 = motionValue2 == null ? void 0 : motionValue2.owner) == null ? void 0 : _a2.current;
    if (!(subject instanceof HTMLElement)) {
      return false;
    }
    const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
    return supportsWaapi() && name2 && acceleratedValues.has(name2) && (name2 !== "transform" || !transformTemplate) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }
  const MAX_RESOLVE_DELAY = 40;
  class AsyncMotionValueAnimation extends WithPromise {
    constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name: name2, motionValue: motionValue2, element: element2, ...options2 }) {
      var _a2;
      super();
      this.stop = () => {
        var _a3, _b2;
        if (this._animation) {
          this._animation.stop();
          (_a3 = this.stopTimeline) == null ? void 0 : _a3.call(this);
        }
        (_b2 = this.keyframeResolver) == null ? void 0 : _b2.cancel();
      };
      this.createdAt = time.now();
      const optionsWithDefaults = {
        autoplay,
        delay: delay2,
        type,
        repeat,
        repeatDelay,
        repeatType,
        name: name2,
        motionValue: motionValue2,
        element: element2,
        ...options2
      };
      const KeyframeResolver$1 = (element2 == null ? void 0 : element2.KeyframeResolver) || KeyframeResolver;
      this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name2, motionValue2, element2);
      (_a2 = this.keyframeResolver) == null ? void 0 : _a2.scheduleResolve();
    }
    onKeyframesResolved(keyframes2, finalKeyframe, options2, sync) {
      this.keyframeResolver = void 0;
      const { name: name2, type, velocity, delay: delay2, isHandoff, onUpdate } = options2;
      this.resolvedAt = time.now();
      if (!canAnimate(keyframes2, name2, type, velocity)) {
        if (MotionGlobalConfig.instantAnimations || !delay2) {
          onUpdate == null ? void 0 : onUpdate(getFinalKeyframe$1(keyframes2, options2, finalKeyframe));
        }
        keyframes2[0] = keyframes2[keyframes2.length - 1];
        makeAnimationInstant(options2);
        options2.repeat = 0;
      }
      const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
      const resolvedOptions = {
        startTime,
        finalKeyframe,
        ...options2,
        keyframes: keyframes2
      };
      const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
        ...resolvedOptions,
        element: resolvedOptions.motionValue.owner.current
      }) : new JSAnimation(resolvedOptions);
      animation.finished.then(() => this.notifyFinished()).catch(noop$2);
      if (this.pendingTimeline) {
        this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
        this.pendingTimeline = void 0;
      }
      this._animation = animation;
    }
    get finished() {
      if (!this._animation) {
        return this._finished;
      } else {
        return this.animation.finished;
      }
    }
    then(onResolve, _onReject) {
      return this.finished.finally(onResolve).then(() => {
      });
    }
    get animation() {
      var _a2;
      if (!this._animation) {
        (_a2 = this.keyframeResolver) == null ? void 0 : _a2.resume();
        flushKeyframeResolvers();
      }
      return this._animation;
    }
    get duration() {
      return this.animation.duration;
    }
    get iterationDuration() {
      return this.animation.iterationDuration;
    }
    get time() {
      return this.animation.time;
    }
    set time(newTime) {
      this.animation.time = newTime;
    }
    get speed() {
      return this.animation.speed;
    }
    get state() {
      return this.animation.state;
    }
    set speed(newSpeed) {
      this.animation.speed = newSpeed;
    }
    get startTime() {
      return this.animation.startTime;
    }
    attachTimeline(timeline) {
      if (this._animation) {
        this.stopTimeline = this.animation.attachTimeline(timeline);
      } else {
        this.pendingTimeline = timeline;
      }
      return () => this.stop();
    }
    play() {
      this.animation.play();
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.complete();
    }
    cancel() {
      var _a2;
      if (this._animation) {
        this.animation.cancel();
      }
      (_a2 = this.keyframeResolver) == null ? void 0 : _a2.cancel();
    }
  }
  const splitCSSVariableRegex = (
    // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
    /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
  );
  function parseCSSVariable(current) {
    const match = splitCSSVariableRegex.exec(current);
    if (!match)
      return [,];
    const [, token1, token2, fallback] = match;
    return [`--${token1 ?? token2}`, fallback];
  }
  function getVariableValue(current, element2, depth = 1) {
    const [token, fallback] = parseCSSVariable(current);
    if (!token)
      return;
    const resolved = window.getComputedStyle(element2).getPropertyValue(token);
    if (resolved) {
      const trimmed = resolved.trim();
      return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    }
    return isCSSVariableToken(fallback) ? getVariableValue(fallback, element2, depth + 1) : fallback;
  }
  function getValueTransition(transition, key) {
    return (transition == null ? void 0 : transition[key]) ?? (transition == null ? void 0 : transition["default"]) ?? transition;
  }
  const positionalKeys = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...transformPropOrder
  ]);
  const auto = {
    test: (v) => v === "auto",
    parse: (v) => v
  };
  const testValueType = (v) => (type) => type.test(v);
  const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
  const findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));
  function isNone(value) {
    if (typeof value === "number") {
      return value === 0;
    } else if (value !== null) {
      return value === "none" || value === "0" || isZeroValueString(value);
    } else {
      return true;
    }
  }
  const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
  function applyDefaultFilter(v) {
    const [name2, value] = v.slice(0, -1).split("(");
    if (name2 === "drop-shadow")
      return v;
    const [number2] = value.match(floatRegex) || [];
    if (!number2)
      return v;
    const unit = value.replace(number2, "");
    let defaultValue = maxDefaults.has(name2) ? 1 : 0;
    if (number2 !== value)
      defaultValue *= 100;
    return name2 + "(" + defaultValue + unit + ")";
  }
  const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
  const filter = {
    ...complex,
    getAnimatableNone: (v) => {
      const functions = v.match(functionRegex);
      return functions ? functions.map(applyDefaultFilter).join(" ") : v;
    }
  };
  const int = {
    ...number,
    transform: Math.round
  };
  const transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px
  };
  const numberValueTypes = {
    // Border props
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    // Positioning props
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    // Spacing props
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    // Misc
    backgroundPositionX: px,
    backgroundPositionY: px,
    ...transformValueTypes,
    zIndex: int,
    // SVG
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
  };
  const defaultValueTypes = {
    ...numberValueTypes,
    // Color props
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    // Border props
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter
  };
  const getDefaultValueType = (key) => defaultValueTypes[key];
  function getAnimatableNone(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter)
      defaultValueType = complex;
    return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
  }
  const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
  function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name2) {
    let i = 0;
    let animatableTemplate = void 0;
    while (i < unresolvedKeyframes.length && !animatableTemplate) {
      const keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
        animatableTemplate = unresolvedKeyframes[i];
      }
      i++;
    }
    if (animatableTemplate && name2) {
      for (const noneIndex of noneKeyframeIndexes) {
        unresolvedKeyframes[noneIndex] = getAnimatableNone(name2, animatableTemplate);
      }
    }
  }
  class DOMKeyframesResolver extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name2, motionValue2, element2) {
      super(unresolvedKeyframes, onComplete, name2, motionValue2, element2, true);
    }
    readKeyframes() {
      const { unresolvedKeyframes, element: element2, name: name2 } = this;
      if (!element2 || !element2.current)
        return;
      super.readKeyframes();
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        let keyframe = unresolvedKeyframes[i];
        if (typeof keyframe === "string") {
          keyframe = keyframe.trim();
          if (isCSSVariableToken(keyframe)) {
            const resolved = getVariableValue(keyframe, element2.current);
            if (resolved !== void 0) {
              unresolvedKeyframes[i] = resolved;
            }
            if (i === unresolvedKeyframes.length - 1) {
              this.finalKeyframe = keyframe;
            }
          }
        }
      }
      this.resolveNoneKeyframes();
      if (!positionalKeys.has(name2) || unresolvedKeyframes.length !== 2) {
        return;
      }
      const [origin2, target] = unresolvedKeyframes;
      const originType = findDimensionValueType(origin2);
      const targetType = findDimensionValueType(target);
      if (originType === targetType)
        return;
      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
        for (let i = 0; i < unresolvedKeyframes.length; i++) {
          const value = unresolvedKeyframes[i];
          if (typeof value === "string") {
            unresolvedKeyframes[i] = parseFloat(value);
          }
        }
      } else if (positionalValues[name2]) {
        this.needsMeasurement = true;
      }
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes, name: name2 } = this;
      const noneKeyframeIndexes = [];
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) {
          noneKeyframeIndexes.push(i);
        }
      }
      if (noneKeyframeIndexes.length) {
        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name2);
      }
    }
    measureInitialState() {
      const { element: element2, unresolvedKeyframes, name: name2 } = this;
      if (!element2 || !element2.current)
        return;
      if (name2 === "height") {
        this.suspendedScrollY = window.pageYOffset;
      }
      this.measuredOrigin = positionalValues[name2](element2.measureViewportBox(), window.getComputedStyle(element2.current));
      unresolvedKeyframes[0] = this.measuredOrigin;
      const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (measureKeyframe !== void 0) {
        element2.getValue(name2, measureKeyframe).jump(measureKeyframe, false);
      }
    }
    measureEndState() {
      var _a2;
      const { element: element2, name: name2, unresolvedKeyframes } = this;
      if (!element2 || !element2.current)
        return;
      const value = element2.getValue(name2);
      value && value.jump(this.measuredOrigin, false);
      const finalKeyframeIndex = unresolvedKeyframes.length - 1;
      const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name2](element2.measureViewportBox(), window.getComputedStyle(element2.current));
      if (finalKeyframe !== null && this.finalKeyframe === void 0) {
        this.finalKeyframe = finalKeyframe;
      }
      if ((_a2 = this.removedTransforms) == null ? void 0 : _a2.length) {
        this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
          element2.getValue(unsetTransformName).set(unsetTransformValue);
        });
      }
      this.resolveNoneKeyframes();
    }
  }
  function resolveElements(elementOrSelector, scope, selectorCache) {
    if (elementOrSelector instanceof EventTarget) {
      return [elementOrSelector];
    } else if (typeof elementOrSelector === "string") {
      let root2 = document;
      const elements = (selectorCache == null ? void 0 : selectorCache[elementOrSelector]) ?? root2.querySelectorAll(elementOrSelector);
      return elements ? Array.from(elements) : [];
    }
    return Array.from(elementOrSelector);
  }
  const getValueAsType = (value, type) => {
    return type && typeof value === "number" ? type.transform(value) : value;
  };
  function isHTMLElement(element2) {
    return isObject$1(element2) && "offsetHeight" in element2;
  }
  const MAX_VELOCITY_DELTA = 30;
  const isFloat = (value) => {
    return !isNaN(parseFloat(value));
  };
  class MotionValue {
    /**
     * @param init - The initiating value
     * @param config - Optional configuration options
     *
     * -  `transformer`: A function to transform incoming values with.
     */
    constructor(init, options2 = {}) {
      this.canTrackVelocity = null;
      this.events = {};
      this.updateAndNotify = (v) => {
        var _a2;
        const currentTime = time.now();
        if (this.updatedAt !== currentTime) {
          this.setPrevFrameValue();
        }
        this.prev = this.current;
        this.setCurrent(v);
        if (this.current !== this.prev) {
          (_a2 = this.events.change) == null ? void 0 : _a2.notify(this.current);
          if (this.dependents) {
            for (const dependent of this.dependents) {
              dependent.dirty();
            }
          }
        }
      };
      this.hasAnimated = false;
      this.setCurrent(init);
      this.owner = options2.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
      if (this.canTrackVelocity === null && current !== void 0) {
        this.canTrackVelocity = isFloat(this.current);
      }
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
    /**
     * Adds a function that will be notified when the `MotionValue` is updated.
     *
     * It returns a function that, when called, will cancel the subscription.
     *
     * When calling `onChange` inside a React component, it should be wrapped with the
     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
     * from the `useEffect` function to ensure you don't add duplicate subscribers..
     *
     * ```jsx
     * export const MyComponent = () => {
     *   const x = useMotionValue(0)
     *   const y = useMotionValue(0)
     *   const opacity = useMotionValue(1)
     *
     *   useEffect(() => {
     *     function updateOpacity() {
     *       const maxXY = Math.max(x.get(), y.get())
     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
     *       opacity.set(newOpacity)
     *     }
     *
     *     const unsubscribeX = x.on("change", updateOpacity)
     *     const unsubscribeY = y.on("change", updateOpacity)
     *
     *     return () => {
     *       unsubscribeX()
     *       unsubscribeY()
     *     }
     *   }, [])
     *
     *   return <motion.div style={{ x }} />
     * }
     * ```
     *
     * @param subscriber - A function that receives the latest value.
     * @returns A function that, when called, will cancel this subscription.
     *
     * @deprecated
     */
    onChange(subscription) {
      return this.on("change", subscription);
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      const unsubscribe = this.events[eventName].add(callback);
      if (eventName === "change") {
        return () => {
          unsubscribe();
          frame.read(() => {
            if (!this.events.change.getSize()) {
              this.stop();
            }
          });
        };
      }
      return unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
    /**
     * Attaches a passive effect to the `MotionValue`.
     */
    attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
    /**
     * Sets the state of the `MotionValue`.
     *
     * @remarks
     *
     * ```jsx
     * const x = useMotionValue(0)
     * x.set(10)
     * ```
     *
     * @param latest - Latest value to set.
     * @param render - Whether to notify render subscribers. Defaults to `true`
     *
     * @public
     */
    set(v) {
      if (!this.passiveEffect) {
        this.updateAndNotify(v);
      } else {
        this.passiveEffect(v, this.updateAndNotify);
      }
    }
    setWithVelocity(prev, current, delta) {
      this.set(current);
      this.prev = void 0;
      this.prevFrameValue = prev;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
    /**
     * Set the state of the `MotionValue`, stopping any active animations,
     * effects, and resets velocity to `0`.
     */
    jump(v, endAnimation = true) {
      this.updateAndNotify(v);
      this.prev = v;
      this.prevUpdatedAt = this.prevFrameValue = void 0;
      endAnimation && this.stop();
      if (this.stopPassiveEffect)
        this.stopPassiveEffect();
    }
    dirty() {
      var _a2;
      (_a2 = this.events.change) == null ? void 0 : _a2.notify(this.current);
    }
    addDependent(dependent) {
      if (!this.dependents) {
        this.dependents = /* @__PURE__ */ new Set();
      }
      this.dependents.add(dependent);
    }
    removeDependent(dependent) {
      if (this.dependents) {
        this.dependents.delete(dependent);
      }
    }
    /**
     * Returns the latest state of `MotionValue`
     *
     * @returns - The latest state of `MotionValue`
     *
     * @public
     */
    get() {
      return this.current;
    }
    /**
     * @public
     */
    getPrevious() {
      return this.prev;
    }
    /**
     * Returns the latest velocity of `MotionValue`
     *
     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
     *
     * @public
     */
    getVelocity() {
      const currentTime = time.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
        return 0;
      }
      const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
    }
    /**
     * Registers a new animation to control this `MotionValue`. Only one
     * animation can drive a `MotionValue` at one time.
     *
     * ```jsx
     * value.start()
     * ```
     *
     * @param animation - A function that starts the provided animation
     */
    start(startAnimation) {
      this.stop();
      return new Promise((resolve) => {
        this.hasAnimated = true;
        this.animation = startAnimation(resolve);
        if (this.events.animationStart) {
          this.events.animationStart.notify();
        }
      }).then(() => {
        if (this.events.animationComplete) {
          this.events.animationComplete.notify();
        }
        this.clearAnimation();
      });
    }
    /**
     * Stop the currently active animation.
     *
     * @public
     */
    stop() {
      if (this.animation) {
        this.animation.stop();
        if (this.events.animationCancel) {
          this.events.animationCancel.notify();
        }
      }
      this.clearAnimation();
    }
    /**
     * Returns `true` if this value is currently animating.
     *
     * @public
     */
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    /**
     * Destroy and clean up subscribers to this `MotionValue`.
     *
     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
     * created a `MotionValue` via the `motionValue` function.
     *
     * @public
     */
    destroy() {
      var _a2, _b2;
      (_a2 = this.dependents) == null ? void 0 : _a2.clear();
      (_b2 = this.events.destroy) == null ? void 0 : _b2.notify();
      this.clearListeners();
      this.stop();
      if (this.stopPassiveEffect) {
        this.stopPassiveEffect();
      }
    }
  }
  function motionValue(init, options2) {
    return new MotionValue(init, options2);
  }
  const { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, false);
  const isDragging = {
    x: false,
    y: false
  };
  function isDragActive() {
    return isDragging.x || isDragging.y;
  }
  function setDragLock(axis) {
    if (axis === "x" || axis === "y") {
      if (isDragging[axis]) {
        return null;
      } else {
        isDragging[axis] = true;
        return () => {
          isDragging[axis] = false;
        };
      }
    } else {
      if (isDragging.x || isDragging.y) {
        return null;
      } else {
        isDragging.x = isDragging.y = true;
        return () => {
          isDragging.x = isDragging.y = false;
        };
      }
    }
  }
  function setupGesture(elementOrSelector, options2) {
    const elements = resolveElements(elementOrSelector);
    const gestureAbortController = new AbortController();
    const eventOptions = {
      passive: true,
      ...options2,
      signal: gestureAbortController.signal
    };
    const cancel = () => gestureAbortController.abort();
    return [elements, eventOptions, cancel];
  }
  function isValidHover(event) {
    return !(event.pointerType === "touch" || isDragActive());
  }
  function hover(elementOrSelector, onHoverStart, options2 = {}) {
    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options2);
    const onPointerEnter = (enterEvent) => {
      if (!isValidHover(enterEvent))
        return;
      const { target } = enterEvent;
      const onHoverEnd = onHoverStart(target, enterEvent);
      if (typeof onHoverEnd !== "function" || !target)
        return;
      const onPointerLeave = (leaveEvent) => {
        if (!isValidHover(leaveEvent))
          return;
        onHoverEnd(leaveEvent);
        target.removeEventListener("pointerleave", onPointerLeave);
      };
      target.addEventListener("pointerleave", onPointerLeave, eventOptions);
    };
    elements.forEach((element2) => {
      element2.addEventListener("pointerenter", onPointerEnter, eventOptions);
    });
    return cancel;
  }
  const isNodeOrChild = (parent, child) => {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  };
  const isPrimaryPointer = (event) => {
    if (event.pointerType === "mouse") {
      return typeof event.button !== "number" || event.button <= 0;
    } else {
      return event.isPrimary !== false;
    }
  };
  const focusableElements = /* @__PURE__ */ new Set([
    "BUTTON",
    "INPUT",
    "SELECT",
    "TEXTAREA",
    "A"
  ]);
  function isElementKeyboardAccessible(element2) {
    return focusableElements.has(element2.tagName) || element2.tabIndex !== -1;
  }
  const isPressing = /* @__PURE__ */ new WeakSet();
  function filterEvents(callback) {
    return (event) => {
      if (event.key !== "Enter")
        return;
      callback(event);
    };
  }
  function firePointerEvent(target, type) {
    target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
  }
  const enableKeyboardPress = (focusEvent, eventOptions) => {
    const element2 = focusEvent.currentTarget;
    if (!element2)
      return;
    const handleKeydown = filterEvents(() => {
      if (isPressing.has(element2))
        return;
      firePointerEvent(element2, "down");
      const handleKeyup = filterEvents(() => {
        firePointerEvent(element2, "up");
      });
      const handleBlur = () => firePointerEvent(element2, "cancel");
      element2.addEventListener("keyup", handleKeyup, eventOptions);
      element2.addEventListener("blur", handleBlur, eventOptions);
    });
    element2.addEventListener("keydown", handleKeydown, eventOptions);
    element2.addEventListener("blur", () => element2.removeEventListener("keydown", handleKeydown), eventOptions);
  };
  function isValidPressEvent(event) {
    return isPrimaryPointer(event) && !isDragActive();
  }
  function press(targetOrSelector, onPressStart, options2 = {}) {
    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options2);
    const startPress = (startEvent) => {
      const target = startEvent.currentTarget;
      if (!isValidPressEvent(startEvent))
        return;
      isPressing.add(target);
      const onPressEnd = onPressStart(target, startEvent);
      const onPointerEnd = (endEvent, success) => {
        window.removeEventListener("pointerup", onPointerUp);
        window.removeEventListener("pointercancel", onPointerCancel);
        if (isPressing.has(target)) {
          isPressing.delete(target);
        }
        if (!isValidPressEvent(endEvent)) {
          return;
        }
        if (typeof onPressEnd === "function") {
          onPressEnd(endEvent, { success });
        }
      };
      const onPointerUp = (upEvent) => {
        onPointerEnd(upEvent, target === window || target === document || options2.useGlobalTarget || isNodeOrChild(target, upEvent.target));
      };
      const onPointerCancel = (cancelEvent) => {
        onPointerEnd(cancelEvent, false);
      };
      window.addEventListener("pointerup", onPointerUp, eventOptions);
      window.addEventListener("pointercancel", onPointerCancel, eventOptions);
    };
    targets.forEach((target) => {
      const pointerDownTarget = options2.useGlobalTarget ? window : target;
      pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
      if (isHTMLElement(target)) {
        target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
        if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
          target.tabIndex = 0;
        }
      }
    });
    return cancelEvents;
  }
  function isSVGElement(element2) {
    return isObject$1(element2) && "ownerSVGElement" in element2;
  }
  function isSVGSVGElement(element2) {
    return isSVGElement(element2) && element2.tagName === "svg";
  }
  const isMotionValue = (value) => Boolean(value && value.getVelocity);
  const valueTypes = [...dimensionValueTypes, color, complex];
  const findValueType = (v) => valueTypes.find(testValueType(v));
  const MotionConfigContext = reactExports.createContext({
    transformPagePoint: (p) => p,
    isStatic: false,
    reducedMotion: "never"
  });
  function setRef(ref, value) {
    if (typeof ref === "function") {
      return ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs(...refs) {
    return (node2) => {
      let hasCleanup = false;
      const cleanups = refs.map((ref) => {
        const cleanup = setRef(ref, node2);
        if (!hasCleanup && typeof cleanup === "function") {
          hasCleanup = true;
        }
        return cleanup;
      });
      if (hasCleanup) {
        return () => {
          for (let i = 0; i < cleanups.length; i++) {
            const cleanup = cleanups[i];
            if (typeof cleanup === "function") {
              cleanup();
            } else {
              setRef(refs[i], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs(...refs) {
    return reactExports.useCallback(composeRefs(...refs), refs);
  }
  class PopChildMeasure extends reactExports.Component {
    getSnapshotBeforeUpdate(prevProps) {
      const element2 = this.props.childRef.current;
      if (element2 && prevProps.isPresent && !this.props.isPresent) {
        const parent = element2.offsetParent;
        const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;
        const size2 = this.props.sizeRef.current;
        size2.height = element2.offsetHeight || 0;
        size2.width = element2.offsetWidth || 0;
        size2.top = element2.offsetTop;
        size2.left = element2.offsetLeft;
        size2.right = parentWidth - size2.width - size2.left;
      }
      return null;
    }
    /**
     * Required with getSnapshotBeforeUpdate to stop React complaining.
     */
    componentDidUpdate() {
    }
    render() {
      return this.props.children;
    }
  }
  function PopChild({ children, isPresent, anchorX, root: root2 }) {
    const id2 = reactExports.useId();
    const ref = reactExports.useRef(null);
    const size2 = reactExports.useRef({
      width: 0,
      height: 0,
      top: 0,
      left: 0,
      right: 0
    });
    const { nonce } = reactExports.useContext(MotionConfigContext);
    const composedRef = useComposedRefs(ref, children == null ? void 0 : children.ref);
    reactExports.useInsertionEffect(() => {
      const { width, height, top, left, right } = size2.current;
      if (isPresent || !ref.current || !width || !height)
        return;
      const x = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
      ref.current.dataset.motionPopId = id2;
      const style = document.createElement("style");
      if (nonce)
        style.nonce = nonce;
      const parent = root2 ?? document.head;
      parent.appendChild(style);
      if (style.sheet) {
        style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x}px !important;
            top: ${top}px !important;
          }
        `);
      }
      return () => {
        if (parent.contains(style)) {
          parent.removeChild(style);
        }
      };
    }, [isPresent]);
    return jsxRuntimeExports.jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2, children: reactExports.cloneElement(children, { ref: composedRef }) });
  }
  const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root: root2 }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id2 = reactExports.useId();
    let isReusedContext = true;
    let context = reactExports.useMemo(() => {
      isReusedContext = false;
      return {
        id: id2,
        initial,
        isPresent,
        custom,
        onExitComplete: (childId) => {
          presenceChildren.set(childId, true);
          for (const isComplete of presenceChildren.values()) {
            if (!isComplete)
              return;
          }
          onExitComplete && onExitComplete();
        },
        register: (childId) => {
          presenceChildren.set(childId, false);
          return () => presenceChildren.delete(childId);
        }
      };
    }, [isPresent, presenceChildren, onExitComplete]);
    if (presenceAffectsLayout && isReusedContext) {
      context = { ...context };
    }
    reactExports.useMemo(() => {
      presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
    }, [isPresent]);
    reactExports.useEffect(() => {
      !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
    }, [isPresent]);
    if (mode === "popLayout") {
      children = jsxRuntimeExports.jsx(PopChild, { isPresent, anchorX, root: root2, children });
    }
    return jsxRuntimeExports.jsx(PresenceContext.Provider, { value: context, children });
  };
  function newChildrenMap() {
    return /* @__PURE__ */ new Map();
  }
  function usePresence(subscribe = true) {
    const context = reactExports.useContext(PresenceContext);
    if (context === null)
      return [true, null];
    const { isPresent, onExitComplete, register } = context;
    const id2 = reactExports.useId();
    reactExports.useEffect(() => {
      if (subscribe) {
        return register(id2);
      }
    }, [subscribe]);
    const safeToRemove = reactExports.useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
  }
  const getChildKey = (child) => child.key || "";
  function onlyElements(children) {
    const filtered = [];
    reactExports.Children.forEach(children, (child) => {
      if (reactExports.isValidElement(child))
        filtered.push(child);
    });
    return filtered;
  }
  const AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", root: root2 }) => {
    const [isParentPresent, safeToRemove] = usePresence(propagate);
    const presentChildren = reactExports.useMemo(() => onlyElements(children), [children]);
    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
    const isInitialRender = reactExports.useRef(true);
    const pendingPresentChildren = reactExports.useRef(presentChildren);
    const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
    const [diffedChildren, setDiffedChildren] = reactExports.useState(presentChildren);
    const [renderedChildren, setRenderedChildren] = reactExports.useState(presentChildren);
    useIsomorphicLayoutEffect$1(() => {
      isInitialRender.current = false;
      pendingPresentChildren.current = presentChildren;
      for (let i = 0; i < renderedChildren.length; i++) {
        const key = getChildKey(renderedChildren[i]);
        if (!presentKeys.includes(key)) {
          if (exitComplete.get(key) !== true) {
            exitComplete.set(key, false);
          }
        } else {
          exitComplete.delete(key);
        }
      }
    }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
    const exitingChildren = [];
    if (presentChildren !== diffedChildren) {
      let nextChildren = [...presentChildren];
      for (let i = 0; i < renderedChildren.length; i++) {
        const child = renderedChildren[i];
        const key = getChildKey(child);
        if (!presentKeys.includes(key)) {
          nextChildren.splice(i, 0, child);
          exitingChildren.push(child);
        }
      }
      if (mode === "wait" && exitingChildren.length) {
        nextChildren = exitingChildren;
      }
      setRenderedChildren(onlyElements(nextChildren));
      setDiffedChildren(presentChildren);
      return null;
    }
    const { forceRender } = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderedChildren.map((child) => {
      const key = getChildKey(child);
      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
      const onExit = () => {
        if (exitComplete.has(key)) {
          exitComplete.set(key, true);
        } else {
          return;
        }
        let isEveryExitComplete = true;
        exitComplete.forEach((isExitComplete) => {
          if (!isExitComplete)
            isEveryExitComplete = false;
        });
        if (isEveryExitComplete) {
          forceRender == null ? void 0 : forceRender();
          setRenderedChildren(pendingPresentChildren.current);
          propagate && (safeToRemove == null ? void 0 : safeToRemove());
          onExitComplete && onExitComplete();
        }
      };
      return jsxRuntimeExports.jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom, presenceAffectsLayout, mode, root: root2, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key);
    }) });
  };
  const LazyContext = reactExports.createContext({ strict: false });
  const featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
  };
  const featureDefinitions = {};
  for (const key in featureProps) {
    featureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name2) => !!props[name2])
    };
  }
  function loadFeatures(features) {
    for (const key in features) {
      featureDefinitions[key] = {
        ...featureDefinitions[key],
        ...features[key]
      };
    }
  }
  const validMotionProps = /* @__PURE__ */ new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport"
  ]);
  function isValidMotionProp(key) {
    return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
  }
  let shouldForward = (key) => !isValidMotionProp(key);
  function loadExternalIsValidProp(isValidProp) {
    if (typeof isValidProp !== "function")
      return;
    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  }
  try {
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
  } catch {
  }
  function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      if (key === "values" && typeof props.values === "object")
        continue;
      if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
      props["draggable"] && key.startsWith("onDrag")) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }
  const MotionContext = /* @__PURE__ */ reactExports.createContext({});
  function isAnimationControls(v) {
    return v !== null && typeof v === "object" && typeof v.start === "function";
  }
  function isVariantLabel(v) {
    return typeof v === "string" || Array.isArray(v);
  }
  const variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ];
  const variantProps = ["initial", ...variantPriorityOrder];
  function isControllingVariants(props) {
    return isAnimationControls(props.animate) || variantProps.some((name2) => isVariantLabel(props[name2]));
  }
  function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
  }
  function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
      const { initial, animate } = props;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : void 0,
        animate: isVariantLabel(animate) ? animate : void 0
      };
    }
    return props.inherit !== false ? context : {};
  }
  function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
    return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
  }
  function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  }
  const scaleCorrectors = {};
  function addScaleCorrector(correctors) {
    for (const key in correctors) {
      scaleCorrectors[key] = correctors[key];
      if (isCSSVariableName(key)) {
        scaleCorrectors[key].isCSSVariable = true;
      }
    }
  }
  function isForcedMotionValue(key, { layout: layout2, layoutId }) {
    return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
  }
  const translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  const numTransforms = transformPropOrder.length;
  function buildTransform(latestValues, transform, transformTemplate) {
    let transformString = "";
    let transformIsDefault = true;
    for (let i = 0; i < numTransforms; i++) {
      const key = transformPropOrder[i];
      const value = latestValues[key];
      if (value === void 0)
        continue;
      let valueIsDefault = true;
      if (typeof value === "number") {
        valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
      } else {
        valueIsDefault = parseFloat(value) === 0;
      }
      if (!valueIsDefault || transformTemplate) {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (!valueIsDefault) {
          transformIsDefault = false;
          const transformName = translateAlias[key] || key;
          transformString += `${transformName}(${valueAsType}) `;
        }
        if (transformTemplate) {
          transform[key] = valueAsType;
        }
      }
    }
    transformString = transformString.trim();
    if (transformTemplate) {
      transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
    } else if (transformIsDefault) {
      transformString = "none";
    }
    return transformString;
  }
  function buildHTMLStyles(state, latestValues, transformTemplate) {
    const { style, vars, transformOrigin: transformOrigin2 } = state;
    let hasTransform2 = false;
    let hasTransformOrigin = false;
    for (const key in latestValues) {
      const value = latestValues[key];
      if (transformProps.has(key)) {
        hasTransform2 = true;
        continue;
      } else if (isCSSVariableName(key)) {
        vars[key] = value;
        continue;
      } else {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (key.startsWith("origin")) {
          hasTransformOrigin = true;
          transformOrigin2[key] = valueAsType;
        } else {
          style[key] = valueAsType;
        }
      }
    }
    if (!latestValues.transform) {
      if (hasTransform2 || transformTemplate) {
        style.transform = buildTransform(latestValues, state.transform, transformTemplate);
      } else if (style.transform) {
        style.transform = "none";
      }
    }
    if (hasTransformOrigin) {
      const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin2;
      style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  }
  const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
  });
  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues({ transformTemplate }, visualState) {
    return reactExports.useMemo(() => {
      const state = createHtmlRenderState();
      buildHTMLStyles(state, visualState, transformTemplate);
      return Object.assign({}, state.vars, state.style);
    }, [visualState]);
  }
  function useStyle(props, visualState) {
    const styleProp = props.style || {};
    const style = {};
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState));
    return style;
  }
  function useHTMLProps(props, visualState) {
    const htmlProps = {};
    const style = useStyle(props, visualState);
    if (props.drag && props.dragListener !== false) {
      htmlProps.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
    }
    if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
      htmlProps.tabIndex = 0;
    }
    htmlProps.style = style;
    return htmlProps;
  }
  const dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  };
  const camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function buildSVGPath(attrs, length, spacing = 1, offset2 = 0, useDashCase = true) {
    attrs.pathLength = 1;
    const keys2 = useDashCase ? dashKeys : camelKeys;
    attrs[keys2.offset] = px.transform(-offset2);
    const pathLength = px.transform(length);
    const pathSpacing = px.transform(spacing);
    attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
  }
  function buildSVGAttrs(state, {
    attrX,
    attrY,
    attrScale,
    pathLength,
    pathSpacing = 1,
    pathOffset = 0,
    // This is object creation, which we try to avoid per-frame.
    ...latest
  }, isSVGTag2, transformTemplate, styleProp) {
    buildHTMLStyles(state, latest, transformTemplate);
    if (isSVGTag2) {
      if (state.style.viewBox) {
        state.attrs.viewBox = state.style.viewBox;
      }
      return;
    }
    state.attrs = state.style;
    state.style = {};
    const { attrs, style } = state;
    if (attrs.transform) {
      style.transform = attrs.transform;
      delete attrs.transform;
    }
    if (style.transform || attrs.transformOrigin) {
      style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
      delete attrs.transformOrigin;
    }
    if (style.transform) {
      style.transformBox = (styleProp == null ? void 0 : styleProp.transformBox) ?? "fill-box";
      delete attrs.transformBox;
    }
    if (attrX !== void 0)
      attrs.x = attrX;
    if (attrY !== void 0)
      attrs.y = attrY;
    if (attrScale !== void 0)
      attrs.scale = attrScale;
    if (pathLength !== void 0) {
      buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
  }
  const createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
  });
  const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
  function useSVGProps(props, visualState, _isStatic, Component2) {
    const visualProps = reactExports.useMemo(() => {
      const state = createSvgRenderState();
      buildSVGAttrs(state, visualState, isSVGTag(Component2), props.transformTemplate, props.style);
      return {
        ...state.attrs,
        style: { ...state.style }
      };
    }, [visualState]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = { ...rawStyles, ...visualProps.style };
    }
    return visualProps;
  }
  const lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view"
  ];
  function isSVGComponent(Component2) {
    if (
      /**
       * If it's not a string, it's a custom React component. Currently we only support
       * HTML custom React components.
       */
      typeof Component2 !== "string" || /**
       * If it contains a dash, the element is a custom HTML webcomponent.
       */
      Component2.includes("-")
    ) {
      return false;
    } else if (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      lowercaseSVGElements.indexOf(Component2) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component2)
    ) {
      return true;
    }
    return false;
  }
  function useRender(Component2, props, ref, { latestValues }, isStatic, forwardMotionProps = false) {
    const useVisualProps = isSVGComponent(Component2) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component2);
    const filteredProps = filterProps(props, typeof Component2 === "string", forwardMotionProps);
    const elementProps = Component2 !== reactExports.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component2, {
      ...elementProps,
      children: renderedChildren
    });
  }
  function getValueState(visualElement) {
    const state = [{}, {}];
    visualElement == null ? void 0 : visualElement.values.forEach((value, key) => {
      state[0][key] = value.get();
      state[1][key] = value.getVelocity();
    });
    return state;
  }
  function resolveVariantFromProps(props, definition2, custom, visualElement) {
    if (typeof definition2 === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition2 = definition2(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    if (typeof definition2 === "string") {
      definition2 = props.variants && props.variants[definition2];
    }
    if (typeof definition2 === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition2 = definition2(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    return definition2;
  }
  function resolveMotionValue(value) {
    return isMotionValue(value) ? value.get() : value;
  }
  function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState }, props, context, presenceContext) {
    const state = {
      latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
      renderState: createRenderState()
    };
    return state;
  }
  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
    const values = {};
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
      if (initial === void 0)
        initial = context.initial;
      if (animate === void 0)
        animate = context.animate;
    }
    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
      const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
      for (let i = 0; i < list2.length; i++) {
        const resolved = resolveVariantFromProps(props, list2[i]);
        if (resolved) {
          const { transitionEnd, transition, ...target } = resolved;
          for (const key in target) {
            let valueTarget = target[key];
            if (Array.isArray(valueTarget)) {
              const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
              valueTarget = valueTarget[index2];
            }
            if (valueTarget !== null) {
              values[key] = valueTarget;
            }
          }
          for (const key in transitionEnd) {
            values[key] = transitionEnd[key];
          }
        }
      }
    }
    return values;
  }
  const makeUseVisualState = (config) => (props, isStatic) => {
    const context = reactExports.useContext(MotionContext);
    const presenceContext = reactExports.useContext(PresenceContext);
    const make = () => makeState(config, props, context, presenceContext);
    return isStatic ? make() : useConstant(make);
  };
  function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
    var _a2;
    const { style } = props;
    const newValues = {};
    for (const key in style) {
      if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a2 = visualElement == null ? void 0 : visualElement.getValue(key)) == null ? void 0 : _a2.liveStyle) !== void 0) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  }
  const useHTMLVisualState = /* @__PURE__ */ makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  });
  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  }
  const useSVGVisualState = /* @__PURE__ */ makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState
  });
  const motionComponentSymbol = Symbol.for("motionComponentSymbol");
  function isRefObject(ref) {
    return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
  }
  function useMotionRef(visualState, visualElement, externalRef) {
    return reactExports.useCallback(
      (instance) => {
        if (instance) {
          visualState.onMount && visualState.onMount(instance);
        }
        if (visualElement) {
          if (instance) {
            visualElement.mount(instance);
          } else {
            visualElement.unmount();
          }
        }
        if (externalRef) {
          if (typeof externalRef === "function") {
            externalRef(instance);
          } else if (isRefObject(externalRef)) {
            externalRef.current = instance;
          }
        }
      },
      /**
       * Include externalRef in dependencies to ensure the callback updates
       * when the ref changes, allowing proper ref forwarding.
       */
      [visualElement]
    );
  }
  const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
  const optimizedAppearDataId = "framerAppearId";
  const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
  const SwitchLayoutGroupContext = reactExports.createContext({});
  function useVisualElement(Component2, visualState, props, createVisualElement, ProjectionNodeConstructor) {
    var _a2, _b2;
    const { visualElement: parent } = reactExports.useContext(MotionContext);
    const lazyContext = reactExports.useContext(LazyContext);
    const presenceContext = reactExports.useContext(PresenceContext);
    const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
    const visualElementRef = reactExports.useRef(null);
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component2, {
        visualState,
        parent,
        props,
        presenceContext,
        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
        reducedMotionConfig
      });
    }
    const visualElement = visualElementRef.current;
    const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
    if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
      createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
    }
    const isMounted = reactExports.useRef(false);
    reactExports.useInsertionEffect(() => {
      if (visualElement && isMounted.current) {
        visualElement.update(props, presenceContext);
      }
    });
    const optimisedAppearId = props[optimizedAppearDataAttribute];
    const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) && !((_a2 = window.MotionHandoffIsComplete) == null ? void 0 : _a2.call(window, optimisedAppearId)) && ((_b2 = window.MotionHasOptimisedAnimation) == null ? void 0 : _b2.call(window, optimisedAppearId)));
    useIsomorphicLayoutEffect$1(() => {
      if (!visualElement)
        return;
      isMounted.current = true;
      window.MotionIsMounted = true;
      visualElement.updateFeatures();
      visualElement.scheduleRenderMicrotask();
      if (wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
    });
    reactExports.useEffect(() => {
      if (!visualElement)
        return;
      if (!wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
      if (wantsHandoff.current) {
        queueMicrotask(() => {
          var _a3;
          (_a3 = window.MotionHandoffMarkAsComplete) == null ? void 0 : _a3.call(window, optimisedAppearId);
        });
        wantsHandoff.current = false;
      }
      visualElement.enteringChildren = void 0;
    });
    return visualElement;
  }
  function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
    const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
    visualElement.projection.setOptions({
      layoutId,
      layout: layout2,
      alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
      visualElement,
      /**
       * TODO: Update options in an effect. This could be tricky as it'll be too late
       * to update by the time layout animations run.
       * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
       * ensuring it gets called if there's no potential layout animations.
       *
       */
      animationType: typeof layout2 === "string" ? layout2 : "both",
      initialPromotionConfig,
      crossfade: layoutCrossfade,
      layoutScroll,
      layoutRoot
    });
  }
  function getClosestProjectingNode(visualElement) {
    if (!visualElement)
      return void 0;
    return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
  }
  function createMotionComponent(Component2, { forwardMotionProps = false } = {}, preloadedFeatures, createVisualElement) {
    preloadedFeatures && loadFeatures(preloadedFeatures);
    const useVisualState = isSVGComponent(Component2) ? useSVGVisualState : useHTMLVisualState;
    function MotionDOMComponent(props, externalRef) {
      let MeasureLayout2;
      const configAndProps = {
        ...reactExports.useContext(MotionConfigContext),
        ...props,
        layoutId: useLayoutId(props)
      };
      const { isStatic } = configAndProps;
      const context = useCreateMotionContext(props);
      const visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser) {
        useStrictMode();
        const layoutProjection = getProjectionFunctionality(configAndProps);
        MeasureLayout2 = layoutProjection.MeasureLayout;
        context.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
      }
      return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component2, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] });
    }
    MotionDOMComponent.displayName = `motion.${typeof Component2 === "string" ? Component2 : `create(${Component2.displayName ?? Component2.name ?? ""})`}`;
    const ForwardRefMotionComponent = reactExports.forwardRef(MotionDOMComponent);
    ForwardRefMotionComponent[motionComponentSymbol] = Component2;
    return ForwardRefMotionComponent;
  }
  function useLayoutId({ layoutId }) {
    const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
    return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
  }
  function useStrictMode(configAndProps, preloadedFeatures) {
    reactExports.useContext(LazyContext).strict;
  }
  function getProjectionFunctionality(props) {
    const { drag: drag2, layout: layout2 } = featureDefinitions;
    if (!drag2 && !layout2)
      return {};
    const combined = { ...drag2, ...layout2 };
    return {
      MeasureLayout: (drag2 == null ? void 0 : drag2.isEnabled(props)) || (layout2 == null ? void 0 : layout2.isEnabled(props)) ? combined.MeasureLayout : void 0,
      ProjectionNode: combined.ProjectionNode
    };
  }
  function createMotionProxy(preloadedFeatures, createVisualElement) {
    if (typeof Proxy === "undefined") {
      return createMotionComponent;
    }
    const componentCache = /* @__PURE__ */ new Map();
    const factory = (Component2, options2) => {
      return createMotionComponent(Component2, options2, preloadedFeatures, createVisualElement);
    };
    const deprecatedFactoryFunction = (Component2, options2) => {
      return factory(Component2, options2);
    };
    return new Proxy(deprecatedFactoryFunction, {
      /**
       * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
       * The prop name is passed through as `key` and we can use that to generate a `motion`
       * DOM component with that name.
       */
      get: (_target, key) => {
        if (key === "create")
          return factory;
        if (!componentCache.has(key)) {
          componentCache.set(key, createMotionComponent(key, void 0, preloadedFeatures, createVisualElement));
        }
        return componentCache.get(key);
      }
    });
  }
  function convertBoundingBoxToBox({ top, left, right, bottom }) {
    return {
      x: { min: left, max: right },
      y: { min: top, max: bottom }
    };
  }
  function convertBoxToBoundingBox({ x, y }) {
    return { top: y.min, right: x.max, bottom: y.max, left: x.min };
  }
  function transformBoxPoints(point2, transformPoint2) {
    if (!transformPoint2)
      return point2;
    const topLeft = transformPoint2({ x: point2.left, y: point2.top });
    const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x
    };
  }
  function isIdentityScale(scale2) {
    return scale2 === void 0 || scale2 === 1;
  }
  function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
    return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
  }
  function hasTransform(values) {
    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && value !== "0%";
  }
  function scalePoint(point2, scale2, originPoint) {
    const distanceFromOrigin = point2 - originPoint;
    const scaled = scale2 * distanceFromOrigin;
    return originPoint + scaled;
  }
  function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
    if (boxScale !== void 0) {
      point2 = scalePoint(point2, boxScale, originPoint);
    }
    return scalePoint(point2, scale2, originPoint) + translate;
  }
  function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function applyBoxDelta(box, { x, y }) {
    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
  }
  const TREE_SCALE_SNAP_MIN = 0.999999999999;
  const TREE_SCALE_SNAP_MAX = 1.0000000000001;
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength)
      return;
    treeScale.x = treeScale.y = 1;
    let node2;
    let delta;
    for (let i = 0; i < treeLength; i++) {
      node2 = treePath[i];
      delta = node2.projectionDelta;
      const { visualElement } = node2.options;
      if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
        continue;
      }
      if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
        transformBox(box, {
          x: -node2.scroll.offset.x,
          y: -node2.scroll.offset.y
        });
      }
      if (delta) {
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        applyBoxDelta(box, delta);
      }
      if (isSharedTransition && hasTransform(node2.latestValues)) {
        transformBox(box, node2.latestValues);
      }
    }
    if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
      treeScale.x = 1;
    }
    if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
      treeScale.y = 1;
    }
  }
  function translateAxis(axis, distance2) {
    axis.min = axis.min + distance2;
    axis.max = axis.max + distance2;
  }
  function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
    const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
  }
  function transformBox(box, transform) {
    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
  }
  function measureViewportBox(instance, transformPoint2) {
    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
  }
  function measurePageBox(element2, rootProjectionNode2, transformPagePoint) {
    const viewportBox = measureViewportBox(element2, transformPagePoint);
    const { scroll } = rootProjectionNode2;
    if (scroll) {
      translateAxis(viewportBox.x, scroll.offset.x);
      translateAxis(viewportBox.y, scroll.offset.y);
    }
    return viewportBox;
  }
  const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  });
  const createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
  });
  const createAxis = () => ({ min: 0, max: 0 });
  const createBox = () => ({
    x: createAxis(),
    y: createAxis()
  });
  const prefersReducedMotion = { current: null };
  const hasReducedMotionListener = { current: false };
  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser)
      return;
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
      const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  }
  const visualElementStore = /* @__PURE__ */ new WeakMap();
  function updateMotionValuesFromProps(element2, next, prev) {
    for (const key in next) {
      const nextValue = next[key];
      const prevValue = prev[key];
      if (isMotionValue(nextValue)) {
        element2.addValue(key, nextValue);
      } else if (isMotionValue(prevValue)) {
        element2.addValue(key, motionValue(nextValue, { owner: element2 }));
      } else if (prevValue !== nextValue) {
        if (element2.hasValue(key)) {
          const existingValue = element2.getValue(key);
          if (existingValue.liveStyle === true) {
            existingValue.jump(nextValue);
          } else if (!existingValue.hasAnimated) {
            existingValue.set(nextValue);
          }
        } else {
          const latestValue = element2.getStaticValue(key);
          element2.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element2 }));
        }
      }
    }
    for (const key in prev) {
      if (next[key] === void 0)
        element2.removeValue(key);
    }
    return next;
  }
  const propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ];
  class VisualElement {
    /**
     * This method takes React props and returns found MotionValues. For example, HTML
     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
     *
     * This isn't an abstract method as it needs calling in the constructor, but it is
     * intended to be one.
     */
    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
      return {};
    }
    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options2 = {}) {
      this.current = null;
      this.children = /* @__PURE__ */ new Set();
      this.isVariantNode = false;
      this.isControllingVariants = false;
      this.shouldReduceMotion = null;
      this.values = /* @__PURE__ */ new Map();
      this.KeyframeResolver = KeyframeResolver;
      this.features = {};
      this.valueSubscriptions = /* @__PURE__ */ new Map();
      this.prevMotionValues = {};
      this.events = {};
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify("Update", this.latestValues);
      this.render = () => {
        if (!this.current)
          return;
        this.triggerBuild();
        this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
      };
      this.renderScheduledAt = 0;
      this.scheduleRender = () => {
        const now2 = time.now();
        if (this.renderScheduledAt < now2) {
          this.renderScheduledAt = now2;
          frame.render(this.render, false, true);
        }
      };
      const { latestValues, renderState } = visualState;
      this.latestValues = latestValues;
      this.baseTarget = { ...latestValues };
      this.initialValues = props.initial ? { ...latestValues } : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.options = options2;
      this.blockInitialAnimation = Boolean(blockInitialAnimation);
      this.isControllingVariants = isControllingVariants(props);
      this.isVariantNode = isVariantNode(props);
      if (this.isVariantNode) {
        this.variantChildren = /* @__PURE__ */ new Set();
      }
      this.manuallyAnimateOnMount = Boolean(parent && parent.current);
      const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
      for (const key in initialMotionValues) {
        const value = initialMotionValues[key];
        if (latestValues[key] !== void 0 && isMotionValue(value)) {
          value.set(latestValues[key]);
        }
      }
    }
    mount(instance) {
      var _a2;
      this.current = instance;
      visualElementStore.set(instance, this);
      if (this.projection && !this.projection.instance) {
        this.projection.mount(instance);
      }
      if (this.parent && this.isVariantNode && !this.isControllingVariants) {
        this.removeFromVariantTree = this.parent.addVariantChild(this);
      }
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
      (_a2 = this.parent) == null ? void 0 : _a2.addChild(this);
      this.update(this.props, this.presenceContext);
    }
    unmount() {
      var _a2;
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach((remove) => remove());
      this.valueSubscriptions.clear();
      this.removeFromVariantTree && this.removeFromVariantTree();
      (_a2 = this.parent) == null ? void 0 : _a2.removeChild(this);
      for (const key in this.events) {
        this.events[key].clear();
      }
      for (const key in this.features) {
        const feature = this.features[key];
        if (feature) {
          feature.unmount();
          feature.isMounted = false;
        }
      }
      this.current = null;
    }
    addChild(child) {
      this.children.add(child);
      this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set());
      this.enteringChildren.add(child);
    }
    removeChild(child) {
      this.children.delete(child);
      this.enteringChildren && this.enteringChildren.delete(child);
    }
    bindToMotionValue(key, value) {
      if (this.valueSubscriptions.has(key)) {
        this.valueSubscriptions.get(key)();
      }
      const valueIsTransform = transformProps.has(key);
      if (valueIsTransform && this.onBindTransform) {
        this.onBindTransform();
      }
      const removeOnChange = value.on("change", (latestValue) => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame.preRender(this.notifyUpdate);
        if (valueIsTransform && this.projection) {
          this.projection.isTransformDirty = true;
        }
        this.scheduleRender();
      });
      let removeSyncCheck;
      if (window.MotionCheckAppearSync) {
        removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
      }
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        if (removeSyncCheck)
          removeSyncCheck();
        if (value.owner)
          value.stop();
      });
    }
    sortNodePosition(other) {
      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
        return 0;
      }
      return this.sortInstanceNodePosition(this.current, other.current);
    }
    updateFeatures() {
      let key = "animation";
      for (key in featureDefinitions) {
        const featureDefinition = featureDefinitions[key];
        if (!featureDefinition)
          continue;
        const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
        if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
          this.features[key] = new FeatureConstructor(this);
        }
        if (this.features[key]) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
    /**
     * Measure the current viewport box with or without transforms.
     * Only measures axis-aligned boxes, rotate and skew must be manually
     * removed with a re-render to work.
     */
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
    /**
     * Update the provided props. Ensure any newly-added motion values are
     * added to our map, old ones removed, and listeners updated.
     */
    update(props, presenceContext) {
      if (props.transformTemplate || this.props.transformTemplate) {
        this.scheduleRender();
      }
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      for (let i = 0; i < propEventHandlers.length; i++) {
        const key = propEventHandlers[i];
        if (this.propEventSubscriptions[key]) {
          this.propEventSubscriptions[key]();
          delete this.propEventSubscriptions[key];
        }
        const listenerName = "on" + key;
        const listener = props[listenerName];
        if (listener) {
          this.propEventSubscriptions[key] = this.on(key, listener);
        }
      }
      this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
      if (this.handleChildMotionValue) {
        this.handleChildMotionValue();
      }
    }
    getProps() {
      return this.props;
    }
    /**
     * Returns the variant definition with a given name.
     */
    getVariant(name2) {
      return this.props.variants ? this.props.variants[name2] : void 0;
    }
    /**
     * Returns the defined default transition on this component.
     */
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
    /**
     * Add a child visual element to our set of children.
     */
    addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    }
    /**
     * Add a motion value and bind it to this visual element.
     */
    addValue(key, value) {
      const existingValue = this.values.get(key);
      if (value !== existingValue) {
        if (existingValue)
          this.removeValue(key);
        this.bindToMotionValue(key, value);
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
    }
    /**
     * Remove a motion value and unbind any active subscriptions.
     */
    removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      if (unsubscribe) {
        unsubscribe();
        this.valueSubscriptions.delete(key);
      }
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
    /**
     * Check whether we have a motion value for this key
     */
    hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      if (value === void 0 && defaultValue !== void 0) {
        value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
        this.addValue(key, value);
      }
      return value;
    }
    /**
     * If we're trying to animate to a previously unencountered value,
     * we need to check for it in our state and as a last resort read it
     * directly from the instance (which might have performance implications).
     */
    readValue(key, target) {
      let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
      if (value !== void 0 && value !== null) {
        if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(target)) {
          value = getAnimatableNone(key, target);
        }
        this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
      }
      return isMotionValue(value) ? value.get() : value;
    }
    /**
     * Set the base target to later animate back to. This is currently
     * only hydrated on creation and when we first read a value.
     */
    setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
    /**
     * Find the base target for a value thats been removed from all animation
     * props.
     */
    getBaseTarget(key) {
      var _a2;
      const { initial } = this.props;
      let valueFromInitial;
      if (typeof initial === "string" || typeof initial === "object") {
        const variant = resolveVariantFromProps(this.props, initial, (_a2 = this.presenceContext) == null ? void 0 : _a2.custom);
        if (variant) {
          valueFromInitial = variant[key];
        }
      }
      if (initial && valueFromInitial !== void 0) {
        return valueFromInitial;
      }
      const target = this.getBaseTargetFromProps(this.props, key);
      if (target !== void 0 && !isMotionValue(target))
        return target;
      return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      if (this.events[eventName]) {
        this.events[eventName].notify(...args);
      }
    }
    scheduleRenderMicrotask() {
      microtask.render(this.render);
    }
  }
  class DOMVisualElement extends VisualElement {
    constructor() {
      super(...arguments);
      this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a, b) {
      return a.compareDocumentPosition(b) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      return props.style ? props.style[key] : void 0;
    }
    removeValueFromRenderState(key, { vars, style }) {
      delete vars[key];
      delete style[key];
    }
    handleChildMotionValue() {
      if (this.childSubscription) {
        this.childSubscription();
        delete this.childSubscription;
      }
      const { children } = this.props;
      if (isMotionValue(children)) {
        this.childSubscription = children.on("change", (latest) => {
          if (this.current) {
            this.current.textContent = `${latest}`;
          }
        });
      }
    }
  }
  function renderHTML(element2, { style, vars }, styleProp, projection) {
    const elementStyle = element2.style;
    let key;
    for (key in style) {
      elementStyle[key] = style[key];
    }
    projection == null ? void 0 : projection.applyProjectionStyles(elementStyle, styleProp);
    for (key in vars) {
      elementStyle.setProperty(key, vars[key]);
    }
  }
  function getComputedStyle$1(element2) {
    return window.getComputedStyle(element2);
  }
  class HTMLVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "html";
      this.renderInstance = renderHTML;
    }
    readValueFromInstance(instance, key) {
      var _a2;
      if (transformProps.has(key)) {
        return ((_a2 = this.projection) == null ? void 0 : _a2.isProjecting) ? defaultTransformValue(key) : readTransformValue(instance, key);
      } else {
        const computedStyle = getComputedStyle$1(instance);
        const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
        return typeof value === "string" ? value.trim() : value;
      }
    }
    measureInstanceViewportBox(instance, { transformPagePoint }) {
      return measureViewportBox(instance, transformPagePoint);
    }
    build(renderState, latestValues, props) {
      buildHTMLStyles(renderState, latestValues, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    }
  }
  const camelCaseAttributes = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust"
  ]);
  function renderSVG(element2, renderState, _styleProp, projection) {
    renderHTML(element2, renderState, void 0, projection);
    for (const key in renderState.attrs) {
      element2.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
  }
  class SVGVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.isSVGTag = false;
      this.measureInstanceViewportBox = createBox;
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      }
      key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
      return instance.getAttribute(key);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
    build(renderState, latestValues, props) {
      buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
      this.isSVGTag = isSVGTag(instance.tagName);
      super.mount(instance);
    }
  }
  const createDomVisualElement = (Component2, options2) => {
    return isSVGComponent(Component2) ? new SVGVisualElement(options2) : new HTMLVisualElement(options2, {
      allowProjection: Component2 !== reactExports.Fragment
    });
  };
  function resolveVariant(visualElement, definition2, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition2, custom !== void 0 ? custom : props.custom, visualElement);
  }
  const isKeyframesTarget = (v) => {
    return Array.isArray(v);
  };
  function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
      visualElement.getValue(key).set(value);
    } else {
      visualElement.addValue(key, motionValue(value));
    }
  }
  function resolveFinalValueInKeyframes(v) {
    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
  }
  function setTarget(visualElement, definition2) {
    const resolved = resolveVariant(visualElement, definition2);
    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
    target = { ...target, ...transitionEnd };
    for (const key in target) {
      const value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement, key, value);
    }
  }
  function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
  }
  function addValueToWillChange(visualElement, key) {
    const willChange = visualElement.getValue("willChange");
    if (isWillChangeMotionValue(willChange)) {
      return willChange.add(key);
    } else if (!willChange && MotionGlobalConfig.WillChange) {
      const newWillChange = new MotionGlobalConfig.WillChange("auto");
      visualElement.addValue("willChange", newWillChange);
      newWillChange.add(key);
    }
  }
  function getOptimisedAppearId(visualElement) {
    return visualElement.props[optimizedAppearDataAttribute];
  }
  const isNotNull = (value) => value !== null;
  function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
    const resolvedKeyframes = keyframes2.filter(isNotNull);
    const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
    return resolvedKeyframes[index2];
  }
  const underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
  const criticallyDampedSpring = (target) => ({
    type: "spring",
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  });
  const keyframesTransition = {
    type: "keyframes",
    duration: 0.8
  };
  const ease = {
    type: "keyframes",
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3
  };
  const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
    if (keyframes2.length > 2) {
      return keyframesTransition;
    } else if (transformProps.has(valueKey)) {
      return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
    }
    return ease;
  };
  function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
    return !!Object.keys(transition).length;
  }
  const animateMotionValue = (name2, value, target, transition = {}, element2, isHandoff) => (onComplete) => {
    const valueTransition = getValueTransition(transition, name2) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - /* @__PURE__ */ secondsToMilliseconds(delay2);
    const options2 = {
      keyframes: Array.isArray(target) ? target : [null, target],
      ease: "easeOut",
      velocity: value.getVelocity(),
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v) => {
        value.set(v);
        valueTransition.onUpdate && valueTransition.onUpdate(v);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      },
      name: name2,
      motionValue: value,
      element: isHandoff ? void 0 : element2
    };
    if (!isTransitionDefined(valueTransition)) {
      Object.assign(options2, getDefaultTransition(name2, options2));
    }
    options2.duration && (options2.duration = /* @__PURE__ */ secondsToMilliseconds(options2.duration));
    options2.repeatDelay && (options2.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(options2.repeatDelay));
    if (options2.from !== void 0) {
      options2.keyframes[0] = options2.from;
    }
    let shouldSkip2 = false;
    if (options2.type === false || options2.duration === 0 && !options2.repeatDelay) {
      makeAnimationInstant(options2);
      if (options2.delay === 0) {
        shouldSkip2 = true;
      }
    }
    if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
      shouldSkip2 = true;
      makeAnimationInstant(options2);
      options2.delay = 0;
    }
    options2.allowFlatten = !valueTransition.type && !valueTransition.ease;
    if (shouldSkip2 && !isHandoff && value.get() !== void 0) {
      const finalKeyframe = getFinalKeyframe(options2.keyframes, valueTransition);
      if (finalKeyframe !== void 0) {
        frame.update(() => {
          options2.onUpdate(finalKeyframe);
          options2.onComplete();
        });
        return;
      }
    }
    return valueTransition.isSync ? new JSAnimation(options2) : new AsyncMotionValueAnimation(options2);
  };
  function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }
  function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
    if (transitionOverride)
      transition = transitionOverride;
    const animations2 = [];
    const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
    for (const key in target) {
      const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
      const valueTarget = target[key];
      if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
        continue;
      }
      const valueTransition = {
        delay: delay2,
        ...getValueTransition(transition || {}, key)
      };
      const currentValue = value.get();
      if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
        continue;
      }
      let isHandoff = false;
      if (window.MotionHandoffAnimation) {
        const appearId = getOptimisedAppearId(visualElement);
        if (appearId) {
          const startTime = window.MotionHandoffAnimation(appearId, key, frame);
          if (startTime !== null) {
            valueTransition.startTime = startTime;
            isHandoff = true;
          }
        }
      }
      addValueToWillChange(visualElement, key);
      value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
      const animation = value.animation;
      if (animation) {
        animations2.push(animation);
      }
    }
    if (transitionEnd) {
      Promise.all(animations2).then(() => {
        frame.update(() => {
          transitionEnd && setTarget(visualElement, transitionEnd);
        });
      });
    }
    return animations2;
  }
  function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
    const index2 = Array.from(children).sort((a, b) => a.sortNodePosition(b)).indexOf(child);
    const numChildren = children.size;
    const maxStaggerDuration = (numChildren - 1) * staggerChildren;
    const delayIsFunction = typeof delayChildren === "function";
    return delayIsFunction ? delayChildren(index2, numChildren) : staggerDirection === 1 ? index2 * staggerChildren : maxStaggerDuration - index2 * staggerChildren;
  }
  function animateVariant(visualElement, variant, options2 = {}) {
    var _a2;
    const resolved = resolveVariant(visualElement, variant, options2.type === "exit" ? (_a2 = visualElement.presenceContext) == null ? void 0 : _a2.custom : void 0);
    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options2.transitionOverride) {
      transition = options2.transitionOverride;
    }
    const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options2)) : () => Promise.resolve();
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
      const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
      return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options2);
    } : () => Promise.resolve();
    const { when } = transition;
    if (when) {
      const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
      return first().then(() => last());
    } else {
      return Promise.all([getAnimation(), getChildAnimations(options2.delay)]);
    }
  }
  function animateChildren(visualElement, variant, delay2 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options2) {
    const animations2 = [];
    for (const child of visualElement.variantChildren) {
      child.notify("AnimationStart", variant);
      animations2.push(animateVariant(child, variant, {
        ...options2,
        delay: delay2 + (typeof delayChildren === "function" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)
      }).then(() => child.notify("AnimationComplete", variant)));
    }
    return Promise.all(animations2);
  }
  function animateVisualElement(visualElement, definition2, options2 = {}) {
    visualElement.notify("AnimationStart", definition2);
    let animation;
    if (Array.isArray(definition2)) {
      const animations2 = definition2.map((variant) => animateVariant(visualElement, variant, options2));
      animation = Promise.all(animations2);
    } else if (typeof definition2 === "string") {
      animation = animateVariant(visualElement, definition2, options2);
    } else {
      const resolvedDefinition = typeof definition2 === "function" ? resolveVariant(visualElement, definition2, options2.custom) : definition2;
      animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options2));
    }
    return animation.then(() => {
      visualElement.notify("AnimationComplete", definition2);
    });
  }
  function shallowCompare(next, prev) {
    if (!Array.isArray(prev))
      return false;
    const prevLength = prev.length;
    if (prevLength !== next.length)
      return false;
    for (let i = 0; i < prevLength; i++) {
      if (prev[i] !== next[i])
        return false;
    }
    return true;
  }
  const numVariantProps = variantProps.length;
  function getVariantContext(visualElement) {
    if (!visualElement)
      return void 0;
    if (!visualElement.isControllingVariants) {
      const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
      if (visualElement.props.initial !== void 0) {
        context2.initial = visualElement.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name2 = variantProps[i];
      const prop = visualElement.props[name2];
      if (isVariantLabel(prop) || prop === false) {
        context[name2] = prop;
      }
    }
    return context;
  }
  const reversePriorityOrder = [...variantPriorityOrder].reverse();
  const numAnimationTypes = variantPriorityOrder.length;
  function animateList(visualElement) {
    return (animations2) => Promise.all(animations2.map(({ animation, options: options2 }) => animateVisualElement(visualElement, animation, options2)));
  }
  function createAnimationState(visualElement) {
    let animate = animateList(visualElement);
    let state = createState();
    let isInitialRender = true;
    const buildResolvedTypeValues = (type) => (acc, definition2) => {
      var _a2;
      const resolved = resolveVariant(visualElement, definition2, type === "exit" ? (_a2 = visualElement.presenceContext) == null ? void 0 : _a2.custom : void 0);
      if (resolved) {
        const { transition, transitionEnd, ...target } = resolved;
        acc = { ...acc, ...target, ...transitionEnd };
      }
      return acc;
    };
    function setAnimateFunction(makeAnimator) {
      animate = makeAnimator(visualElement);
    }
    function animateChanges(changedActiveType) {
      const { props } = visualElement;
      const context = getVariantContext(visualElement.parent) || {};
      const animations2 = [];
      const removedKeys = /* @__PURE__ */ new Set();
      let encounteredKeys = {};
      let removedVariantIndex = Infinity;
      for (let i = 0; i < numAnimationTypes; i++) {
        const type = reversePriorityOrder[i];
        const typeState = state[type];
        const prop = props[type] !== void 0 ? props[type] : context[type];
        const propIsVariant = isVariantLabel(prop);
        const activeDelta = type === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false)
          removedVariantIndex = i;
        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
          isInherited = false;
        }
        typeState.protectedKeys = { ...encounteredKeys };
        if (
          // If it isn't active and hasn't *just* been set as inactive
          !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
          !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
          isAnimationControls(prop) || typeof prop === "boolean"
        ) {
          continue;
        }
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
        type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
        i > removedVariantIndex && propIsVariant;
        let handledRemovedValues = false;
        const definitionList = Array.isArray(prop) ? prop : [prop];
        let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
        if (activeDelta === false)
          resolvedValues = {};
        const { prevResolvedValues = {} } = typeState;
        const allKeys = {
          ...prevResolvedValues,
          ...resolvedValues
        };
        const markToAnimate = (key) => {
          shouldAnimateType = true;
          if (removedKeys.has(key)) {
            handledRemovedValues = true;
            removedKeys.delete(key);
          }
          typeState.needsAnimating[key] = true;
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = false;
        };
        for (const key in allKeys) {
          const next = resolvedValues[key];
          const prev = prevResolvedValues[key];
          if (encounteredKeys.hasOwnProperty(key))
            continue;
          let valueHasChanged = false;
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            valueHasChanged = !shallowCompare(next, prev);
          } else {
            valueHasChanged = next !== prev;
          }
          if (valueHasChanged) {
            if (next !== void 0 && next !== null) {
              markToAnimate(key);
            } else {
              removedKeys.add(key);
            }
          } else if (next !== void 0 && removedKeys.has(key)) {
            markToAnimate(key);
          } else {
            typeState.protectedKeys[key] = true;
          }
        }
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        if (typeState.isActive) {
          encounteredKeys = { ...encounteredKeys, ...resolvedValues };
        }
        if (isInitialRender && visualElement.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        const willAnimateViaParent = isInherited && variantDidChange;
        const needsAnimating = !willAnimateViaParent || handledRemovedValues;
        if (shouldAnimateType && needsAnimating) {
          animations2.push(...definitionList.map((animation) => {
            const options2 = { type };
            if (typeof animation === "string" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {
              const { parent } = visualElement;
              const parentVariant = resolveVariant(parent, animation);
              if (parent.enteringChildren && parentVariant) {
                const { delayChildren } = parentVariant.transition || {};
                options2.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);
              }
            }
            return {
              animation,
              options: options2
            };
          }));
        }
      }
      if (removedKeys.size) {
        const fallbackAnimation = {};
        if (typeof props.initial !== "boolean") {
          const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
          if (initialTransition && initialTransition.transition) {
            fallbackAnimation.transition = initialTransition.transition;
          }
        }
        removedKeys.forEach((key) => {
          const fallbackTarget = visualElement.getBaseTarget(key);
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = true;
          fallbackAnimation[key] = fallbackTarget ?? null;
        });
        animations2.push({ animation: fallbackAnimation });
      }
      let shouldAnimate = Boolean(animations2.length);
      if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate(animations2) : Promise.resolve();
    }
    function setActive(type, isActive) {
      var _a2;
      if (state[type].isActive === isActive)
        return Promise.resolve();
      (_a2 = visualElement.variantChildren) == null ? void 0 : _a2.forEach((child) => {
        var _a3;
        return (_a3 = child.animationState) == null ? void 0 : _a3.setActive(type, isActive);
      });
      state[type].isActive = isActive;
      const animations2 = animateChanges(type);
      for (const key in state) {
        state[key].protectedKeys = {};
      }
      return animations2;
    }
    return {
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: () => state,
      reset: () => {
        state = createState();
      }
    };
  }
  function checkVariantsDidChange(prev, next) {
    if (typeof next === "string") {
      return next !== prev;
    } else if (Array.isArray(next)) {
      return !shallowCompare(next, prev);
    }
    return false;
  }
  function createTypeState(isActive = false) {
    return {
      isActive,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function createState() {
    return {
      animate: createTypeState(true),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState()
    };
  }
  class Feature {
    constructor(node2) {
      this.isMounted = false;
      this.node = node2;
    }
    update() {
    }
  }
  class AnimationFeature extends Feature {
    /**
     * We dynamically generate the AnimationState manager as it contains a reference
     * to the underlying animation library. We only want to load that if we load this,
     * so people can optionally code split it out using the `m` component.
     */
    constructor(node2) {
      super(node2);
      node2.animationState || (node2.animationState = createAnimationState(node2));
    }
    updateAnimationControlsSubscription() {
      const { animate } = this.node.getProps();
      if (isAnimationControls(animate)) {
        this.unmountControls = animate.subscribe(this.node);
      }
    }
    /**
     * Subscribe any provided AnimationControls to the component's VisualElement
     */
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate } = this.node.getProps();
      const { animate: prevAnimate } = this.node.prevProps || {};
      if (animate !== prevAnimate) {
        this.updateAnimationControlsSubscription();
      }
    }
    unmount() {
      var _a2;
      this.node.animationState.reset();
      (_a2 = this.unmountControls) == null ? void 0 : _a2.call(this);
    }
  }
  let id$1 = 0;
  class ExitAnimationFeature extends Feature {
    constructor() {
      super(...arguments);
      this.id = id$1++;
    }
    update() {
      if (!this.node.presenceContext)
        return;
      const { isPresent, onExitComplete } = this.node.presenceContext;
      const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || isPresent === prevIsPresent) {
        return;
      }
      const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
      if (onExitComplete && !isPresent) {
        exitAnimation.then(() => {
          onExitComplete(this.id);
        });
      }
    }
    mount() {
      const { register, onExitComplete } = this.node.presenceContext || {};
      if (onExitComplete) {
        onExitComplete(this.id);
      }
      if (register) {
        this.unmount = register(this.id);
      }
    }
    unmount() {
    }
  }
  const animations = {
    animation: {
      Feature: AnimationFeature
    },
    exit: {
      Feature: ExitAnimationFeature
    }
  };
  function addDomEvent(target, eventName, handler, options2 = { passive: true }) {
    target.addEventListener(eventName, handler, options2);
    return () => target.removeEventListener(eventName, handler);
  }
  function extractEventInfo(event) {
    return {
      point: {
        x: event.pageX,
        y: event.pageY
      }
    };
  }
  const addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
  };
  function addPointerEvent(target, eventName, handler, options2) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options2);
  }
  const SCALE_PRECISION = 1e-4;
  const SCALE_MIN = 1 - SCALE_PRECISION;
  const SCALE_MAX = 1 + SCALE_PRECISION;
  const TRANSLATE_PRECISION = 0.01;
  const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
  const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target, maxDistance) {
    return Math.abs(value - target) <= maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin2 = 0.5) {
    delta.origin = origin2;
    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
    if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
      delta.scale = 1;
    }
    if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
      delta.translate = 0;
    }
  }
  function calcBoxDelta(delta, source, target, origin2) {
    calcAxisDelta(delta.x, source.x, target.x, origin2 ? origin2.originX : void 0);
    calcAxisDelta(delta.y, source.y, target.y, origin2 ? origin2.originY : void 0);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout2, parent) {
    target.min = layout2.min - parent.min;
    target.max = target.min + calcLength(layout2);
  }
  function calcRelativePosition(target, layout2, parent) {
    calcRelativeAxisPosition(target.x, layout2.x, parent.x);
    calcRelativeAxisPosition(target.y, layout2.y, parent.y);
  }
  function eachAxis(callback) {
    return [callback("x"), callback("y")];
  }
  const getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
  };
  const distance = (a, b) => Math.abs(a - b);
  function distance2D(a, b) {
    const xDelta = distance(a.x, b.x);
    const yDelta = distance(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }
  class PanSession {
    constructor(event, handlers2, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3 } = {}) {
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.contextWindow = window;
      this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
        const isPanStarted = this.startEvent !== null;
        const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        const { point: point3 } = info2;
        const { timestamp: timestamp2 } = frameData;
        this.history.push({ ...point3, timestamp: timestamp2 });
        const { onStart, onMove } = this.handlers;
        if (!isPanStarted) {
          onStart && onStart(this.lastMoveEvent, info2);
          this.startEvent = this.lastMoveEvent;
        }
        onMove && onMove(this.lastMoveEvent, info2);
      };
      this.handlePointerMove = (event2, info2) => {
        this.lastMoveEvent = event2;
        this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
        frame.update(this.updatePoint, true);
      };
      this.handlePointerUp = (event2, info2) => {
        this.end();
        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
        if (this.dragSnapToOrigin)
          resumeAnimation && resumeAnimation();
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
        if (this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (!isPrimaryPointer(event))
        return;
      this.dragSnapToOrigin = dragSnapToOrigin;
      this.handlers = handlers2;
      this.transformPagePoint = transformPagePoint;
      this.distanceThreshold = distanceThreshold;
      this.contextWindow = contextWindow || window;
      const info = extractEventInfo(event);
      const initialInfo = transformPoint(info, this.transformPagePoint);
      const { point: point2 } = initialInfo;
      const { timestamp } = frameData;
      this.history = [{ ...point2, timestamp }];
      const { onSessionStart } = handlers2;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
    }
    updateHandlers(handlers2) {
      this.handlers = handlers2;
    }
    end() {
      this.removeListeners && this.removeListeners();
      cancelFrame(this.updatePoint);
    }
  }
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
  }
  function subtractPoint(a, b) {
    return { x: a.x - b.x, y: a.y - b.y };
  }
  function getPanInfo({ point: point2 }, history) {
    return {
      point: point2,
      delta: subtractPoint(point2, lastDevicePoint(history)),
      offset: subtractPoint(point2, startDevicePoint(history)),
      velocity: getVelocity(history, 0.1)
    };
  }
  function startDevicePoint(history) {
    return history[0];
  }
  function lastDevicePoint(history) {
    return history[history.length - 1];
  }
  function getVelocity(history, timeDelta) {
    if (history.length < 2) {
      return { x: 0, y: 0 };
    }
    let i = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while (i >= 0) {
      timestampedPoint = history[i];
      if (lastPoint.timestamp - timestampedPoint.timestamp > /* @__PURE__ */ secondsToMilliseconds(timeDelta)) {
        break;
      }
      i--;
    }
    if (!timestampedPoint) {
      return { x: 0, y: 0 };
    }
    const time2 = /* @__PURE__ */ millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time2 === 0) {
      return { x: 0, y: 0 };
    }
    const currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time2,
      y: (lastPoint.y - timestampedPoint.y) / time2
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  }
  function applyConstraints(point2, { min: min2, max: max2 }, elastic) {
    if (min2 !== void 0 && point2 < min2) {
      point2 = elastic ? mixNumber$1(min2, point2, elastic.min) : Math.max(point2, min2);
    } else if (max2 !== void 0 && point2 > max2) {
      point2 = elastic ? mixNumber$1(max2, point2, elastic.max) : Math.min(point2, max2);
    }
    return point2;
  }
  function calcRelativeAxisConstraints(axis, min2, max2) {
    return {
      min: min2 !== void 0 ? axis.min + min2 : void 0,
      max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
    };
  }
  function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left, right),
      y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
    };
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min2 = constraintsAxis.min - layoutAxis.min;
    let max2 = constraintsAxis.max - layoutAxis.max;
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      [min2, max2] = [max2, min2];
    }
    return { min: min2, max: max2 };
  }
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
    };
  }
  function calcOrigin(source, target) {
    let origin2 = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin2 = /* @__PURE__ */ progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin2 = /* @__PURE__ */ progress(source.min, source.max - targetLength, target.min);
    }
    return clamp(0, 1, origin2);
  }
  function rebaseAxisConstraints(layout2, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== void 0) {
      relativeConstraints.min = constraints.min - layout2.min;
    }
    if (constraints.max !== void 0) {
      relativeConstraints.max = constraints.max - layout2.min;
    }
    return relativeConstraints;
  }
  const defaultElastic = 0.35;
  function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, "left", "right"),
      y: resolveAxisElastic(dragElastic, "top", "bottom")
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel)
    };
  }
  function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
  }
  const elementDragControls = /* @__PURE__ */ new WeakMap();
  class VisualElementDragControls {
    constructor(visualElement) {
      this.openDragLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.latestPointerEvent = null;
      this.latestPanInfo = null;
      this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
      const { presenceContext } = this.visualElement;
      if (presenceContext && presenceContext.isPresent === false)
        return;
      const onSessionStart = (event) => {
        const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
        dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
        if (snapToCursor) {
          this.snapToCursor(extractEventInfo(event).point);
        }
      };
      const onStart = (event, info) => {
        const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
        if (drag2 && !dragPropagation) {
          if (this.openDragLock)
            this.openDragLock();
          this.openDragLock = setDragLock(drag2);
          if (!this.openDragLock)
            return;
        }
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.isDragging = true;
        this.currentDirection = null;
        this.resolveConstraints();
        if (this.visualElement.projection) {
          this.visualElement.projection.isAnimationBlocked = true;
          this.visualElement.projection.target = void 0;
        }
        eachAxis((axis) => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            const { projection } = this.visualElement;
            if (projection && projection.layout) {
              const measuredAxis = projection.layout.layoutBox[axis];
              if (measuredAxis) {
                const length = calcLength(measuredAxis);
                current = length * (parseFloat(current) / 100);
              }
            }
          }
          this.originPoint[axis] = current;
        });
        if (onDragStart) {
          frame.postRender(() => onDragStart(event, info));
        }
        addValueToWillChange(this.visualElement, "transform");
        const { animationState } = this.visualElement;
        animationState && animationState.setActive("whileDrag", true);
      };
      const onMove = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
        if (!dragPropagation && !this.openDragLock)
          return;
        const { offset: offset2 } = info;
        if (dragDirectionLock && this.currentDirection === null) {
          this.currentDirection = getCurrentDirection(offset2);
          if (this.currentDirection !== null) {
            onDirectionLock && onDirectionLock(this.currentDirection);
          }
          return;
        }
        this.updateAxis("x", info.point, offset2);
        this.updateAxis("y", info.point, offset2);
        this.visualElement.render();
        onDrag && onDrag(event, info);
      };
      const onSessionEnd = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.stop(event, info);
        this.latestPointerEvent = null;
        this.latestPanInfo = null;
      };
      const resumeAnimation = () => eachAxis((axis) => {
        var _a2;
        return this.getAnimationState(axis) === "paused" && ((_a2 = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a2.play());
      });
      const { dragSnapToOrigin } = this.getProps();
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        distanceThreshold,
        contextWindow: getContextWindow(this.visualElement)
      });
    }
    /**
     * @internal
     */
    stop(event, panInfo) {
      const finalEvent = event || this.latestPointerEvent;
      const finalPanInfo = panInfo || this.latestPanInfo;
      const isDragging2 = this.isDragging;
      this.cancel();
      if (!isDragging2 || !finalPanInfo || !finalEvent)
        return;
      const { velocity } = finalPanInfo;
      this.startAnimation(velocity);
      const { onDragEnd } = this.getProps();
      if (onDragEnd) {
        frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
      }
    }
    /**
     * @internal
     */
    cancel() {
      this.isDragging = false;
      const { projection, animationState } = this.visualElement;
      if (projection) {
        projection.isAnimationBlocked = false;
      }
      this.panSession && this.panSession.end();
      this.panSession = void 0;
      const { dragPropagation } = this.getProps();
      if (!dragPropagation && this.openDragLock) {
        this.openDragLock();
        this.openDragLock = null;
      }
      animationState && animationState.setActive("whileDrag", false);
    }
    updateAxis(axis, _point, offset2) {
      const { drag: drag2 } = this.getProps();
      if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      let next = this.originPoint[axis] + offset2[axis];
      if (this.constraints && this.constraints[axis]) {
        next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next);
    }
    resolveConstraints() {
      var _a2;
      const { dragConstraints, dragElastic } = this.getProps();
      const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a2 = this.visualElement.projection) == null ? void 0 : _a2.layout;
      const prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout2) {
          this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
        eachAxis((axis) => {
          if (this.constraints !== false && this.getAxisMotionValue(axis)) {
            this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
          }
        });
      }
    }
    resolveRefConstraints() {
      const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
      if (!constraints || !isRefObject(constraints))
        return false;
      const constraintsElement = constraints.current;
      const { projection } = this.visualElement;
      if (!projection || !projection.layout)
        return false;
      const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
      if (onMeasureDragConstraints) {
        const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    }
    startAnimation(velocity) {
      const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
      const constraints = this.constraints || {};
      const momentumAnimations = eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, this.currentDirection)) {
          return;
        }
        let transition = constraints && constraints[axis] || {};
        if (dragSnapToOrigin)
          transition = { min: 0, max: 0 };
        const bounceStiffness = dragElastic ? 200 : 1e6;
        const bounceDamping = dragElastic ? 40 : 1e7;
        const inertia2 = {
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...dragTransition,
          ...transition
        };
        return this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
      const axisValue = this.getAxisMotionValue(axis);
      addValueToWillChange(this.visualElement, axis);
      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
    }
    stopAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
      eachAxis((axis) => {
        var _a2;
        return (_a2 = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a2.pause();
      });
    }
    getAnimationState(axis) {
      var _a2;
      return (_a2 = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a2.state;
    }
    /**
     * Drag works differently depending on which props are provided.
     *
     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
     * - Otherwise, we apply the delta to the x/y motion values.
     */
    getAxisMotionValue(axis) {
      const dragKey = `_drag${axis.toUpperCase()}`;
      const props = this.visualElement.getProps();
      const externalMotionValue = props[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
    }
    snapToCursor(point2) {
      eachAxis((axis) => {
        const { drag: drag2 } = this.getProps();
        if (!shouldDrag(axis, drag2, this.currentDirection))
          return;
        const { projection } = this.visualElement;
        const axisValue = this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
          axisValue.set(point2[axis] - mixNumber$1(min2, max2, 0.5));
        }
      });
    }
    /**
     * When the viewport resizes we want to check if the measured constraints
     * have changed and, if so, reposition the element within those new constraints
     * relative to where it was before the resize.
     */
    scalePositionWithinConstraints() {
      if (!this.visualElement.current)
        return;
      const { drag: drag2, dragConstraints } = this.getProps();
      const { projection } = this.visualElement;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      const boxProgress = { x: 0, y: 0 };
      eachAxis((axis) => {
        const axisValue = this.getAxisMotionValue(axis);
        if (axisValue && this.constraints !== false) {
          const latest = axisValue.get();
          boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
        }
      });
      const { transformTemplate } = this.visualElement.getProps();
      this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, null))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        const { min: min2, max: max2 } = this.constraints[axis];
        axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
      });
    }
    addListeners() {
      if (!this.visualElement.current)
        return;
      elementDragControls.set(this.visualElement, this);
      const element2 = this.visualElement.current;
      const stopPointerListener = addPointerEvent(element2, "pointerdown", (event) => {
        const { drag: drag2, dragListener = true } = this.getProps();
        drag2 && dragListener && this.start(event);
      });
      const measureDragConstraints = () => {
        const { dragConstraints } = this.getProps();
        if (isRefObject(dragConstraints) && dragConstraints.current) {
          this.constraints = this.resolveRefConstraints();
        }
      };
      const { projection } = this.visualElement;
      const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
      }
      frame.read(measureDragConstraints);
      const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
      const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          this.visualElement.render();
        }
      });
      return () => {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
        stopLayoutUpdateListener && stopLayoutUpdateListener();
      };
    }
    getProps() {
      const props = this.visualElement.getProps();
      const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
      return {
        ...props,
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      };
    }
  }
  function shouldDrag(direction, drag2, currentDirection) {
    return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
  }
  function getCurrentDirection(offset2, lockThreshold = 10) {
    let direction = null;
    if (Math.abs(offset2.y) > lockThreshold) {
      direction = "y";
    } else if (Math.abs(offset2.x) > lockThreshold) {
      direction = "x";
    }
    return direction;
  }
  class DragGesture extends Feature {
    constructor(node2) {
      super(node2);
      this.removeGroupControls = noop$2;
      this.removeListeners = noop$2;
      this.controls = new VisualElementDragControls(node2);
    }
    mount() {
      const { dragControls } = this.node.getProps();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
      this.removeListeners = this.controls.addListeners() || noop$2;
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
    }
  }
  const asyncHandler = (handler) => (event, info) => {
    if (handler) {
      frame.postRender(() => handler(event, info));
    }
  };
  class PanGesture extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = noop$2;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node)
      });
    }
    createPanHandlers() {
      const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(onPanSessionStart),
        onStart: asyncHandler(onPanStart),
        onMove: onPan,
        onEnd: (event, info) => {
          delete this.session;
          if (onPanEnd) {
            frame.postRender(() => onPanEnd(event, info));
          }
        }
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  }
  const globalProjectionState = {
    /**
     * Global flag as to whether the tree has animated since the last time
     * we resized the window
     */
    hasAnimatedSinceResize: true,
    /**
     * We set this to true once, on the first update. Any nodes added to the tree beyond that
     * update will be given a `data-projection-id` attribute.
     */
    hasEverUpdated: false
  };
  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min)
      return 0;
    return pixels / (axis.max - axis.min) * 100;
  }
  const correctBorderRadius = {
    correct: (latest, node2) => {
      if (!node2.target)
        return latest;
      if (typeof latest === "string") {
        if (px.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      const x = pixelsToPercent(latest, node2.target.x);
      const y = pixelsToPercent(latest, node2.target.y);
      return `${x}% ${y}%`;
    }
  };
  const correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
      const original = latest;
      const shadow = complex.parse(latest);
      if (shadow.length > 5)
        return original;
      const template = complex.createTransformer(latest);
      const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
      const xScale = projectionDelta.x.scale * treeScale.x;
      const yScale = projectionDelta.y.scale * treeScale.y;
      shadow[0 + offset2] /= xScale;
      shadow[1 + offset2] /= yScale;
      const averageScale = mixNumber$1(xScale, yScale, 0.5);
      if (typeof shadow[2 + offset2] === "number")
        shadow[2 + offset2] /= averageScale;
      if (typeof shadow[3 + offset2] === "number")
        shadow[3 + offset2] /= averageScale;
      return template(shadow);
    }
  };
  let hasTakenAnySnapshot = false;
  class MeasureLayoutWithContext extends reactExports.Component {
    /**
     * This only mounts projection nodes for components that
     * need measuring, we might want to do it for all components
     * in order to incorporate transforms
     */
    componentDidMount() {
      const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
      const { projection } = visualElement;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup.group)
          layoutGroup.group.add(projection);
        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
          switchLayoutGroup.register(projection);
        }
        if (hasTakenAnySnapshot) {
          projection.root.didUpdate();
        }
        projection.addEventListener("animationComplete", () => {
          this.safeToRemove();
        });
        projection.setOptions({
          ...projection.options,
          onExitComplete: () => this.safeToRemove()
        });
      }
      globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
      const { projection } = visualElement;
      if (!projection)
        return null;
      projection.isPresent = isPresent;
      hasTakenAnySnapshot = true;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          frame.postRender(() => {
            const stack = projection.getStack();
            if (!stack || !stack.members.length) {
              this.safeToRemove();
            }
          });
        }
      }
      return null;
    }
    componentDidUpdate() {
      const { projection } = this.props.visualElement;
      if (projection) {
        projection.root.didUpdate();
        microtask.postRender(() => {
          if (!projection.currentAnimation && projection.isLead()) {
            this.safeToRemove();
          }
        });
      }
    }
    componentWillUnmount() {
      const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
      const { projection } = visualElement;
      hasTakenAnySnapshot = true;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup && layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext && promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    }
    safeToRemove() {
      const { safeToRemove } = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  }
  function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence();
    const layoutGroup = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
  }
  const defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
  };
  function animateSingleValue(value, keyframes2, options2) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options2));
    return motionValue$1.animation;
  }
  const compareByDepth = (a, b) => a.depth - b.depth;
  class FlatTree {
    constructor() {
      this.children = [];
      this.isDirty = false;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    }
  }
  function delay(callback, timeout) {
    const start = time.now();
    const checkElapsed = ({ timestamp }) => {
      const elapsed = timestamp - start;
      if (elapsed >= timeout) {
        cancelFrame(checkElapsed);
        callback(elapsed - timeout);
      }
    };
    frame.setup(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
  }
  const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
  const numBorders = borders.length;
  const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
  const isPx = (value) => typeof value === "number" || px.test(value);
  function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
      target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
      target.opacityExit = mixNumber$1(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
    } else if (isOnlyMember) {
      target.opacity = mixNumber$1(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
    }
    for (let i = 0; i < numBorders; i++) {
      const borderLabel = `border${borders[i]}Radius`;
      let followRadius = getRadius(follow, borderLabel);
      let leadRadius = getRadius(lead, borderLabel);
      if (followRadius === void 0 && leadRadius === void 0)
        continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += "%";
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    if (follow.rotate || lead.rotate) {
      target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
    }
  }
  function getRadius(values, radiusName) {
    return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
  }
  const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
  const easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop$2);
  function compress(min2, max2, easing) {
    return (p) => {
      if (p < min2)
        return 0;
      if (p > max2)
        return 1;
      return easing(/* @__PURE__ */ progress(min2, max2, p));
    };
  }
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
  }
  function copyAxisDeltaInto(delta, originDelta) {
    delta.translate = originDelta.translate;
    delta.scale = originDelta.scale;
    delta.originPoint = originDelta.originPoint;
    delta.origin = originDelta.origin;
  }
  function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
    point2 -= translate;
    point2 = scalePoint(point2, 1 / scale2, originPoint);
    if (boxScale !== void 0) {
      point2 = scalePoint(point2, 1 / boxScale, originPoint);
    }
    return point2;
  }
  function removeAxisDelta(axis, translate = 0, scale2 = 1, origin2 = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number")
      return;
    let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin2);
    if (axis === originAxis)
      originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin2, sourceAxis) {
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin2, sourceAxis);
  }
  const xKeys = ["x", "scaleX", "originX"];
  const yKeys = ["y", "scaleY", "originY"];
  function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
  }
  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function axisEquals(a, b) {
    return a.min === b.min && a.max === b.max;
  }
  function boxEquals(a, b) {
    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
  }
  function axisEqualsRounded(a, b) {
    return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
  }
  function boxEqualsRounded(a, b) {
    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
  }
  function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
  }
  function axisDeltaEquals(a, b) {
    return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
  }
  class NodeStack {
    constructor() {
      this.members = [];
    }
    add(node2) {
      addUniqueItem(this.members, node2);
      node2.scheduleRender();
    }
    remove(node2) {
      removeItem(this.members, node2);
      if (node2 === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node2 === this.lead) {
        const prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    }
    relegate(node2) {
      const indexOfNode = this.members.findIndex((member) => node2 === member);
      if (indexOfNode === 0)
        return false;
      let prevLead;
      for (let i = indexOfNode; i >= 0; i--) {
        const member = this.members[i];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    }
    promote(node2, preserveFollowOpacity) {
      const prevLead = this.lead;
      if (node2 === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node2;
      node2.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node2.scheduleRender();
        node2.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node2.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node2.snapshot = prevLead.snapshot;
          node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        }
        if (node2.root && node2.root.isUpdating) {
          node2.isLayoutDirty = true;
        }
        const { crossfade } = node2.options;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    }
    exitAnimationComplete() {
      this.members.forEach((node2) => {
        const { options: options2, resumingFrom } = node2;
        options2.onExitComplete && options2.onExitComplete();
        if (resumingFrom) {
          resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
        }
      });
    }
    scheduleRender() {
      this.members.forEach((node2) => {
        node2.instance && node2.scheduleRender(false);
      });
    }
    /**
     * Clear any leads that have been removed this render to prevent them from being
     * used in future animations and to prevent memory leaks
     */
    removeLeadSnapshot() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    }
  }
  function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform = "";
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    const zTranslate = (latestTransform == null ? void 0 : latestTransform.z) || 0;
    if (xTranslate || yTranslate || zTranslate) {
      transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
    }
    if (treeScale.x !== 1 || treeScale.y !== 1) {
      transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
      const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
      if (transformPerspective)
        transform = `perspective(${transformPerspective}px) ${transform}`;
      if (rotate2)
        transform += `rotate(${rotate2}deg) `;
      if (rotateX)
        transform += `rotateX(${rotateX}deg) `;
      if (rotateY)
        transform += `rotateY(${rotateY}deg) `;
      if (skewX)
        transform += `skewX(${skewX}deg) `;
      if (skewY)
        transform += `skewY(${skewY}deg) `;
    }
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
      transform += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform || "none";
  }
  const transformAxes = ["", "X", "Y", "Z"];
  const animationTarget = 1e3;
  let id = 0;
  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const { latestValues } = visualElement;
    if (latestValues[key]) {
      values[key] = latestValues[key];
      visualElement.setStaticValue(key, 0);
      if (sharedAnimationValues) {
        sharedAnimationValues[key] = 0;
      }
    }
  }
  function cancelTreeOptimisedTransformAnimations(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = true;
    if (projectionNode.root === projectionNode)
      return;
    const { visualElement } = projectionNode.options;
    if (!visualElement)
      return;
    const appearId = getOptimisedAppearId(visualElement);
    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
      const { layout: layout2, layoutId } = projectionNode.options;
      window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
    }
    const { parent } = projectionNode;
    if (parent && !parent.hasCheckedOptimisedAppear) {
      cancelTreeOptimisedTransformAnimations(parent);
    }
  }
  function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
    return class ProjectionNode {
      constructor(latestValues = {}, parent = defaultParent == null ? void 0 : defaultParent()) {
        this.id = id++;
        this.animationId = 0;
        this.animationCommitId = 0;
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.isProjectionDirty = false;
        this.isSharedProjectionDirty = false;
        this.isTransformDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.hasCheckedOptimisedAppear = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.hasTreeAnimated = false;
        this.updateScheduled = false;
        this.scheduleUpdate = () => this.update();
        this.projectionUpdateScheduled = false;
        this.checkUpdateFailed = () => {
          if (this.isUpdating) {
            this.isUpdating = false;
            this.clearAllSnapshots();
          }
        };
        this.updateProjection = () => {
          this.projectionUpdateScheduled = false;
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
        };
        this.resolvedRelativeTargetAt = 0;
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [...parent.path, parent] : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        for (let i = 0; i < this.path.length; i++) {
          this.path[i].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      addEventListener(name2, handler) {
        if (!this.eventHandlers.has(name2)) {
          this.eventHandlers.set(name2, new SubscriptionManager());
        }
        return this.eventHandlers.get(name2).add(handler);
      }
      notifyListeners(name2, ...args) {
        const subscriptionManager = this.eventHandlers.get(name2);
        subscriptionManager && subscriptionManager.notify(...args);
      }
      hasListeners(name2) {
        return this.eventHandlers.has(name2);
      }
      /**
       * Lifecycles
       */
      mount(instance) {
        if (this.instance)
          return;
        this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
        this.instance = instance;
        const { layoutId, layout: layout2, visualElement } = this.options;
        if (visualElement && !visualElement.current) {
          visualElement.mount(instance);
        }
        this.root.nodes.add(this);
        this.parent && this.parent.children.add(this);
        if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          let cancelDelay;
          let innerWidth = 0;
          const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
          frame.read(() => {
            innerWidth = window.innerWidth;
          });
          attachResizeListener(instance, () => {
            const newInnerWidth = window.innerWidth;
            if (newInnerWidth === innerWidth)
              return;
            innerWidth = newInnerWidth;
            this.root.updateBlockedByResize = true;
            cancelDelay && cancelDelay();
            cancelDelay = delay(resizeUnblockUpdate, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
          this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
            if (this.isTreeAnimationBlocked()) {
              this.target = void 0;
              this.relativeTarget = void 0;
              return;
            }
            const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
            const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
            const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
            const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
            if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
              if (this.resumeFrom) {
                this.resumingFrom = this.resumeFrom;
                this.resumingFrom.resumingFrom = void 0;
              }
              const animationOptions = {
                ...getValueTransition(layoutTransition, "layout"),
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete
              };
              if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              this.startAnimation(animationOptions);
              this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            } else {
              if (!hasLayoutChanged) {
                finishAnimation(this);
              }
              if (this.isLead() && this.options.onExitComplete) {
                this.options.onExitComplete();
              }
            }
            this.targetLayout = newLayout;
          });
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack = this.getStack();
        stack && stack.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = void 0;
        this.eventHandlers.clear();
        cancelFrame(this.updateProjection);
      }
      // only on the root
      blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
      }
      // Note: currently only running on root node
      startUpdate() {
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        this.nodes && this.nodes.forEach(resetSkewAndRotation);
        this.animationId++;
      }
      getTransformTemplate() {
        const { visualElement } = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = true) {
        this.root.hasTreeAnimated = true;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
          cancelTreeOptimisedTransformAnimations(this);
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          node2.shouldResetTransform = true;
          node2.updateScroll("snapshot");
          if (node2.options.layoutRoot) {
            node2.willUpdate(false);
          }
        }
        const { layoutId, layout: layout2 } = this.options;
        if (layoutId === void 0 && !layout2)
          return;
        const transformTemplate = this.getTransformTemplate();
        this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      }
      update() {
        this.updateScheduled = false;
        const updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (this.animationId <= this.animationCommitId) {
          this.nodes.forEach(clearIsLayoutDirty);
          return;
        }
        this.animationCommitId = this.animationId;
        if (!this.isUpdating) {
          this.nodes.forEach(clearIsLayoutDirty);
        } else {
          this.isUpdating = false;
          this.nodes.forEach(resetTransformStyle);
          this.nodes.forEach(updateLayout);
          this.nodes.forEach(notifyLayoutUpdate);
        }
        this.clearAllSnapshots();
        const now2 = time.now();
        frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
        frameData.timestamp = now2;
        frameData.isProcessing = true;
        frameSteps.update.process(frameData);
        frameSteps.preRender.process(frameData);
        frameSteps.render.process(frameData);
        frameData.isProcessing = false;
      }
      didUpdate() {
        if (!this.updateScheduled) {
          this.updateScheduled = true;
          microtask.read(this.scheduleUpdate);
        }
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        if (!this.projectionUpdateScheduled) {
          this.projectionUpdateScheduled = true;
          frame.preRender(this.updateProjection, false, true);
        }
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          if (this.isLayoutDirty) {
            this.root.didUpdate();
          } else {
            this.root.checkUpdateFailed();
          }
        });
      }
      /**
       * Update measurements
       */
      updateSnapshot() {
        if (this.snapshot || !this.instance)
          return;
        this.snapshot = this.measure();
        if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
          this.snapshot = void 0;
        }
      }
      updateLayout() {
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (let i = 0; i < this.path.length; i++) {
            const node2 = this.path[i];
            node2.updateScroll();
          }
        }
        const prevLayout = this.layout;
        this.layout = this.measure(false);
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement } = this.options;
        visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
      }
      updateScroll(phase = "measure") {
        let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
          needsMeasurement = false;
        }
        if (needsMeasurement && this.instance) {
          const isRoot = checkIsScrollRoot(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase,
            isRoot,
            offset: measureScroll(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : isRoot
          };
        }
      }
      resetTransform() {
        if (!resetTransform)
          return;
        const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
        const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        const transformTemplate = this.getTransformTemplate();
        const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      }
      measure(removeTransform = true) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        if (removeTransform) {
          layoutBox = this.removeTransform(layoutBox);
        }
        roundBox(layoutBox);
        return {
          animationId: this.root.animationId,
          measuredBox: pageBox,
          layoutBox,
          latestValues: {},
          source: this.id
        };
      }
      measurePageBox() {
        var _a2;
        const { visualElement } = this.options;
        if (!visualElement)
          return createBox();
        const box = visualElement.measureViewportBox();
        const wasInScrollRoot = ((_a2 = this.scroll) == null ? void 0 : _a2.wasRoot) || this.path.some(checkNodeWasScrollRoot);
        if (!wasInScrollRoot) {
          const { scroll } = this.root;
          if (scroll) {
            translateAxis(box.x, scroll.offset.x);
            translateAxis(box.y, scroll.offset.y);
          }
        }
        return box;
      }
      removeElementScroll(box) {
        var _a2;
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        if ((_a2 = this.scroll) == null ? void 0 : _a2.wasRoot) {
          return boxWithoutScroll;
        }
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          const { scroll, options: options2 } = node2;
          if (node2 !== this.root && scroll && options2.layoutScroll) {
            if (scroll.wasRoot) {
              copyBoxInto(boxWithoutScroll, box);
            }
            translateAxis(boxWithoutScroll.x, scroll.offset.x);
            translateAxis(boxWithoutScroll.y, scroll.offset.y);
          }
        }
        return boxWithoutScroll;
      }
      applyTransform(box, transformOnly = false) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
            transformBox(withTransforms, {
              x: -node2.scroll.offset.x,
              y: -node2.scroll.offset.y
            });
          }
          if (!hasTransform(node2.latestValues))
            continue;
          transformBox(withTransforms, node2.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      }
      removeTransform(box) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          if (!node2.instance)
            continue;
          if (!hasTransform(node2.latestValues))
            continue;
          hasScale(node2.latestValues) && node2.updateSnapshot();
          const sourceBox = createBox();
          const nodeBox = node2.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = true;
      }
      setOptions(options2) {
        this.options = {
          ...this.options,
          ...options2,
          crossfade: options2.crossfade !== void 0 ? options2.crossfade : true
        };
      }
      clearMeasurements() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        if (!this.relativeParent)
          return;
        if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
          this.relativeParent.resolveTargetDelta(true);
        }
      }
      resolveTargetDelta(forceRecalculation = false) {
        var _a2;
        const lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a2 = this.parent) == null ? void 0 : _a2.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        if (!this.layout || !(layout2 || layoutId))
          return;
        this.resolvedRelativeTargetAt = frameData.timestamp;
        if (!this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
          this.forceRelativeParentToResolveTarget();
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.layoutBox);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
      }
      getClosestProjectingParent() {
        if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
          return void 0;
        }
        if (this.parent.isProjecting()) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
      }
      calcProjection() {
        var _a2;
        const lead = this.getLead();
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        let canSkip = true;
        if (this.isProjectionDirty || ((_a2 = this.parent) == null ? void 0 : _a2.isProjectionDirty)) {
          canSkip = false;
        }
        if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
          canSkip = false;
        }
        if (this.resolvedRelativeTargetAt === frameData.timestamp) {
          canSkip = false;
        }
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout2 || layoutId))
          return;
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        const prevTreeScaleX = this.treeScale.x;
        const prevTreeScaleY = this.treeScale.y;
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
        if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
          lead.target = lead.layout.layoutBox;
          lead.targetWithTransforms = createBox();
        }
        const { target } = lead;
        if (!target) {
          if (this.prevProjectionDelta) {
            this.createProjectionDeltas();
            this.scheduleRender();
          }
          return;
        }
        if (!this.projectionDelta || !this.prevProjectionDelta) {
          this.createProjectionDeltas();
        } else {
          copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
          copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
        }
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
      }
      hide() {
        this.isVisible = false;
      }
      show() {
        this.isVisible = true;
      }
      scheduleRender(notifyAll = true) {
        var _a2;
        (_a2 = this.options.visualElement) == null ? void 0 : _a2.scheduleRender();
        if (notifyAll) {
          const stack = this.getStack();
          stack && stack.scheduleRender();
        }
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = createDelta();
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
        const snapshot = this.snapshot;
        const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
        const mixedValues = { ...this.latestValues };
        const targetDelta = createDelta();
        if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
          this.relativeTarget = this.relativeTargetOrigin = void 0;
        }
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox();
        const snapshotSource = snapshot ? snapshot.source : void 0;
        const layoutSource = this.layout ? this.layout.source : void 0;
        const isSharedLayoutAnimation = snapshotSource !== layoutSource;
        const stack = this.getStack();
        const isOnlyMember = !stack || stack.members.length <= 1;
        const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = (latest) => {
          const progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          this.setTargetDelta(targetDelta);
          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
              this.isProjectionDirty = false;
            }
            if (!prevRelativeTarget)
              prevRelativeTarget = createBox();
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = progress2;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(options2) {
        var _a2, _b2, _c2;
        this.notifyListeners("animationStart");
        (_a2 = this.currentAnimation) == null ? void 0 : _a2.stop();
        (_c2 = (_b2 = this.resumingFrom) == null ? void 0 : _b2.currentAnimation) == null ? void 0 : _c2.stop();
        if (this.pendingAnimation) {
          cancelFrame(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = true;
          this.motionValue || (this.motionValue = motionValue(0));
          this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
            ...options2,
            velocity: 0,
            isSync: true,
            onUpdate: (latest) => {
              this.mixTargetDelta(latest);
              options2.onUpdate && options2.onUpdate(latest);
            },
            onStop: () => {
            },
            onComplete: () => {
              options2.onComplete && options2.onComplete();
              this.completeAnimation();
            }
          });
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = this.currentAnimation;
          }
          this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        const stack = this.getStack();
        stack && stack.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        if (this.currentAnimation) {
          this.mixTargetDelta && this.mixTargetDelta(animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
        if (!targetWithTransforms || !target || !layout2)
          return;
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min;
          target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min;
          target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
      registerSharedNode(layoutId, node2) {
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        const stack = this.sharedNodes.get(layoutId);
        stack.add(node2);
        const config = node2.options.initialPromotionConfig;
        node2.promote({
          transition: config ? config.transition : void 0,
          preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node2) : void 0
        });
      }
      isLead() {
        const stack = this.getStack();
        return stack ? stack.lead === this : true;
      }
      getLead() {
        var _a2;
        const { layoutId } = this.options;
        return layoutId ? ((_a2 = this.getStack()) == null ? void 0 : _a2.lead) || this : this;
      }
      getPrevLead() {
        var _a2;
        const { layoutId } = this.options;
        return layoutId ? (_a2 = this.getStack()) == null ? void 0 : _a2.prevLead : void 0;
      }
      getStack() {
        const { layoutId } = this.options;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      }
      promote({ needsReset, transition, preserveFollowOpacity } = {}) {
        const stack = this.getStack();
        if (stack)
          stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition)
          this.setOptions({ transition });
      }
      relegate() {
        const stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      }
      resetSkewAndRotation() {
        const { visualElement } = this.options;
        if (!visualElement)
          return;
        let hasDistortingTransform = false;
        const { latestValues } = visualElement;
        if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
          hasDistortingTransform = true;
        }
        if (!hasDistortingTransform)
          return;
        const resetValues = {};
        if (latestValues.z) {
          resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
        }
        for (let i = 0; i < transformAxes.length; i++) {
          resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
          resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        }
        visualElement.render();
        for (const key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
          if (this.animationValues) {
            this.animationValues[key] = resetValues[key];
          }
        }
        visualElement.scheduleRender();
      }
      applyProjectionStyles(targetStyle, styleProp) {
        if (!this.instance || this.isSVG)
          return;
        if (!this.isVisible) {
          targetStyle.visibility = "hidden";
          return;
        }
        const transformTemplate = this.getTransformTemplate();
        if (this.needsReset) {
          this.needsReset = false;
          targetStyle.visibility = "";
          targetStyle.opacity = "";
          targetStyle.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
          targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return;
        }
        const lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          if (this.options.layoutId) {
            targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
            targetStyle.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return;
        }
        targetStyle.visibility = "";
        const valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        let transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          transform = transformTemplate(valuesToRender, transform);
        }
        targetStyle.transform = transform;
        const { x, y } = this.projectionDelta;
        targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
        if (lead.animationValues) {
          targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
        }
        for (const key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
          const corrected = transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
          if (applyTo) {
            const num = applyTo.length;
            for (let i = 0; i < num; i++) {
              targetStyle[applyTo[i]] = corrected;
            }
          } else {
            if (isCSSVariable) {
              this.options.visualElement.renderState.vars[key] = corrected;
            } else {
              targetStyle[key] = corrected;
            }
          }
        }
        if (this.options.layoutId) {
          targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "" : "none";
        }
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
      // Only run on root
      resetTree() {
        this.root.nodes.forEach((node2) => {
          var _a2;
          return (_a2 = node2.currentAnimation) == null ? void 0 : _a2.stop();
        });
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node2) {
    node2.updateLayout();
  }
  function notifyLayoutUpdate(node2) {
    var _a2;
    const snapshot = ((_a2 = node2.resumeFrom) == null ? void 0 : _a2.snapshot) || node2.snapshot;
    if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
      const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout;
      const { animationType } = node2.options;
      const isShared = snapshot.source !== node2.layout.source;
      if (animationType === "size") {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(axisSnapshot);
          axisSnapshot.min = layout2[axis].min;
          axisSnapshot.max = axisSnapshot.min + length;
        });
      } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(layout2[axis]);
          axisSnapshot.max = axisSnapshot.min + length;
          if (node2.relativeTarget && !node2.currentAnimation) {
            node2.isProjectionDirty = true;
            node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length;
          }
        });
      }
      const layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
      const visualDelta = createDelta();
      if (isShared) {
        calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot.measuredBox);
      } else {
        calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
      }
      const hasLayoutChanged = !isDeltaZero(layoutDelta);
      let hasRelativeLayoutChanged = false;
      if (!node2.resumeFrom) {
        const relativeParent = node2.getClosestProjectingParent();
        if (relativeParent && !relativeParent.resumeFrom) {
          const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
              hasRelativeLayoutChanged = true;
            }
            if (relativeParent.options.layoutRoot) {
              node2.relativeTarget = relativeLayout;
              node2.relativeTargetOrigin = relativeSnapshot;
              node2.relativeParent = relativeParent;
            }
          }
        }
      }
      node2.notifyListeners("didUpdate", {
        layout: layout2,
        snapshot,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeLayoutChanged
      });
    } else if (node2.isLead()) {
      const { onExitComplete } = node2.options;
      onExitComplete && onExitComplete();
    }
    node2.options.transition = void 0;
  }
  function propagateDirtyNodes(node2) {
    if (!node2.parent)
      return;
    if (!node2.isProjecting()) {
      node2.isProjectionDirty = node2.parent.isProjectionDirty;
    }
    node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
    node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
  }
  function cleanDirtyNodes(node2) {
    node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
  }
  function clearSnapshot(node2) {
    node2.clearSnapshot();
  }
  function clearMeasurements(node2) {
    node2.clearMeasurements();
  }
  function clearIsLayoutDirty(node2) {
    node2.isLayoutDirty = false;
  }
  function resetTransformStyle(node2) {
    const { visualElement } = node2.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
      visualElement.notify("BeforeLayoutMeasure");
    }
    node2.resetTransform();
  }
  function finishAnimation(node2) {
    node2.finishAnimation();
    node2.targetDelta = node2.relativeTarget = node2.target = void 0;
    node2.isProjectionDirty = true;
  }
  function resolveTargetDelta(node2) {
    node2.resolveTargetDelta();
  }
  function calcProjection(node2) {
    node2.calcProjection();
  }
  function resetSkewAndRotation(node2) {
    node2.resetSkewAndRotation();
  }
  function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
  }
  function mixAxisDelta(output, delta, p) {
    output.translate = mixNumber$1(delta.translate, 0, p);
    output.scale = mixNumber$1(delta.scale, 1, p);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
  }
  function mixAxis(output, from, to, p) {
    output.min = mixNumber$1(from.min, to.min, p);
    output.max = mixNumber$1(from.max, to.max, p);
  }
  function mixBox(output, from, to, p) {
    mixAxis(output.x, from.x, to.x, p);
    mixAxis(output.y, from.y, to.y, p);
  }
  function hasOpacityCrossfade(node2) {
    return node2.animationValues && node2.animationValues.opacityExit !== void 0;
  }
  const defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1]
  };
  const userAgentContains = (string2) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string2);
  const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$2;
  function roundAxis(axis) {
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
  }
  function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
    return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
  }
  function checkNodeWasScrollRoot(node2) {
    var _a2;
    return node2 !== node2.root && ((_a2 = node2.scroll) == null ? void 0 : _a2.wasRoot);
  }
  const DocumentProjectionNode = createProjectionNode({
    attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => true
  });
  const rootProjectionNode = {
    current: void 0
  };
  const HTMLProjectionNode = createProjectionNode({
    measureScroll: (instance) => ({
      x: instance.scrollLeft,
      y: instance.scrollTop
    }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const documentNode = new DocumentProjectionNode({});
        documentNode.mount(window);
        documentNode.setOptions({ layoutScroll: true });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: (instance, value) => {
      instance.style.transform = value !== void 0 ? value : "none";
    },
    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
  });
  const drag = {
    pan: {
      Feature: PanGesture
    },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };
  function handleHoverEvent(node2, event, lifecycle) {
    const { props } = node2;
    if (node2.animationState && props.whileHover) {
      node2.animationState.setActive("whileHover", lifecycle === "Start");
    }
    const eventName = "onHover" + lifecycle;
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  class HoverGesture extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = hover(current, (_element, startEvent) => {
        handleHoverEvent(this.node, startEvent, "Start");
        return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
      });
    }
    unmount() {
    }
  }
  class FocusGesture extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = false;
    }
    onFocus() {
      let isFocusVisible = false;
      try {
        isFocusVisible = this.node.current.matches(":focus-visible");
      } catch (e) {
        isFocusVisible = true;
      }
      if (!isFocusVisible || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", true);
      this.isActive = true;
    }
    onBlur() {
      if (!this.isActive || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", false);
      this.isActive = false;
    }
    mount() {
      this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() {
    }
  }
  function handlePressEvent(node2, event, lifecycle) {
    const { props } = node2;
    if (node2.current instanceof HTMLButtonElement && node2.current.disabled) {
      return;
    }
    if (node2.animationState && props.whileTap) {
      node2.animationState.setActive("whileTap", lifecycle === "Start");
    }
    const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  class PressGesture extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = press(current, (_element, startEvent) => {
        handlePressEvent(this.node, startEvent, "Start");
        return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
      }, { useGlobalTarget: this.node.props.globalTapTarget });
    }
    unmount() {
    }
  }
  const observerCallbacks = /* @__PURE__ */ new WeakMap();
  const observers = /* @__PURE__ */ new WeakMap();
  const fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  };
  const fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver({ root: root2, ...options2 }) {
    const lookupRoot = root2 || document;
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options2);
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options2 });
    }
    return rootObservers[key];
  }
  function observeIntersection(element2, options2, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options2);
    observerCallbacks.set(element2, callback);
    rootInteresectionObserver.observe(element2);
    return () => {
      observerCallbacks.delete(element2);
      rootInteresectionObserver.unobserve(element2);
    };
  }
  const thresholdNames = {
    some: 0,
    all: 1
  };
  class InViewFeature extends Feature {
    constructor() {
      super(...arguments);
      this.hasEnteredView = false;
      this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport = {} } = this.node.getProps();
      const { root: root2, margin: rootMargin, amount = "some", once } = viewport;
      const options2 = {
        root: root2 ? root2.current : void 0,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholdNames[amount]
      };
      const onIntersectionUpdate = (entry) => {
        const { isIntersecting } = entry;
        if (this.isInView === isIntersecting)
          return;
        this.isInView = isIntersecting;
        if (once && !isIntersecting && this.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          this.hasEnteredView = true;
        }
        if (this.node.animationState) {
          this.node.animationState.setActive("whileInView", isIntersecting);
        }
        const { onViewportEnter, onViewportLeave } = this.node.getProps();
        const callback = isIntersecting ? onViewportEnter : onViewportLeave;
        callback && callback(entry);
      };
      return observeIntersection(this.node.current, options2, onIntersectionUpdate);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver === "undefined")
        return;
      const { props, prevProps } = this.node;
      const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
      if (hasOptionsChanged) {
        this.startObserver();
      }
    }
    unmount() {
    }
  }
  function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
    return (name2) => viewport[name2] !== prevViewport[name2];
  }
  const gestureAnimations = {
    inView: {
      Feature: InViewFeature
    },
    tap: {
      Feature: PressGesture
    },
    focus: {
      Feature: FocusGesture
    },
    hover: {
      Feature: HoverGesture
    }
  };
  const layout = {
    layout: {
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };
  const featureBundle = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
  };
  const motion = /* @__PURE__ */ createMotionProxy(featureBundle, createDomVisualElement);
  function cn(...inputs) {
    return twMerge(clsx(inputs));
  }
  var Subscribable = class {
    constructor() {
      this.listeners = /* @__PURE__ */ new Set();
      this.subscribe = this.subscribe.bind(this);
    }
    subscribe(listener) {
      this.listeners.add(listener);
      this.onSubscribe();
      return () => {
        this.listeners.delete(listener);
        this.onUnsubscribe();
      };
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {
    }
    onUnsubscribe() {
    }
  };
  var isServer = typeof window === "undefined" || "Deno" in globalThis;
  function noop$1() {
  }
  function functionalUpdate(updater, input) {
    return typeof updater === "function" ? updater(input) : updater;
  }
  function isValidTimeout(value) {
    return typeof value === "number" && value >= 0 && value !== Infinity;
  }
  function timeUntilStale(updatedAt, staleTime) {
    return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
  }
  function resolveStaleTime(staleTime, query) {
    return typeof staleTime === "function" ? staleTime(query) : staleTime;
  }
  function resolveEnabled(enabled, query) {
    return typeof enabled === "function" ? enabled(query) : enabled;
  }
  function matchQuery(filters, query) {
    const {
      type = "all",
      exact,
      fetchStatus,
      predicate,
      queryKey,
      stale
    } = filters;
    if (queryKey) {
      if (exact) {
        if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
          return false;
        }
      } else if (!partialMatchKey(query.queryKey, queryKey)) {
        return false;
      }
    }
    if (type !== "all") {
      const isActive = query.isActive();
      if (type === "active" && !isActive) {
        return false;
      }
      if (type === "inactive" && isActive) {
        return false;
      }
    }
    if (typeof stale === "boolean" && query.isStale() !== stale) {
      return false;
    }
    if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
      return false;
    }
    if (predicate && !predicate(query)) {
      return false;
    }
    return true;
  }
  function matchMutation(filters, mutation) {
    const { exact, status, predicate, mutationKey } = filters;
    if (mutationKey) {
      if (!mutation.options.mutationKey) {
        return false;
      }
      if (exact) {
        if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
          return false;
        }
      } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
        return false;
      }
    }
    if (status && mutation.state.status !== status) {
      return false;
    }
    if (predicate && !predicate(mutation)) {
      return false;
    }
    return true;
  }
  function hashQueryKeyByOptions(queryKey, options2) {
    const hashFn = (options2 == null ? void 0 : options2.queryKeyHashFn) || hashKey;
    return hashFn(queryKey);
  }
  function hashKey(queryKey) {
    return JSON.stringify(
      queryKey,
      (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
        result[key] = val[key];
        return result;
      }, {}) : val
    );
  }
  function partialMatchKey(a, b) {
    if (a === b) {
      return true;
    }
    if (typeof a !== typeof b) {
      return false;
    }
    if (a && b && typeof a === "object" && typeof b === "object") {
      return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));
    }
    return false;
  }
  function replaceEqualDeep(a, b) {
    if (a === b) {
      return a;
    }
    const array = isPlainArray(a) && isPlainArray(b);
    if (array || isPlainObject(a) && isPlainObject(b)) {
      const aItems = array ? a : Object.keys(a);
      const aSize = aItems.length;
      const bItems = array ? b : Object.keys(b);
      const bSize = bItems.length;
      const copy = array ? [] : {};
      const aItemsSet = new Set(aItems);
      let equalItems = 0;
      for (let i = 0; i < bSize; i++) {
        const key = array ? i : bItems[i];
        if ((!array && aItemsSet.has(key) || array) && a[key] === void 0 && b[key] === void 0) {
          copy[key] = void 0;
          equalItems++;
        } else {
          copy[key] = replaceEqualDeep(a[key], b[key]);
          if (copy[key] === a[key] && a[key] !== void 0) {
            equalItems++;
          }
        }
      }
      return aSize === bSize && equalItems === aSize ? a : copy;
    }
    return b;
  }
  function shallowEqualObjects(a, b) {
    if (!b || Object.keys(a).length !== Object.keys(b).length) {
      return false;
    }
    for (const key in a) {
      if (a[key] !== b[key]) {
        return false;
      }
    }
    return true;
  }
  function isPlainArray(value) {
    return Array.isArray(value) && value.length === Object.keys(value).length;
  }
  function isPlainObject(o) {
    if (!hasObjectPrototype(o)) {
      return false;
    }
    const ctor = o.constructor;
    if (ctor === void 0) {
      return true;
    }
    const prot = ctor.prototype;
    if (!hasObjectPrototype(prot)) {
      return false;
    }
    if (!prot.hasOwnProperty("isPrototypeOf")) {
      return false;
    }
    if (Object.getPrototypeOf(o) !== Object.prototype) {
      return false;
    }
    return true;
  }
  function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  }
  function sleep(timeout) {
    return new Promise((resolve) => {
      setTimeout(resolve, timeout);
    });
  }
  function replaceData(prevData, data, options2) {
    if (typeof options2.structuralSharing === "function") {
      return options2.structuralSharing(prevData, data);
    } else if (options2.structuralSharing !== false) {
      return replaceEqualDeep(prevData, data);
    }
    return data;
  }
  function addToEnd(items, item, max2 = 0) {
    const newItems = [...items, item];
    return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
  }
  function addToStart(items, item, max2 = 0) {
    const newItems = [item, ...items];
    return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
  }
  var skipToken = Symbol();
  function ensureQueryFn(options2, fetchOptions) {
    if (!options2.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
      return () => fetchOptions.initialPromise;
    }
    if (!options2.queryFn || options2.queryFn === skipToken) {
      return () => Promise.reject(new Error(`Missing queryFn: '${options2.queryHash}'`));
    }
    return options2.queryFn;
  }
  function shouldThrowError(throwOnError, params) {
    if (typeof throwOnError === "function") {
      return throwOnError(...params);
    }
    return !!throwOnError;
  }
  var FocusManager = (_a = class extends Subscribable {
    constructor() {
      super();
      __privateAdd(this, _focused);
      __privateAdd(this, _cleanup);
      __privateAdd(this, _setup);
      __privateSet(this, _setup, (onFocus) => {
        if (!isServer && window.addEventListener) {
          const listener = () => onFocus();
          window.addEventListener("visibilitychange", listener, false);
          return () => {
            window.removeEventListener("visibilitychange", listener);
          };
        }
        return;
      });
    }
    onSubscribe() {
      if (!__privateGet(this, _cleanup)) {
        this.setEventListener(__privateGet(this, _setup));
      }
    }
    onUnsubscribe() {
      var _a2;
      if (!this.hasListeners()) {
        (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
        __privateSet(this, _cleanup, void 0);
      }
    }
    setEventListener(setup) {
      var _a2;
      __privateSet(this, _setup, setup);
      (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup, setup((focused) => {
        if (typeof focused === "boolean") {
          this.setFocused(focused);
        } else {
          this.onFocus();
        }
      }));
    }
    setFocused(focused) {
      const changed = __privateGet(this, _focused) !== focused;
      if (changed) {
        __privateSet(this, _focused, focused);
        this.onFocus();
      }
    }
    onFocus() {
      const isFocused = this.isFocused();
      this.listeners.forEach((listener) => {
        listener(isFocused);
      });
    }
    isFocused() {
      var _a2;
      if (typeof __privateGet(this, _focused) === "boolean") {
        return __privateGet(this, _focused);
      }
      return ((_a2 = globalThis.document) == null ? void 0 : _a2.visibilityState) !== "hidden";
    }
  }, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
  var focusManager = new FocusManager();
  var OnlineManager = (_b = class extends Subscribable {
    constructor() {
      super();
      __privateAdd(this, _online, true);
      __privateAdd(this, _cleanup2);
      __privateAdd(this, _setup2);
      __privateSet(this, _setup2, (onOnline) => {
        if (!isServer && window.addEventListener) {
          const onlineListener = () => onOnline(true);
          const offlineListener = () => onOnline(false);
          window.addEventListener("online", onlineListener, false);
          window.addEventListener("offline", offlineListener, false);
          return () => {
            window.removeEventListener("online", onlineListener);
            window.removeEventListener("offline", offlineListener);
          };
        }
        return;
      });
    }
    onSubscribe() {
      if (!__privateGet(this, _cleanup2)) {
        this.setEventListener(__privateGet(this, _setup2));
      }
    }
    onUnsubscribe() {
      var _a2;
      if (!this.hasListeners()) {
        (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
        __privateSet(this, _cleanup2, void 0);
      }
    }
    setEventListener(setup) {
      var _a2;
      __privateSet(this, _setup2, setup);
      (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
    }
    setOnline(online) {
      const changed = __privateGet(this, _online) !== online;
      if (changed) {
        __privateSet(this, _online, online);
        this.listeners.forEach((listener) => {
          listener(online);
        });
      }
    }
    isOnline() {
      return __privateGet(this, _online);
    }
  }, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _b);
  var onlineManager = new OnlineManager();
  function pendingThenable() {
    let resolve;
    let reject;
    const thenable = new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    });
    thenable.status = "pending";
    thenable.catch(() => {
    });
    function finalize(data) {
      Object.assign(thenable, data);
      delete thenable.resolve;
      delete thenable.reject;
    }
    thenable.resolve = (value) => {
      finalize({
        status: "fulfilled",
        value
      });
      resolve(value);
    };
    thenable.reject = (reason) => {
      finalize({
        status: "rejected",
        reason
      });
      reject(reason);
    };
    return thenable;
  }
  function defaultRetryDelay(failureCount) {
    return Math.min(1e3 * 2 ** failureCount, 3e4);
  }
  function canFetch(networkMode) {
    return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
  }
  var CancelledError = class extends Error {
    constructor(options2) {
      super("CancelledError");
      this.revert = options2 == null ? void 0 : options2.revert;
      this.silent = options2 == null ? void 0 : options2.silent;
    }
  };
  function isCancelledError(value) {
    return value instanceof CancelledError;
  }
  function createRetryer(config) {
    let isRetryCancelled = false;
    let failureCount = 0;
    let isResolved = false;
    let continueFn;
    const thenable = pendingThenable();
    const cancel = (cancelOptions) => {
      var _a2;
      if (!isResolved) {
        reject(new CancelledError(cancelOptions));
        (_a2 = config.abort) == null ? void 0 : _a2.call(config);
      }
    };
    const cancelRetry = () => {
      isRetryCancelled = true;
    };
    const continueRetry = () => {
      isRetryCancelled = false;
    };
    const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
    const canStart = () => canFetch(config.networkMode) && config.canRun();
    const resolve = (value) => {
      var _a2;
      if (!isResolved) {
        isResolved = true;
        (_a2 = config.onSuccess) == null ? void 0 : _a2.call(config, value);
        continueFn == null ? void 0 : continueFn();
        thenable.resolve(value);
      }
    };
    const reject = (value) => {
      var _a2;
      if (!isResolved) {
        isResolved = true;
        (_a2 = config.onError) == null ? void 0 : _a2.call(config, value);
        continueFn == null ? void 0 : continueFn();
        thenable.reject(value);
      }
    };
    const pause = () => {
      return new Promise((continueResolve) => {
        var _a2;
        continueFn = (value) => {
          if (isResolved || canContinue()) {
            continueResolve(value);
          }
        };
        (_a2 = config.onPause) == null ? void 0 : _a2.call(config);
      }).then(() => {
        var _a2;
        continueFn = void 0;
        if (!isResolved) {
          (_a2 = config.onContinue) == null ? void 0 : _a2.call(config);
        }
      });
    };
    const run = () => {
      if (isResolved) {
        return;
      }
      let promiseOrValue;
      const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
      try {
        promiseOrValue = initialPromise ?? config.fn();
      } catch (error) {
        promiseOrValue = Promise.reject(error);
      }
      Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
        var _a2;
        if (isResolved) {
          return;
        }
        const retry = config.retry ?? (isServer ? 0 : 3);
        const retryDelay = config.retryDelay ?? defaultRetryDelay;
        const delay2 = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
        const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
        if (isRetryCancelled || !shouldRetry) {
          reject(error);
          return;
        }
        failureCount++;
        (_a2 = config.onFail) == null ? void 0 : _a2.call(config, failureCount, error);
        sleep(delay2).then(() => {
          return canContinue() ? void 0 : pause();
        }).then(() => {
          if (isRetryCancelled) {
            reject(error);
          } else {
            run();
          }
        });
      });
    };
    return {
      promise: thenable,
      cancel,
      continue: () => {
        continueFn == null ? void 0 : continueFn();
        return thenable;
      },
      cancelRetry,
      continueRetry,
      canStart,
      start: () => {
        if (canStart()) {
          run();
        } else {
          pause().then(run);
        }
        return thenable;
      }
    };
  }
  var defaultScheduler = (cb) => setTimeout(cb, 0);
  function createNotifyManager() {
    let queue = [];
    let transactions = 0;
    let notifyFn = (callback) => {
      callback();
    };
    let batchNotifyFn = (callback) => {
      callback();
    };
    let scheduleFn = defaultScheduler;
    const schedule = (callback) => {
      if (transactions) {
        queue.push(callback);
      } else {
        scheduleFn(() => {
          notifyFn(callback);
        });
      }
    };
    const flush = () => {
      const originalQueue = queue;
      queue = [];
      if (originalQueue.length) {
        scheduleFn(() => {
          batchNotifyFn(() => {
            originalQueue.forEach((callback) => {
              notifyFn(callback);
            });
          });
        });
      }
    };
    return {
      batch: (callback) => {
        let result;
        transactions++;
        try {
          result = callback();
        } finally {
          transactions--;
          if (!transactions) {
            flush();
          }
        }
        return result;
      },
      /**
       * All calls to the wrapped function will be batched.
       */
      batchCalls: (callback) => {
        return (...args) => {
          schedule(() => {
            callback(...args);
          });
        };
      },
      schedule,
      /**
       * Use this method to set a custom notify function.
       * This can be used to for example wrap notifications with `React.act` while running tests.
       */
      setNotifyFunction: (fn) => {
        notifyFn = fn;
      },
      /**
       * Use this method to set a custom function to batch notifications together into a single tick.
       * By default React Query will use the batch function provided by ReactDOM or React Native.
       */
      setBatchNotifyFunction: (fn) => {
        batchNotifyFn = fn;
      },
      setScheduler: (fn) => {
        scheduleFn = fn;
      }
    };
  }
  var notifyManager = createNotifyManager();
  var Removable = (_c = class {
    constructor() {
      __privateAdd(this, _gcTimeout);
    }
    destroy() {
      this.clearGcTimeout();
    }
    scheduleGc() {
      this.clearGcTimeout();
      if (isValidTimeout(this.gcTime)) {
        __privateSet(this, _gcTimeout, setTimeout(() => {
          this.optionalRemove();
        }, this.gcTime));
      }
    }
    updateGcTime(newGcTime) {
      this.gcTime = Math.max(
        this.gcTime || 0,
        newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
      );
    }
    clearGcTimeout() {
      if (__privateGet(this, _gcTimeout)) {
        clearTimeout(__privateGet(this, _gcTimeout));
        __privateSet(this, _gcTimeout, void 0);
      }
    }
  }, _gcTimeout = new WeakMap(), _c);
  var Query = (_d = class extends Removable {
    constructor(config) {
      super();
      __privateAdd(this, _Query_instances);
      __privateAdd(this, _initialState);
      __privateAdd(this, _revertState);
      __privateAdd(this, _cache);
      __privateAdd(this, _client);
      __privateAdd(this, _retryer);
      __privateAdd(this, _defaultOptions);
      __privateAdd(this, _abortSignalConsumed);
      __privateSet(this, _abortSignalConsumed, false);
      __privateSet(this, _defaultOptions, config.defaultOptions);
      this.setOptions(config.options);
      this.observers = [];
      __privateSet(this, _client, config.client);
      __privateSet(this, _cache, __privateGet(this, _client).getQueryCache());
      this.queryKey = config.queryKey;
      this.queryHash = config.queryHash;
      __privateSet(this, _initialState, getDefaultState$1(this.options));
      this.state = config.state ?? __privateGet(this, _initialState);
      this.scheduleGc();
    }
    get meta() {
      return this.options.meta;
    }
    get promise() {
      var _a2;
      return (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
    }
    setOptions(options2) {
      this.options = { ...__privateGet(this, _defaultOptions), ...options2 };
      this.updateGcTime(this.options.gcTime);
    }
    optionalRemove() {
      if (!this.observers.length && this.state.fetchStatus === "idle") {
        __privateGet(this, _cache).remove(this);
      }
    }
    setData(newData, options2) {
      const data = replaceData(this.state.data, newData, this.options);
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
        data,
        type: "success",
        dataUpdatedAt: options2 == null ? void 0 : options2.updatedAt,
        manual: options2 == null ? void 0 : options2.manual
      });
      return data;
    }
    setState(state, setStateOptions) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
    }
    cancel(options2) {
      var _a2, _b2;
      const promise = (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
      (_b2 = __privateGet(this, _retryer)) == null ? void 0 : _b2.cancel(options2);
      return promise ? promise.then(noop$1).catch(noop$1) : Promise.resolve();
    }
    destroy() {
      super.destroy();
      this.cancel({ silent: true });
    }
    reset() {
      this.destroy();
      this.setState(__privateGet(this, _initialState));
    }
    isActive() {
      return this.observers.some(
        (observer) => resolveEnabled(observer.options.enabled, this) !== false
      );
    }
    isDisabled() {
      if (this.getObserversCount() > 0) {
        return !this.isActive();
      }
      return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
    }
    isStatic() {
      if (this.getObserversCount() > 0) {
        return this.observers.some(
          (observer) => resolveStaleTime(observer.options.staleTime, this) === "static"
        );
      }
      return false;
    }
    isStale() {
      if (this.getObserversCount() > 0) {
        return this.observers.some(
          (observer) => observer.getCurrentResult().isStale
        );
      }
      return this.state.data === void 0 || this.state.isInvalidated;
    }
    isStaleByTime(staleTime = 0) {
      if (this.state.data === void 0) {
        return true;
      }
      if (staleTime === "static") {
        return false;
      }
      if (this.state.isInvalidated) {
        return true;
      }
      return !timeUntilStale(this.state.dataUpdatedAt, staleTime);
    }
    onFocus() {
      var _a2;
      const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
      observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
      (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
    }
    onOnline() {
      var _a2;
      const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
      observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
      (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
    }
    addObserver(observer) {
      if (!this.observers.includes(observer)) {
        this.observers.push(observer);
        this.clearGcTimeout();
        __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
      }
    }
    removeObserver(observer) {
      if (this.observers.includes(observer)) {
        this.observers = this.observers.filter((x) => x !== observer);
        if (!this.observers.length) {
          if (__privateGet(this, _retryer)) {
            if (__privateGet(this, _abortSignalConsumed)) {
              __privateGet(this, _retryer).cancel({ revert: true });
            } else {
              __privateGet(this, _retryer).cancelRetry();
            }
          }
          this.scheduleGc();
        }
        __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
      }
    }
    getObserversCount() {
      return this.observers.length;
    }
    invalidate() {
      if (!this.state.isInvalidated) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
      }
    }
    fetch(options2, fetchOptions) {
      var _a2, _b2, _c2;
      if (this.state.fetchStatus !== "idle") {
        if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
          this.cancel({ silent: true });
        } else if (__privateGet(this, _retryer)) {
          __privateGet(this, _retryer).continueRetry();
          return __privateGet(this, _retryer).promise;
        }
      }
      if (options2) {
        this.setOptions(options2);
      }
      if (!this.options.queryFn) {
        const observer = this.observers.find((x) => x.options.queryFn);
        if (observer) {
          this.setOptions(observer.options);
        }
      }
      const abortController = new AbortController();
      const addSignalProperty = (object) => {
        Object.defineProperty(object, "signal", {
          enumerable: true,
          get: () => {
            __privateSet(this, _abortSignalConsumed, true);
            return abortController.signal;
          }
        });
      };
      const fetchFn = () => {
        const queryFn = ensureQueryFn(this.options, fetchOptions);
        const createQueryFnContext = () => {
          const queryFnContext2 = {
            client: __privateGet(this, _client),
            queryKey: this.queryKey,
            meta: this.meta
          };
          addSignalProperty(queryFnContext2);
          return queryFnContext2;
        };
        const queryFnContext = createQueryFnContext();
        __privateSet(this, _abortSignalConsumed, false);
        if (this.options.persister) {
          return this.options.persister(
            queryFn,
            queryFnContext,
            this
          );
        }
        return queryFn(queryFnContext);
      };
      const createFetchContext = () => {
        const context2 = {
          fetchOptions,
          options: this.options,
          queryKey: this.queryKey,
          client: __privateGet(this, _client),
          state: this.state,
          fetchFn
        };
        addSignalProperty(context2);
        return context2;
      };
      const context = createFetchContext();
      (_a2 = this.options.behavior) == null ? void 0 : _a2.onFetch(context, this);
      __privateSet(this, _revertState, this.state);
      if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b2 = context.fetchOptions) == null ? void 0 : _b2.meta)) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: (_c2 = context.fetchOptions) == null ? void 0 : _c2.meta });
      }
      const onError = (error) => {
        var _a3, _b3, _c3, _d2;
        if (!(isCancelledError(error) && error.silent)) {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
            type: "error",
            error
          });
        }
        if (!isCancelledError(error)) {
          (_b3 = (_a3 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b3.call(
            _a3,
            error,
            this
          );
          (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
            _c3,
            this.state.data,
            error,
            this
          );
        }
        this.scheduleGc();
      };
      __privateSet(this, _retryer, createRetryer({
        initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
        fn: context.fetchFn,
        abort: abortController.abort.bind(abortController),
        onSuccess: (data) => {
          var _a3, _b3, _c3, _d2;
          if (data === void 0) {
            onError(new Error(`${this.queryHash} data is undefined`));
            return;
          }
          try {
            this.setData(data);
          } catch (error) {
            onError(error);
            return;
          }
          (_b3 = (_a3 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b3.call(_a3, data, this);
          (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
            _c3,
            data,
            this.state.error,
            this
          );
          this.scheduleGc();
        },
        onError,
        onFail: (failureCount, error) => {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
        },
        onPause: () => {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
        },
        onContinue: () => {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
        },
        retry: context.options.retry,
        retryDelay: context.options.retryDelay,
        networkMode: context.options.networkMode,
        canRun: () => true
      }));
      return __privateGet(this, _retryer).start();
    }
  }, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _client = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            ...fetchState(state.data, this.options),
            fetchMeta: action.meta ?? null
          };
        case "success":
          __privateSet(this, _revertState, void 0);
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
            return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate();
      });
      __privateGet(this, _cache).notify({ query: this, type: "updated", action });
    });
  }, _d);
  function fetchState(data, options2) {
    return {
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchStatus: canFetch(options2.networkMode) ? "fetching" : "paused",
      ...data === void 0 && {
        error: null,
        status: "pending"
      }
    };
  }
  function getDefaultState$1(options2) {
    const data = typeof options2.initialData === "function" ? options2.initialData() : options2.initialData;
    const hasData = data !== void 0;
    const initialDataUpdatedAt = hasData ? typeof options2.initialDataUpdatedAt === "function" ? options2.initialDataUpdatedAt() : options2.initialDataUpdatedAt : 0;
    return {
      data,
      dataUpdateCount: 0,
      dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: false,
      status: hasData ? "success" : "pending",
      fetchStatus: "idle"
    };
  }
  var QueryCache = (_e2 = class extends Subscribable {
    constructor(config = {}) {
      super();
      __privateAdd(this, _queries);
      this.config = config;
      __privateSet(this, _queries, /* @__PURE__ */ new Map());
    }
    build(client2, options2, state) {
      const queryKey = options2.queryKey;
      const queryHash = options2.queryHash ?? hashQueryKeyByOptions(queryKey, options2);
      let query = this.get(queryHash);
      if (!query) {
        query = new Query({
          client: client2,
          queryKey,
          queryHash,
          options: client2.defaultQueryOptions(options2),
          state,
          defaultOptions: client2.getQueryDefaults(queryKey)
        });
        this.add(query);
      }
      return query;
    }
    add(query) {
      if (!__privateGet(this, _queries).has(query.queryHash)) {
        __privateGet(this, _queries).set(query.queryHash, query);
        this.notify({
          type: "added",
          query
        });
      }
    }
    remove(query) {
      const queryInMap = __privateGet(this, _queries).get(query.queryHash);
      if (queryInMap) {
        query.destroy();
        if (queryInMap === query) {
          __privateGet(this, _queries).delete(query.queryHash);
        }
        this.notify({ type: "removed", query });
      }
    }
    clear() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          this.remove(query);
        });
      });
    }
    get(queryHash) {
      return __privateGet(this, _queries).get(queryHash);
    }
    getAll() {
      return [...__privateGet(this, _queries).values()];
    }
    find(filters) {
      const defaultedFilters = { exact: true, ...filters };
      return this.getAll().find(
        (query) => matchQuery(defaultedFilters, query)
      );
    }
    findAll(filters = {}) {
      const queries = this.getAll();
      return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach((listener) => {
          listener(event);
        });
      });
    }
    onFocus() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          query.onFocus();
        });
      });
    }
    onOnline() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          query.onOnline();
        });
      });
    }
  }, _queries = new WeakMap(), _e2);
  var Mutation = (_f = class extends Removable {
    constructor(config) {
      super();
      __privateAdd(this, _Mutation_instances);
      __privateAdd(this, _observers);
      __privateAdd(this, _mutationCache);
      __privateAdd(this, _retryer2);
      this.mutationId = config.mutationId;
      __privateSet(this, _mutationCache, config.mutationCache);
      __privateSet(this, _observers, []);
      this.state = config.state || getDefaultState();
      this.setOptions(config.options);
      this.scheduleGc();
    }
    setOptions(options2) {
      this.options = options2;
      this.updateGcTime(this.options.gcTime);
    }
    get meta() {
      return this.options.meta;
    }
    addObserver(observer) {
      if (!__privateGet(this, _observers).includes(observer)) {
        __privateGet(this, _observers).push(observer);
        this.clearGcTimeout();
        __privateGet(this, _mutationCache).notify({
          type: "observerAdded",
          mutation: this,
          observer
        });
      }
    }
    removeObserver(observer) {
      __privateSet(this, _observers, __privateGet(this, _observers).filter((x) => x !== observer));
      this.scheduleGc();
      __privateGet(this, _mutationCache).notify({
        type: "observerRemoved",
        mutation: this,
        observer
      });
    }
    optionalRemove() {
      if (!__privateGet(this, _observers).length) {
        if (this.state.status === "pending") {
          this.scheduleGc();
        } else {
          __privateGet(this, _mutationCache).remove(this);
        }
      }
    }
    continue() {
      var _a2;
      return ((_a2 = __privateGet(this, _retryer2)) == null ? void 0 : _a2.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
      this.execute(this.state.variables);
    }
    async execute(variables) {
      var _a2, _b2, _c2, _d2, _e3, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n, _o, _p, _q, _r, _s, _t2;
      const onContinue = () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
      };
      __privateSet(this, _retryer2, createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject(new Error("No mutationFn found"));
          }
          return this.options.mutationFn(variables);
        },
        onFail: (failureCount, error) => {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
        },
        onPause: () => {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
        },
        onContinue,
        retry: this.options.retry ?? 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode,
        canRun: () => __privateGet(this, _mutationCache).canRun(this)
      }));
      const restored = this.state.status === "pending";
      const isPaused = !__privateGet(this, _retryer2).canStart();
      try {
        if (restored) {
          onContinue();
        } else {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
          await ((_b2 = (_a2 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b2.call(
            _a2,
            variables,
            this
          ));
          const context = await ((_d2 = (_c2 = this.options).onMutate) == null ? void 0 : _d2.call(_c2, variables));
          if (context !== this.state.context) {
            __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
              type: "pending",
              context,
              variables,
              isPaused
            });
          }
        }
        const data = await __privateGet(this, _retryer2).start();
        await ((_f2 = (_e3 = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f2.call(
          _e3,
          data,
          variables,
          this.state.context,
          this
        ));
        await ((_h2 = (_g2 = this.options).onSuccess) == null ? void 0 : _h2.call(_g2, data, variables, this.state.context));
        await ((_j2 = (_i2 = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j2.call(
          _i2,
          data,
          null,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_l2 = (_k2 = this.options).onSettled) == null ? void 0 : _l2.call(_k2, data, null, variables, this.state.context));
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data });
        return data;
      } catch (error) {
        try {
          await ((_n = (_m2 = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n.call(
            _m2,
            error,
            variables,
            this.state.context,
            this
          ));
          await ((_p = (_o = this.options).onError) == null ? void 0 : _p.call(
            _o,
            error,
            variables,
            this.state.context
          ));
          await ((_r = (_q = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r.call(
            _q,
            void 0,
            error,
            this.state.variables,
            this.state.context,
            this
          ));
          await ((_t2 = (_s = this.options).onSettled) == null ? void 0 : _t2.call(
            _s,
            void 0,
            error,
            variables,
            this.state.context
          ));
          throw error;
        } finally {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
        }
      } finally {
        __privateGet(this, _mutationCache).runNext(this);
      }
    }
  }, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "pending":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: action.isPaused,
            status: "pending",
            variables: action.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      __privateGet(this, _observers).forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      __privateGet(this, _mutationCache).notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }, _f);
  function getDefaultState() {
    return {
      context: void 0,
      data: void 0,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: false,
      status: "idle",
      variables: void 0,
      submittedAt: 0
    };
  }
  var MutationCache = (_g = class extends Subscribable {
    constructor(config = {}) {
      super();
      __privateAdd(this, _mutations);
      __privateAdd(this, _scopes);
      __privateAdd(this, _mutationId);
      this.config = config;
      __privateSet(this, _mutations, /* @__PURE__ */ new Set());
      __privateSet(this, _scopes, /* @__PURE__ */ new Map());
      __privateSet(this, _mutationId, 0);
    }
    build(client2, options2, state) {
      const mutation = new Mutation({
        mutationCache: this,
        mutationId: ++__privateWrapper(this, _mutationId)._,
        options: client2.defaultMutationOptions(options2),
        state
      });
      this.add(mutation);
      return mutation;
    }
    add(mutation) {
      __privateGet(this, _mutations).add(mutation);
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = __privateGet(this, _scopes).get(scope);
        if (scopedMutations) {
          scopedMutations.push(mutation);
        } else {
          __privateGet(this, _scopes).set(scope, [mutation]);
        }
      }
      this.notify({ type: "added", mutation });
    }
    remove(mutation) {
      if (__privateGet(this, _mutations).delete(mutation)) {
        const scope = scopeFor(mutation);
        if (typeof scope === "string") {
          const scopedMutations = __privateGet(this, _scopes).get(scope);
          if (scopedMutations) {
            if (scopedMutations.length > 1) {
              const index2 = scopedMutations.indexOf(mutation);
              if (index2 !== -1) {
                scopedMutations.splice(index2, 1);
              }
            } else if (scopedMutations[0] === mutation) {
              __privateGet(this, _scopes).delete(scope);
            }
          }
        }
      }
      this.notify({ type: "removed", mutation });
    }
    canRun(mutation) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const mutationsWithSameScope = __privateGet(this, _scopes).get(scope);
        const firstPendingMutation = mutationsWithSameScope == null ? void 0 : mutationsWithSameScope.find(
          (m2) => m2.state.status === "pending"
        );
        return !firstPendingMutation || firstPendingMutation === mutation;
      } else {
        return true;
      }
    }
    runNext(mutation) {
      var _a2;
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const foundMutation = (_a2 = __privateGet(this, _scopes).get(scope)) == null ? void 0 : _a2.find((m2) => m2 !== mutation && m2.state.isPaused);
        return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
      } else {
        return Promise.resolve();
      }
    }
    clear() {
      notifyManager.batch(() => {
        __privateGet(this, _mutations).forEach((mutation) => {
          this.notify({ type: "removed", mutation });
        });
        __privateGet(this, _mutations).clear();
        __privateGet(this, _scopes).clear();
      });
    }
    getAll() {
      return Array.from(__privateGet(this, _mutations));
    }
    find(filters) {
      const defaultedFilters = { exact: true, ...filters };
      return this.getAll().find(
        (mutation) => matchMutation(defaultedFilters, mutation)
      );
    }
    findAll(filters = {}) {
      return this.getAll().filter((mutation) => matchMutation(filters, mutation));
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach((listener) => {
          listener(event);
        });
      });
    }
    resumePausedMutations() {
      const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
      return notifyManager.batch(
        () => Promise.all(
          pausedMutations.map((mutation) => mutation.continue().catch(noop$1))
        )
      );
    }
  }, _mutations = new WeakMap(), _scopes = new WeakMap(), _mutationId = new WeakMap(), _g);
  function scopeFor(mutation) {
    var _a2;
    return (_a2 = mutation.options.scope) == null ? void 0 : _a2.id;
  }
  function infiniteQueryBehavior(pages) {
    return {
      onFetch: (context, query) => {
        var _a2, _b2, _c2, _d2, _e3;
        const options2 = context.options;
        const direction = (_c2 = (_b2 = (_a2 = context.fetchOptions) == null ? void 0 : _a2.meta) == null ? void 0 : _b2.fetchMore) == null ? void 0 : _c2.direction;
        const oldPages = ((_d2 = context.state.data) == null ? void 0 : _d2.pages) || [];
        const oldPageParams = ((_e3 = context.state.data) == null ? void 0 : _e3.pageParams) || [];
        let result = { pages: [], pageParams: [] };
        let currentPage = 0;
        const fetchFn = async () => {
          let cancelled = false;
          const addSignalProperty = (object) => {
            Object.defineProperty(object, "signal", {
              enumerable: true,
              get: () => {
                if (context.signal.aborted) {
                  cancelled = true;
                } else {
                  context.signal.addEventListener("abort", () => {
                    cancelled = true;
                  });
                }
                return context.signal;
              }
            });
          };
          const queryFn = ensureQueryFn(context.options, context.fetchOptions);
          const fetchPage = async (data, param, previous2) => {
            if (cancelled) {
              return Promise.reject();
            }
            if (param == null && data.pages.length) {
              return Promise.resolve(data);
            }
            const createQueryFnContext = () => {
              const queryFnContext2 = {
                client: context.client,
                queryKey: context.queryKey,
                pageParam: param,
                direction: previous2 ? "backward" : "forward",
                meta: context.options.meta
              };
              addSignalProperty(queryFnContext2);
              return queryFnContext2;
            };
            const queryFnContext = createQueryFnContext();
            const page = await queryFn(queryFnContext);
            const { maxPages } = context.options;
            const addTo = previous2 ? addToStart : addToEnd;
            return {
              pages: addTo(data.pages, page, maxPages),
              pageParams: addTo(data.pageParams, param, maxPages)
            };
          };
          if (direction && oldPages.length) {
            const previous2 = direction === "backward";
            const pageParamFn = previous2 ? getPreviousPageParam : getNextPageParam;
            const oldData = {
              pages: oldPages,
              pageParams: oldPageParams
            };
            const param = pageParamFn(options2, oldData);
            result = await fetchPage(oldData, param, previous2);
          } else {
            const remainingPages = pages ?? oldPages.length;
            do {
              const param = currentPage === 0 ? oldPageParams[0] ?? options2.initialPageParam : getNextPageParam(options2, result);
              if (currentPage > 0 && param == null) {
                break;
              }
              result = await fetchPage(result, param);
              currentPage++;
            } while (currentPage < remainingPages);
          }
          return result;
        };
        if (context.options.persister) {
          context.fetchFn = () => {
            var _a3, _b3;
            return (_b3 = (_a3 = context.options).persister) == null ? void 0 : _b3.call(
              _a3,
              fetchFn,
              {
                client: context.client,
                queryKey: context.queryKey,
                meta: context.options.meta,
                signal: context.signal
              },
              query
            );
          };
        } else {
          context.fetchFn = fetchFn;
        }
      }
    };
  }
  function getNextPageParam(options2, { pages, pageParams }) {
    const lastIndex = pages.length - 1;
    return pages.length > 0 ? options2.getNextPageParam(
      pages[lastIndex],
      pages,
      pageParams[lastIndex],
      pageParams
    ) : void 0;
  }
  function getPreviousPageParam(options2, { pages, pageParams }) {
    var _a2;
    return pages.length > 0 ? (_a2 = options2.getPreviousPageParam) == null ? void 0 : _a2.call(options2, pages[0], pages, pageParams[0], pageParams) : void 0;
  }
  var QueryClient = (_h = class {
    constructor(config = {}) {
      __privateAdd(this, _queryCache);
      __privateAdd(this, _mutationCache2);
      __privateAdd(this, _defaultOptions2);
      __privateAdd(this, _queryDefaults);
      __privateAdd(this, _mutationDefaults);
      __privateAdd(this, _mountCount);
      __privateAdd(this, _unsubscribeFocus);
      __privateAdd(this, _unsubscribeOnline);
      __privateSet(this, _queryCache, config.queryCache || new QueryCache());
      __privateSet(this, _mutationCache2, config.mutationCache || new MutationCache());
      __privateSet(this, _defaultOptions2, config.defaultOptions || {});
      __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
      __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
      __privateSet(this, _mountCount, 0);
    }
    mount() {
      __privateWrapper(this, _mountCount)._++;
      if (__privateGet(this, _mountCount) !== 1) return;
      __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
        if (focused) {
          await this.resumePausedMutations();
          __privateGet(this, _queryCache).onFocus();
        }
      }));
      __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
        if (online) {
          await this.resumePausedMutations();
          __privateGet(this, _queryCache).onOnline();
        }
      }));
    }
    unmount() {
      var _a2, _b2;
      __privateWrapper(this, _mountCount)._--;
      if (__privateGet(this, _mountCount) !== 0) return;
      (_a2 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _unsubscribeFocus, void 0);
      (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
      __privateSet(this, _unsubscribeOnline, void 0);
    }
    isFetching(filters) {
      return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
    }
    isMutating(filters) {
      return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
    }
    /**
     * Imperative (non-reactive) way to retrieve data for a QueryKey.
     * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
     *
     * Hint: Do not use this function inside a component, because it won't receive updates.
     * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
     */
    getQueryData(queryKey) {
      var _a2;
      const options2 = this.defaultQueryOptions({ queryKey });
      return (_a2 = __privateGet(this, _queryCache).get(options2.queryHash)) == null ? void 0 : _a2.state.data;
    }
    ensureQueryData(options2) {
      const defaultedOptions = this.defaultQueryOptions(options2);
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      const cachedData = query.state.data;
      if (cachedData === void 0) {
        return this.fetchQuery(options2);
      }
      if (options2.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
        void this.prefetchQuery(defaultedOptions);
      }
      return Promise.resolve(cachedData);
    }
    getQueriesData(filters) {
      return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
        const data = state.data;
        return [queryKey, data];
      });
    }
    setQueryData(queryKey, updater, options2) {
      const defaultedOptions = this.defaultQueryOptions({ queryKey });
      const query = __privateGet(this, _queryCache).get(
        defaultedOptions.queryHash
      );
      const prevData = query == null ? void 0 : query.state.data;
      const data = functionalUpdate(updater, prevData);
      if (data === void 0) {
        return void 0;
      }
      return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options2, manual: true });
    }
    setQueriesData(filters, updater, options2) {
      return notifyManager.batch(
        () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
          queryKey,
          this.setQueryData(queryKey, updater, options2)
        ])
      );
    }
    getQueryState(queryKey) {
      var _a2;
      const options2 = this.defaultQueryOptions({ queryKey });
      return (_a2 = __privateGet(this, _queryCache).get(
        options2.queryHash
      )) == null ? void 0 : _a2.state;
    }
    removeQueries(filters) {
      const queryCache = __privateGet(this, _queryCache);
      notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          queryCache.remove(query);
        });
      });
    }
    resetQueries(filters, options2) {
      const queryCache = __privateGet(this, _queryCache);
      return notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          query.reset();
        });
        return this.refetchQueries(
          {
            type: "active",
            ...filters
          },
          options2
        );
      });
    }
    cancelQueries(filters, cancelOptions = {}) {
      const defaultedCancelOptions = { revert: true, ...cancelOptions };
      const promises = notifyManager.batch(
        () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
      );
      return Promise.all(promises).then(noop$1).catch(noop$1);
    }
    invalidateQueries(filters, options2 = {}) {
      return notifyManager.batch(() => {
        __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
          query.invalidate();
        });
        if ((filters == null ? void 0 : filters.refetchType) === "none") {
          return Promise.resolve();
        }
        return this.refetchQueries(
          {
            ...filters,
            type: (filters == null ? void 0 : filters.refetchType) ?? (filters == null ? void 0 : filters.type) ?? "active"
          },
          options2
        );
      });
    }
    refetchQueries(filters, options2 = {}) {
      const fetchOptions = {
        ...options2,
        cancelRefetch: options2.cancelRefetch ?? true
      };
      const promises = notifyManager.batch(
        () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {
          let promise = query.fetch(void 0, fetchOptions);
          if (!fetchOptions.throwOnError) {
            promise = promise.catch(noop$1);
          }
          return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
        })
      );
      return Promise.all(promises).then(noop$1);
    }
    fetchQuery(options2) {
      const defaultedOptions = this.defaultQueryOptions(options2);
      if (defaultedOptions.retry === void 0) {
        defaultedOptions.retry = false;
      }
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      return query.isStaleByTime(
        resolveStaleTime(defaultedOptions.staleTime, query)
      ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
    }
    prefetchQuery(options2) {
      return this.fetchQuery(options2).then(noop$1).catch(noop$1);
    }
    fetchInfiniteQuery(options2) {
      options2.behavior = infiniteQueryBehavior(options2.pages);
      return this.fetchQuery(options2);
    }
    prefetchInfiniteQuery(options2) {
      return this.fetchInfiniteQuery(options2).then(noop$1).catch(noop$1);
    }
    ensureInfiniteQueryData(options2) {
      options2.behavior = infiniteQueryBehavior(options2.pages);
      return this.ensureQueryData(options2);
    }
    resumePausedMutations() {
      if (onlineManager.isOnline()) {
        return __privateGet(this, _mutationCache2).resumePausedMutations();
      }
      return Promise.resolve();
    }
    getQueryCache() {
      return __privateGet(this, _queryCache);
    }
    getMutationCache() {
      return __privateGet(this, _mutationCache2);
    }
    getDefaultOptions() {
      return __privateGet(this, _defaultOptions2);
    }
    setDefaultOptions(options2) {
      __privateSet(this, _defaultOptions2, options2);
    }
    setQueryDefaults(queryKey, options2) {
      __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
        queryKey,
        defaultOptions: options2
      });
    }
    getQueryDefaults(queryKey) {
      const defaults2 = [...__privateGet(this, _queryDefaults).values()];
      const result = {};
      defaults2.forEach((queryDefault) => {
        if (partialMatchKey(queryKey, queryDefault.queryKey)) {
          Object.assign(result, queryDefault.defaultOptions);
        }
      });
      return result;
    }
    setMutationDefaults(mutationKey, options2) {
      __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
        mutationKey,
        defaultOptions: options2
      });
    }
    getMutationDefaults(mutationKey) {
      const defaults2 = [...__privateGet(this, _mutationDefaults).values()];
      const result = {};
      defaults2.forEach((queryDefault) => {
        if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
          Object.assign(result, queryDefault.defaultOptions);
        }
      });
      return result;
    }
    defaultQueryOptions(options2) {
      if (options2._defaulted) {
        return options2;
      }
      const defaultedOptions = {
        ...__privateGet(this, _defaultOptions2).queries,
        ...this.getQueryDefaults(options2.queryKey),
        ...options2,
        _defaulted: true
      };
      if (!defaultedOptions.queryHash) {
        defaultedOptions.queryHash = hashQueryKeyByOptions(
          defaultedOptions.queryKey,
          defaultedOptions
        );
      }
      if (defaultedOptions.refetchOnReconnect === void 0) {
        defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
      }
      if (defaultedOptions.throwOnError === void 0) {
        defaultedOptions.throwOnError = !!defaultedOptions.suspense;
      }
      if (!defaultedOptions.networkMode && defaultedOptions.persister) {
        defaultedOptions.networkMode = "offlineFirst";
      }
      if (defaultedOptions.queryFn === skipToken) {
        defaultedOptions.enabled = false;
      }
      return defaultedOptions;
    }
    defaultMutationOptions(options2) {
      if (options2 == null ? void 0 : options2._defaulted) {
        return options2;
      }
      return {
        ...__privateGet(this, _defaultOptions2).mutations,
        ...(options2 == null ? void 0 : options2.mutationKey) && this.getMutationDefaults(options2.mutationKey),
        ...options2,
        _defaulted: true
      };
    }
    clear() {
      __privateGet(this, _queryCache).clear();
      __privateGet(this, _mutationCache2).clear();
    }
  }, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _h);
  var QueryObserver = (_i = class extends Subscribable {
    constructor(client2, options2) {
      super();
      __privateAdd(this, _QueryObserver_instances);
      __privateAdd(this, _client2);
      __privateAdd(this, _currentQuery);
      __privateAdd(this, _currentQueryInitialState);
      __privateAdd(this, _currentResult);
      __privateAdd(this, _currentResultState);
      __privateAdd(this, _currentResultOptions);
      __privateAdd(this, _currentThenable);
      __privateAdd(this, _selectError);
      __privateAdd(this, _selectFn);
      __privateAdd(this, _selectResult);
      // This property keeps track of the last query with defined data.
      // It will be used to pass the previous data and query to the placeholder function between renders.
      __privateAdd(this, _lastQueryWithDefinedData);
      __privateAdd(this, _staleTimeoutId);
      __privateAdd(this, _refetchIntervalId);
      __privateAdd(this, _currentRefetchInterval);
      __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
      this.options = options2;
      __privateSet(this, _client2, client2);
      __privateSet(this, _selectError, null);
      __privateSet(this, _currentThenable, pendingThenable());
      if (!this.options.experimental_prefetchInRender) {
        __privateGet(this, _currentThenable).reject(
          new Error("experimental_prefetchInRender feature flag is not enabled")
        );
      }
      this.bindMethods();
      this.setOptions(options2);
    }
    bindMethods() {
      this.refetch = this.refetch.bind(this);
    }
    onSubscribe() {
      if (this.listeners.size === 1) {
        __privateGet(this, _currentQuery).addObserver(this);
        if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
          __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
        } else {
          this.updateResult();
        }
        __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        this.destroy();
      }
    }
    shouldFetchOnReconnect() {
      return shouldFetchOn(
        __privateGet(this, _currentQuery),
        this.options,
        this.options.refetchOnReconnect
      );
    }
    shouldFetchOnWindowFocus() {
      return shouldFetchOn(
        __privateGet(this, _currentQuery),
        this.options,
        this.options.refetchOnWindowFocus
      );
    }
    destroy() {
      this.listeners = /* @__PURE__ */ new Set();
      __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
      __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
      __privateGet(this, _currentQuery).removeObserver(this);
    }
    setOptions(options2) {
      const prevOptions = this.options;
      const prevQuery = __privateGet(this, _currentQuery);
      this.options = __privateGet(this, _client2).defaultQueryOptions(options2);
      if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
        throw new Error(
          "Expected enabled to be a boolean or a callback that returns a boolean"
        );
      }
      __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
      __privateGet(this, _currentQuery).setOptions(this.options);
      if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
        __privateGet(this, _client2).getQueryCache().notify({
          type: "observerOptionsUpdated",
          query: __privateGet(this, _currentQuery),
          observer: this
        });
      }
      const mounted = this.hasListeners();
      if (mounted && shouldFetchOptionally(
        __privateGet(this, _currentQuery),
        prevQuery,
        this.options,
        prevOptions
      )) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      }
      this.updateResult();
      if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
        __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
      }
      const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
      if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
        __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
      }
    }
    getOptimisticResult(options2) {
      const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), options2);
      const result = this.createResult(query, options2);
      if (shouldAssignObserverCurrentProperties(this, result)) {
        __privateSet(this, _currentResult, result);
        __privateSet(this, _currentResultOptions, this.options);
        __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
      }
      return result;
    }
    getCurrentResult() {
      return __privateGet(this, _currentResult);
    }
    trackResult(result, onPropTracked) {
      return new Proxy(result, {
        get: (target, key) => {
          this.trackProp(key);
          onPropTracked == null ? void 0 : onPropTracked(key);
          return Reflect.get(target, key);
        }
      });
    }
    trackProp(key) {
      __privateGet(this, _trackedProps).add(key);
    }
    getCurrentQuery() {
      return __privateGet(this, _currentQuery);
    }
    refetch({ ...options2 } = {}) {
      return this.fetch({
        ...options2
      });
    }
    fetchOptimistic(options2) {
      const defaultedOptions = __privateGet(this, _client2).defaultQueryOptions(options2);
      const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), defaultedOptions);
      return query.fetch().then(() => this.createResult(query, defaultedOptions));
    }
    fetch(fetchOptions) {
      return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {
        ...fetchOptions,
        cancelRefetch: fetchOptions.cancelRefetch ?? true
      }).then(() => {
        this.updateResult();
        return __privateGet(this, _currentResult);
      });
    }
    createResult(query, options2) {
      var _a2;
      const prevQuery = __privateGet(this, _currentQuery);
      const prevOptions = this.options;
      const prevResult = __privateGet(this, _currentResult);
      const prevResultState = __privateGet(this, _currentResultState);
      const prevResultOptions = __privateGet(this, _currentResultOptions);
      const queryChange = query !== prevQuery;
      const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
      const { state } = query;
      let newState = { ...state };
      let isPlaceholderData = false;
      let data;
      if (options2._optimisticResults) {
        const mounted = this.hasListeners();
        const fetchOnMount = !mounted && shouldFetchOnMount(query, options2);
        const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options2, prevOptions);
        if (fetchOnMount || fetchOptionally) {
          newState = {
            ...newState,
            ...fetchState(state.data, query.options)
          };
        }
        if (options2._optimisticResults === "isRestoring") {
          newState.fetchStatus = "idle";
        }
      }
      let { error, errorUpdatedAt, status } = newState;
      data = newState.data;
      let skipSelect = false;
      if (options2.placeholderData !== void 0 && data === void 0 && status === "pending") {
        let placeholderData;
        if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options2.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
          placeholderData = prevResult.data;
          skipSelect = true;
        } else {
          placeholderData = typeof options2.placeholderData === "function" ? options2.placeholderData(
            (_a2 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a2.state.data,
            __privateGet(this, _lastQueryWithDefinedData)
          ) : options2.placeholderData;
        }
        if (placeholderData !== void 0) {
          status = "success";
          data = replaceData(
            prevResult == null ? void 0 : prevResult.data,
            placeholderData,
            options2
          );
          isPlaceholderData = true;
        }
      }
      if (options2.select && data !== void 0 && !skipSelect) {
        if (prevResult && data === (prevResultState == null ? void 0 : prevResultState.data) && options2.select === __privateGet(this, _selectFn)) {
          data = __privateGet(this, _selectResult);
        } else {
          try {
            __privateSet(this, _selectFn, options2.select);
            data = options2.select(data);
            data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options2);
            __privateSet(this, _selectResult, data);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      }
      if (__privateGet(this, _selectError)) {
        error = __privateGet(this, _selectError);
        data = __privateGet(this, _selectResult);
        errorUpdatedAt = Date.now();
        status = "error";
      }
      const isFetching = newState.fetchStatus === "fetching";
      const isPending = status === "pending";
      const isError = status === "error";
      const isLoading = isPending && isFetching;
      const hasData = data !== void 0;
      const result = {
        status,
        fetchStatus: newState.fetchStatus,
        isPending,
        isSuccess: status === "success",
        isError,
        isInitialLoading: isLoading,
        isLoading,
        data,
        dataUpdatedAt: newState.dataUpdatedAt,
        error,
        errorUpdatedAt,
        failureCount: newState.fetchFailureCount,
        failureReason: newState.fetchFailureReason,
        errorUpdateCount: newState.errorUpdateCount,
        isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
        isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
        isFetching,
        isRefetching: isFetching && !isPending,
        isLoadingError: isError && !hasData,
        isPaused: newState.fetchStatus === "paused",
        isPlaceholderData,
        isRefetchError: isError && hasData,
        isStale: isStale(query, options2),
        refetch: this.refetch,
        promise: __privateGet(this, _currentThenable)
      };
      const nextResult = result;
      if (this.options.experimental_prefetchInRender) {
        const finalizeThenableIfPossible = (thenable) => {
          if (nextResult.status === "error") {
            thenable.reject(nextResult.error);
          } else if (nextResult.data !== void 0) {
            thenable.resolve(nextResult.data);
          }
        };
        const recreateThenable = () => {
          const pending = __privateSet(this, _currentThenable, nextResult.promise = pendingThenable());
          finalizeThenableIfPossible(pending);
        };
        const prevThenable = __privateGet(this, _currentThenable);
        switch (prevThenable.status) {
          case "pending":
            if (query.queryHash === prevQuery.queryHash) {
              finalizeThenableIfPossible(prevThenable);
            }
            break;
          case "fulfilled":
            if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
              recreateThenable();
            }
            break;
          case "rejected":
            if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
              recreateThenable();
            }
            break;
        }
      }
      return nextResult;
    }
    updateResult() {
      const prevResult = __privateGet(this, _currentResult);
      const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
      __privateSet(this, _currentResultOptions, this.options);
      if (__privateGet(this, _currentResultState).data !== void 0) {
        __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
      }
      if (shallowEqualObjects(nextResult, prevResult)) {
        return;
      }
      __privateSet(this, _currentResult, nextResult);
      const shouldNotifyListeners = () => {
        if (!prevResult) {
          return true;
        }
        const { notifyOnChangeProps } = this.options;
        const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
        if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
          return true;
        }
        const includedProps = new Set(
          notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)
        );
        if (this.options.throwOnError) {
          includedProps.add("error");
        }
        return Object.keys(__privateGet(this, _currentResult)).some((key) => {
          const typedKey = key;
          const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
          return changed && includedProps.has(typedKey);
        });
      };
      __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { listeners: shouldNotifyListeners() });
    }
    onQueryUpdate() {
      this.updateResult();
      if (this.hasListeners()) {
        __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
      }
    }
  }, _client2 = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _currentThenable = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    let promise = __privateGet(this, _currentQuery).fetch(
      this.options,
      fetchOptions
    );
    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
      promise = promise.catch(noop$1);
    }
    return promise;
  }, updateStaleTimeout_fn = function() {
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    const staleTime = resolveStaleTime(
      this.options.staleTime,
      __privateGet(this, _currentQuery)
    );
    if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
      return;
    }
    const time2 = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
    const timeout = time2 + 1;
    __privateSet(this, _staleTimeoutId, setTimeout(() => {
      if (!__privateGet(this, _currentResult).isStale) {
        this.updateResult();
      }
    }, timeout));
  }, computeRefetchInterval_fn = function() {
    return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;
  }, updateRefetchInterval_fn = function(nextInterval) {
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateSet(this, _currentRefetchInterval, nextInterval);
    if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
      return;
    }
    __privateSet(this, _refetchIntervalId, setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      }
    }, __privateGet(this, _currentRefetchInterval)));
  }, updateTimers_fn = function() {
    __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
  }, clearStaleTimeout_fn = function() {
    if (__privateGet(this, _staleTimeoutId)) {
      clearTimeout(__privateGet(this, _staleTimeoutId));
      __privateSet(this, _staleTimeoutId, void 0);
    }
  }, clearRefetchInterval_fn = function() {
    if (__privateGet(this, _refetchIntervalId)) {
      clearInterval(__privateGet(this, _refetchIntervalId));
      __privateSet(this, _refetchIntervalId, void 0);
    }
  }, updateQuery_fn = function() {
    const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), this.options);
    if (query === __privateGet(this, _currentQuery)) {
      return;
    }
    const prevQuery = __privateGet(this, _currentQuery);
    __privateSet(this, _currentQuery, query);
    __privateSet(this, _currentQueryInitialState, query.state);
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }, notify_fn = function(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(__privateGet(this, _currentResult));
        });
      }
      __privateGet(this, _client2).getQueryCache().notify({
        query: __privateGet(this, _currentQuery),
        type: "observerResultsUpdated"
      });
    });
  }, _i);
  function shouldLoadOnMount(query, options2) {
    return resolveEnabled(options2.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options2.retryOnMount === false);
  }
  function shouldFetchOnMount(query, options2) {
    return shouldLoadOnMount(query, options2) || query.state.data !== void 0 && shouldFetchOn(query, options2, options2.refetchOnMount);
  }
  function shouldFetchOn(query, options2, field) {
    if (resolveEnabled(options2.enabled, query) !== false && resolveStaleTime(options2.staleTime, query) !== "static") {
      const value = typeof field === "function" ? field(query) : field;
      return value === "always" || value !== false && isStale(query, options2);
    }
    return false;
  }
  function shouldFetchOptionally(query, prevQuery, options2, prevOptions) {
    return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options2.suspense || query.state.status !== "error") && isStale(query, options2);
  }
  function isStale(query, options2) {
    return resolveEnabled(options2.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options2.staleTime, query));
  }
  function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
    if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
      return true;
    }
    return false;
  }
  var MutationObserver$1 = (_j = class extends Subscribable {
    constructor(client2, options2) {
      super();
      __privateAdd(this, _MutationObserver_instances);
      __privateAdd(this, _client3);
      __privateAdd(this, _currentResult2);
      __privateAdd(this, _currentMutation);
      __privateAdd(this, _mutateOptions);
      __privateSet(this, _client3, client2);
      this.setOptions(options2);
      this.bindMethods();
      __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    }
    bindMethods() {
      this.mutate = this.mutate.bind(this);
      this.reset = this.reset.bind(this);
    }
    setOptions(options2) {
      var _a2;
      const prevOptions = this.options;
      this.options = __privateGet(this, _client3).defaultMutationOptions(options2);
      if (!shallowEqualObjects(this.options, prevOptions)) {
        __privateGet(this, _client3).getMutationCache().notify({
          type: "observerOptionsUpdated",
          mutation: __privateGet(this, _currentMutation),
          observer: this
        });
      }
      if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
        this.reset();
      } else if (((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state.status) === "pending") {
        __privateGet(this, _currentMutation).setOptions(this.options);
      }
    }
    onUnsubscribe() {
      var _a2;
      if (!this.hasListeners()) {
        (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
      }
    }
    onMutationUpdate(action) {
      __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
      __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this, action);
    }
    getCurrentResult() {
      return __privateGet(this, _currentResult2);
    }
    reset() {
      var _a2;
      (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
      __privateSet(this, _currentMutation, void 0);
      __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
      __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this);
    }
    mutate(variables, options2) {
      var _a2;
      __privateSet(this, _mutateOptions, options2);
      (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
      __privateSet(this, _currentMutation, __privateGet(this, _client3).getMutationCache().build(__privateGet(this, _client3), this.options));
      __privateGet(this, _currentMutation).addObserver(this);
      return __privateGet(this, _currentMutation).execute(variables);
    }
  }, _client3 = new WeakMap(), _currentResult2 = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
    var _a2;
    const state = ((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state) ?? getDefaultState();
    __privateSet(this, _currentResult2, {
      ...state,
      isPending: state.status === "pending",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    });
  }, notify_fn2 = function(action) {
    notifyManager.batch(() => {
      var _a2, _b2, _c2, _d2, _e3, _f2, _g2, _h2;
      if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
        const variables = __privateGet(this, _currentResult2).variables;
        const context = __privateGet(this, _currentResult2).context;
        if ((action == null ? void 0 : action.type) === "success") {
          (_b2 = (_a2 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b2.call(_a2, action.data, variables, context);
          (_d2 = (_c2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d2.call(_c2, action.data, null, variables, context);
        } else if ((action == null ? void 0 : action.type) === "error") {
          (_f2 = (_e3 = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f2.call(_e3, action.error, variables, context);
          (_h2 = (_g2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h2.call(
            _g2,
            void 0,
            action.error,
            variables,
            context
          );
        }
      }
      this.listeners.forEach((listener) => {
        listener(__privateGet(this, _currentResult2));
      });
    });
  }, _j);
  var QueryClientContext = reactExports.createContext(
    void 0
  );
  var useQueryClient = (queryClient) => {
    const client2 = reactExports.useContext(QueryClientContext);
    if (!client2) {
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
    }
    return client2;
  };
  var QueryClientProvider$1 = ({
    client: client2,
    children
  }) => {
    reactExports.useEffect(() => {
      client2.mount();
      return () => {
        client2.unmount();
      };
    }, [client2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientContext.Provider, { value: client2, children });
  };
  var IsRestoringContext = reactExports.createContext(false);
  var useIsRestoring = () => reactExports.useContext(IsRestoringContext);
  IsRestoringContext.Provider;
  function createValue() {
    let isReset = false;
    return {
      clearReset: () => {
        isReset = false;
      },
      reset: () => {
        isReset = true;
      },
      isReset: () => {
        return isReset;
      }
    };
  }
  var QueryErrorResetBoundaryContext = reactExports.createContext(createValue());
  var useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
  var ensurePreventErrorBoundaryRetry = (options2, errorResetBoundary) => {
    if (options2.suspense || options2.throwOnError || options2.experimental_prefetchInRender) {
      if (!errorResetBoundary.isReset()) {
        options2.retryOnMount = false;
      }
    }
  };
  var useClearResetErrorBoundary = (errorResetBoundary) => {
    reactExports.useEffect(() => {
      errorResetBoundary.clearReset();
    }, [errorResetBoundary]);
  };
  var getHasError = ({
    result,
    errorResetBoundary,
    throwOnError,
    query,
    suspense
  }) => {
    return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));
  };
  var ensureSuspenseTimers = (defaultedOptions) => {
    if (defaultedOptions.suspense) {
      const clamp2 = (value) => value === "static" ? value : Math.max(value ?? 1e3, 1e3);
      const originalStaleTime = defaultedOptions.staleTime;
      defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => clamp2(originalStaleTime(...args)) : clamp2(originalStaleTime);
      if (typeof defaultedOptions.gcTime === "number") {
        defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
      }
    }
  };
  var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
  var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
  var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
    errorResetBoundary.clearReset();
  });
  function useBaseQuery(options2, Observer, queryClient) {
    var _a2, _b2, _c2, _d2, _e3;
    const isRestoring = useIsRestoring();
    const errorResetBoundary = useQueryErrorResetBoundary();
    const client2 = useQueryClient();
    const defaultedOptions = client2.defaultQueryOptions(options2);
    (_b2 = (_a2 = client2.getDefaultOptions().queries) == null ? void 0 : _a2._experimental_beforeQuery) == null ? void 0 : _b2.call(
      _a2,
      defaultedOptions
    );
    defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
    ensureSuspenseTimers(defaultedOptions);
    ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
    useClearResetErrorBoundary(errorResetBoundary);
    const isNewCacheEntry = !client2.getQueryCache().get(defaultedOptions.queryHash);
    const [observer] = reactExports.useState(
      () => new Observer(
        client2,
        defaultedOptions
      )
    );
    const result = observer.getOptimisticResult(defaultedOptions);
    const shouldSubscribe = !isRestoring && options2.subscribed !== false;
    reactExports.useSyncExternalStore(
      reactExports.useCallback(
        (onStoreChange) => {
          const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop$1;
          observer.updateResult();
          return unsubscribe;
        },
        [observer, shouldSubscribe]
      ),
      () => observer.getCurrentResult(),
      () => observer.getCurrentResult()
    );
    reactExports.useEffect(() => {
      observer.setOptions(defaultedOptions);
    }, [defaultedOptions, observer]);
    if (shouldSuspend(defaultedOptions, result)) {
      throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
    }
    if (getHasError({
      result,
      errorResetBoundary,
      throwOnError: defaultedOptions.throwOnError,
      query: client2.getQueryCache().get(defaultedOptions.queryHash),
      suspense: defaultedOptions.suspense
    })) {
      throw result.error;
    }
    (_d2 = (_c2 = client2.getDefaultOptions().queries) == null ? void 0 : _c2._experimental_afterQuery) == null ? void 0 : _d2.call(
      _c2,
      defaultedOptions,
      result
    );
    if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
      const promise = isNewCacheEntry ? (
        // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
      ) : (
        // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
        (_e3 = client2.getQueryCache().get(defaultedOptions.queryHash)) == null ? void 0 : _e3.promise
      );
      promise == null ? void 0 : promise.catch(noop$1).finally(() => {
        observer.updateResult();
      });
    }
    return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
  }
  function useQuery(options2, queryClient) {
    return useBaseQuery(options2, QueryObserver);
  }
  function useMutation(options2, queryClient) {
    const client2 = useQueryClient();
    const [observer] = reactExports.useState(
      () => new MutationObserver$1(
        client2,
        options2
      )
    );
    reactExports.useEffect(() => {
      observer.setOptions(options2);
    }, [observer, options2]);
    const result = reactExports.useSyncExternalStore(
      reactExports.useCallback(
        (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
        [observer]
      ),
      () => observer.getCurrentResult(),
      () => observer.getCurrentResult()
    );
    const mutate = reactExports.useCallback(
      (variables, mutateOptions) => {
        observer.mutate(variables, mutateOptions).catch(noop$1);
      },
      [observer]
    );
    if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
      throw result.error;
    }
    return { ...result, mutate, mutateAsync: result.mutate };
  }
  var pusher = { exports: {} };
  /*!
   * Pusher JavaScript Library v8.4.0
   * https://pusher.com/
   *
   * Copyright 2020, Pusher
   * Released under the MIT licence.
   */
  (function(module2, exports3) {
    (function webpackUniversalModuleDefinition(root2, factory) {
      module2.exports = factory();
    })(window, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.l = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports4, name2, getter) {
            if (!__webpack_require__.o(exports4, name2)) {
              Object.defineProperty(exports4, name2, { enumerable: true, get: getter });
            }
          };
          __webpack_require__.r = function(exports4) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports4, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports4, "__esModule", { value: true });
          };
          __webpack_require__.t = function(value, mode) {
            if (mode & 1) value = __webpack_require__(value);
            if (mode & 8) return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__.d(ns, key, (function(key2) {
              return value[key2];
            }).bind(null, key));
            return ns;
          };
          __webpack_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? (
              /******/
              function getDefault() {
                return module3["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module3;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 2);
        }([
          /* 0 */
          /***/
          function(module3, exports4, __webpack_require__) {
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports4, "__esModule", { value: true });
            var INVALID_BYTE = 256;
            var Coder = (
              /** @class */
              function() {
                function Coder2(_paddingCharacter) {
                  if (_paddingCharacter === void 0) {
                    _paddingCharacter = "=";
                  }
                  this._paddingCharacter = _paddingCharacter;
                }
                Coder2.prototype.encodedLength = function(length) {
                  if (!this._paddingCharacter) {
                    return (length * 8 + 5) / 6 | 0;
                  }
                  return (length + 2) / 3 * 4 | 0;
                };
                Coder2.prototype.encode = function(data) {
                  var out = "";
                  var i = 0;
                  for (; i < data.length - 2; i += 3) {
                    var c = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
                    out += this._encodeByte(c >>> 3 * 6 & 63);
                    out += this._encodeByte(c >>> 2 * 6 & 63);
                    out += this._encodeByte(c >>> 1 * 6 & 63);
                    out += this._encodeByte(c >>> 0 * 6 & 63);
                  }
                  var left = data.length - i;
                  if (left > 0) {
                    var c = data[i] << 16 | (left === 2 ? data[i + 1] << 8 : 0);
                    out += this._encodeByte(c >>> 3 * 6 & 63);
                    out += this._encodeByte(c >>> 2 * 6 & 63);
                    if (left === 2) {
                      out += this._encodeByte(c >>> 1 * 6 & 63);
                    } else {
                      out += this._paddingCharacter || "";
                    }
                    out += this._paddingCharacter || "";
                  }
                  return out;
                };
                Coder2.prototype.maxDecodedLength = function(length) {
                  if (!this._paddingCharacter) {
                    return (length * 6 + 7) / 8 | 0;
                  }
                  return length / 4 * 3 | 0;
                };
                Coder2.prototype.decodedLength = function(s) {
                  return this.maxDecodedLength(s.length - this._getPaddingLength(s));
                };
                Coder2.prototype.decode = function(s) {
                  if (s.length === 0) {
                    return new Uint8Array(0);
                  }
                  var paddingLength = this._getPaddingLength(s);
                  var length = s.length - paddingLength;
                  var out = new Uint8Array(this.maxDecodedLength(length));
                  var op = 0;
                  var i = 0;
                  var haveBad = 0;
                  var v0 = 0, v1 = 0, v2 = 0, v3 = 0;
                  for (; i < length - 4; i += 4) {
                    v0 = this._decodeChar(s.charCodeAt(i + 0));
                    v1 = this._decodeChar(s.charCodeAt(i + 1));
                    v2 = this._decodeChar(s.charCodeAt(i + 2));
                    v3 = this._decodeChar(s.charCodeAt(i + 3));
                    out[op++] = v0 << 2 | v1 >>> 4;
                    out[op++] = v1 << 4 | v2 >>> 2;
                    out[op++] = v2 << 6 | v3;
                    haveBad |= v0 & INVALID_BYTE;
                    haveBad |= v1 & INVALID_BYTE;
                    haveBad |= v2 & INVALID_BYTE;
                    haveBad |= v3 & INVALID_BYTE;
                  }
                  if (i < length - 1) {
                    v0 = this._decodeChar(s.charCodeAt(i));
                    v1 = this._decodeChar(s.charCodeAt(i + 1));
                    out[op++] = v0 << 2 | v1 >>> 4;
                    haveBad |= v0 & INVALID_BYTE;
                    haveBad |= v1 & INVALID_BYTE;
                  }
                  if (i < length - 2) {
                    v2 = this._decodeChar(s.charCodeAt(i + 2));
                    out[op++] = v1 << 4 | v2 >>> 2;
                    haveBad |= v2 & INVALID_BYTE;
                  }
                  if (i < length - 3) {
                    v3 = this._decodeChar(s.charCodeAt(i + 3));
                    out[op++] = v2 << 6 | v3;
                    haveBad |= v3 & INVALID_BYTE;
                  }
                  if (haveBad !== 0) {
                    throw new Error("Base64Coder: incorrect characters for decoding");
                  }
                  return out;
                };
                Coder2.prototype._encodeByte = function(b) {
                  var result = b;
                  result += 65;
                  result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
                  result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
                  result += 61 - b >>> 8 & 52 - 48 - 62 + 43;
                  result += 62 - b >>> 8 & 62 - 43 - 63 + 47;
                  return String.fromCharCode(result);
                };
                Coder2.prototype._decodeChar = function(c) {
                  var result = INVALID_BYTE;
                  result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;
                  result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;
                  result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
                  result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
                  result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
                  return result;
                };
                Coder2.prototype._getPaddingLength = function(s) {
                  var paddingLength = 0;
                  if (this._paddingCharacter) {
                    for (var i = s.length - 1; i >= 0; i--) {
                      if (s[i] !== this._paddingCharacter) {
                        break;
                      }
                      paddingLength++;
                    }
                    if (s.length < 4 || paddingLength > 2) {
                      throw new Error("Base64Coder: incorrect padding");
                    }
                  }
                  return paddingLength;
                };
                return Coder2;
              }()
            );
            exports4.Coder = Coder;
            var stdCoder = new Coder();
            function encode2(data) {
              return stdCoder.encode(data);
            }
            exports4.encode = encode2;
            function decode2(s) {
              return stdCoder.decode(s);
            }
            exports4.decode = decode2;
            var URLSafeCoder = (
              /** @class */
              function(_super) {
                __extends(URLSafeCoder2, _super);
                function URLSafeCoder2() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                URLSafeCoder2.prototype._encodeByte = function(b) {
                  var result = b;
                  result += 65;
                  result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
                  result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
                  result += 61 - b >>> 8 & 52 - 48 - 62 + 45;
                  result += 62 - b >>> 8 & 62 - 45 - 63 + 95;
                  return String.fromCharCode(result);
                };
                URLSafeCoder2.prototype._decodeChar = function(c) {
                  var result = INVALID_BYTE;
                  result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;
                  result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;
                  result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
                  result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
                  result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
                  return result;
                };
                return URLSafeCoder2;
              }(Coder)
            );
            exports4.URLSafeCoder = URLSafeCoder;
            var urlSafeCoder = new URLSafeCoder();
            function encodeURLSafe(data) {
              return urlSafeCoder.encode(data);
            }
            exports4.encodeURLSafe = encodeURLSafe;
            function decodeURLSafe(s) {
              return urlSafeCoder.decode(s);
            }
            exports4.decodeURLSafe = decodeURLSafe;
            exports4.encodedLength = function(length) {
              return stdCoder.encodedLength(length);
            };
            exports4.maxDecodedLength = function(length) {
              return stdCoder.maxDecodedLength(length);
            };
            exports4.decodedLength = function(s) {
              return stdCoder.decodedLength(s);
            };
          },
          /* 1 */
          /***/
          function(module3, exports4, __webpack_require__) {
            Object.defineProperty(exports4, "__esModule", { value: true });
            var INVALID_UTF16 = "utf8: invalid string";
            var INVALID_UTF8 = "utf8: invalid source encoding";
            function encode2(s) {
              var arr = new Uint8Array(encodedLength(s));
              var pos = 0;
              for (var i = 0; i < s.length; i++) {
                var c = s.charCodeAt(i);
                if (c < 128) {
                  arr[pos++] = c;
                } else if (c < 2048) {
                  arr[pos++] = 192 | c >> 6;
                  arr[pos++] = 128 | c & 63;
                } else if (c < 55296) {
                  arr[pos++] = 224 | c >> 12;
                  arr[pos++] = 128 | c >> 6 & 63;
                  arr[pos++] = 128 | c & 63;
                } else {
                  i++;
                  c = (c & 1023) << 10;
                  c |= s.charCodeAt(i) & 1023;
                  c += 65536;
                  arr[pos++] = 240 | c >> 18;
                  arr[pos++] = 128 | c >> 12 & 63;
                  arr[pos++] = 128 | c >> 6 & 63;
                  arr[pos++] = 128 | c & 63;
                }
              }
              return arr;
            }
            exports4.encode = encode2;
            function encodedLength(s) {
              var result = 0;
              for (var i = 0; i < s.length; i++) {
                var c = s.charCodeAt(i);
                if (c < 128) {
                  result += 1;
                } else if (c < 2048) {
                  result += 2;
                } else if (c < 55296) {
                  result += 3;
                } else if (c <= 57343) {
                  if (i >= s.length - 1) {
                    throw new Error(INVALID_UTF16);
                  }
                  i++;
                  result += 4;
                } else {
                  throw new Error(INVALID_UTF16);
                }
              }
              return result;
            }
            exports4.encodedLength = encodedLength;
            function decode2(arr) {
              var chars = [];
              for (var i = 0; i < arr.length; i++) {
                var b = arr[i];
                if (b & 128) {
                  var min2 = void 0;
                  if (b < 224) {
                    if (i >= arr.length) {
                      throw new Error(INVALID_UTF8);
                    }
                    var n1 = arr[++i];
                    if ((n1 & 192) !== 128) {
                      throw new Error(INVALID_UTF8);
                    }
                    b = (b & 31) << 6 | n1 & 63;
                    min2 = 128;
                  } else if (b < 240) {
                    if (i >= arr.length - 1) {
                      throw new Error(INVALID_UTF8);
                    }
                    var n1 = arr[++i];
                    var n2 = arr[++i];
                    if ((n1 & 192) !== 128 || (n2 & 192) !== 128) {
                      throw new Error(INVALID_UTF8);
                    }
                    b = (b & 15) << 12 | (n1 & 63) << 6 | n2 & 63;
                    min2 = 2048;
                  } else if (b < 248) {
                    if (i >= arr.length - 2) {
                      throw new Error(INVALID_UTF8);
                    }
                    var n1 = arr[++i];
                    var n2 = arr[++i];
                    var n3 = arr[++i];
                    if ((n1 & 192) !== 128 || (n2 & 192) !== 128 || (n3 & 192) !== 128) {
                      throw new Error(INVALID_UTF8);
                    }
                    b = (b & 15) << 18 | (n1 & 63) << 12 | (n2 & 63) << 6 | n3 & 63;
                    min2 = 65536;
                  } else {
                    throw new Error(INVALID_UTF8);
                  }
                  if (b < min2 || b >= 55296 && b <= 57343) {
                    throw new Error(INVALID_UTF8);
                  }
                  if (b >= 65536) {
                    if (b > 1114111) {
                      throw new Error(INVALID_UTF8);
                    }
                    b -= 65536;
                    chars.push(String.fromCharCode(55296 | b >> 10));
                    b = 56320 | b & 1023;
                  }
                }
                chars.push(String.fromCharCode(b));
              }
              return chars.join("");
            }
            exports4.decode = decode2;
          },
          /* 2 */
          /***/
          function(module3, exports4, __webpack_require__) {
            module3.exports = __webpack_require__(3).default;
          },
          /* 3 */
          /***/
          function(module3, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);
            class ScriptReceiverFactory {
              constructor(prefix2, name2) {
                this.lastId = 0;
                this.prefix = prefix2;
                this.name = name2;
              }
              create(callback) {
                this.lastId++;
                var number2 = this.lastId;
                var id2 = this.prefix + number2;
                var name2 = this.name + "[" + number2 + "]";
                var called = false;
                var callbackWrapper = function() {
                  if (!called) {
                    callback.apply(null, arguments);
                    called = true;
                  }
                };
                this[number2] = callbackWrapper;
                return { number: number2, id: id2, name: name2, callback: callbackWrapper };
              }
              remove(receiver) {
                delete this[receiver.number];
              }
            }
            var ScriptReceivers = new ScriptReceiverFactory("_pusher_script_", "Pusher.ScriptReceivers");
            var Defaults = {
              VERSION: "8.4.0",
              PROTOCOL: 7,
              wsPort: 80,
              wssPort: 443,
              wsPath: "",
              httpHost: "sockjs.pusher.com",
              httpPort: 80,
              httpsPort: 443,
              httpPath: "/pusher",
              stats_host: "stats.pusher.com",
              authEndpoint: "/pusher/auth",
              authTransport: "ajax",
              activityTimeout: 12e4,
              pongTimeout: 3e4,
              unavailableTimeout: 1e4,
              userAuthentication: {
                endpoint: "/pusher/user-auth",
                transport: "ajax"
              },
              channelAuthorization: {
                endpoint: "/pusher/auth",
                transport: "ajax"
              },
              cdn_http: "http://js.pusher.com",
              cdn_https: "https://js.pusher.com",
              dependency_suffix: ""
            };
            var defaults2 = Defaults;
            class dependency_loader_DependencyLoader {
              constructor(options2) {
                this.options = options2;
                this.receivers = options2.receivers || ScriptReceivers;
                this.loading = {};
              }
              load(name2, options2, callback) {
                var self2 = this;
                if (self2.loading[name2] && self2.loading[name2].length > 0) {
                  self2.loading[name2].push(callback);
                } else {
                  self2.loading[name2] = [callback];
                  var request = runtime.createScriptRequest(self2.getPath(name2, options2));
                  var receiver = self2.receivers.create(function(error) {
                    self2.receivers.remove(receiver);
                    if (self2.loading[name2]) {
                      var callbacks = self2.loading[name2];
                      delete self2.loading[name2];
                      var successCallback = function(wasSuccessful) {
                        if (!wasSuccessful) {
                          request.cleanup();
                        }
                      };
                      for (var i = 0; i < callbacks.length; i++) {
                        callbacks[i](error, successCallback);
                      }
                    }
                  });
                  request.send(receiver);
                }
              }
              getRoot(options2) {
                var cdn;
                var protocol = runtime.getDocument().location.protocol;
                if (options2 && options2.useTLS || protocol === "https:") {
                  cdn = this.options.cdn_https;
                } else {
                  cdn = this.options.cdn_http;
                }
                return cdn.replace(/\/*$/, "") + "/" + this.options.version;
              }
              getPath(name2, options2) {
                return this.getRoot(options2) + "/" + name2 + this.options.suffix + ".js";
              }
            }
            var DependenciesReceivers = new ScriptReceiverFactory("_pusher_dependencies", "Pusher.DependenciesReceivers");
            var Dependencies = new dependency_loader_DependencyLoader({
              cdn_http: defaults2.cdn_http,
              cdn_https: defaults2.cdn_https,
              version: defaults2.VERSION,
              suffix: defaults2.dependency_suffix,
              receivers: DependenciesReceivers
            });
            const urlStore = {
              baseUrl: "https://pusher.com",
              urls: {
                authenticationEndpoint: {
                  path: "/docs/channels/server_api/authenticating_users"
                },
                authorizationEndpoint: {
                  path: "/docs/channels/server_api/authorizing-users/"
                },
                javascriptQuickStart: {
                  path: "/docs/javascript_quick_start"
                },
                triggeringClientEvents: {
                  path: "/docs/client_api_guide/client_events#trigger-events"
                },
                encryptedChannelSupport: {
                  fullUrl: "https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support"
                }
              }
            };
            const buildLogSuffix = function(key) {
              const urlPrefix = "See:";
              const urlObj = urlStore.urls[key];
              if (!urlObj)
                return "";
              let url;
              if (urlObj.fullUrl) {
                url = urlObj.fullUrl;
              } else if (urlObj.path) {
                url = urlStore.baseUrl + urlObj.path;
              }
              if (!url)
                return "";
              return `${urlPrefix} ${url}`;
            };
            var url_store = { buildLogSuffix };
            var AuthRequestType;
            (function(AuthRequestType2) {
              AuthRequestType2["UserAuthentication"] = "user-authentication";
              AuthRequestType2["ChannelAuthorization"] = "channel-authorization";
            })(AuthRequestType || (AuthRequestType = {}));
            class BadEventName extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            class BadChannelName extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            class RequestTimedOut extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            class TransportPriorityTooLow extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            class TransportClosed extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            class UnsupportedFeature extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            class UnsupportedTransport extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            class UnsupportedStrategy extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            class HTTPAuthError extends Error {
              constructor(status, msg) {
                super(msg);
                this.status = status;
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            const ajax = function(context, query, authOptions, authRequestType, callback) {
              const xhr = runtime.createXHR();
              xhr.open("POST", authOptions.endpoint, true);
              xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
              for (var headerName in authOptions.headers) {
                xhr.setRequestHeader(headerName, authOptions.headers[headerName]);
              }
              if (authOptions.headersProvider != null) {
                let dynamicHeaders = authOptions.headersProvider();
                for (var headerName in dynamicHeaders) {
                  xhr.setRequestHeader(headerName, dynamicHeaders[headerName]);
                }
              }
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  if (xhr.status === 200) {
                    let data;
                    let parsed = false;
                    try {
                      data = JSON.parse(xhr.responseText);
                      parsed = true;
                    } catch (e) {
                      callback(new HTTPAuthError(200, `JSON returned from ${authRequestType.toString()} endpoint was invalid, yet status code was 200. Data was: ${xhr.responseText}`), null);
                    }
                    if (parsed) {
                      callback(null, data);
                    }
                  } else {
                    let suffix = "";
                    switch (authRequestType) {
                      case AuthRequestType.UserAuthentication:
                        suffix = url_store.buildLogSuffix("authenticationEndpoint");
                        break;
                      case AuthRequestType.ChannelAuthorization:
                        suffix = `Clients must be authorized to join private or presence channels. ${url_store.buildLogSuffix("authorizationEndpoint")}`;
                        break;
                    }
                    callback(new HTTPAuthError(xhr.status, `Unable to retrieve auth string from ${authRequestType.toString()} endpoint - received status: ${xhr.status} from ${authOptions.endpoint}. ${suffix}`), null);
                  }
                }
              };
              xhr.send(query);
              return xhr;
            };
            var xhr_auth = ajax;
            function encode2(s) {
              return btoa2(utob(s));
            }
            var fromCharCode = String.fromCharCode;
            var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var cb_utob = function(c) {
              var cc = c.charCodeAt(0);
              return cc < 128 ? c : cc < 2048 ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | cc & 63) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
            };
            var utob = function(u) {
              return u.replace(/[^\x00-\x7F]/g, cb_utob);
            };
            var cb_encode = function(ccc) {
              var padlen = [0, 2, 1][ccc.length % 3];
              var ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0);
              var chars = [
                b64chars.charAt(ord >>> 18),
                b64chars.charAt(ord >>> 12 & 63),
                padlen >= 2 ? "=" : b64chars.charAt(ord >>> 6 & 63),
                padlen >= 1 ? "=" : b64chars.charAt(ord & 63)
              ];
              return chars.join("");
            };
            var btoa2 = window.btoa || function(b) {
              return b.replace(/[\s\S]{1,3}/g, cb_encode);
            };
            class Timer {
              constructor(set, clear, delay2, callback) {
                this.clear = clear;
                this.timer = set(() => {
                  if (this.timer) {
                    this.timer = callback(this.timer);
                  }
                }, delay2);
              }
              isRunning() {
                return this.timer !== null;
              }
              ensureAborted() {
                if (this.timer) {
                  this.clear(this.timer);
                  this.timer = null;
                }
              }
            }
            var abstract_timer = Timer;
            function timers_clearTimeout(timer) {
              window.clearTimeout(timer);
            }
            function timers_clearInterval(timer) {
              window.clearInterval(timer);
            }
            class timers_OneOffTimer extends abstract_timer {
              constructor(delay2, callback) {
                super(setTimeout, timers_clearTimeout, delay2, function(timer) {
                  callback();
                  return null;
                });
              }
            }
            class timers_PeriodicTimer extends abstract_timer {
              constructor(delay2, callback) {
                super(setInterval, timers_clearInterval, delay2, function(timer) {
                  callback();
                  return timer;
                });
              }
            }
            var Util = {
              now() {
                if (Date.now) {
                  return Date.now();
                } else {
                  return (/* @__PURE__ */ new Date()).valueOf();
                }
              },
              defer(callback) {
                return new timers_OneOffTimer(0, callback);
              },
              method(name2, ...args) {
                var boundArguments = Array.prototype.slice.call(arguments, 1);
                return function(object) {
                  return object[name2].apply(object, boundArguments.concat(arguments));
                };
              }
            };
            var util = Util;
            function extend2(target, ...sources) {
              for (var i = 0; i < sources.length; i++) {
                var extensions = sources[i];
                for (var property in extensions) {
                  if (extensions[property] && extensions[property].constructor && extensions[property].constructor === Object) {
                    target[property] = extend2(target[property] || {}, extensions[property]);
                  } else {
                    target[property] = extensions[property];
                  }
                }
              }
              return target;
            }
            function stringify2() {
              var m2 = ["Pusher"];
              for (var i = 0; i < arguments.length; i++) {
                if (typeof arguments[i] === "string") {
                  m2.push(arguments[i]);
                } else {
                  m2.push(safeJSONStringify(arguments[i]));
                }
              }
              return m2.join(" : ");
            }
            function arrayIndexOf(array, item) {
              var nativeIndexOf = Array.prototype.indexOf;
              if (array === null) {
                return -1;
              }
              if (nativeIndexOf && array.indexOf === nativeIndexOf) {
                return array.indexOf(item);
              }
              for (var i = 0, l = array.length; i < l; i++) {
                if (array[i] === item) {
                  return i;
                }
              }
              return -1;
            }
            function objectApply(object, f) {
              for (var key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                  f(object[key], key, object);
                }
              }
            }
            function keys2(object) {
              var keys3 = [];
              objectApply(object, function(_, key) {
                keys3.push(key);
              });
              return keys3;
            }
            function values(object) {
              var values2 = [];
              objectApply(object, function(value) {
                values2.push(value);
              });
              return values2;
            }
            function apply(array, f, context) {
              for (var i = 0; i < array.length; i++) {
                f.call(context || window, array[i], i, array);
              }
            }
            function map(array, f) {
              var result = [];
              for (var i = 0; i < array.length; i++) {
                result.push(f(array[i], i, array, result));
              }
              return result;
            }
            function mapObject(object, f) {
              var result = {};
              objectApply(object, function(value, key) {
                result[key] = f(value);
              });
              return result;
            }
            function filter2(array, test2) {
              test2 = test2 || function(value) {
                return !!value;
              };
              var result = [];
              for (var i = 0; i < array.length; i++) {
                if (test2(array[i], i, array, result)) {
                  result.push(array[i]);
                }
              }
              return result;
            }
            function filterObject(object, test2) {
              var result = {};
              objectApply(object, function(value, key) {
                if (test2 && test2(value, key, object, result) || Boolean(value)) {
                  result[key] = value;
                }
              });
              return result;
            }
            function flatten(object) {
              var result = [];
              objectApply(object, function(value, key) {
                result.push([key, value]);
              });
              return result;
            }
            function any(array, test2) {
              for (var i = 0; i < array.length; i++) {
                if (test2(array[i], i, array)) {
                  return true;
                }
              }
              return false;
            }
            function collections_all(array, test2) {
              for (var i = 0; i < array.length; i++) {
                if (!test2(array[i], i, array)) {
                  return false;
                }
              }
              return true;
            }
            function encodeParamsObject(data) {
              return mapObject(data, function(value) {
                if (typeof value === "object") {
                  value = safeJSONStringify(value);
                }
                return encodeURIComponent(encode2(value.toString()));
              });
            }
            function buildQueryString(data) {
              var params = filterObject(data, function(value) {
                return value !== void 0;
              });
              var query = map(flatten(encodeParamsObject(params)), util.method("join", "=")).join("&");
              return query;
            }
            function decycleObject(object) {
              var objects = [], paths = [];
              return function derez(value, path) {
                var i, name2, nu;
                switch (typeof value) {
                  case "object":
                    if (!value) {
                      return null;
                    }
                    for (i = 0; i < objects.length; i += 1) {
                      if (objects[i] === value) {
                        return { $ref: paths[i] };
                      }
                    }
                    objects.push(value);
                    paths.push(path);
                    if (Object.prototype.toString.apply(value) === "[object Array]") {
                      nu = [];
                      for (i = 0; i < value.length; i += 1) {
                        nu[i] = derez(value[i], path + "[" + i + "]");
                      }
                    } else {
                      nu = {};
                      for (name2 in value) {
                        if (Object.prototype.hasOwnProperty.call(value, name2)) {
                          nu[name2] = derez(value[name2], path + "[" + JSON.stringify(name2) + "]");
                        }
                      }
                    }
                    return nu;
                  case "number":
                  case "string":
                  case "boolean":
                    return value;
                }
              }(object, "$");
            }
            function safeJSONStringify(source) {
              try {
                return JSON.stringify(source);
              } catch (e) {
                return JSON.stringify(decycleObject(source));
              }
            }
            class logger_Logger {
              constructor() {
                this.globalLog = (message) => {
                  if (window.console && window.console.log) {
                    window.console.log(message);
                  }
                };
              }
              debug(...args) {
                this.log(this.globalLog, args);
              }
              warn(...args) {
                this.log(this.globalLogWarn, args);
              }
              error(...args) {
                this.log(this.globalLogError, args);
              }
              globalLogWarn(message) {
                if (window.console && window.console.warn) {
                  window.console.warn(message);
                } else {
                  this.globalLog(message);
                }
              }
              globalLogError(message) {
                if (window.console && window.console.error) {
                  window.console.error(message);
                } else {
                  this.globalLogWarn(message);
                }
              }
              log(defaultLoggingFunction, ...args) {
                var message = stringify2.apply(this, arguments);
                if (core_pusher.log) {
                  core_pusher.log(message);
                } else if (core_pusher.logToConsole) {
                  const log = defaultLoggingFunction.bind(this);
                  log(message);
                }
              }
            }
            var logger2 = new logger_Logger();
            var jsonp = function(context, query, authOptions, authRequestType, callback) {
              if (authOptions.headers !== void 0 || authOptions.headersProvider != null) {
                logger2.warn(`To send headers with the ${authRequestType.toString()} request, you must use AJAX, rather than JSONP.`);
              }
              var callbackName = context.nextAuthCallbackID.toString();
              context.nextAuthCallbackID++;
              var document2 = context.getDocument();
              var script = document2.createElement("script");
              context.auth_callbacks[callbackName] = function(data) {
                callback(null, data);
              };
              var callback_name = "Pusher.auth_callbacks['" + callbackName + "']";
              script.src = authOptions.endpoint + "?callback=" + encodeURIComponent(callback_name) + "&" + query;
              var head = document2.getElementsByTagName("head")[0] || document2.documentElement;
              head.insertBefore(script, head.firstChild);
            };
            var jsonp_auth = jsonp;
            class ScriptRequest {
              constructor(src) {
                this.src = src;
              }
              send(receiver) {
                var self2 = this;
                var errorString = "Error loading " + self2.src;
                self2.script = document.createElement("script");
                self2.script.id = receiver.id;
                self2.script.src = self2.src;
                self2.script.type = "text/javascript";
                self2.script.charset = "UTF-8";
                if (self2.script.addEventListener) {
                  self2.script.onerror = function() {
                    receiver.callback(errorString);
                  };
                  self2.script.onload = function() {
                    receiver.callback(null);
                  };
                } else {
                  self2.script.onreadystatechange = function() {
                    if (self2.script.readyState === "loaded" || self2.script.readyState === "complete") {
                      receiver.callback(null);
                    }
                  };
                }
                if (self2.script.async === void 0 && document.attachEvent && /opera/i.test(navigator.userAgent)) {
                  self2.errorScript = document.createElement("script");
                  self2.errorScript.id = receiver.id + "_error";
                  self2.errorScript.text = receiver.name + "('" + errorString + "');";
                  self2.script.async = self2.errorScript.async = false;
                } else {
                  self2.script.async = true;
                }
                var head = document.getElementsByTagName("head")[0];
                head.insertBefore(self2.script, head.firstChild);
                if (self2.errorScript) {
                  head.insertBefore(self2.errorScript, self2.script.nextSibling);
                }
              }
              cleanup() {
                if (this.script) {
                  this.script.onload = this.script.onerror = null;
                  this.script.onreadystatechange = null;
                }
                if (this.script && this.script.parentNode) {
                  this.script.parentNode.removeChild(this.script);
                }
                if (this.errorScript && this.errorScript.parentNode) {
                  this.errorScript.parentNode.removeChild(this.errorScript);
                }
                this.script = null;
                this.errorScript = null;
              }
            }
            class jsonp_request_JSONPRequest {
              constructor(url, data) {
                this.url = url;
                this.data = data;
              }
              send(receiver) {
                if (this.request) {
                  return;
                }
                var query = buildQueryString(this.data);
                var url = this.url + "/" + receiver.number + "?" + query;
                this.request = runtime.createScriptRequest(url);
                this.request.send(receiver);
              }
              cleanup() {
                if (this.request) {
                  this.request.cleanup();
                }
              }
            }
            var getAgent = function(sender, useTLS) {
              return function(data, callback) {
                var scheme = "http" + (useTLS ? "s" : "") + "://";
                var url = scheme + (sender.host || sender.options.host) + sender.options.path;
                var request = runtime.createJSONPRequest(url, data);
                var receiver = runtime.ScriptReceivers.create(function(error, result) {
                  ScriptReceivers.remove(receiver);
                  request.cleanup();
                  if (result && result.host) {
                    sender.host = result.host;
                  }
                  if (callback) {
                    callback(error, result);
                  }
                });
                request.send(receiver);
              };
            };
            var jsonp_timeline_jsonp = {
              name: "jsonp",
              getAgent
            };
            var jsonp_timeline = jsonp_timeline_jsonp;
            function getGenericURL(baseScheme, params, path) {
              var scheme = baseScheme + (params.useTLS ? "s" : "");
              var host = params.useTLS ? params.hostTLS : params.hostNonTLS;
              return scheme + "://" + host + path;
            }
            function getGenericPath(key, queryString) {
              var path = "/app/" + key;
              var query = "?protocol=" + defaults2.PROTOCOL + "&client=js&version=" + defaults2.VERSION + (queryString ? "&" + queryString : "");
              return path + query;
            }
            var ws = {
              getInitial: function(key, params) {
                var path = (params.httpPath || "") + getGenericPath(key, "flash=false");
                return getGenericURL("ws", params, path);
              }
            };
            var http = {
              getInitial: function(key, params) {
                var path = (params.httpPath || "/pusher") + getGenericPath(key);
                return getGenericURL("http", params, path);
              }
            };
            var sockjs = {
              getInitial: function(key, params) {
                return getGenericURL("http", params, params.httpPath || "/pusher");
              },
              getPath: function(key, params) {
                return getGenericPath(key);
              }
            };
            class callback_registry_CallbackRegistry {
              constructor() {
                this._callbacks = {};
              }
              get(name2) {
                return this._callbacks[prefix(name2)];
              }
              add(name2, callback, context) {
                var prefixedEventName = prefix(name2);
                this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];
                this._callbacks[prefixedEventName].push({
                  fn: callback,
                  context
                });
              }
              remove(name2, callback, context) {
                if (!name2 && !callback && !context) {
                  this._callbacks = {};
                  return;
                }
                var names = name2 ? [prefix(name2)] : keys2(this._callbacks);
                if (callback || context) {
                  this.removeCallback(names, callback, context);
                } else {
                  this.removeAllCallbacks(names);
                }
              }
              removeCallback(names, callback, context) {
                apply(names, function(name2) {
                  this._callbacks[name2] = filter2(this._callbacks[name2] || [], function(binding) {
                    return callback && callback !== binding.fn || context && context !== binding.context;
                  });
                  if (this._callbacks[name2].length === 0) {
                    delete this._callbacks[name2];
                  }
                }, this);
              }
              removeAllCallbacks(names) {
                apply(names, function(name2) {
                  delete this._callbacks[name2];
                }, this);
              }
            }
            function prefix(name2) {
              return "_" + name2;
            }
            class dispatcher_Dispatcher {
              constructor(failThrough) {
                this.callbacks = new callback_registry_CallbackRegistry();
                this.global_callbacks = [];
                this.failThrough = failThrough;
              }
              bind(eventName, callback, context) {
                this.callbacks.add(eventName, callback, context);
                return this;
              }
              bind_global(callback) {
                this.global_callbacks.push(callback);
                return this;
              }
              unbind(eventName, callback, context) {
                this.callbacks.remove(eventName, callback, context);
                return this;
              }
              unbind_global(callback) {
                if (!callback) {
                  this.global_callbacks = [];
                  return this;
                }
                this.global_callbacks = filter2(this.global_callbacks || [], (c) => c !== callback);
                return this;
              }
              unbind_all() {
                this.unbind();
                this.unbind_global();
                return this;
              }
              emit(eventName, data, metadata) {
                for (var i = 0; i < this.global_callbacks.length; i++) {
                  this.global_callbacks[i](eventName, data);
                }
                var callbacks = this.callbacks.get(eventName);
                var args = [];
                if (metadata) {
                  args.push(data, metadata);
                } else if (data) {
                  args.push(data);
                }
                if (callbacks && callbacks.length > 0) {
                  for (var i = 0; i < callbacks.length; i++) {
                    callbacks[i].fn.apply(callbacks[i].context || window, args);
                  }
                } else if (this.failThrough) {
                  this.failThrough(eventName, data);
                }
                return this;
              }
            }
            class transport_connection_TransportConnection extends dispatcher_Dispatcher {
              constructor(hooks, name2, priority, key, options2) {
                super();
                this.initialize = runtime.transportConnectionInitializer;
                this.hooks = hooks;
                this.name = name2;
                this.priority = priority;
                this.key = key;
                this.options = options2;
                this.state = "new";
                this.timeline = options2.timeline;
                this.activityTimeout = options2.activityTimeout;
                this.id = this.timeline.generateUniqueID();
              }
              handlesActivityChecks() {
                return Boolean(this.hooks.handlesActivityChecks);
              }
              supportsPing() {
                return Boolean(this.hooks.supportsPing);
              }
              connect() {
                if (this.socket || this.state !== "initialized") {
                  return false;
                }
                var url = this.hooks.urls.getInitial(this.key, this.options);
                try {
                  this.socket = this.hooks.getSocket(url, this.options);
                } catch (e) {
                  util.defer(() => {
                    this.onError(e);
                    this.changeState("closed");
                  });
                  return false;
                }
                this.bindListeners();
                logger2.debug("Connecting", { transport: this.name, url });
                this.changeState("connecting");
                return true;
              }
              close() {
                if (this.socket) {
                  this.socket.close();
                  return true;
                } else {
                  return false;
                }
              }
              send(data) {
                if (this.state === "open") {
                  util.defer(() => {
                    if (this.socket) {
                      this.socket.send(data);
                    }
                  });
                  return true;
                } else {
                  return false;
                }
              }
              ping() {
                if (this.state === "open" && this.supportsPing()) {
                  this.socket.ping();
                }
              }
              onOpen() {
                if (this.hooks.beforeOpen) {
                  this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));
                }
                this.changeState("open");
                this.socket.onopen = void 0;
              }
              onError(error) {
                this.emit("error", { type: "WebSocketError", error });
                this.timeline.error(this.buildTimelineMessage({ error: error.toString() }));
              }
              onClose(closeEvent) {
                if (closeEvent) {
                  this.changeState("closed", {
                    code: closeEvent.code,
                    reason: closeEvent.reason,
                    wasClean: closeEvent.wasClean
                  });
                } else {
                  this.changeState("closed");
                }
                this.unbindListeners();
                this.socket = void 0;
              }
              onMessage(message) {
                this.emit("message", message);
              }
              onActivity() {
                this.emit("activity");
              }
              bindListeners() {
                this.socket.onopen = () => {
                  this.onOpen();
                };
                this.socket.onerror = (error) => {
                  this.onError(error);
                };
                this.socket.onclose = (closeEvent) => {
                  this.onClose(closeEvent);
                };
                this.socket.onmessage = (message) => {
                  this.onMessage(message);
                };
                if (this.supportsPing()) {
                  this.socket.onactivity = () => {
                    this.onActivity();
                  };
                }
              }
              unbindListeners() {
                if (this.socket) {
                  this.socket.onopen = void 0;
                  this.socket.onerror = void 0;
                  this.socket.onclose = void 0;
                  this.socket.onmessage = void 0;
                  if (this.supportsPing()) {
                    this.socket.onactivity = void 0;
                  }
                }
              }
              changeState(state2, params) {
                this.state = state2;
                this.timeline.info(this.buildTimelineMessage({
                  state: state2,
                  params
                }));
                this.emit(state2, params);
              }
              buildTimelineMessage(message) {
                return extend2({ cid: this.id }, message);
              }
            }
            class transport_Transport {
              constructor(hooks) {
                this.hooks = hooks;
              }
              isSupported(environment) {
                return this.hooks.isSupported(environment);
              }
              createConnection(name2, priority, key, options2) {
                return new transport_connection_TransportConnection(this.hooks, name2, priority, key, options2);
              }
            }
            var WSTransport = new transport_Transport({
              urls: ws,
              handlesActivityChecks: false,
              supportsPing: false,
              isInitialized: function() {
                return Boolean(runtime.getWebSocketAPI());
              },
              isSupported: function() {
                return Boolean(runtime.getWebSocketAPI());
              },
              getSocket: function(url) {
                return runtime.createWebSocket(url);
              }
            });
            var httpConfiguration = {
              urls: http,
              handlesActivityChecks: false,
              supportsPing: true,
              isInitialized: function() {
                return true;
              }
            };
            var streamingConfiguration = extend2({
              getSocket: function(url) {
                return runtime.HTTPFactory.createStreamingSocket(url);
              }
            }, httpConfiguration);
            var pollingConfiguration = extend2({
              getSocket: function(url) {
                return runtime.HTTPFactory.createPollingSocket(url);
              }
            }, httpConfiguration);
            var xhrConfiguration = {
              isSupported: function() {
                return runtime.isXHRSupported();
              }
            };
            var XHRStreamingTransport = new transport_Transport(extend2({}, streamingConfiguration, xhrConfiguration));
            var XHRPollingTransport = new transport_Transport(extend2({}, pollingConfiguration, xhrConfiguration));
            var Transports = {
              ws: WSTransport,
              xhr_streaming: XHRStreamingTransport,
              xhr_polling: XHRPollingTransport
            };
            var transports = Transports;
            var SockJSTransport = new transport_Transport({
              file: "sockjs",
              urls: sockjs,
              handlesActivityChecks: true,
              supportsPing: false,
              isSupported: function() {
                return true;
              },
              isInitialized: function() {
                return window.SockJS !== void 0;
              },
              getSocket: function(url, options2) {
                return new window.SockJS(url, null, {
                  js_path: Dependencies.getPath("sockjs", {
                    useTLS: options2.useTLS
                  }),
                  ignore_null_origin: options2.ignoreNullOrigin
                });
              },
              beforeOpen: function(socket, path) {
                socket.send(JSON.stringify({
                  path
                }));
              }
            });
            var xdrConfiguration = {
              isSupported: function(environment) {
                var yes = runtime.isXDRSupported(environment.useTLS);
                return yes;
              }
            };
            var XDRStreamingTransport = new transport_Transport(extend2({}, streamingConfiguration, xdrConfiguration));
            var XDRPollingTransport = new transport_Transport(extend2({}, pollingConfiguration, xdrConfiguration));
            transports.xdr_streaming = XDRStreamingTransport;
            transports.xdr_polling = XDRPollingTransport;
            transports.sockjs = SockJSTransport;
            var transports_transports = transports;
            class net_info_NetInfo extends dispatcher_Dispatcher {
              constructor() {
                super();
                var self2 = this;
                if (window.addEventListener !== void 0) {
                  window.addEventListener("online", function() {
                    self2.emit("online");
                  }, false);
                  window.addEventListener("offline", function() {
                    self2.emit("offline");
                  }, false);
                }
              }
              isOnline() {
                if (window.navigator.onLine === void 0) {
                  return true;
                } else {
                  return window.navigator.onLine;
                }
              }
            }
            var net_info_Network = new net_info_NetInfo();
            class assistant_to_the_transport_manager_AssistantToTheTransportManager {
              constructor(manager, transport, options2) {
                this.manager = manager;
                this.transport = transport;
                this.minPingDelay = options2.minPingDelay;
                this.maxPingDelay = options2.maxPingDelay;
                this.pingDelay = void 0;
              }
              createConnection(name2, priority, key, options2) {
                options2 = extend2({}, options2, {
                  activityTimeout: this.pingDelay
                });
                var connection = this.transport.createConnection(name2, priority, key, options2);
                var openTimestamp = null;
                var onOpen = function() {
                  connection.unbind("open", onOpen);
                  connection.bind("closed", onClosed);
                  openTimestamp = util.now();
                };
                var onClosed = (closeEvent) => {
                  connection.unbind("closed", onClosed);
                  if (closeEvent.code === 1002 || closeEvent.code === 1003) {
                    this.manager.reportDeath();
                  } else if (!closeEvent.wasClean && openTimestamp) {
                    var lifespan = util.now() - openTimestamp;
                    if (lifespan < 2 * this.maxPingDelay) {
                      this.manager.reportDeath();
                      this.pingDelay = Math.max(lifespan / 2, this.minPingDelay);
                    }
                  }
                };
                connection.bind("open", onOpen);
                return connection;
              }
              isSupported(environment) {
                return this.manager.isAlive() && this.transport.isSupported(environment);
              }
            }
            const Protocol = {
              decodeMessage: function(messageEvent) {
                try {
                  var messageData = JSON.parse(messageEvent.data);
                  var pusherEventData = messageData.data;
                  if (typeof pusherEventData === "string") {
                    try {
                      pusherEventData = JSON.parse(messageData.data);
                    } catch (e) {
                    }
                  }
                  var pusherEvent = {
                    event: messageData.event,
                    channel: messageData.channel,
                    data: pusherEventData
                  };
                  if (messageData.user_id) {
                    pusherEvent.user_id = messageData.user_id;
                  }
                  return pusherEvent;
                } catch (e) {
                  throw { type: "MessageParseError", error: e, data: messageEvent.data };
                }
              },
              encodeMessage: function(event) {
                return JSON.stringify(event);
              },
              processHandshake: function(messageEvent) {
                var message = Protocol.decodeMessage(messageEvent);
                if (message.event === "pusher:connection_established") {
                  if (!message.data.activity_timeout) {
                    throw "No activity timeout specified in handshake";
                  }
                  return {
                    action: "connected",
                    id: message.data.socket_id,
                    activityTimeout: message.data.activity_timeout * 1e3
                  };
                } else if (message.event === "pusher:error") {
                  return {
                    action: this.getCloseAction(message.data),
                    error: this.getCloseError(message.data)
                  };
                } else {
                  throw "Invalid handshake";
                }
              },
              getCloseAction: function(closeEvent) {
                if (closeEvent.code < 4e3) {
                  if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {
                    return "backoff";
                  } else {
                    return null;
                  }
                } else if (closeEvent.code === 4e3) {
                  return "tls_only";
                } else if (closeEvent.code < 4100) {
                  return "refused";
                } else if (closeEvent.code < 4200) {
                  return "backoff";
                } else if (closeEvent.code < 4300) {
                  return "retry";
                } else {
                  return "refused";
                }
              },
              getCloseError: function(closeEvent) {
                if (closeEvent.code !== 1e3 && closeEvent.code !== 1001) {
                  return {
                    type: "PusherError",
                    data: {
                      code: closeEvent.code,
                      message: closeEvent.reason || closeEvent.message
                    }
                  };
                } else {
                  return null;
                }
              }
            };
            var protocol_protocol = Protocol;
            class connection_Connection extends dispatcher_Dispatcher {
              constructor(id2, transport) {
                super();
                this.id = id2;
                this.transport = transport;
                this.activityTimeout = transport.activityTimeout;
                this.bindListeners();
              }
              handlesActivityChecks() {
                return this.transport.handlesActivityChecks();
              }
              send(data) {
                return this.transport.send(data);
              }
              send_event(name2, data, channel) {
                var event = { event: name2, data };
                if (channel) {
                  event.channel = channel;
                }
                logger2.debug("Event sent", event);
                return this.send(protocol_protocol.encodeMessage(event));
              }
              ping() {
                if (this.transport.supportsPing()) {
                  this.transport.ping();
                } else {
                  this.send_event("pusher:ping", {});
                }
              }
              close() {
                this.transport.close();
              }
              bindListeners() {
                var listeners = {
                  message: (messageEvent) => {
                    var pusherEvent;
                    try {
                      pusherEvent = protocol_protocol.decodeMessage(messageEvent);
                    } catch (e) {
                      this.emit("error", {
                        type: "MessageParseError",
                        error: e,
                        data: messageEvent.data
                      });
                    }
                    if (pusherEvent !== void 0) {
                      logger2.debug("Event recd", pusherEvent);
                      switch (pusherEvent.event) {
                        case "pusher:error":
                          this.emit("error", {
                            type: "PusherError",
                            data: pusherEvent.data
                          });
                          break;
                        case "pusher:ping":
                          this.emit("ping");
                          break;
                        case "pusher:pong":
                          this.emit("pong");
                          break;
                      }
                      this.emit("message", pusherEvent);
                    }
                  },
                  activity: () => {
                    this.emit("activity");
                  },
                  error: (error) => {
                    this.emit("error", error);
                  },
                  closed: (closeEvent) => {
                    unbindListeners();
                    if (closeEvent && closeEvent.code) {
                      this.handleCloseEvent(closeEvent);
                    }
                    this.transport = null;
                    this.emit("closed");
                  }
                };
                var unbindListeners = () => {
                  objectApply(listeners, (listener, event) => {
                    this.transport.unbind(event, listener);
                  });
                };
                objectApply(listeners, (listener, event) => {
                  this.transport.bind(event, listener);
                });
              }
              handleCloseEvent(closeEvent) {
                var action = protocol_protocol.getCloseAction(closeEvent);
                var error = protocol_protocol.getCloseError(closeEvent);
                if (error) {
                  this.emit("error", error);
                }
                if (action) {
                  this.emit(action, { action, error });
                }
              }
            }
            class handshake_Handshake {
              constructor(transport, callback) {
                this.transport = transport;
                this.callback = callback;
                this.bindListeners();
              }
              close() {
                this.unbindListeners();
                this.transport.close();
              }
              bindListeners() {
                this.onMessage = (m2) => {
                  this.unbindListeners();
                  var result;
                  try {
                    result = protocol_protocol.processHandshake(m2);
                  } catch (e) {
                    this.finish("error", { error: e });
                    this.transport.close();
                    return;
                  }
                  if (result.action === "connected") {
                    this.finish("connected", {
                      connection: new connection_Connection(result.id, this.transport),
                      activityTimeout: result.activityTimeout
                    });
                  } else {
                    this.finish(result.action, { error: result.error });
                    this.transport.close();
                  }
                };
                this.onClosed = (closeEvent) => {
                  this.unbindListeners();
                  var action = protocol_protocol.getCloseAction(closeEvent) || "backoff";
                  var error = protocol_protocol.getCloseError(closeEvent);
                  this.finish(action, { error });
                };
                this.transport.bind("message", this.onMessage);
                this.transport.bind("closed", this.onClosed);
              }
              unbindListeners() {
                this.transport.unbind("message", this.onMessage);
                this.transport.unbind("closed", this.onClosed);
              }
              finish(action, params) {
                this.callback(extend2({ transport: this.transport, action }, params));
              }
            }
            class timeline_sender_TimelineSender {
              constructor(timeline, options2) {
                this.timeline = timeline;
                this.options = options2 || {};
              }
              send(useTLS, callback) {
                if (this.timeline.isEmpty()) {
                  return;
                }
                this.timeline.send(runtime.TimelineTransport.getAgent(this, useTLS), callback);
              }
            }
            class channel_Channel extends dispatcher_Dispatcher {
              constructor(name2, pusher2) {
                super(function(event, data) {
                  logger2.debug("No callbacks on " + name2 + " for " + event);
                });
                this.name = name2;
                this.pusher = pusher2;
                this.subscribed = false;
                this.subscriptionPending = false;
                this.subscriptionCancelled = false;
              }
              authorize(socketId, callback) {
                return callback(null, { auth: "" });
              }
              trigger(event, data) {
                if (event.indexOf("client-") !== 0) {
                  throw new BadEventName("Event '" + event + "' does not start with 'client-'");
                }
                if (!this.subscribed) {
                  var suffix = url_store.buildLogSuffix("triggeringClientEvents");
                  logger2.warn(`Client event triggered before channel 'subscription_succeeded' event . ${suffix}`);
                }
                return this.pusher.send_event(event, data, this.name);
              }
              disconnect() {
                this.subscribed = false;
                this.subscriptionPending = false;
              }
              handleEvent(event) {
                var eventName = event.event;
                var data = event.data;
                if (eventName === "pusher_internal:subscription_succeeded") {
                  this.handleSubscriptionSucceededEvent(event);
                } else if (eventName === "pusher_internal:subscription_count") {
                  this.handleSubscriptionCountEvent(event);
                } else if (eventName.indexOf("pusher_internal:") !== 0) {
                  var metadata = {};
                  this.emit(eventName, data, metadata);
                }
              }
              handleSubscriptionSucceededEvent(event) {
                this.subscriptionPending = false;
                this.subscribed = true;
                if (this.subscriptionCancelled) {
                  this.pusher.unsubscribe(this.name);
                } else {
                  this.emit("pusher:subscription_succeeded", event.data);
                }
              }
              handleSubscriptionCountEvent(event) {
                if (event.data.subscription_count) {
                  this.subscriptionCount = event.data.subscription_count;
                }
                this.emit("pusher:subscription_count", event.data);
              }
              subscribe() {
                if (this.subscribed) {
                  return;
                }
                this.subscriptionPending = true;
                this.subscriptionCancelled = false;
                this.authorize(this.pusher.connection.socket_id, (error, data) => {
                  if (error) {
                    this.subscriptionPending = false;
                    logger2.error(error.toString());
                    this.emit("pusher:subscription_error", Object.assign({}, {
                      type: "AuthError",
                      error: error.message
                    }, error instanceof HTTPAuthError ? { status: error.status } : {}));
                  } else {
                    this.pusher.send_event("pusher:subscribe", {
                      auth: data.auth,
                      channel_data: data.channel_data,
                      channel: this.name
                    });
                  }
                });
              }
              unsubscribe() {
                this.subscribed = false;
                this.pusher.send_event("pusher:unsubscribe", {
                  channel: this.name
                });
              }
              cancelSubscription() {
                this.subscriptionCancelled = true;
              }
              reinstateSubscription() {
                this.subscriptionCancelled = false;
              }
            }
            class private_channel_PrivateChannel extends channel_Channel {
              authorize(socketId, callback) {
                return this.pusher.config.channelAuthorizer({
                  channelName: this.name,
                  socketId
                }, callback);
              }
            }
            class members_Members {
              constructor() {
                this.reset();
              }
              get(id2) {
                if (Object.prototype.hasOwnProperty.call(this.members, id2)) {
                  return {
                    id: id2,
                    info: this.members[id2]
                  };
                } else {
                  return null;
                }
              }
              each(callback) {
                objectApply(this.members, (member, id2) => {
                  callback(this.get(id2));
                });
              }
              setMyID(id2) {
                this.myID = id2;
              }
              onSubscription(subscriptionData) {
                this.members = subscriptionData.presence.hash;
                this.count = subscriptionData.presence.count;
                this.me = this.get(this.myID);
              }
              addMember(memberData) {
                if (this.get(memberData.user_id) === null) {
                  this.count++;
                }
                this.members[memberData.user_id] = memberData.user_info;
                return this.get(memberData.user_id);
              }
              removeMember(memberData) {
                var member = this.get(memberData.user_id);
                if (member) {
                  delete this.members[memberData.user_id];
                  this.count--;
                }
                return member;
              }
              reset() {
                this.members = {};
                this.count = 0;
                this.myID = null;
                this.me = null;
              }
            }
            var __awaiter = function(thisArg, _arguments, P, generator) {
              function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                  resolve(value);
                });
              }
              return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function step(result) {
                  result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            class presence_channel_PresenceChannel extends private_channel_PrivateChannel {
              constructor(name2, pusher2) {
                super(name2, pusher2);
                this.members = new members_Members();
              }
              authorize(socketId, callback) {
                super.authorize(socketId, (error, authData) => __awaiter(this, void 0, void 0, function* () {
                  if (!error) {
                    authData = authData;
                    if (authData.channel_data != null) {
                      var channelData = JSON.parse(authData.channel_data);
                      this.members.setMyID(channelData.user_id);
                    } else {
                      yield this.pusher.user.signinDonePromise;
                      if (this.pusher.user.user_data != null) {
                        this.members.setMyID(this.pusher.user.user_data.id);
                      } else {
                        let suffix = url_store.buildLogSuffix("authorizationEndpoint");
                        logger2.error(`Invalid auth response for channel '${this.name}', expected 'channel_data' field. ${suffix}, or the user should be signed in.`);
                        callback("Invalid auth response");
                        return;
                      }
                    }
                  }
                  callback(error, authData);
                }));
              }
              handleEvent(event) {
                var eventName = event.event;
                if (eventName.indexOf("pusher_internal:") === 0) {
                  this.handleInternalEvent(event);
                } else {
                  var data = event.data;
                  var metadata = {};
                  if (event.user_id) {
                    metadata.user_id = event.user_id;
                  }
                  this.emit(eventName, data, metadata);
                }
              }
              handleInternalEvent(event) {
                var eventName = event.event;
                var data = event.data;
                switch (eventName) {
                  case "pusher_internal:subscription_succeeded":
                    this.handleSubscriptionSucceededEvent(event);
                    break;
                  case "pusher_internal:subscription_count":
                    this.handleSubscriptionCountEvent(event);
                    break;
                  case "pusher_internal:member_added":
                    var addedMember = this.members.addMember(data);
                    this.emit("pusher:member_added", addedMember);
                    break;
                  case "pusher_internal:member_removed":
                    var removedMember = this.members.removeMember(data);
                    if (removedMember) {
                      this.emit("pusher:member_removed", removedMember);
                    }
                    break;
                }
              }
              handleSubscriptionSucceededEvent(event) {
                this.subscriptionPending = false;
                this.subscribed = true;
                if (this.subscriptionCancelled) {
                  this.pusher.unsubscribe(this.name);
                } else {
                  this.members.onSubscription(event.data);
                  this.emit("pusher:subscription_succeeded", this.members);
                }
              }
              disconnect() {
                this.members.reset();
                super.disconnect();
              }
            }
            var utf8 = __webpack_require__(1);
            var base642 = __webpack_require__(0);
            class encrypted_channel_EncryptedChannel extends private_channel_PrivateChannel {
              constructor(name2, pusher2, nacl) {
                super(name2, pusher2);
                this.key = null;
                this.nacl = nacl;
              }
              authorize(socketId, callback) {
                super.authorize(socketId, (error, authData) => {
                  if (error) {
                    callback(error, authData);
                    return;
                  }
                  let sharedSecret = authData["shared_secret"];
                  if (!sharedSecret) {
                    callback(new Error(`No shared_secret key in auth payload for encrypted channel: ${this.name}`), null);
                    return;
                  }
                  this.key = Object(base642["decode"])(sharedSecret);
                  delete authData["shared_secret"];
                  callback(null, authData);
                });
              }
              trigger(event, data) {
                throw new UnsupportedFeature("Client events are not currently supported for encrypted channels");
              }
              handleEvent(event) {
                var eventName = event.event;
                var data = event.data;
                if (eventName.indexOf("pusher_internal:") === 0 || eventName.indexOf("pusher:") === 0) {
                  super.handleEvent(event);
                  return;
                }
                this.handleEncryptedEvent(eventName, data);
              }
              handleEncryptedEvent(event, data) {
                if (!this.key) {
                  logger2.debug("Received encrypted event before key has been retrieved from the authEndpoint");
                  return;
                }
                if (!data.ciphertext || !data.nonce) {
                  logger2.error("Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: " + data);
                  return;
                }
                let cipherText = Object(base642["decode"])(data.ciphertext);
                if (cipherText.length < this.nacl.secretbox.overheadLength) {
                  logger2.error(`Expected encrypted event ciphertext length to be ${this.nacl.secretbox.overheadLength}, got: ${cipherText.length}`);
                  return;
                }
                let nonce = Object(base642["decode"])(data.nonce);
                if (nonce.length < this.nacl.secretbox.nonceLength) {
                  logger2.error(`Expected encrypted event nonce length to be ${this.nacl.secretbox.nonceLength}, got: ${nonce.length}`);
                  return;
                }
                let bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);
                if (bytes === null) {
                  logger2.debug("Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...");
                  this.authorize(this.pusher.connection.socket_id, (error, authData) => {
                    if (error) {
                      logger2.error(`Failed to make a request to the authEndpoint: ${authData}. Unable to fetch new key, so dropping encrypted event`);
                      return;
                    }
                    bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);
                    if (bytes === null) {
                      logger2.error(`Failed to decrypt event with new key. Dropping encrypted event`);
                      return;
                    }
                    this.emit(event, this.getDataToEmit(bytes));
                    return;
                  });
                  return;
                }
                this.emit(event, this.getDataToEmit(bytes));
              }
              getDataToEmit(bytes) {
                let raw = Object(utf8["decode"])(bytes);
                try {
                  return JSON.parse(raw);
                } catch (_a2) {
                  return raw;
                }
              }
            }
            class connection_manager_ConnectionManager extends dispatcher_Dispatcher {
              constructor(key, options2) {
                super();
                this.state = "initialized";
                this.connection = null;
                this.key = key;
                this.options = options2;
                this.timeline = this.options.timeline;
                this.usingTLS = this.options.useTLS;
                this.errorCallbacks = this.buildErrorCallbacks();
                this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);
                this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);
                var Network = runtime.getNetwork();
                Network.bind("online", () => {
                  this.timeline.info({ netinfo: "online" });
                  if (this.state === "connecting" || this.state === "unavailable") {
                    this.retryIn(0);
                  }
                });
                Network.bind("offline", () => {
                  this.timeline.info({ netinfo: "offline" });
                  if (this.connection) {
                    this.sendActivityCheck();
                  }
                });
                this.updateStrategy();
              }
              connect() {
                if (this.connection || this.runner) {
                  return;
                }
                if (!this.strategy.isSupported()) {
                  this.updateState("failed");
                  return;
                }
                this.updateState("connecting");
                this.startConnecting();
                this.setUnavailableTimer();
              }
              send(data) {
                if (this.connection) {
                  return this.connection.send(data);
                } else {
                  return false;
                }
              }
              send_event(name2, data, channel) {
                if (this.connection) {
                  return this.connection.send_event(name2, data, channel);
                } else {
                  return false;
                }
              }
              disconnect() {
                this.disconnectInternally();
                this.updateState("disconnected");
              }
              isUsingTLS() {
                return this.usingTLS;
              }
              startConnecting() {
                var callback = (error, handshake) => {
                  if (error) {
                    this.runner = this.strategy.connect(0, callback);
                  } else {
                    if (handshake.action === "error") {
                      this.emit("error", {
                        type: "HandshakeError",
                        error: handshake.error
                      });
                      this.timeline.error({ handshakeError: handshake.error });
                    } else {
                      this.abortConnecting();
                      this.handshakeCallbacks[handshake.action](handshake);
                    }
                  }
                };
                this.runner = this.strategy.connect(0, callback);
              }
              abortConnecting() {
                if (this.runner) {
                  this.runner.abort();
                  this.runner = null;
                }
              }
              disconnectInternally() {
                this.abortConnecting();
                this.clearRetryTimer();
                this.clearUnavailableTimer();
                if (this.connection) {
                  var connection = this.abandonConnection();
                  connection.close();
                }
              }
              updateStrategy() {
                this.strategy = this.options.getStrategy({
                  key: this.key,
                  timeline: this.timeline,
                  useTLS: this.usingTLS
                });
              }
              retryIn(delay2) {
                this.timeline.info({ action: "retry", delay: delay2 });
                if (delay2 > 0) {
                  this.emit("connecting_in", Math.round(delay2 / 1e3));
                }
                this.retryTimer = new timers_OneOffTimer(delay2 || 0, () => {
                  this.disconnectInternally();
                  this.connect();
                });
              }
              clearRetryTimer() {
                if (this.retryTimer) {
                  this.retryTimer.ensureAborted();
                  this.retryTimer = null;
                }
              }
              setUnavailableTimer() {
                this.unavailableTimer = new timers_OneOffTimer(this.options.unavailableTimeout, () => {
                  this.updateState("unavailable");
                });
              }
              clearUnavailableTimer() {
                if (this.unavailableTimer) {
                  this.unavailableTimer.ensureAborted();
                }
              }
              sendActivityCheck() {
                this.stopActivityCheck();
                this.connection.ping();
                this.activityTimer = new timers_OneOffTimer(this.options.pongTimeout, () => {
                  this.timeline.error({ pong_timed_out: this.options.pongTimeout });
                  this.retryIn(0);
                });
              }
              resetActivityCheck() {
                this.stopActivityCheck();
                if (this.connection && !this.connection.handlesActivityChecks()) {
                  this.activityTimer = new timers_OneOffTimer(this.activityTimeout, () => {
                    this.sendActivityCheck();
                  });
                }
              }
              stopActivityCheck() {
                if (this.activityTimer) {
                  this.activityTimer.ensureAborted();
                }
              }
              buildConnectionCallbacks(errorCallbacks) {
                return extend2({}, errorCallbacks, {
                  message: (message) => {
                    this.resetActivityCheck();
                    this.emit("message", message);
                  },
                  ping: () => {
                    this.send_event("pusher:pong", {});
                  },
                  activity: () => {
                    this.resetActivityCheck();
                  },
                  error: (error) => {
                    this.emit("error", error);
                  },
                  closed: () => {
                    this.abandonConnection();
                    if (this.shouldRetry()) {
                      this.retryIn(1e3);
                    }
                  }
                });
              }
              buildHandshakeCallbacks(errorCallbacks) {
                return extend2({}, errorCallbacks, {
                  connected: (handshake) => {
                    this.activityTimeout = Math.min(this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);
                    this.clearUnavailableTimer();
                    this.setConnection(handshake.connection);
                    this.socket_id = this.connection.id;
                    this.updateState("connected", { socket_id: this.socket_id });
                  }
                });
              }
              buildErrorCallbacks() {
                let withErrorEmitted = (callback) => {
                  return (result) => {
                    if (result.error) {
                      this.emit("error", { type: "WebSocketError", error: result.error });
                    }
                    callback(result);
                  };
                };
                return {
                  tls_only: withErrorEmitted(() => {
                    this.usingTLS = true;
                    this.updateStrategy();
                    this.retryIn(0);
                  }),
                  refused: withErrorEmitted(() => {
                    this.disconnect();
                  }),
                  backoff: withErrorEmitted(() => {
                    this.retryIn(1e3);
                  }),
                  retry: withErrorEmitted(() => {
                    this.retryIn(0);
                  })
                };
              }
              setConnection(connection) {
                this.connection = connection;
                for (var event in this.connectionCallbacks) {
                  this.connection.bind(event, this.connectionCallbacks[event]);
                }
                this.resetActivityCheck();
              }
              abandonConnection() {
                if (!this.connection) {
                  return;
                }
                this.stopActivityCheck();
                for (var event in this.connectionCallbacks) {
                  this.connection.unbind(event, this.connectionCallbacks[event]);
                }
                var connection = this.connection;
                this.connection = null;
                return connection;
              }
              updateState(newState, data) {
                var previousState = this.state;
                this.state = newState;
                if (previousState !== newState) {
                  var newStateDescription = newState;
                  if (newStateDescription === "connected") {
                    newStateDescription += " with new socket ID " + data.socket_id;
                  }
                  logger2.debug("State changed", previousState + " -> " + newStateDescription);
                  this.timeline.info({ state: newState, params: data });
                  this.emit("state_change", { previous: previousState, current: newState });
                  this.emit(newState, data);
                }
              }
              shouldRetry() {
                return this.state === "connecting" || this.state === "connected";
              }
            }
            class channels_Channels {
              constructor() {
                this.channels = {};
              }
              add(name2, pusher2) {
                if (!this.channels[name2]) {
                  this.channels[name2] = createChannel(name2, pusher2);
                }
                return this.channels[name2];
              }
              all() {
                return values(this.channels);
              }
              find(name2) {
                return this.channels[name2];
              }
              remove(name2) {
                var channel = this.channels[name2];
                delete this.channels[name2];
                return channel;
              }
              disconnect() {
                objectApply(this.channels, function(channel) {
                  channel.disconnect();
                });
              }
            }
            function createChannel(name2, pusher2) {
              if (name2.indexOf("private-encrypted-") === 0) {
                if (pusher2.config.nacl) {
                  return factory.createEncryptedChannel(name2, pusher2, pusher2.config.nacl);
                }
                let errMsg = "Tried to subscribe to a private-encrypted- channel but no nacl implementation available";
                let suffix = url_store.buildLogSuffix("encryptedChannelSupport");
                throw new UnsupportedFeature(`${errMsg}. ${suffix}`);
              } else if (name2.indexOf("private-") === 0) {
                return factory.createPrivateChannel(name2, pusher2);
              } else if (name2.indexOf("presence-") === 0) {
                return factory.createPresenceChannel(name2, pusher2);
              } else if (name2.indexOf("#") === 0) {
                throw new BadChannelName('Cannot create a channel with name "' + name2 + '".');
              } else {
                return factory.createChannel(name2, pusher2);
              }
            }
            var Factory = {
              createChannels() {
                return new channels_Channels();
              },
              createConnectionManager(key, options2) {
                return new connection_manager_ConnectionManager(key, options2);
              },
              createChannel(name2, pusher2) {
                return new channel_Channel(name2, pusher2);
              },
              createPrivateChannel(name2, pusher2) {
                return new private_channel_PrivateChannel(name2, pusher2);
              },
              createPresenceChannel(name2, pusher2) {
                return new presence_channel_PresenceChannel(name2, pusher2);
              },
              createEncryptedChannel(name2, pusher2, nacl) {
                return new encrypted_channel_EncryptedChannel(name2, pusher2, nacl);
              },
              createTimelineSender(timeline, options2) {
                return new timeline_sender_TimelineSender(timeline, options2);
              },
              createHandshake(transport, callback) {
                return new handshake_Handshake(transport, callback);
              },
              createAssistantToTheTransportManager(manager, transport, options2) {
                return new assistant_to_the_transport_manager_AssistantToTheTransportManager(manager, transport, options2);
              }
            };
            var factory = Factory;
            class transport_manager_TransportManager {
              constructor(options2) {
                this.options = options2 || {};
                this.livesLeft = this.options.lives || Infinity;
              }
              getAssistant(transport) {
                return factory.createAssistantToTheTransportManager(this, transport, {
                  minPingDelay: this.options.minPingDelay,
                  maxPingDelay: this.options.maxPingDelay
                });
              }
              isAlive() {
                return this.livesLeft > 0;
              }
              reportDeath() {
                this.livesLeft -= 1;
              }
            }
            class sequential_strategy_SequentialStrategy {
              constructor(strategies, options2) {
                this.strategies = strategies;
                this.loop = Boolean(options2.loop);
                this.failFast = Boolean(options2.failFast);
                this.timeout = options2.timeout;
                this.timeoutLimit = options2.timeoutLimit;
              }
              isSupported() {
                return any(this.strategies, util.method("isSupported"));
              }
              connect(minPriority, callback) {
                var strategies = this.strategies;
                var current = 0;
                var timeout = this.timeout;
                var runner = null;
                var tryNextStrategy = (error, handshake) => {
                  if (handshake) {
                    callback(null, handshake);
                  } else {
                    current = current + 1;
                    if (this.loop) {
                      current = current % strategies.length;
                    }
                    if (current < strategies.length) {
                      if (timeout) {
                        timeout = timeout * 2;
                        if (this.timeoutLimit) {
                          timeout = Math.min(timeout, this.timeoutLimit);
                        }
                      }
                      runner = this.tryStrategy(strategies[current], minPriority, { timeout, failFast: this.failFast }, tryNextStrategy);
                    } else {
                      callback(true);
                    }
                  }
                };
                runner = this.tryStrategy(strategies[current], minPriority, { timeout, failFast: this.failFast }, tryNextStrategy);
                return {
                  abort: function() {
                    runner.abort();
                  },
                  forceMinPriority: function(p) {
                    minPriority = p;
                    if (runner) {
                      runner.forceMinPriority(p);
                    }
                  }
                };
              }
              tryStrategy(strategy, minPriority, options2, callback) {
                var timer = null;
                var runner = null;
                if (options2.timeout > 0) {
                  timer = new timers_OneOffTimer(options2.timeout, function() {
                    runner.abort();
                    callback(true);
                  });
                }
                runner = strategy.connect(minPriority, function(error, handshake) {
                  if (error && timer && timer.isRunning() && !options2.failFast) {
                    return;
                  }
                  if (timer) {
                    timer.ensureAborted();
                  }
                  callback(error, handshake);
                });
                return {
                  abort: function() {
                    if (timer) {
                      timer.ensureAborted();
                    }
                    runner.abort();
                  },
                  forceMinPriority: function(p) {
                    runner.forceMinPriority(p);
                  }
                };
              }
            }
            class best_connected_ever_strategy_BestConnectedEverStrategy {
              constructor(strategies) {
                this.strategies = strategies;
              }
              isSupported() {
                return any(this.strategies, util.method("isSupported"));
              }
              connect(minPriority, callback) {
                return connect(this.strategies, minPriority, function(i, runners) {
                  return function(error, handshake) {
                    runners[i].error = error;
                    if (error) {
                      if (allRunnersFailed(runners)) {
                        callback(true);
                      }
                      return;
                    }
                    apply(runners, function(runner) {
                      runner.forceMinPriority(handshake.transport.priority);
                    });
                    callback(null, handshake);
                  };
                });
              }
            }
            function connect(strategies, minPriority, callbackBuilder) {
              var runners = map(strategies, function(strategy, i, _, rs) {
                return strategy.connect(minPriority, callbackBuilder(i, rs));
              });
              return {
                abort: function() {
                  apply(runners, abortRunner);
                },
                forceMinPriority: function(p) {
                  apply(runners, function(runner) {
                    runner.forceMinPriority(p);
                  });
                }
              };
            }
            function allRunnersFailed(runners) {
              return collections_all(runners, function(runner) {
                return Boolean(runner.error);
              });
            }
            function abortRunner(runner) {
              if (!runner.error && !runner.aborted) {
                runner.abort();
                runner.aborted = true;
              }
            }
            class websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy {
              constructor(strategy, transports2, options2) {
                this.strategy = strategy;
                this.transports = transports2;
                this.ttl = options2.ttl || 1800 * 1e3;
                this.usingTLS = options2.useTLS;
                this.timeline = options2.timeline;
              }
              isSupported() {
                return this.strategy.isSupported();
              }
              connect(minPriority, callback) {
                var usingTLS = this.usingTLS;
                var info = fetchTransportCache(usingTLS);
                var cacheSkipCount = info && info.cacheSkipCount ? info.cacheSkipCount : 0;
                var strategies = [this.strategy];
                if (info && info.timestamp + this.ttl >= util.now()) {
                  var transport = this.transports[info.transport];
                  if (transport) {
                    if (["ws", "wss"].includes(info.transport) || cacheSkipCount > 3) {
                      this.timeline.info({
                        cached: true,
                        transport: info.transport,
                        latency: info.latency
                      });
                      strategies.push(new sequential_strategy_SequentialStrategy([transport], {
                        timeout: info.latency * 2 + 1e3,
                        failFast: true
                      }));
                    } else {
                      cacheSkipCount++;
                    }
                  }
                }
                var startTimestamp = util.now();
                var runner = strategies.pop().connect(minPriority, function cb(error, handshake) {
                  if (error) {
                    flushTransportCache(usingTLS);
                    if (strategies.length > 0) {
                      startTimestamp = util.now();
                      runner = strategies.pop().connect(minPriority, cb);
                    } else {
                      callback(error);
                    }
                  } else {
                    storeTransportCache(usingTLS, handshake.transport.name, util.now() - startTimestamp, cacheSkipCount);
                    callback(null, handshake);
                  }
                });
                return {
                  abort: function() {
                    runner.abort();
                  },
                  forceMinPriority: function(p) {
                    minPriority = p;
                    if (runner) {
                      runner.forceMinPriority(p);
                    }
                  }
                };
              }
            }
            function getTransportCacheKey(usingTLS) {
              return "pusherTransport" + (usingTLS ? "TLS" : "NonTLS");
            }
            function fetchTransportCache(usingTLS) {
              var storage = runtime.getLocalStorage();
              if (storage) {
                try {
                  var serializedCache = storage[getTransportCacheKey(usingTLS)];
                  if (serializedCache) {
                    return JSON.parse(serializedCache);
                  }
                } catch (e) {
                  flushTransportCache(usingTLS);
                }
              }
              return null;
            }
            function storeTransportCache(usingTLS, transport, latency, cacheSkipCount) {
              var storage = runtime.getLocalStorage();
              if (storage) {
                try {
                  storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({
                    timestamp: util.now(),
                    transport,
                    latency,
                    cacheSkipCount
                  });
                } catch (e) {
                }
              }
            }
            function flushTransportCache(usingTLS) {
              var storage = runtime.getLocalStorage();
              if (storage) {
                try {
                  delete storage[getTransportCacheKey(usingTLS)];
                } catch (e) {
                }
              }
            }
            class delayed_strategy_DelayedStrategy {
              constructor(strategy, { delay: number2 }) {
                this.strategy = strategy;
                this.options = { delay: number2 };
              }
              isSupported() {
                return this.strategy.isSupported();
              }
              connect(minPriority, callback) {
                var strategy = this.strategy;
                var runner;
                var timer = new timers_OneOffTimer(this.options.delay, function() {
                  runner = strategy.connect(minPriority, callback);
                });
                return {
                  abort: function() {
                    timer.ensureAborted();
                    if (runner) {
                      runner.abort();
                    }
                  },
                  forceMinPriority: function(p) {
                    minPriority = p;
                    if (runner) {
                      runner.forceMinPriority(p);
                    }
                  }
                };
              }
            }
            class IfStrategy {
              constructor(test2, trueBranch, falseBranch) {
                this.test = test2;
                this.trueBranch = trueBranch;
                this.falseBranch = falseBranch;
              }
              isSupported() {
                var branch = this.test() ? this.trueBranch : this.falseBranch;
                return branch.isSupported();
              }
              connect(minPriority, callback) {
                var branch = this.test() ? this.trueBranch : this.falseBranch;
                return branch.connect(minPriority, callback);
              }
            }
            class FirstConnectedStrategy {
              constructor(strategy) {
                this.strategy = strategy;
              }
              isSupported() {
                return this.strategy.isSupported();
              }
              connect(minPriority, callback) {
                var runner = this.strategy.connect(minPriority, function(error, handshake) {
                  if (handshake) {
                    runner.abort();
                  }
                  callback(error, handshake);
                });
                return runner;
              }
            }
            function testSupportsStrategy(strategy) {
              return function() {
                return strategy.isSupported();
              };
            }
            var getDefaultStrategy = function(config, baseOptions, defineTransport) {
              var definedTransports = {};
              function defineTransportStrategy(name2, type, priority, options2, manager) {
                var transport = defineTransport(config, name2, type, priority, options2, manager);
                definedTransports[name2] = transport;
                return transport;
              }
              var ws_options = Object.assign({}, baseOptions, {
                hostNonTLS: config.wsHost + ":" + config.wsPort,
                hostTLS: config.wsHost + ":" + config.wssPort,
                httpPath: config.wsPath
              });
              var wss_options = Object.assign({}, ws_options, {
                useTLS: true
              });
              var sockjs_options = Object.assign({}, baseOptions, {
                hostNonTLS: config.httpHost + ":" + config.httpPort,
                hostTLS: config.httpHost + ":" + config.httpsPort,
                httpPath: config.httpPath
              });
              var timeouts = {
                loop: true,
                timeout: 15e3,
                timeoutLimit: 6e4
              };
              var ws_manager = new transport_manager_TransportManager({
                minPingDelay: 1e4,
                maxPingDelay: config.activityTimeout
              });
              var streaming_manager = new transport_manager_TransportManager({
                lives: 2,
                minPingDelay: 1e4,
                maxPingDelay: config.activityTimeout
              });
              var ws_transport = defineTransportStrategy("ws", "ws", 3, ws_options, ws_manager);
              var wss_transport = defineTransportStrategy("wss", "ws", 3, wss_options, ws_manager);
              var sockjs_transport = defineTransportStrategy("sockjs", "sockjs", 1, sockjs_options);
              var xhr_streaming_transport = defineTransportStrategy("xhr_streaming", "xhr_streaming", 1, sockjs_options, streaming_manager);
              var xdr_streaming_transport = defineTransportStrategy("xdr_streaming", "xdr_streaming", 1, sockjs_options, streaming_manager);
              var xhr_polling_transport = defineTransportStrategy("xhr_polling", "xhr_polling", 1, sockjs_options);
              var xdr_polling_transport = defineTransportStrategy("xdr_polling", "xdr_polling", 1, sockjs_options);
              var ws_loop = new sequential_strategy_SequentialStrategy([ws_transport], timeouts);
              var wss_loop = new sequential_strategy_SequentialStrategy([wss_transport], timeouts);
              var sockjs_loop = new sequential_strategy_SequentialStrategy([sockjs_transport], timeouts);
              var streaming_loop = new sequential_strategy_SequentialStrategy([
                new IfStrategy(testSupportsStrategy(xhr_streaming_transport), xhr_streaming_transport, xdr_streaming_transport)
              ], timeouts);
              var polling_loop = new sequential_strategy_SequentialStrategy([
                new IfStrategy(testSupportsStrategy(xhr_polling_transport), xhr_polling_transport, xdr_polling_transport)
              ], timeouts);
              var http_loop = new sequential_strategy_SequentialStrategy([
                new IfStrategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy_BestConnectedEverStrategy([
                  streaming_loop,
                  new delayed_strategy_DelayedStrategy(polling_loop, { delay: 4e3 })
                ]), polling_loop)
              ], timeouts);
              var http_fallback_loop = new IfStrategy(testSupportsStrategy(http_loop), http_loop, sockjs_loop);
              var wsStrategy;
              if (baseOptions.useTLS) {
                wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([
                  ws_loop,
                  new delayed_strategy_DelayedStrategy(http_fallback_loop, { delay: 2e3 })
                ]);
              } else {
                wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([
                  ws_loop,
                  new delayed_strategy_DelayedStrategy(wss_loop, { delay: 2e3 }),
                  new delayed_strategy_DelayedStrategy(http_fallback_loop, { delay: 5e3 })
                ]);
              }
              return new websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy(new FirstConnectedStrategy(new IfStrategy(testSupportsStrategy(ws_transport), wsStrategy, http_fallback_loop)), definedTransports, {
                ttl: 18e5,
                timeline: baseOptions.timeline,
                useTLS: baseOptions.useTLS
              });
            };
            var default_strategy = getDefaultStrategy;
            var transport_connection_initializer = function() {
              var self2 = this;
              self2.timeline.info(self2.buildTimelineMessage({
                transport: self2.name + (self2.options.useTLS ? "s" : "")
              }));
              if (self2.hooks.isInitialized()) {
                self2.changeState("initialized");
              } else if (self2.hooks.file) {
                self2.changeState("initializing");
                Dependencies.load(self2.hooks.file, { useTLS: self2.options.useTLS }, function(error, callback) {
                  if (self2.hooks.isInitialized()) {
                    self2.changeState("initialized");
                    callback(true);
                  } else {
                    if (error) {
                      self2.onError(error);
                    }
                    self2.onClose();
                    callback(false);
                  }
                });
              } else {
                self2.onClose();
              }
            };
            var http_xdomain_request_hooks = {
              getRequest: function(socket) {
                var xdr = new window.XDomainRequest();
                xdr.ontimeout = function() {
                  socket.emit("error", new RequestTimedOut());
                  socket.close();
                };
                xdr.onerror = function(e) {
                  socket.emit("error", e);
                  socket.close();
                };
                xdr.onprogress = function() {
                  if (xdr.responseText && xdr.responseText.length > 0) {
                    socket.onChunk(200, xdr.responseText);
                  }
                };
                xdr.onload = function() {
                  if (xdr.responseText && xdr.responseText.length > 0) {
                    socket.onChunk(200, xdr.responseText);
                  }
                  socket.emit("finished", 200);
                  socket.close();
                };
                return xdr;
              },
              abortRequest: function(xdr) {
                xdr.ontimeout = xdr.onerror = xdr.onprogress = xdr.onload = null;
                xdr.abort();
              }
            };
            var http_xdomain_request = http_xdomain_request_hooks;
            const MAX_BUFFER_LENGTH = 256 * 1024;
            class http_request_HTTPRequest extends dispatcher_Dispatcher {
              constructor(hooks, method, url) {
                super();
                this.hooks = hooks;
                this.method = method;
                this.url = url;
              }
              start(payload) {
                this.position = 0;
                this.xhr = this.hooks.getRequest(this);
                this.unloader = () => {
                  this.close();
                };
                runtime.addUnloadListener(this.unloader);
                this.xhr.open(this.method, this.url, true);
                if (this.xhr.setRequestHeader) {
                  this.xhr.setRequestHeader("Content-Type", "application/json");
                }
                this.xhr.send(payload);
              }
              close() {
                if (this.unloader) {
                  runtime.removeUnloadListener(this.unloader);
                  this.unloader = null;
                }
                if (this.xhr) {
                  this.hooks.abortRequest(this.xhr);
                  this.xhr = null;
                }
              }
              onChunk(status, data) {
                while (true) {
                  var chunk = this.advanceBuffer(data);
                  if (chunk) {
                    this.emit("chunk", { status, data: chunk });
                  } else {
                    break;
                  }
                }
                if (this.isBufferTooLong(data)) {
                  this.emit("buffer_too_long");
                }
              }
              advanceBuffer(buffer) {
                var unreadData = buffer.slice(this.position);
                var endOfLinePosition = unreadData.indexOf("\n");
                if (endOfLinePosition !== -1) {
                  this.position += endOfLinePosition + 1;
                  return unreadData.slice(0, endOfLinePosition);
                } else {
                  return null;
                }
              }
              isBufferTooLong(buffer) {
                return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;
              }
            }
            var State;
            (function(State2) {
              State2[State2["CONNECTING"] = 0] = "CONNECTING";
              State2[State2["OPEN"] = 1] = "OPEN";
              State2[State2["CLOSED"] = 3] = "CLOSED";
            })(State || (State = {}));
            var state = State;
            var autoIncrement = 1;
            class http_socket_HTTPSocket {
              constructor(hooks, url) {
                this.hooks = hooks;
                this.session = randomNumber(1e3) + "/" + randomString(8);
                this.location = getLocation(url);
                this.readyState = state.CONNECTING;
                this.openStream();
              }
              send(payload) {
                return this.sendRaw(JSON.stringify([payload]));
              }
              ping() {
                this.hooks.sendHeartbeat(this);
              }
              close(code2, reason) {
                this.onClose(code2, reason, true);
              }
              sendRaw(payload) {
                if (this.readyState === state.OPEN) {
                  try {
                    runtime.createSocketRequest("POST", getUniqueURL(getSendURL(this.location, this.session))).start(payload);
                    return true;
                  } catch (e) {
                    return false;
                  }
                } else {
                  return false;
                }
              }
              reconnect() {
                this.closeStream();
                this.openStream();
              }
              onClose(code2, reason, wasClean) {
                this.closeStream();
                this.readyState = state.CLOSED;
                if (this.onclose) {
                  this.onclose({
                    code: code2,
                    reason,
                    wasClean
                  });
                }
              }
              onChunk(chunk) {
                if (chunk.status !== 200) {
                  return;
                }
                if (this.readyState === state.OPEN) {
                  this.onActivity();
                }
                var payload;
                var type = chunk.data.slice(0, 1);
                switch (type) {
                  case "o":
                    payload = JSON.parse(chunk.data.slice(1) || "{}");
                    this.onOpen(payload);
                    break;
                  case "a":
                    payload = JSON.parse(chunk.data.slice(1) || "[]");
                    for (var i = 0; i < payload.length; i++) {
                      this.onEvent(payload[i]);
                    }
                    break;
                  case "m":
                    payload = JSON.parse(chunk.data.slice(1) || "null");
                    this.onEvent(payload);
                    break;
                  case "h":
                    this.hooks.onHeartbeat(this);
                    break;
                  case "c":
                    payload = JSON.parse(chunk.data.slice(1) || "[]");
                    this.onClose(payload[0], payload[1], true);
                    break;
                }
              }
              onOpen(options2) {
                if (this.readyState === state.CONNECTING) {
                  if (options2 && options2.hostname) {
                    this.location.base = replaceHost(this.location.base, options2.hostname);
                  }
                  this.readyState = state.OPEN;
                  if (this.onopen) {
                    this.onopen();
                  }
                } else {
                  this.onClose(1006, "Server lost session", true);
                }
              }
              onEvent(event) {
                if (this.readyState === state.OPEN && this.onmessage) {
                  this.onmessage({ data: event });
                }
              }
              onActivity() {
                if (this.onactivity) {
                  this.onactivity();
                }
              }
              onError(error) {
                if (this.onerror) {
                  this.onerror(error);
                }
              }
              openStream() {
                this.stream = runtime.createSocketRequest("POST", getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));
                this.stream.bind("chunk", (chunk) => {
                  this.onChunk(chunk);
                });
                this.stream.bind("finished", (status) => {
                  this.hooks.onFinished(this, status);
                });
                this.stream.bind("buffer_too_long", () => {
                  this.reconnect();
                });
                try {
                  this.stream.start();
                } catch (error) {
                  util.defer(() => {
                    this.onError(error);
                    this.onClose(1006, "Could not start streaming", false);
                  });
                }
              }
              closeStream() {
                if (this.stream) {
                  this.stream.unbind_all();
                  this.stream.close();
                  this.stream = null;
                }
              }
            }
            function getLocation(url) {
              var parts = /([^\?]*)\/*(\??.*)/.exec(url);
              return {
                base: parts[1],
                queryString: parts[2]
              };
            }
            function getSendURL(url, session) {
              return url.base + "/" + session + "/xhr_send";
            }
            function getUniqueURL(url) {
              var separator = url.indexOf("?") === -1 ? "?" : "&";
              return url + separator + "t=" + +/* @__PURE__ */ new Date() + "&n=" + autoIncrement++;
            }
            function replaceHost(url, hostname) {
              var urlParts = /(https?:\/\/)([^\/:]+)((\/|:)?.*)/.exec(url);
              return urlParts[1] + hostname + urlParts[3];
            }
            function randomNumber(max2) {
              return runtime.randomInt(max2);
            }
            function randomString(length) {
              var result = [];
              for (var i = 0; i < length; i++) {
                result.push(randomNumber(32).toString(32));
              }
              return result.join("");
            }
            var http_socket = http_socket_HTTPSocket;
            var http_streaming_socket_hooks = {
              getReceiveURL: function(url, session) {
                return url.base + "/" + session + "/xhr_streaming" + url.queryString;
              },
              onHeartbeat: function(socket) {
                socket.sendRaw("[]");
              },
              sendHeartbeat: function(socket) {
                socket.sendRaw("[]");
              },
              onFinished: function(socket, status) {
                socket.onClose(1006, "Connection interrupted (" + status + ")", false);
              }
            };
            var http_streaming_socket = http_streaming_socket_hooks;
            var http_polling_socket_hooks = {
              getReceiveURL: function(url, session) {
                return url.base + "/" + session + "/xhr" + url.queryString;
              },
              onHeartbeat: function() {
              },
              sendHeartbeat: function(socket) {
                socket.sendRaw("[]");
              },
              onFinished: function(socket, status) {
                if (status === 200) {
                  socket.reconnect();
                } else {
                  socket.onClose(1006, "Connection interrupted (" + status + ")", false);
                }
              }
            };
            var http_polling_socket = http_polling_socket_hooks;
            var http_xhr_request_hooks = {
              getRequest: function(socket) {
                var Constructor = runtime.getXHRAPI();
                var xhr = new Constructor();
                xhr.onreadystatechange = xhr.onprogress = function() {
                  switch (xhr.readyState) {
                    case 3:
                      if (xhr.responseText && xhr.responseText.length > 0) {
                        socket.onChunk(xhr.status, xhr.responseText);
                      }
                      break;
                    case 4:
                      if (xhr.responseText && xhr.responseText.length > 0) {
                        socket.onChunk(xhr.status, xhr.responseText);
                      }
                      socket.emit("finished", xhr.status);
                      socket.close();
                      break;
                  }
                };
                return xhr;
              },
              abortRequest: function(xhr) {
                xhr.onreadystatechange = null;
                xhr.abort();
              }
            };
            var http_xhr_request = http_xhr_request_hooks;
            var HTTP = {
              createStreamingSocket(url) {
                return this.createSocket(http_streaming_socket, url);
              },
              createPollingSocket(url) {
                return this.createSocket(http_polling_socket, url);
              },
              createSocket(hooks, url) {
                return new http_socket(hooks, url);
              },
              createXHR(method, url) {
                return this.createRequest(http_xhr_request, method, url);
              },
              createRequest(hooks, method, url) {
                return new http_request_HTTPRequest(hooks, method, url);
              }
            };
            var http_http = HTTP;
            http_http.createXDR = function(method, url) {
              return this.createRequest(http_xdomain_request, method, url);
            };
            var web_http_http = http_http;
            var Runtime = {
              nextAuthCallbackID: 1,
              auth_callbacks: {},
              ScriptReceivers,
              DependenciesReceivers,
              getDefaultStrategy: default_strategy,
              Transports: transports_transports,
              transportConnectionInitializer: transport_connection_initializer,
              HTTPFactory: web_http_http,
              TimelineTransport: jsonp_timeline,
              getXHRAPI() {
                return window.XMLHttpRequest;
              },
              getWebSocketAPI() {
                return window.WebSocket || window.MozWebSocket;
              },
              setup(PusherClass) {
                window.Pusher = PusherClass;
                var initializeOnDocumentBody = () => {
                  this.onDocumentBody(PusherClass.ready);
                };
                if (!window.JSON) {
                  Dependencies.load("json2", {}, initializeOnDocumentBody);
                } else {
                  initializeOnDocumentBody();
                }
              },
              getDocument() {
                return document;
              },
              getProtocol() {
                return this.getDocument().location.protocol;
              },
              getAuthorizers() {
                return { ajax: xhr_auth, jsonp: jsonp_auth };
              },
              onDocumentBody(callback) {
                if (document.body) {
                  callback();
                } else {
                  setTimeout(() => {
                    this.onDocumentBody(callback);
                  }, 0);
                }
              },
              createJSONPRequest(url, data) {
                return new jsonp_request_JSONPRequest(url, data);
              },
              createScriptRequest(src) {
                return new ScriptRequest(src);
              },
              getLocalStorage() {
                try {
                  return window.localStorage;
                } catch (e) {
                  return void 0;
                }
              },
              createXHR() {
                if (this.getXHRAPI()) {
                  return this.createXMLHttpRequest();
                } else {
                  return this.createMicrosoftXHR();
                }
              },
              createXMLHttpRequest() {
                var Constructor = this.getXHRAPI();
                return new Constructor();
              },
              createMicrosoftXHR() {
                return new ActiveXObject("Microsoft.XMLHTTP");
              },
              getNetwork() {
                return net_info_Network;
              },
              createWebSocket(url) {
                var Constructor = this.getWebSocketAPI();
                return new Constructor(url);
              },
              createSocketRequest(method, url) {
                if (this.isXHRSupported()) {
                  return this.HTTPFactory.createXHR(method, url);
                } else if (this.isXDRSupported(url.indexOf("https:") === 0)) {
                  return this.HTTPFactory.createXDR(method, url);
                } else {
                  throw "Cross-origin HTTP requests are not supported";
                }
              },
              isXHRSupported() {
                var Constructor = this.getXHRAPI();
                return Boolean(Constructor) && new Constructor().withCredentials !== void 0;
              },
              isXDRSupported(useTLS) {
                var protocol = useTLS ? "https:" : "http:";
                var documentProtocol = this.getProtocol();
                return Boolean(window["XDomainRequest"]) && documentProtocol === protocol;
              },
              addUnloadListener(listener) {
                if (window.addEventListener !== void 0) {
                  window.addEventListener("unload", listener, false);
                } else if (window.attachEvent !== void 0) {
                  window.attachEvent("onunload", listener);
                }
              },
              removeUnloadListener(listener) {
                if (window.addEventListener !== void 0) {
                  window.removeEventListener("unload", listener, false);
                } else if (window.detachEvent !== void 0) {
                  window.detachEvent("onunload", listener);
                }
              },
              randomInt(max2) {
                const random = function() {
                  const crypto = window.crypto || window["msCrypto"];
                  const random2 = crypto.getRandomValues(new Uint32Array(1))[0];
                  return random2 / Math.pow(2, 32);
                };
                return Math.floor(random() * max2);
              }
            };
            var runtime = Runtime;
            var TimelineLevel;
            (function(TimelineLevel2) {
              TimelineLevel2[TimelineLevel2["ERROR"] = 3] = "ERROR";
              TimelineLevel2[TimelineLevel2["INFO"] = 6] = "INFO";
              TimelineLevel2[TimelineLevel2["DEBUG"] = 7] = "DEBUG";
            })(TimelineLevel || (TimelineLevel = {}));
            var timeline_level = TimelineLevel;
            class timeline_Timeline {
              constructor(key, session, options2) {
                this.key = key;
                this.session = session;
                this.events = [];
                this.options = options2 || {};
                this.sent = 0;
                this.uniqueID = 0;
              }
              log(level, event) {
                if (level <= this.options.level) {
                  this.events.push(extend2({}, event, { timestamp: util.now() }));
                  if (this.options.limit && this.events.length > this.options.limit) {
                    this.events.shift();
                  }
                }
              }
              error(event) {
                this.log(timeline_level.ERROR, event);
              }
              info(event) {
                this.log(timeline_level.INFO, event);
              }
              debug(event) {
                this.log(timeline_level.DEBUG, event);
              }
              isEmpty() {
                return this.events.length === 0;
              }
              send(sendfn, callback) {
                var data = extend2({
                  session: this.session,
                  bundle: this.sent + 1,
                  key: this.key,
                  lib: "js",
                  version: this.options.version,
                  cluster: this.options.cluster,
                  features: this.options.features,
                  timeline: this.events
                }, this.options.params);
                this.events = [];
                sendfn(data, (error, result) => {
                  if (!error) {
                    this.sent++;
                  }
                  if (callback) {
                    callback(error, result);
                  }
                });
                return true;
              }
              generateUniqueID() {
                this.uniqueID++;
                return this.uniqueID;
              }
            }
            class transport_strategy_TransportStrategy {
              constructor(name2, priority, transport, options2) {
                this.name = name2;
                this.priority = priority;
                this.transport = transport;
                this.options = options2 || {};
              }
              isSupported() {
                return this.transport.isSupported({
                  useTLS: this.options.useTLS
                });
              }
              connect(minPriority, callback) {
                if (!this.isSupported()) {
                  return failAttempt(new UnsupportedStrategy(), callback);
                } else if (this.priority < minPriority) {
                  return failAttempt(new TransportPriorityTooLow(), callback);
                }
                var connected = false;
                var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);
                var handshake = null;
                var onInitialized = function() {
                  transport.unbind("initialized", onInitialized);
                  transport.connect();
                };
                var onOpen = function() {
                  handshake = factory.createHandshake(transport, function(result) {
                    connected = true;
                    unbindListeners();
                    callback(null, result);
                  });
                };
                var onError = function(error) {
                  unbindListeners();
                  callback(error);
                };
                var onClosed = function() {
                  unbindListeners();
                  var serializedTransport;
                  serializedTransport = safeJSONStringify(transport);
                  callback(new TransportClosed(serializedTransport));
                };
                var unbindListeners = function() {
                  transport.unbind("initialized", onInitialized);
                  transport.unbind("open", onOpen);
                  transport.unbind("error", onError);
                  transport.unbind("closed", onClosed);
                };
                transport.bind("initialized", onInitialized);
                transport.bind("open", onOpen);
                transport.bind("error", onError);
                transport.bind("closed", onClosed);
                transport.initialize();
                return {
                  abort: () => {
                    if (connected) {
                      return;
                    }
                    unbindListeners();
                    if (handshake) {
                      handshake.close();
                    } else {
                      transport.close();
                    }
                  },
                  forceMinPriority: (p) => {
                    if (connected) {
                      return;
                    }
                    if (this.priority < p) {
                      if (handshake) {
                        handshake.close();
                      } else {
                        transport.close();
                      }
                    }
                  }
                };
              }
            }
            function failAttempt(error, callback) {
              util.defer(function() {
                callback(error);
              });
              return {
                abort: function() {
                },
                forceMinPriority: function() {
                }
              };
            }
            const { Transports: strategy_builder_Transports } = runtime;
            var strategy_builder_defineTransport = function(config, name2, type, priority, options2, manager) {
              var transportClass = strategy_builder_Transports[type];
              if (!transportClass) {
                throw new UnsupportedTransport(type);
              }
              var enabled = (!config.enabledTransports || arrayIndexOf(config.enabledTransports, name2) !== -1) && (!config.disabledTransports || arrayIndexOf(config.disabledTransports, name2) === -1);
              var transport;
              if (enabled) {
                options2 = Object.assign({ ignoreNullOrigin: config.ignoreNullOrigin }, options2);
                transport = new transport_strategy_TransportStrategy(name2, priority, manager ? manager.getAssistant(transportClass) : transportClass, options2);
              } else {
                transport = strategy_builder_UnsupportedStrategy;
              }
              return transport;
            };
            var strategy_builder_UnsupportedStrategy = {
              isSupported: function() {
                return false;
              },
              connect: function(_, callback) {
                var deferred = util.defer(function() {
                  callback(new UnsupportedStrategy());
                });
                return {
                  abort: function() {
                    deferred.ensureAborted();
                  },
                  forceMinPriority: function() {
                  }
                };
              }
            };
            function validateOptions(options2) {
              if (options2 == null) {
                throw "You must pass an options object";
              }
              if (options2.cluster == null) {
                throw "Options object must provide a cluster";
              }
              if ("disableStats" in options2) {
                logger2.warn("The disableStats option is deprecated in favor of enableStats");
              }
            }
            const composeChannelQuery = (params, authOptions) => {
              var query = "socket_id=" + encodeURIComponent(params.socketId);
              for (var key in authOptions.params) {
                query += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(authOptions.params[key]);
              }
              if (authOptions.paramsProvider != null) {
                let dynamicParams = authOptions.paramsProvider();
                for (var key in dynamicParams) {
                  query += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dynamicParams[key]);
                }
              }
              return query;
            };
            const UserAuthenticator = (authOptions) => {
              if (typeof runtime.getAuthorizers()[authOptions.transport] === "undefined") {
                throw `'${authOptions.transport}' is not a recognized auth transport`;
              }
              return (params, callback) => {
                const query = composeChannelQuery(params, authOptions);
                runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.UserAuthentication, callback);
              };
            };
            var user_authenticator = UserAuthenticator;
            const channel_authorizer_composeChannelQuery = (params, authOptions) => {
              var query = "socket_id=" + encodeURIComponent(params.socketId);
              query += "&channel_name=" + encodeURIComponent(params.channelName);
              for (var key in authOptions.params) {
                query += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(authOptions.params[key]);
              }
              if (authOptions.paramsProvider != null) {
                let dynamicParams = authOptions.paramsProvider();
                for (var key in dynamicParams) {
                  query += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dynamicParams[key]);
                }
              }
              return query;
            };
            const ChannelAuthorizer = (authOptions) => {
              if (typeof runtime.getAuthorizers()[authOptions.transport] === "undefined") {
                throw `'${authOptions.transport}' is not a recognized auth transport`;
              }
              return (params, callback) => {
                const query = channel_authorizer_composeChannelQuery(params, authOptions);
                runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.ChannelAuthorization, callback);
              };
            };
            var channel_authorizer = ChannelAuthorizer;
            const ChannelAuthorizerProxy = (pusher2, authOptions, channelAuthorizerGenerator) => {
              const deprecatedAuthorizerOptions = {
                authTransport: authOptions.transport,
                authEndpoint: authOptions.endpoint,
                auth: {
                  params: authOptions.params,
                  headers: authOptions.headers
                }
              };
              return (params, callback) => {
                const channel = pusher2.channel(params.channelName);
                const channelAuthorizer = channelAuthorizerGenerator(channel, deprecatedAuthorizerOptions);
                channelAuthorizer.authorize(params.socketId, callback);
              };
            };
            function getConfig(opts, pusher2) {
              let config = {
                activityTimeout: opts.activityTimeout || defaults2.activityTimeout,
                cluster: opts.cluster,
                httpPath: opts.httpPath || defaults2.httpPath,
                httpPort: opts.httpPort || defaults2.httpPort,
                httpsPort: opts.httpsPort || defaults2.httpsPort,
                pongTimeout: opts.pongTimeout || defaults2.pongTimeout,
                statsHost: opts.statsHost || defaults2.stats_host,
                unavailableTimeout: opts.unavailableTimeout || defaults2.unavailableTimeout,
                wsPath: opts.wsPath || defaults2.wsPath,
                wsPort: opts.wsPort || defaults2.wsPort,
                wssPort: opts.wssPort || defaults2.wssPort,
                enableStats: getEnableStatsConfig(opts),
                httpHost: getHttpHost(opts),
                useTLS: shouldUseTLS(opts),
                wsHost: getWebsocketHost(opts),
                userAuthenticator: buildUserAuthenticator(opts),
                channelAuthorizer: buildChannelAuthorizer(opts, pusher2)
              };
              if ("disabledTransports" in opts)
                config.disabledTransports = opts.disabledTransports;
              if ("enabledTransports" in opts)
                config.enabledTransports = opts.enabledTransports;
              if ("ignoreNullOrigin" in opts)
                config.ignoreNullOrigin = opts.ignoreNullOrigin;
              if ("timelineParams" in opts)
                config.timelineParams = opts.timelineParams;
              if ("nacl" in opts) {
                config.nacl = opts.nacl;
              }
              return config;
            }
            function getHttpHost(opts) {
              if (opts.httpHost) {
                return opts.httpHost;
              }
              if (opts.cluster) {
                return `sockjs-${opts.cluster}.pusher.com`;
              }
              return defaults2.httpHost;
            }
            function getWebsocketHost(opts) {
              if (opts.wsHost) {
                return opts.wsHost;
              }
              return getWebsocketHostFromCluster(opts.cluster);
            }
            function getWebsocketHostFromCluster(cluster) {
              return `ws-${cluster}.pusher.com`;
            }
            function shouldUseTLS(opts) {
              if (runtime.getProtocol() === "https:") {
                return true;
              } else if (opts.forceTLS === false) {
                return false;
              }
              return true;
            }
            function getEnableStatsConfig(opts) {
              if ("enableStats" in opts) {
                return opts.enableStats;
              }
              if ("disableStats" in opts) {
                return !opts.disableStats;
              }
              return false;
            }
            function buildUserAuthenticator(opts) {
              const userAuthentication = Object.assign(Object.assign({}, defaults2.userAuthentication), opts.userAuthentication);
              if ("customHandler" in userAuthentication && userAuthentication["customHandler"] != null) {
                return userAuthentication["customHandler"];
              }
              return user_authenticator(userAuthentication);
            }
            function buildChannelAuth(opts, pusher2) {
              let channelAuthorization;
              if ("channelAuthorization" in opts) {
                channelAuthorization = Object.assign(Object.assign({}, defaults2.channelAuthorization), opts.channelAuthorization);
              } else {
                channelAuthorization = {
                  transport: opts.authTransport || defaults2.authTransport,
                  endpoint: opts.authEndpoint || defaults2.authEndpoint
                };
                if ("auth" in opts) {
                  if ("params" in opts.auth)
                    channelAuthorization.params = opts.auth.params;
                  if ("headers" in opts.auth)
                    channelAuthorization.headers = opts.auth.headers;
                }
                if ("authorizer" in opts)
                  channelAuthorization.customHandler = ChannelAuthorizerProxy(pusher2, channelAuthorization, opts.authorizer);
              }
              return channelAuthorization;
            }
            function buildChannelAuthorizer(opts, pusher2) {
              const channelAuthorization = buildChannelAuth(opts, pusher2);
              if ("customHandler" in channelAuthorization && channelAuthorization["customHandler"] != null) {
                return channelAuthorization["customHandler"];
              }
              return channel_authorizer(channelAuthorization);
            }
            class watchlist_WatchlistFacade extends dispatcher_Dispatcher {
              constructor(pusher2) {
                super(function(eventName, data) {
                  logger2.debug(`No callbacks on watchlist events for ${eventName}`);
                });
                this.pusher = pusher2;
                this.bindWatchlistInternalEvent();
              }
              handleEvent(pusherEvent) {
                pusherEvent.data.events.forEach((watchlistEvent) => {
                  this.emit(watchlistEvent.name, watchlistEvent);
                });
              }
              bindWatchlistInternalEvent() {
                this.pusher.connection.bind("message", (pusherEvent) => {
                  var eventName = pusherEvent.event;
                  if (eventName === "pusher_internal:watchlist_events") {
                    this.handleEvent(pusherEvent);
                  }
                });
              }
            }
            function flatPromise() {
              let resolve, reject;
              const promise = new Promise((res, rej) => {
                resolve = res;
                reject = rej;
              });
              return { promise, resolve, reject };
            }
            var flat_promise = flatPromise;
            class user_UserFacade extends dispatcher_Dispatcher {
              constructor(pusher2) {
                super(function(eventName, data) {
                  logger2.debug("No callbacks on user for " + eventName);
                });
                this.signin_requested = false;
                this.user_data = null;
                this.serverToUserChannel = null;
                this.signinDonePromise = null;
                this._signinDoneResolve = null;
                this._onAuthorize = (err, authData) => {
                  if (err) {
                    logger2.warn(`Error during signin: ${err}`);
                    this._cleanup();
                    return;
                  }
                  this.pusher.send_event("pusher:signin", {
                    auth: authData.auth,
                    user_data: authData.user_data
                  });
                };
                this.pusher = pusher2;
                this.pusher.connection.bind("state_change", ({ previous: previous2, current }) => {
                  if (previous2 !== "connected" && current === "connected") {
                    this._signin();
                  }
                  if (previous2 === "connected" && current !== "connected") {
                    this._cleanup();
                    this._newSigninPromiseIfNeeded();
                  }
                });
                this.watchlist = new watchlist_WatchlistFacade(pusher2);
                this.pusher.connection.bind("message", (event) => {
                  var eventName = event.event;
                  if (eventName === "pusher:signin_success") {
                    this._onSigninSuccess(event.data);
                  }
                  if (this.serverToUserChannel && this.serverToUserChannel.name === event.channel) {
                    this.serverToUserChannel.handleEvent(event);
                  }
                });
              }
              signin() {
                if (this.signin_requested) {
                  return;
                }
                this.signin_requested = true;
                this._signin();
              }
              _signin() {
                if (!this.signin_requested) {
                  return;
                }
                this._newSigninPromiseIfNeeded();
                if (this.pusher.connection.state !== "connected") {
                  return;
                }
                this.pusher.config.userAuthenticator({
                  socketId: this.pusher.connection.socket_id
                }, this._onAuthorize);
              }
              _onSigninSuccess(data) {
                try {
                  this.user_data = JSON.parse(data.user_data);
                } catch (e) {
                  logger2.error(`Failed parsing user data after signin: ${data.user_data}`);
                  this._cleanup();
                  return;
                }
                if (typeof this.user_data.id !== "string" || this.user_data.id === "") {
                  logger2.error(`user_data doesn't contain an id. user_data: ${this.user_data}`);
                  this._cleanup();
                  return;
                }
                this._signinDoneResolve();
                this._subscribeChannels();
              }
              _subscribeChannels() {
                const ensure_subscribed = (channel) => {
                  if (channel.subscriptionPending && channel.subscriptionCancelled) {
                    channel.reinstateSubscription();
                  } else if (!channel.subscriptionPending && this.pusher.connection.state === "connected") {
                    channel.subscribe();
                  }
                };
                this.serverToUserChannel = new channel_Channel(`#server-to-user-${this.user_data.id}`, this.pusher);
                this.serverToUserChannel.bind_global((eventName, data) => {
                  if (eventName.indexOf("pusher_internal:") === 0 || eventName.indexOf("pusher:") === 0) {
                    return;
                  }
                  this.emit(eventName, data);
                });
                ensure_subscribed(this.serverToUserChannel);
              }
              _cleanup() {
                this.user_data = null;
                if (this.serverToUserChannel) {
                  this.serverToUserChannel.unbind_all();
                  this.serverToUserChannel.disconnect();
                  this.serverToUserChannel = null;
                }
                if (this.signin_requested) {
                  this._signinDoneResolve();
                }
              }
              _newSigninPromiseIfNeeded() {
                if (!this.signin_requested) {
                  return;
                }
                if (this.signinDonePromise && !this.signinDonePromise.done) {
                  return;
                }
                const { promise, resolve } = flat_promise();
                promise.done = false;
                const setDone = () => {
                  promise.done = true;
                };
                promise.then(setDone).catch(setDone);
                this.signinDonePromise = promise;
                this._signinDoneResolve = resolve;
              }
            }
            class pusher_Pusher {
              static ready() {
                pusher_Pusher.isReady = true;
                for (var i = 0, l = pusher_Pusher.instances.length; i < l; i++) {
                  pusher_Pusher.instances[i].connect();
                }
              }
              static getClientFeatures() {
                return keys2(filterObject({ ws: runtime.Transports.ws }, function(t) {
                  return t.isSupported({});
                }));
              }
              constructor(app_key, options2) {
                checkAppKey(app_key);
                validateOptions(options2);
                this.key = app_key;
                this.config = getConfig(options2, this);
                this.channels = factory.createChannels();
                this.global_emitter = new dispatcher_Dispatcher();
                this.sessionID = runtime.randomInt(1e9);
                this.timeline = new timeline_Timeline(this.key, this.sessionID, {
                  cluster: this.config.cluster,
                  features: pusher_Pusher.getClientFeatures(),
                  params: this.config.timelineParams || {},
                  limit: 50,
                  level: timeline_level.INFO,
                  version: defaults2.VERSION
                });
                if (this.config.enableStats) {
                  this.timelineSender = factory.createTimelineSender(this.timeline, {
                    host: this.config.statsHost,
                    path: "/timeline/v2/" + runtime.TimelineTransport.name
                  });
                }
                var getStrategy = (options3) => {
                  return runtime.getDefaultStrategy(this.config, options3, strategy_builder_defineTransport);
                };
                this.connection = factory.createConnectionManager(this.key, {
                  getStrategy,
                  timeline: this.timeline,
                  activityTimeout: this.config.activityTimeout,
                  pongTimeout: this.config.pongTimeout,
                  unavailableTimeout: this.config.unavailableTimeout,
                  useTLS: Boolean(this.config.useTLS)
                });
                this.connection.bind("connected", () => {
                  this.subscribeAll();
                  if (this.timelineSender) {
                    this.timelineSender.send(this.connection.isUsingTLS());
                  }
                });
                this.connection.bind("message", (event) => {
                  var eventName = event.event;
                  var internal = eventName.indexOf("pusher_internal:") === 0;
                  if (event.channel) {
                    var channel = this.channel(event.channel);
                    if (channel) {
                      channel.handleEvent(event);
                    }
                  }
                  if (!internal) {
                    this.global_emitter.emit(event.event, event.data);
                  }
                });
                this.connection.bind("connecting", () => {
                  this.channels.disconnect();
                });
                this.connection.bind("disconnected", () => {
                  this.channels.disconnect();
                });
                this.connection.bind("error", (err) => {
                  logger2.warn(err);
                });
                pusher_Pusher.instances.push(this);
                this.timeline.info({ instances: pusher_Pusher.instances.length });
                this.user = new user_UserFacade(this);
                if (pusher_Pusher.isReady) {
                  this.connect();
                }
              }
              channel(name2) {
                return this.channels.find(name2);
              }
              allChannels() {
                return this.channels.all();
              }
              connect() {
                this.connection.connect();
                if (this.timelineSender) {
                  if (!this.timelineSenderTimer) {
                    var usingTLS = this.connection.isUsingTLS();
                    var timelineSender = this.timelineSender;
                    this.timelineSenderTimer = new timers_PeriodicTimer(6e4, function() {
                      timelineSender.send(usingTLS);
                    });
                  }
                }
              }
              disconnect() {
                this.connection.disconnect();
                if (this.timelineSenderTimer) {
                  this.timelineSenderTimer.ensureAborted();
                  this.timelineSenderTimer = null;
                }
              }
              bind(event_name, callback, context) {
                this.global_emitter.bind(event_name, callback, context);
                return this;
              }
              unbind(event_name, callback, context) {
                this.global_emitter.unbind(event_name, callback, context);
                return this;
              }
              bind_global(callback) {
                this.global_emitter.bind_global(callback);
                return this;
              }
              unbind_global(callback) {
                this.global_emitter.unbind_global(callback);
                return this;
              }
              unbind_all(callback) {
                this.global_emitter.unbind_all();
                return this;
              }
              subscribeAll() {
                var channelName;
                for (channelName in this.channels.channels) {
                  if (this.channels.channels.hasOwnProperty(channelName)) {
                    this.subscribe(channelName);
                  }
                }
              }
              subscribe(channel_name) {
                var channel = this.channels.add(channel_name, this);
                if (channel.subscriptionPending && channel.subscriptionCancelled) {
                  channel.reinstateSubscription();
                } else if (!channel.subscriptionPending && this.connection.state === "connected") {
                  channel.subscribe();
                }
                return channel;
              }
              unsubscribe(channel_name) {
                var channel = this.channels.find(channel_name);
                if (channel && channel.subscriptionPending) {
                  channel.cancelSubscription();
                } else {
                  channel = this.channels.remove(channel_name);
                  if (channel && channel.subscribed) {
                    channel.unsubscribe();
                  }
                }
              }
              send_event(event_name, data, channel) {
                return this.connection.send_event(event_name, data, channel);
              }
              shouldUseTLS() {
                return this.config.useTLS;
              }
              signin() {
                this.user.signin();
              }
            }
            pusher_Pusher.instances = [];
            pusher_Pusher.isReady = false;
            pusher_Pusher.logToConsole = false;
            pusher_Pusher.Runtime = runtime;
            pusher_Pusher.ScriptReceivers = runtime.ScriptReceivers;
            pusher_Pusher.DependenciesReceivers = runtime.DependenciesReceivers;
            pusher_Pusher.auth_callbacks = runtime.auth_callbacks;
            var core_pusher = __webpack_exports__["default"] = pusher_Pusher;
            function checkAppKey(key) {
              if (key === null || key === void 0) {
                throw "You must pass your app key when you instantiate Pusher.";
              }
            }
            runtime.setup(pusher_Pusher);
          }
          /******/
        ])
      );
    });
  })(pusher);
  var pusherExports = pusher.exports;
  const Pusher = /* @__PURE__ */ getDefaultExportFromCjs(pusherExports);
  const authApi = {
    /**
     * Authenticate with an agent
     * @param agentName The name of the agent to authenticate with
     * @param configToken The configuration token for the application (optional if sessionId is provided)
     * @param sessionId The session ID for resuming a previous session (optional)
     * @returns Agent authentication response with token and userId
     */
    authenticateWithAgent: async (authUrl, agentName, configToken, sessionId) => {
      try {
        const requestBody = {};
        if (configToken) {
          requestBody.token = configToken;
        } else if (sessionId) {
          requestBody.sessionId = sessionId;
        }
        const response = await axios.post(
          `${authUrl}/agent/${agentName}`,
          requestBody,
          {
            headers: {
              "Content-Type": "application/json"
            }
          }
        );
        return response.data;
      } catch (error) {
        console.error("Agent authentication error:", error);
        throw new Error("Failed to authenticate with agent");
      }
    }
  };
  let authToken = null;
  let userId = null;
  const authService = {
    /**
     * Set the authentication token and update the API client
     * @param token The authentication token
     * @param userIdValue The user ID associated with the token
     */
    setAuthToken(token, userIdValue) {
      authToken = token;
      userId = userIdValue;
      const apiClient = getApiClient();
      apiClient.setAuthToken(token);
    },
    /**
     * Get the current authentication token
     * @returns The current token or null if not set
     */
    getAuthToken() {
      return authToken;
    },
    /**
     * Get the user ID
     * @returns The current user ID or null if not set
     */
    getUserId() {
      return userId;
    }
  };
  function generateUuid() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r2 = Math.random() * 16 | 0;
      const v = c === "x" ? r2 : r2 & 3 | 8;
      return v.toString(16);
    });
  }
  const LuaPopContext = reactExports.createContext(void 0);
  function useLuaPop() {
    const context = reactExports.useContext(LuaPopContext);
    if (!context) {
      throw new Error("useLuaPop must be used within LuaPopProvider");
    }
    return context;
  }
  function LuaPopProvider({
    config,
    authUrl,
    children
  }) {
    const [isPusherReady, setIsPusherReady] = reactExports.useState(false);
    const [isChatOpen, setIsChatOpen] = reactExports.useState(config.displayMode === "embedded");
    const pusherRef = reactExports.useRef(null);
    const channelRef = reactExports.useRef(null);
    const isChatOpenRef = reactExports.useRef(isChatOpen);
    const { setMessages } = pn();
    const { setHasUnreadMessages } = hn();
    reactExports.useEffect(() => {
      isChatOpenRef.current = isChatOpen;
    }, [isChatOpen]);
    const agentAuthMutation = useMutation({
      mutationFn: () => authApi.authenticateWithAgent(
        authUrl,
        config.agentId || "",
        config.authToken,
        config.sessionId
      ),
      onSuccess: (data) => {
        authService.setAuthToken(data.token, data.userId);
      },
      onError: (error) => {
        console.error("Authentication error:", error);
      }
    });
    reactExports.useEffect(() => {
      if (config.authToken || config.sessionId) {
        agentAuthMutation.mutate();
      }
    }, [config.authToken, config.sessionId]);
    reactExports.useEffect(() => {
      if (!agentAuthMutation.isSuccess) return;
      const userId2 = authService.getUserId();
      if (!userId2) return;
      if (pusherRef.current) {
        return;
      }
      try {
        pusherRef.current = new Pusher("2d7f090aebbafca0165c", {
          cluster: "eu"
        });
        channelRef.current = pusherRef.current.subscribe(userId2);
        channelRef.current.bind("message", function(data) {
          const assistantMessage = {
            id: generateUuid(),
            role: "assistant",
            content: data.message,
            type: "text",
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          setMessages((prev) => [...prev, assistantMessage]);
          if (!isChatOpenRef.current) {
            setHasUnreadMessages(true);
          }
        });
        setIsPusherReady(true);
        console.debug("Pusher initialized successfully", { userId: userId2 });
      } catch (error) {
        console.error("Failed to initialize Pusher:", error);
      }
      return () => {
        if (channelRef.current) {
          channelRef.current.unbind_all();
          channelRef.current.unsubscribe();
          channelRef.current = null;
        }
        if (pusherRef.current) {
          pusherRef.current.disconnect();
          pusherRef.current = null;
        }
        setIsPusherReady(false);
      };
    }, [agentAuthMutation.isSuccess]);
    const value = {
      authToken: authService.getAuthToken(),
      userId: authService.getUserId(),
      isAuthenticating: agentAuthMutation.isPending,
      isAuthSuccess: agentAuthMutation.isSuccess,
      isAuthError: agentAuthMutation.isError,
      isPusherReady,
      isReady: agentAuthMutation.isSuccess && isPusherReady,
      setIsChatOpen
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(LuaPopContext.Provider, { value, children });
  }
  const chatApi = {
    fetchChatHistory: async () => {
      var _a2;
      const api = getApiClient();
      const config = ((_a2 = window.LuaPop) == null ? void 0 : _a2.config) || {};
      const agentId = config.agentId || "";
      const endpoint = agentId ? `/chat/history/${agentId}` : "/chat/history";
      return api.get(endpoint);
    },
    streamChat: async (messages, runtimeContext, navigate) => {
      var _a2;
      const api = getApiClient();
      const channel = "pop";
      const config = ((_a2 = window.LuaPop) == null ? void 0 : _a2.config) || {};
      const agentId = config.agentId || "";
      const endpoint = agentId ? `/chat/stream/${agentId}?channel=${channel}` : `/chat/stream?channel=${channel}`;
      const reader = await api.stream(endpoint, {
        messages,
        navigate,
        ...runtimeContext && { runtimeContext }
      });
      if (!reader) {
        throw new Error("No response body");
      }
      return reader;
    },
    fetchUrlMetadata: async (url) => {
      const api = getApiClient();
      return api.get(`/chat/url-metadata`, {
        params: { url }
      });
    }
  };
  function normalizeStringEscaping(stringToNormalize) {
    if (!stringToNormalize) return stringToNormalize;
    stringToNormalize = stringToNormalize.replace(/:::\\\\n\\\\n/g, ":::\n\n");
    stringToNormalize = stringToNormalize.replace(/:::\\(?!n)/g, ":::\n\n");
    stringToNormalize = stringToNormalize.replace(/\\\\n/g, "\\n");
    return stringToNormalize;
  }
  function useChatHistory({
    authToken: authToken2,
    enabled = true
  }) {
    const { setMessages } = pn();
    const { data: historyData = [], isLoading: isLoadingHistory } = useQuery({
      queryKey: ["chatHistory"],
      queryFn: chatApi.fetchChatHistory,
      enabled: !!authToken2 && enabled
      // Only fetch when we have an auth token and enabled
    });
    reactExports.useEffect(() => {
      if (historyData.length > 0 && !isLoadingHistory) {
        const history = [];
        historyData.forEach((msg) => {
          if (typeof msg.content === "string" || msg.content instanceof String) {
            return;
          }
          msg.content.reverse().forEach((content2) => {
            const contentItem = content2;
            const message = {
              id: generateUuid(),
              role: msg.role,
              createdAt: msg.createdAt,
              content: normalizeStringEscaping(contentItem.text || "")
            };
            switch (contentItem.type) {
              case "audio":
                message.type = "audio";
                message.url = contentItem.data;
                message.mediaType = contentItem.mediaType;
                break;
              case "image":
                message.type = "image";
                message.url = contentItem.image;
                message.mediaType = contentItem.mediaType;
                break;
              case "file":
                message.mediaType = contentItem.mediaType;
                message.type = "file";
                message.url = contentItem.data;
                break;
              case "location":
                message.type = "location";
                message.location = {
                  latitude: contentItem.latitude,
                  longitude: contentItem.longitude
                };
                break;
              case "text":
                if (contentItem.latitude && contentItem.longitude) {
                  message.type = "location";
                  message.location = {
                    latitude: contentItem.latitude,
                    longitude: contentItem.longitude
                  };
                } else {
                  message.type = "text";
                }
                break;
            }
            if (message.content || message.type !== "text") {
              history.push(message);
            }
          });
        });
        setMessages(history);
      }
    }, [historyData, isLoadingHistory, setMessages]);
    return {
      historyData,
      isLoadingHistory
    };
  }
  var define_process_env_default = {};
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const stringToByteArray$1 = function(str) {
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
      let c = str.charCodeAt(i);
      if (c < 128) {
        out[p++] = c;
      } else if (c < 2048) {
        out[p++] = c >> 6 | 192;
        out[p++] = c & 63 | 128;
      } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        out[p++] = c >> 18 | 240;
        out[p++] = c >> 12 & 63 | 128;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      } else {
        out[p++] = c >> 12 | 224;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      }
    }
    return out;
  };
  const byteArrayToString = function(bytes) {
    const out = [];
    let pos = 0, c = 0;
    while (pos < bytes.length) {
      const c1 = bytes[pos++];
      if (c1 < 128) {
        out[c++] = String.fromCharCode(c1);
      } else if (c1 > 191 && c1 < 224) {
        const c2 = bytes[pos++];
        out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
      } else if (c1 > 239 && c1 < 365) {
        const c2 = bytes[pos++];
        const c3 = bytes[pos++];
        const c4 = bytes[pos++];
        const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
        out[c++] = String.fromCharCode(55296 + (u >> 10));
        out[c++] = String.fromCharCode(56320 + (u & 1023));
      } else {
        const c2 = bytes[pos++];
        const c3 = bytes[pos++];
        out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
      }
    }
    return out.join("");
  };
  const base64 = {
    /**
     * Maps bytes to characters.
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     */
    ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     */
    get ENCODED_VALS() {
      return this.ENCODED_VALS_BASE + "+/=";
    },
    /**
     * Our websafe alphabet.
     */
    get ENCODED_VALS_WEBSAFE() {
      return this.ENCODED_VALS_BASE + "-_.";
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     */
    HAS_NATIVE_SUPPORT: typeof atob === "function",
    /**
     * Base64-encode an array of bytes.
     *
     * @param input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeByteArray(input, webSafe) {
      if (!Array.isArray(input)) {
        throw Error("encodeByteArray takes an array as a parameter");
      }
      this.init_();
      const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
      const output = [];
      for (let i = 0; i < input.length; i += 3) {
        const byte1 = input[i];
        const haveByte2 = i + 1 < input.length;
        const byte2 = haveByte2 ? input[i + 1] : 0;
        const haveByte3 = i + 2 < input.length;
        const byte3 = haveByte3 ? input[i + 2] : 0;
        const outByte1 = byte1 >> 2;
        const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
        let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
        let outByte4 = byte3 & 63;
        if (!haveByte3) {
          outByte4 = 64;
          if (!haveByte2) {
            outByte3 = 64;
          }
        }
        output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
      }
      return output.join("");
    },
    /**
     * Base64-encode a string.
     *
     * @param input A string to encode.
     * @param webSafe If true, we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeString(input, webSafe) {
      if (this.HAS_NATIVE_SUPPORT && !webSafe) {
        return btoa(input);
      }
      return this.encodeByteArray(stringToByteArray$1(input), webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param input to decode.
     * @param webSafe True if we should use the
     *     alternative alphabet.
     * @return string representing the decoded value.
     */
    decodeString(input, webSafe) {
      if (this.HAS_NATIVE_SUPPORT && !webSafe) {
        return atob(input);
      }
      return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param input Input to decode.
     * @param webSafe True if we should use the web-safe alphabet.
     * @return bytes representing the decoded value.
     */
    decodeStringToByteArray(input, webSafe) {
      this.init_();
      const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
      const output = [];
      for (let i = 0; i < input.length; ) {
        const byte1 = charToByteMap[input.charAt(i++)];
        const haveByte2 = i < input.length;
        const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
        ++i;
        const haveByte3 = i < input.length;
        const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
        ++i;
        const haveByte4 = i < input.length;
        const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
        ++i;
        if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
          throw new DecodeBase64StringError();
        }
        const outByte1 = byte1 << 2 | byte2 >> 4;
        output.push(outByte1);
        if (byte3 !== 64) {
          const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
          output.push(outByte2);
          if (byte4 !== 64) {
            const outByte3 = byte3 << 6 & 192 | byte4;
            output.push(outByte3);
          }
        }
      }
      return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_() {
      if (!this.byteToCharMap_) {
        this.byteToCharMap_ = {};
        this.charToByteMap_ = {};
        this.byteToCharMapWebSafe_ = {};
        this.charToByteMapWebSafe_ = {};
        for (let i = 0; i < this.ENCODED_VALS.length; i++) {
          this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
          this.charToByteMap_[this.byteToCharMap_[i]] = i;
          this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
          this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
          if (i >= this.ENCODED_VALS_BASE.length) {
            this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
            this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
          }
        }
      }
    }
  };
  class DecodeBase64StringError extends Error {
    constructor() {
      super(...arguments);
      this.name = "DecodeBase64StringError";
    }
  }
  const base64Encode = function(str) {
    const utf8Bytes = stringToByteArray$1(str);
    return base64.encodeByteArray(utf8Bytes, true);
  };
  const base64urlEncodeWithoutPadding = function(str) {
    return base64Encode(str).replace(/\./g, "");
  };
  const base64Decode = function(str) {
    try {
      return base64.decodeString(str, true);
    } catch (e) {
      console.error("base64Decode failed: ", e);
    }
    return null;
  };
  /**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function getGlobal() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw new Error("Unable to locate global object.");
  }
  /**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;
  const getDefaultsFromEnvVariable = () => {
    if (typeof process === "undefined" || typeof define_process_env_default === "undefined") {
      return;
    }
    const defaultsJsonString = define_process_env_default.__FIREBASE_DEFAULTS__;
    if (defaultsJsonString) {
      return JSON.parse(defaultsJsonString);
    }
  };
  const getDefaultsFromCookie = () => {
    if (typeof document === "undefined") {
      return;
    }
    let match;
    try {
      match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
    } catch (e) {
      return;
    }
    const decoded = match && base64Decode(match[1]);
    return decoded && JSON.parse(decoded);
  };
  const getDefaults = () => {
    try {
      return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();
    } catch (e) {
      console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
      return;
    }
  };
  const getDefaultEmulatorHost = (productName) => {
    var _a2, _b2;
    return (_b2 = (_a2 = getDefaults()) === null || _a2 === void 0 ? void 0 : _a2.emulatorHosts) === null || _b2 === void 0 ? void 0 : _b2[productName];
  };
  const getDefaultAppConfig = () => {
    var _a2;
    return (_a2 = getDefaults()) === null || _a2 === void 0 ? void 0 : _a2.config;
  };
  const getExperimentalSetting = (name2) => {
    var _a2;
    return (_a2 = getDefaults()) === null || _a2 === void 0 ? void 0 : _a2[`_${name2}`];
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Deferred {
    constructor() {
      this.reject = () => {
      };
      this.resolve = () => {
      };
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
    }
    /**
     * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around
     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
     * and returns a node-style callback which will resolve or reject the Deferred's promise.
     */
    wrapCallback(callback) {
      return (error, value) => {
        if (error) {
          this.reject(error);
        } else {
          this.resolve(value);
        }
        if (typeof callback === "function") {
          this.promise.catch(() => {
          });
          if (callback.length === 1) {
            callback(error);
          } else {
            callback(error, value);
          }
        }
      };
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function getUA() {
    if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
      return navigator["userAgent"];
    } else {
      return "";
    }
  }
  function isMobileCordova() {
    return typeof window !== "undefined" && // @ts-ignore Setting up an broadly applicable index signature for Window
    // just to deal with this case would probably be a bad idea.
    !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
  }
  function isCloudflareWorker() {
    return typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers";
  }
  function isBrowserExtension() {
    const runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
    return typeof runtime === "object" && runtime.id !== void 0;
  }
  function isReactNative() {
    return typeof navigator === "object" && navigator["product"] === "ReactNative";
  }
  function isIE() {
    const ua = getUA();
    return ua.indexOf("MSIE ") >= 0 || ua.indexOf("Trident/") >= 0;
  }
  function isIndexedDBAvailable() {
    try {
      return typeof indexedDB === "object";
    } catch (e) {
      return false;
    }
  }
  function validateIndexedDBOpenable() {
    return new Promise((resolve, reject) => {
      try {
        let preExist = true;
        const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
        const request = self.indexedDB.open(DB_CHECK_NAME);
        request.onsuccess = () => {
          request.result.close();
          if (!preExist) {
            self.indexedDB.deleteDatabase(DB_CHECK_NAME);
          }
          resolve(true);
        };
        request.onupgradeneeded = () => {
          preExist = false;
        };
        request.onerror = () => {
          var _a2;
          reject(((_a2 = request.error) === null || _a2 === void 0 ? void 0 : _a2.message) || "");
        };
      } catch (error) {
        reject(error);
      }
    });
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const ERROR_NAME = "FirebaseError";
  class FirebaseError extends Error {
    constructor(code2, message, customData) {
      super(message);
      this.code = code2;
      this.customData = customData;
      this.name = ERROR_NAME;
      Object.setPrototypeOf(this, FirebaseError.prototype);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ErrorFactory.prototype.create);
      }
    }
  }
  class ErrorFactory {
    constructor(service, serviceName, errors) {
      this.service = service;
      this.serviceName = serviceName;
      this.errors = errors;
    }
    create(code2, ...data) {
      const customData = data[0] || {};
      const fullCode = `${this.service}/${code2}`;
      const template = this.errors[code2];
      const message = template ? replaceTemplate(template, customData) : "Error";
      const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
      const error = new FirebaseError(fullCode, fullMessage, customData);
      return error;
    }
  }
  function replaceTemplate(template, data) {
    return template.replace(PATTERN, (_, key) => {
      const value = data[key];
      return value != null ? String(value) : `<${key}?>`;
    });
  }
  const PATTERN = /\{\$([^}]+)}/g;
  function isEmpty(obj) {
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  }
  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    for (const k of aKeys) {
      if (!bKeys.includes(k)) {
        return false;
      }
      const aProp = a[k];
      const bProp = b[k];
      if (isObject(aProp) && isObject(bProp)) {
        if (!deepEqual(aProp, bProp)) {
          return false;
        }
      } else if (aProp !== bProp) {
        return false;
      }
    }
    for (const k of bKeys) {
      if (!aKeys.includes(k)) {
        return false;
      }
    }
    return true;
  }
  function isObject(thing) {
    return thing !== null && typeof thing === "object";
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function querystring(querystringParams) {
    const params = [];
    for (const [key, value] of Object.entries(querystringParams)) {
      if (Array.isArray(value)) {
        value.forEach((arrayVal) => {
          params.push(encodeURIComponent(key) + "=" + encodeURIComponent(arrayVal));
        });
      } else {
        params.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
      }
    }
    return params.length ? "&" + params.join("&") : "";
  }
  function createSubscribe(executor, onNoObservers) {
    const proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
  }
  class ObserverProxy {
    /**
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    constructor(executor, onNoObservers) {
      this.observers = [];
      this.unsubscribes = [];
      this.observerCount = 0;
      this.task = Promise.resolve();
      this.finalized = false;
      this.onNoObservers = onNoObservers;
      this.task.then(() => {
        executor(this);
      }).catch((e) => {
        this.error(e);
      });
    }
    next(value) {
      this.forEachObserver((observer) => {
        observer.next(value);
      });
    }
    error(error) {
      this.forEachObserver((observer) => {
        observer.error(error);
      });
      this.close(error);
    }
    complete() {
      this.forEachObserver((observer) => {
        observer.complete();
      });
      this.close();
    }
    /**
     * Subscribe function that can be used to add an Observer to the fan-out list.
     *
     * - We require that no event is sent to a subscriber synchronously to their
     *   call to subscribe().
     */
    subscribe(nextOrObserver, error, complete) {
      let observer;
      if (nextOrObserver === void 0 && error === void 0 && complete === void 0) {
        throw new Error("Missing Observer.");
      }
      if (implementsAnyMethods(nextOrObserver, [
        "next",
        "error",
        "complete"
      ])) {
        observer = nextOrObserver;
      } else {
        observer = {
          next: nextOrObserver,
          error,
          complete
        };
      }
      if (observer.next === void 0) {
        observer.next = noop;
      }
      if (observer.error === void 0) {
        observer.error = noop;
      }
      if (observer.complete === void 0) {
        observer.complete = noop;
      }
      const unsub = this.unsubscribeOne.bind(this, this.observers.length);
      if (this.finalized) {
        this.task.then(() => {
          try {
            if (this.finalError) {
              observer.error(this.finalError);
            } else {
              observer.complete();
            }
          } catch (e) {
          }
          return;
        });
      }
      this.observers.push(observer);
      return unsub;
    }
    // Unsubscribe is synchronous - we guarantee that no events are sent to
    // any unsubscribed Observer.
    unsubscribeOne(i) {
      if (this.observers === void 0 || this.observers[i] === void 0) {
        return;
      }
      delete this.observers[i];
      this.observerCount -= 1;
      if (this.observerCount === 0 && this.onNoObservers !== void 0) {
        this.onNoObservers(this);
      }
    }
    forEachObserver(fn) {
      if (this.finalized) {
        return;
      }
      for (let i = 0; i < this.observers.length; i++) {
        this.sendOne(i, fn);
      }
    }
    // Call the Observer via one of it's callback function. We are careful to
    // confirm that the observe has not been unsubscribed since this asynchronous
    // function had been queued.
    sendOne(i, fn) {
      this.task.then(() => {
        if (this.observers !== void 0 && this.observers[i] !== void 0) {
          try {
            fn(this.observers[i]);
          } catch (e) {
            if (typeof console !== "undefined" && console.error) {
              console.error(e);
            }
          }
        }
      });
    }
    close(err) {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      if (err !== void 0) {
        this.finalError = err;
      }
      this.task.then(() => {
        this.observers = void 0;
        this.onNoObservers = void 0;
      });
    }
  }
  function implementsAnyMethods(obj, methods) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    for (const method of methods) {
      if (method in obj && typeof obj[method] === "function") {
        return true;
      }
    }
    return false;
  }
  function noop() {
  }
  /**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function getModularInstance(service) {
    if (service && service._delegate) {
      return service._delegate;
    } else {
      return service;
    }
  }
  class Component {
    /**
     *
     * @param name The public service name, e.g. app, auth, firestore, database
     * @param instanceFactory Service factory responsible for creating the public interface
     * @param type whether the service provided by the component is public or private
     */
    constructor(name2, instanceFactory, type) {
      this.name = name2;
      this.instanceFactory = instanceFactory;
      this.type = type;
      this.multipleInstances = false;
      this.serviceProps = {};
      this.instantiationMode = "LAZY";
      this.onInstanceCreated = null;
    }
    setInstantiationMode(mode) {
      this.instantiationMode = mode;
      return this;
    }
    setMultipleInstances(multipleInstances) {
      this.multipleInstances = multipleInstances;
      return this;
    }
    setServiceProps(props) {
      this.serviceProps = props;
      return this;
    }
    setInstanceCreatedCallback(callback) {
      this.onInstanceCreated = callback;
      return this;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const DEFAULT_ENTRY_NAME$1 = "[DEFAULT]";
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Provider {
    constructor(name2, container) {
      this.name = name2;
      this.container = container;
      this.component = null;
      this.instances = /* @__PURE__ */ new Map();
      this.instancesDeferred = /* @__PURE__ */ new Map();
      this.instancesOptions = /* @__PURE__ */ new Map();
      this.onInitCallbacks = /* @__PURE__ */ new Map();
    }
    /**
     * @param identifier A provider can provide multiple instances of a service
     * if this.component.multipleInstances is true.
     */
    get(identifier) {
      const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
      if (!this.instancesDeferred.has(normalizedIdentifier)) {
        const deferred = new Deferred();
        this.instancesDeferred.set(normalizedIdentifier, deferred);
        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
          try {
            const instance = this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
            if (instance) {
              deferred.resolve(instance);
            }
          } catch (e) {
          }
        }
      }
      return this.instancesDeferred.get(normalizedIdentifier).promise;
    }
    getImmediate(options2) {
      var _a2;
      const normalizedIdentifier = this.normalizeInstanceIdentifier(options2 === null || options2 === void 0 ? void 0 : options2.identifier);
      const optional = (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.optional) !== null && _a2 !== void 0 ? _a2 : false;
      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
        try {
          return this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
        } catch (e) {
          if (optional) {
            return null;
          } else {
            throw e;
          }
        }
      } else {
        if (optional) {
          return null;
        } else {
          throw Error(`Service ${this.name} is not available`);
        }
      }
    }
    getComponent() {
      return this.component;
    }
    setComponent(component) {
      if (component.name !== this.name) {
        throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
      }
      if (this.component) {
        throw Error(`Component for ${this.name} has already been provided`);
      }
      this.component = component;
      if (!this.shouldAutoInitialize()) {
        return;
      }
      if (isComponentEager(component)) {
        try {
          this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME$1 });
        } catch (e) {
        }
      }
      for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
        const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
        try {
          const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          instanceDeferred.resolve(instance);
        } catch (e) {
        }
      }
    }
    clearInstance(identifier = DEFAULT_ENTRY_NAME$1) {
      this.instancesDeferred.delete(identifier);
      this.instancesOptions.delete(identifier);
      this.instances.delete(identifier);
    }
    // app.delete() will call this method on every provider to delete the services
    // TODO: should we mark the provider as deleted?
    async delete() {
      const services = Array.from(this.instances.values());
      await Promise.all([
        ...services.filter((service) => "INTERNAL" in service).map((service) => service.INTERNAL.delete()),
        ...services.filter((service) => "_delete" in service).map((service) => service._delete())
      ]);
    }
    isComponentSet() {
      return this.component != null;
    }
    isInitialized(identifier = DEFAULT_ENTRY_NAME$1) {
      return this.instances.has(identifier);
    }
    getOptions(identifier = DEFAULT_ENTRY_NAME$1) {
      return this.instancesOptions.get(identifier) || {};
    }
    initialize(opts = {}) {
      const { options: options2 = {} } = opts;
      const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
      if (this.isInitialized(normalizedIdentifier)) {
        throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
      }
      if (!this.isComponentSet()) {
        throw Error(`Component ${this.name} has not been registered yet`);
      }
      const instance = this.getOrInitializeService({
        instanceIdentifier: normalizedIdentifier,
        options: options2
      });
      for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
        const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
        if (normalizedIdentifier === normalizedDeferredIdentifier) {
          instanceDeferred.resolve(instance);
        }
      }
      return instance;
    }
    /**
     *
     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
     *
     * @param identifier An optional instance identifier
     * @returns a function to unregister the callback
     */
    onInit(callback, identifier) {
      var _a2;
      const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
      const existingCallbacks = (_a2 = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Set();
      existingCallbacks.add(callback);
      this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
      const existingInstance = this.instances.get(normalizedIdentifier);
      if (existingInstance) {
        callback(existingInstance, normalizedIdentifier);
      }
      return () => {
        existingCallbacks.delete(callback);
      };
    }
    /**
     * Invoke onInit callbacks synchronously
     * @param instance the service instance`
     */
    invokeOnInitCallbacks(instance, identifier) {
      const callbacks = this.onInitCallbacks.get(identifier);
      if (!callbacks) {
        return;
      }
      for (const callback of callbacks) {
        try {
          callback(instance, identifier);
        } catch (_a2) {
        }
      }
    }
    getOrInitializeService({ instanceIdentifier, options: options2 = {} }) {
      let instance = this.instances.get(instanceIdentifier);
      if (!instance && this.component) {
        instance = this.component.instanceFactory(this.container, {
          instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
          options: options2
        });
        this.instances.set(instanceIdentifier, instance);
        this.instancesOptions.set(instanceIdentifier, options2);
        this.invokeOnInitCallbacks(instance, instanceIdentifier);
        if (this.component.onInstanceCreated) {
          try {
            this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
          } catch (_a2) {
          }
        }
      }
      return instance || null;
    }
    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME$1) {
      if (this.component) {
        return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME$1;
      } else {
        return identifier;
      }
    }
    shouldAutoInitialize() {
      return !!this.component && this.component.instantiationMode !== "EXPLICIT";
    }
  }
  function normalizeIdentifierForFactory(identifier) {
    return identifier === DEFAULT_ENTRY_NAME$1 ? void 0 : identifier;
  }
  function isComponentEager(component) {
    return component.instantiationMode === "EAGER";
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ComponentContainer {
    constructor(name2) {
      this.name = name2;
      this.providers = /* @__PURE__ */ new Map();
    }
    /**
     *
     * @param component Component being added
     * @param overwrite When a component with the same name has already been registered,
     * if overwrite is true: overwrite the existing component with the new component and create a new
     * provider with the new component. It can be useful in tests where you want to use different mocks
     * for different tests.
     * if overwrite is false: throw an exception
     */
    addComponent(component) {
      const provider = this.getProvider(component.name);
      if (provider.isComponentSet()) {
        throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
      }
      provider.setComponent(component);
    }
    addOrOverwriteComponent(component) {
      const provider = this.getProvider(component.name);
      if (provider.isComponentSet()) {
        this.providers.delete(component.name);
      }
      this.addComponent(component);
    }
    /**
     * getProvider provides a type safe interface where it can only be called with a field name
     * present in NameServiceMapping interface.
     *
     * Firebase SDKs providing services should extend NameServiceMapping interface to register
     * themselves.
     */
    getProvider(name2) {
      if (this.providers.has(name2)) {
        return this.providers.get(name2);
      }
      const provider = new Provider(name2, this);
      this.providers.set(name2, provider);
      return provider;
    }
    getProviders() {
      return Array.from(this.providers.values());
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
    LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
    LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
    LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
    LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
    LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
  })(LogLevel || (LogLevel = {}));
  const levelStringToEnum = {
    "debug": LogLevel.DEBUG,
    "verbose": LogLevel.VERBOSE,
    "info": LogLevel.INFO,
    "warn": LogLevel.WARN,
    "error": LogLevel.ERROR,
    "silent": LogLevel.SILENT
  };
  const defaultLogLevel = LogLevel.INFO;
  const ConsoleMethod = {
    [LogLevel.DEBUG]: "log",
    [LogLevel.VERBOSE]: "log",
    [LogLevel.INFO]: "info",
    [LogLevel.WARN]: "warn",
    [LogLevel.ERROR]: "error"
  };
  const defaultLogHandler = (instance, logType, ...args) => {
    if (logType < instance.logLevel) {
      return;
    }
    const now2 = (/* @__PURE__ */ new Date()).toISOString();
    const method = ConsoleMethod[logType];
    if (method) {
      console[method](`[${now2}]  ${instance.name}:`, ...args);
    } else {
      throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
    }
  };
  class Logger {
    /**
     * Gives you an instance of a Logger to capture messages according to
     * Firebase's logging scheme.
     *
     * @param name The name that the logs will be associated with
     */
    constructor(name2) {
      this.name = name2;
      this._logLevel = defaultLogLevel;
      this._logHandler = defaultLogHandler;
      this._userLogHandler = null;
    }
    get logLevel() {
      return this._logLevel;
    }
    set logLevel(val) {
      if (!(val in LogLevel)) {
        throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
      }
      this._logLevel = val;
    }
    // Workaround for setter/getter having to be the same type.
    setLogLevel(val) {
      this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
    }
    get logHandler() {
      return this._logHandler;
    }
    set logHandler(val) {
      if (typeof val !== "function") {
        throw new TypeError("Value assigned to `logHandler` must be a function");
      }
      this._logHandler = val;
    }
    get userLogHandler() {
      return this._userLogHandler;
    }
    set userLogHandler(val) {
      this._userLogHandler = val;
    }
    /**
     * The functions below are all based on the `console` interface
     */
    debug(...args) {
      this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
      this._logHandler(this, LogLevel.DEBUG, ...args);
    }
    log(...args) {
      this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
      this._logHandler(this, LogLevel.VERBOSE, ...args);
    }
    info(...args) {
      this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
      this._logHandler(this, LogLevel.INFO, ...args);
    }
    warn(...args) {
      this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
      this._logHandler(this, LogLevel.WARN, ...args);
    }
    error(...args) {
      this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
      this._logHandler(this, LogLevel.ERROR, ...args);
    }
  }
  const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
  let idbProxyableTypes;
  let cursorAdvanceMethods;
  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
      IDBDatabase,
      IDBObjectStore,
      IDBIndex,
      IDBCursor,
      IDBTransaction
    ]);
  }
  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ]);
  }
  const cursorRequestMap = /* @__PURE__ */ new WeakMap();
  const transactionDoneMap = /* @__PURE__ */ new WeakMap();
  const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
  const transformCache = /* @__PURE__ */ new WeakMap();
  const reverseTransformCache = /* @__PURE__ */ new WeakMap();
  function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
      const unlisten = () => {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      };
      const success = () => {
        resolve(wrap(request.result));
        unlisten();
      };
      const error = () => {
        reject(request.error);
        unlisten();
      };
      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    promise.then((value) => {
      if (value instanceof IDBCursor) {
        cursorRequestMap.set(value, request);
      }
    }).catch(() => {
    });
    reverseTransformCache.set(promise, request);
    return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx))
      return;
    const done = new Promise((resolve, reject) => {
      const unlisten = () => {
        tx.removeEventListener("complete", complete);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      };
      const complete = () => {
        resolve();
        unlisten();
      };
      const error = () => {
        reject(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      };
      tx.addEventListener("complete", complete);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }
  let idbProxyTraps = {
    get(target, prop, receiver) {
      if (target instanceof IDBTransaction) {
        if (prop === "done")
          return transactionDoneMap.get(target);
        if (prop === "objectStoreNames") {
          return target.objectStoreNames || transactionStoreNamesMap.get(target);
        }
        if (prop === "store") {
          return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
        }
      }
      return wrap(target[prop]);
    },
    set(target, prop, value) {
      target[prop] = value;
      return true;
    },
    has(target, prop) {
      if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
        return true;
      }
      return prop in target;
    }
  };
  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
    if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
      return function(storeNames, ...args) {
        const tx = func.call(unwrap(this), storeNames, ...args);
        transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
        return wrap(tx);
      };
    }
    if (getCursorAdvanceMethods().includes(func)) {
      return function(...args) {
        func.apply(unwrap(this), args);
        return wrap(cursorRequestMap.get(this));
      };
    }
    return function(...args) {
      return wrap(func.apply(unwrap(this), args));
    };
  }
  function transformCachableValue(value) {
    if (typeof value === "function")
      return wrapFunction(value);
    if (value instanceof IDBTransaction)
      cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
      return new Proxy(value, idbProxyTraps);
    return value;
  }
  function wrap(value) {
    if (value instanceof IDBRequest)
      return promisifyRequest(value);
    if (transformCache.has(value))
      return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }
    return newValue;
  }
  const unwrap = (value) => reverseTransformCache.get(value);
  function openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name2, version2);
    const openPromise = wrap(request);
    if (upgrade) {
      request.addEventListener("upgradeneeded", (event) => {
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
      });
    }
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion,
        event.newVersion,
        event
      ));
    }
    openPromise.then((db) => {
      if (terminated)
        db.addEventListener("close", () => terminated());
      if (blocking) {
        db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
      }
    }).catch(() => {
    });
    return openPromise;
  }
  const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
  const writeMethods = ["put", "add", "delete", "clear"];
  const cachedMethods = /* @__PURE__ */ new Map();
  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }
    if (cachedMethods.get(prop))
      return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
    ) {
      return;
    }
    const method = async function(storeName, ...args) {
      const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
      let target2 = tx.store;
      if (useIndex)
        target2 = target2.index(args.shift());
      return (await Promise.all([
        target2[targetFuncName](...args),
        isWrite && tx.done
      ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
  }
  replaceTraps((oldTraps) => ({
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
  }));
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class PlatformLoggerServiceImpl {
    constructor(container) {
      this.container = container;
    }
    // In initial implementation, this will be called by installations on
    // auth token refresh, and installations will send this string.
    getPlatformInfoString() {
      const providers = this.container.getProviders();
      return providers.map((provider) => {
        if (isVersionServiceProvider(provider)) {
          const service = provider.getImmediate();
          return `${service.library}/${service.version}`;
        } else {
          return null;
        }
      }).filter((logString) => logString).join(" ");
    }
  }
  function isVersionServiceProvider(provider) {
    const component = provider.getComponent();
    return (component === null || component === void 0 ? void 0 : component.type) === "VERSION";
  }
  const name$q = "@firebase/app";
  const version$1$1 = "0.10.13";
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const logger = new Logger("@firebase/app");
  const name$p = "@firebase/app-compat";
  const name$o = "@firebase/analytics-compat";
  const name$n = "@firebase/analytics";
  const name$m = "@firebase/app-check-compat";
  const name$l = "@firebase/app-check";
  const name$k = "@firebase/auth";
  const name$j = "@firebase/auth-compat";
  const name$i = "@firebase/database";
  const name$h = "@firebase/data-connect";
  const name$g = "@firebase/database-compat";
  const name$f = "@firebase/functions";
  const name$e = "@firebase/functions-compat";
  const name$d = "@firebase/installations";
  const name$c = "@firebase/installations-compat";
  const name$b = "@firebase/messaging";
  const name$a = "@firebase/messaging-compat";
  const name$9 = "@firebase/performance";
  const name$8 = "@firebase/performance-compat";
  const name$7 = "@firebase/remote-config";
  const name$6 = "@firebase/remote-config-compat";
  const name$5 = "@firebase/storage";
  const name$4 = "@firebase/storage-compat";
  const name$3 = "@firebase/firestore";
  const name$2 = "@firebase/vertexai-preview";
  const name$1$1 = "@firebase/firestore-compat";
  const name$r = "firebase";
  const version$2 = "10.14.1";
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const DEFAULT_ENTRY_NAME = "[DEFAULT]";
  const PLATFORM_LOG_STRING = {
    [name$q]: "fire-core",
    [name$p]: "fire-core-compat",
    [name$n]: "fire-analytics",
    [name$o]: "fire-analytics-compat",
    [name$l]: "fire-app-check",
    [name$m]: "fire-app-check-compat",
    [name$k]: "fire-auth",
    [name$j]: "fire-auth-compat",
    [name$i]: "fire-rtdb",
    [name$h]: "fire-data-connect",
    [name$g]: "fire-rtdb-compat",
    [name$f]: "fire-fn",
    [name$e]: "fire-fn-compat",
    [name$d]: "fire-iid",
    [name$c]: "fire-iid-compat",
    [name$b]: "fire-fcm",
    [name$a]: "fire-fcm-compat",
    [name$9]: "fire-perf",
    [name$8]: "fire-perf-compat",
    [name$7]: "fire-rc",
    [name$6]: "fire-rc-compat",
    [name$5]: "fire-gcs",
    [name$4]: "fire-gcs-compat",
    [name$3]: "fire-fst",
    [name$1$1]: "fire-fst-compat",
    [name$2]: "fire-vertex",
    "fire-js": "fire-js",
    [name$r]: "fire-js-all"
  };
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const _apps = /* @__PURE__ */ new Map();
  const _serverApps = /* @__PURE__ */ new Map();
  const _components = /* @__PURE__ */ new Map();
  function _addComponent(app, component) {
    try {
      app.container.addComponent(component);
    } catch (e) {
      logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);
    }
  }
  function _registerComponent(component) {
    const componentName = component.name;
    if (_components.has(componentName)) {
      logger.debug(`There were multiple attempts to register component ${componentName}.`);
      return false;
    }
    _components.set(componentName, component);
    for (const app of _apps.values()) {
      _addComponent(app, component);
    }
    for (const serverApp of _serverApps.values()) {
      _addComponent(serverApp, component);
    }
    return true;
  }
  function _getProvider(app, name2) {
    const heartbeatController = app.container.getProvider("heartbeat").getImmediate({ optional: true });
    if (heartbeatController) {
      void heartbeatController.triggerHeartbeat();
    }
    return app.container.getProvider(name2);
  }
  function _isFirebaseServerApp(obj) {
    return obj.settings !== void 0;
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const ERRORS = {
    [
      "no-app"
      /* AppError.NO_APP */
    ]: "No Firebase App '{$appName}' has been created - call initializeApp() first",
    [
      "bad-app-name"
      /* AppError.BAD_APP_NAME */
    ]: "Illegal App name: '{$appName}'",
    [
      "duplicate-app"
      /* AppError.DUPLICATE_APP */
    ]: "Firebase App named '{$appName}' already exists with different options or config",
    [
      "app-deleted"
      /* AppError.APP_DELETED */
    ]: "Firebase App named '{$appName}' already deleted",
    [
      "server-app-deleted"
      /* AppError.SERVER_APP_DELETED */
    ]: "Firebase Server App has been deleted",
    [
      "no-options"
      /* AppError.NO_OPTIONS */
    ]: "Need to provide options, when not being deployed to hosting via source.",
    [
      "invalid-app-argument"
      /* AppError.INVALID_APP_ARGUMENT */
    ]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
    [
      "invalid-log-argument"
      /* AppError.INVALID_LOG_ARGUMENT */
    ]: "First argument to `onLog` must be null or a function.",
    [
      "idb-open"
      /* AppError.IDB_OPEN */
    ]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
    [
      "idb-get"
      /* AppError.IDB_GET */
    ]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
    [
      "idb-set"
      /* AppError.IDB_WRITE */
    ]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
    [
      "idb-delete"
      /* AppError.IDB_DELETE */
    ]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
    [
      "finalization-registry-not-supported"
      /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */
    ]: "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
    [
      "invalid-server-app-environment"
      /* AppError.INVALID_SERVER_APP_ENVIRONMENT */
    ]: "FirebaseServerApp is not for use in browser environments."
  };
  const ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class FirebaseAppImpl {
    constructor(options2, config, container) {
      this._isDeleted = false;
      this._options = Object.assign({}, options2);
      this._config = Object.assign({}, config);
      this._name = config.name;
      this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;
      this._container = container;
      this.container.addComponent(new Component(
        "app",
        () => this,
        "PUBLIC"
        /* ComponentType.PUBLIC */
      ));
    }
    get automaticDataCollectionEnabled() {
      this.checkDestroyed();
      return this._automaticDataCollectionEnabled;
    }
    set automaticDataCollectionEnabled(val) {
      this.checkDestroyed();
      this._automaticDataCollectionEnabled = val;
    }
    get name() {
      this.checkDestroyed();
      return this._name;
    }
    get options() {
      this.checkDestroyed();
      return this._options;
    }
    get config() {
      this.checkDestroyed();
      return this._config;
    }
    get container() {
      return this._container;
    }
    get isDeleted() {
      return this._isDeleted;
    }
    set isDeleted(val) {
      this._isDeleted = val;
    }
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    checkDestroyed() {
      if (this.isDeleted) {
        throw ERROR_FACTORY.create("app-deleted", { appName: this._name });
      }
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const SDK_VERSION = version$2;
  function initializeApp(_options, rawConfig = {}) {
    let options2 = _options;
    if (typeof rawConfig !== "object") {
      const name3 = rawConfig;
      rawConfig = { name: name3 };
    }
    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);
    const name2 = config.name;
    if (typeof name2 !== "string" || !name2) {
      throw ERROR_FACTORY.create("bad-app-name", {
        appName: String(name2)
      });
    }
    options2 || (options2 = getDefaultAppConfig());
    if (!options2) {
      throw ERROR_FACTORY.create(
        "no-options"
        /* AppError.NO_OPTIONS */
      );
    }
    const existingApp = _apps.get(name2);
    if (existingApp) {
      if (deepEqual(options2, existingApp.options) && deepEqual(config, existingApp.config)) {
        return existingApp;
      } else {
        throw ERROR_FACTORY.create("duplicate-app", { appName: name2 });
      }
    }
    const container = new ComponentContainer(name2);
    for (const component of _components.values()) {
      container.addComponent(component);
    }
    const newApp = new FirebaseAppImpl(options2, config, container);
    _apps.set(name2, newApp);
    return newApp;
  }
  function getApp$1(name2 = DEFAULT_ENTRY_NAME) {
    const app = _apps.get(name2);
    if (!app && name2 === DEFAULT_ENTRY_NAME && getDefaultAppConfig()) {
      return initializeApp();
    }
    if (!app) {
      throw ERROR_FACTORY.create("no-app", { appName: name2 });
    }
    return app;
  }
  function registerVersion(libraryKeyOrName, version2, variant) {
    var _a2;
    let library = (_a2 = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a2 !== void 0 ? _a2 : libraryKeyOrName;
    if (variant) {
      library += `-${variant}`;
    }
    const libraryMismatch = library.match(/\s|\//);
    const versionMismatch = version2.match(/\s|\//);
    if (libraryMismatch || versionMismatch) {
      const warning = [
        `Unable to register library "${library}" with version "${version2}":`
      ];
      if (libraryMismatch) {
        warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
      }
      if (libraryMismatch && versionMismatch) {
        warning.push("and");
      }
      if (versionMismatch) {
        warning.push(`version name "${version2}" contains illegal characters (whitespace or "/")`);
      }
      logger.warn(warning.join(" "));
      return;
    }
    _registerComponent(new Component(
      `${library}-version`,
      () => ({ library, version: version2 }),
      "VERSION"
      /* ComponentType.VERSION */
    ));
  }
  /**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const DB_NAME$1 = "firebase-heartbeat-database";
  const DB_VERSION$1 = 1;
  const STORE_NAME = "firebase-heartbeat-store";
  let dbPromise = null;
  function getDbPromise() {
    if (!dbPromise) {
      dbPromise = openDB(DB_NAME$1, DB_VERSION$1, {
        upgrade: (db, oldVersion) => {
          switch (oldVersion) {
            case 0:
              try {
                db.createObjectStore(STORE_NAME);
              } catch (e) {
                console.warn(e);
              }
          }
        }
      }).catch((e) => {
        throw ERROR_FACTORY.create("idb-open", {
          originalErrorMessage: e.message
        });
      });
    }
    return dbPromise;
  }
  async function readHeartbeatsFromIndexedDB(app) {
    try {
      const db = await getDbPromise();
      const tx = db.transaction(STORE_NAME);
      const result = await tx.objectStore(STORE_NAME).get(computeKey(app));
      await tx.done;
      return result;
    } catch (e) {
      if (e instanceof FirebaseError) {
        logger.warn(e.message);
      } else {
        const idbGetError = ERROR_FACTORY.create("idb-get", {
          originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
        });
        logger.warn(idbGetError.message);
      }
    }
  }
  async function writeHeartbeatsToIndexedDB(app, heartbeatObject) {
    try {
      const db = await getDbPromise();
      const tx = db.transaction(STORE_NAME, "readwrite");
      const objectStore = tx.objectStore(STORE_NAME);
      await objectStore.put(heartbeatObject, computeKey(app));
      await tx.done;
    } catch (e) {
      if (e instanceof FirebaseError) {
        logger.warn(e.message);
      } else {
        const idbGetError = ERROR_FACTORY.create("idb-set", {
          originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
        });
        logger.warn(idbGetError.message);
      }
    }
  }
  function computeKey(app) {
    return `${app.name}!${app.options.appId}`;
  }
  /**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const MAX_HEADER_BYTES = 1024;
  const STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1e3;
  class HeartbeatServiceImpl {
    constructor(container) {
      this.container = container;
      this._heartbeatsCache = null;
      const app = this.container.getProvider("app").getImmediate();
      this._storage = new HeartbeatStorageImpl(app);
      this._heartbeatsCachePromise = this._storage.read().then((result) => {
        this._heartbeatsCache = result;
        return result;
      });
    }
    /**
     * Called to report a heartbeat. The function will generate
     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
     * to IndexedDB.
     * Note that we only store one heartbeat per day. So if a heartbeat for today is
     * already logged, subsequent calls to this function in the same day will be ignored.
     */
    async triggerHeartbeat() {
      var _a2, _b2;
      try {
        const platformLogger = this.container.getProvider("platform-logger").getImmediate();
        const agent = platformLogger.getPlatformInfoString();
        const date = getUTCDateString();
        if (((_a2 = this._heartbeatsCache) === null || _a2 === void 0 ? void 0 : _a2.heartbeats) == null) {
          this._heartbeatsCache = await this._heartbeatsCachePromise;
          if (((_b2 = this._heartbeatsCache) === null || _b2 === void 0 ? void 0 : _b2.heartbeats) == null) {
            return;
          }
        }
        if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat) => singleDateHeartbeat.date === date)) {
          return;
        } else {
          this._heartbeatsCache.heartbeats.push({ date, agent });
        }
        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat) => {
          const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
          const now2 = Date.now();
          return now2 - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
        });
        return this._storage.overwrite(this._heartbeatsCache);
      } catch (e) {
        logger.warn(e);
      }
    }
    /**
     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
     * It also clears all heartbeats from memory as well as in IndexedDB.
     *
     * NOTE: Consuming product SDKs should not send the header if this method
     * returns an empty string.
     */
    async getHeartbeatsHeader() {
      var _a2;
      try {
        if (this._heartbeatsCache === null) {
          await this._heartbeatsCachePromise;
        }
        if (((_a2 = this._heartbeatsCache) === null || _a2 === void 0 ? void 0 : _a2.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) {
          return "";
        }
        const date = getUTCDateString();
        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
        const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
        this._heartbeatsCache.lastSentHeartbeatDate = date;
        if (unsentEntries.length > 0) {
          this._heartbeatsCache.heartbeats = unsentEntries;
          await this._storage.overwrite(this._heartbeatsCache);
        } else {
          this._heartbeatsCache.heartbeats = [];
          void this._storage.overwrite(this._heartbeatsCache);
        }
        return headerString;
      } catch (e) {
        logger.warn(e);
        return "";
      }
    }
  }
  function getUTCDateString() {
    const today = /* @__PURE__ */ new Date();
    return today.toISOString().substring(0, 10);
  }
  function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
    const heartbeatsToSend = [];
    let unsentEntries = heartbeatsCache.slice();
    for (const singleDateHeartbeat of heartbeatsCache) {
      const heartbeatEntry = heartbeatsToSend.find((hb) => hb.agent === singleDateHeartbeat.agent);
      if (!heartbeatEntry) {
        heartbeatsToSend.push({
          agent: singleDateHeartbeat.agent,
          dates: [singleDateHeartbeat.date]
        });
        if (countBytes(heartbeatsToSend) > maxSize) {
          heartbeatsToSend.pop();
          break;
        }
      } else {
        heartbeatEntry.dates.push(singleDateHeartbeat.date);
        if (countBytes(heartbeatsToSend) > maxSize) {
          heartbeatEntry.dates.pop();
          break;
        }
      }
      unsentEntries = unsentEntries.slice(1);
    }
    return {
      heartbeatsToSend,
      unsentEntries
    };
  }
  class HeartbeatStorageImpl {
    constructor(app) {
      this.app = app;
      this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
    }
    async runIndexedDBEnvironmentCheck() {
      if (!isIndexedDBAvailable()) {
        return false;
      } else {
        return validateIndexedDBOpenable().then(() => true).catch(() => false);
      }
    }
    /**
     * Read all heartbeats.
     */
    async read() {
      const canUseIndexedDB = await this._canUseIndexedDBPromise;
      if (!canUseIndexedDB) {
        return { heartbeats: [] };
      } else {
        const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
        if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {
          return idbHeartbeatObject;
        } else {
          return { heartbeats: [] };
        }
      }
    }
    // overwrite the storage with the provided heartbeats
    async overwrite(heartbeatsObject) {
      var _a2;
      const canUseIndexedDB = await this._canUseIndexedDBPromise;
      if (!canUseIndexedDB) {
        return;
      } else {
        const existingHeartbeatsObject = await this.read();
        return writeHeartbeatsToIndexedDB(this.app, {
          lastSentHeartbeatDate: (_a2 = heartbeatsObject.lastSentHeartbeatDate) !== null && _a2 !== void 0 ? _a2 : existingHeartbeatsObject.lastSentHeartbeatDate,
          heartbeats: heartbeatsObject.heartbeats
        });
      }
    }
    // add heartbeats
    async add(heartbeatsObject) {
      var _a2;
      const canUseIndexedDB = await this._canUseIndexedDBPromise;
      if (!canUseIndexedDB) {
        return;
      } else {
        const existingHeartbeatsObject = await this.read();
        return writeHeartbeatsToIndexedDB(this.app, {
          lastSentHeartbeatDate: (_a2 = heartbeatsObject.lastSentHeartbeatDate) !== null && _a2 !== void 0 ? _a2 : existingHeartbeatsObject.lastSentHeartbeatDate,
          heartbeats: [
            ...existingHeartbeatsObject.heartbeats,
            ...heartbeatsObject.heartbeats
          ]
        });
      }
    }
  }
  function countBytes(heartbeatsCache) {
    return base64urlEncodeWithoutPadding(
      // heartbeatsCache wrapper properties
      JSON.stringify({ version: 2, heartbeats: heartbeatsCache })
    ).length;
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function registerCoreComponents(variant) {
    _registerComponent(new Component(
      "platform-logger",
      (container) => new PlatformLoggerServiceImpl(container),
      "PRIVATE"
      /* ComponentType.PRIVATE */
    ));
    _registerComponent(new Component(
      "heartbeat",
      (container) => new HeartbeatServiceImpl(container),
      "PRIVATE"
      /* ComponentType.PRIVATE */
    ));
    registerVersion(name$q, version$1$1, variant);
    registerVersion(name$q, version$1$1, "esm2017");
    registerVersion("fire-js", "");
  }
  registerCoreComponents("");
  var name$1 = "firebase";
  var version$1 = "10.14.1";
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  registerVersion(name$1, version$1, "app");
  function _prodErrorMap() {
    return {
      [
        "dependent-sdk-initialized-before-auth"
        /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
      ]: "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
    };
  }
  const prodErrorMap = _prodErrorMap;
  const _DEFAULT_AUTH_ERROR_FACTORY = new ErrorFactory("auth", "Firebase", _prodErrorMap());
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const logClient = new Logger("@firebase/auth");
  function _logWarn(msg, ...args) {
    if (logClient.logLevel <= LogLevel.WARN) {
      logClient.warn(`Auth (${SDK_VERSION}): ${msg}`, ...args);
    }
  }
  function _logError(msg, ...args) {
    if (logClient.logLevel <= LogLevel.ERROR) {
      logClient.error(`Auth (${SDK_VERSION}): ${msg}`, ...args);
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _fail(authOrCode, ...rest) {
    throw createErrorInternal(authOrCode, ...rest);
  }
  function _createError(authOrCode, ...rest) {
    return createErrorInternal(authOrCode, ...rest);
  }
  function _errorWithCustomMessage(auth, code2, message) {
    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code2]: message });
    const factory = new ErrorFactory("auth", "Firebase", errorMap);
    return factory.create(code2, {
      appName: auth.name
    });
  }
  function _serverAppCurrentUserOperationNotSupportedError(auth) {
    return _errorWithCustomMessage(auth, "operation-not-supported-in-this-environment", "Operations that alter the current user are not supported in conjunction with FirebaseServerApp");
  }
  function createErrorInternal(authOrCode, ...rest) {
    if (typeof authOrCode !== "string") {
      const code2 = rest[0];
      const fullParams = [...rest.slice(1)];
      if (fullParams[0]) {
        fullParams[0].appName = authOrCode.name;
      }
      return authOrCode._errorFactory.create(code2, ...fullParams);
    }
    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);
  }
  function _assert(assertion, authOrCode, ...rest) {
    if (!assertion) {
      throw createErrorInternal(authOrCode, ...rest);
    }
  }
  function debugFail(failure) {
    const message = `INTERNAL ASSERTION FAILED: ` + failure;
    _logError(message);
    throw new Error(message);
  }
  function debugAssert(assertion, message) {
    if (!assertion) {
      debugFail(message);
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _getCurrentUrl() {
    var _a2;
    return typeof self !== "undefined" && ((_a2 = self.location) === null || _a2 === void 0 ? void 0 : _a2.href) || "";
  }
  function _isHttpOrHttps() {
    return _getCurrentScheme() === "http:" || _getCurrentScheme() === "https:";
  }
  function _getCurrentScheme() {
    var _a2;
    return typeof self !== "undefined" && ((_a2 = self.location) === null || _a2 === void 0 ? void 0 : _a2.protocol) || null;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _isOnline() {
    if (typeof navigator !== "undefined" && navigator && "onLine" in navigator && typeof navigator.onLine === "boolean" && // Apply only for traditional web apps and Chrome extensions.
    // This is especially true for Cordova apps which have unreliable
    // navigator.onLine behavior unless cordova-plugin-network-information is
    // installed which overwrites the native navigator.onLine value and
    // defines navigator.connection.
    (_isHttpOrHttps() || isBrowserExtension() || "connection" in navigator)) {
      return navigator.onLine;
    }
    return true;
  }
  function _getUserLanguage() {
    if (typeof navigator === "undefined") {
      return null;
    }
    const navigatorLanguage = navigator;
    return (
      // Most reliable, but only supported in Chrome/Firefox.
      navigatorLanguage.languages && navigatorLanguage.languages[0] || // Supported in most browsers, but returns the language of the browser
      // UI, not the language set in browser settings.
      navigatorLanguage.language || // Couldn't determine language.
      null
    );
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Delay {
    constructor(shortDelay, longDelay) {
      this.shortDelay = shortDelay;
      this.longDelay = longDelay;
      debugAssert(longDelay > shortDelay, "Short delay should be less than long delay!");
      this.isMobile = isMobileCordova() || isReactNative();
    }
    get() {
      if (!_isOnline()) {
        return Math.min(5e3, this.shortDelay);
      }
      return this.isMobile ? this.longDelay : this.shortDelay;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _emulatorUrl(config, path) {
    debugAssert(config.emulator, "Emulator should always be set here");
    const { url } = config.emulator;
    if (!path) {
      return url;
    }
    return `${url}${path.startsWith("/") ? path.slice(1) : path}`;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class FetchProvider {
    static initialize(fetchImpl, headersImpl, responseImpl) {
      this.fetchImpl = fetchImpl;
      if (headersImpl) {
        this.headersImpl = headersImpl;
      }
      if (responseImpl) {
        this.responseImpl = responseImpl;
      }
    }
    static fetch() {
      if (this.fetchImpl) {
        return this.fetchImpl;
      }
      if (typeof self !== "undefined" && "fetch" in self) {
        return self.fetch;
      }
      if (typeof globalThis !== "undefined" && globalThis.fetch) {
        return globalThis.fetch;
      }
      if (typeof fetch !== "undefined") {
        return fetch;
      }
      debugFail("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
    }
    static headers() {
      if (this.headersImpl) {
        return this.headersImpl;
      }
      if (typeof self !== "undefined" && "Headers" in self) {
        return self.Headers;
      }
      if (typeof globalThis !== "undefined" && globalThis.Headers) {
        return globalThis.Headers;
      }
      if (typeof Headers !== "undefined") {
        return Headers;
      }
      debugFail("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
    }
    static response() {
      if (this.responseImpl) {
        return this.responseImpl;
      }
      if (typeof self !== "undefined" && "Response" in self) {
        return self.Response;
      }
      if (typeof globalThis !== "undefined" && globalThis.Response) {
        return globalThis.Response;
      }
      if (typeof Response !== "undefined") {
        return Response;
      }
      debugFail("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const SERVER_ERROR_MAP = {
    // Custom token errors.
    [
      "CREDENTIAL_MISMATCH"
      /* ServerError.CREDENTIAL_MISMATCH */
    ]: "custom-token-mismatch",
    // This can only happen if the SDK sends a bad request.
    [
      "MISSING_CUSTOM_TOKEN"
      /* ServerError.MISSING_CUSTOM_TOKEN */
    ]: "internal-error",
    // Create Auth URI errors.
    [
      "INVALID_IDENTIFIER"
      /* ServerError.INVALID_IDENTIFIER */
    ]: "invalid-email",
    // This can only happen if the SDK sends a bad request.
    [
      "MISSING_CONTINUE_URI"
      /* ServerError.MISSING_CONTINUE_URI */
    ]: "internal-error",
    // Sign in with email and password errors (some apply to sign up too).
    [
      "INVALID_PASSWORD"
      /* ServerError.INVALID_PASSWORD */
    ]: "wrong-password",
    // This can only happen if the SDK sends a bad request.
    [
      "MISSING_PASSWORD"
      /* ServerError.MISSING_PASSWORD */
    ]: "missing-password",
    // Thrown if Email Enumeration Protection is enabled in the project and the email or password is
    // invalid.
    [
      "INVALID_LOGIN_CREDENTIALS"
      /* ServerError.INVALID_LOGIN_CREDENTIALS */
    ]: "invalid-credential",
    // Sign up with email and password errors.
    [
      "EMAIL_EXISTS"
      /* ServerError.EMAIL_EXISTS */
    ]: "email-already-in-use",
    [
      "PASSWORD_LOGIN_DISABLED"
      /* ServerError.PASSWORD_LOGIN_DISABLED */
    ]: "operation-not-allowed",
    // Verify assertion for sign in with credential errors:
    [
      "INVALID_IDP_RESPONSE"
      /* ServerError.INVALID_IDP_RESPONSE */
    ]: "invalid-credential",
    [
      "INVALID_PENDING_TOKEN"
      /* ServerError.INVALID_PENDING_TOKEN */
    ]: "invalid-credential",
    [
      "FEDERATED_USER_ID_ALREADY_LINKED"
      /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */
    ]: "credential-already-in-use",
    // This can only happen if the SDK sends a bad request.
    [
      "MISSING_REQ_TYPE"
      /* ServerError.MISSING_REQ_TYPE */
    ]: "internal-error",
    // Send Password reset email errors:
    [
      "EMAIL_NOT_FOUND"
      /* ServerError.EMAIL_NOT_FOUND */
    ]: "user-not-found",
    [
      "RESET_PASSWORD_EXCEED_LIMIT"
      /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */
    ]: "too-many-requests",
    [
      "EXPIRED_OOB_CODE"
      /* ServerError.EXPIRED_OOB_CODE */
    ]: "expired-action-code",
    [
      "INVALID_OOB_CODE"
      /* ServerError.INVALID_OOB_CODE */
    ]: "invalid-action-code",
    // This can only happen if the SDK sends a bad request.
    [
      "MISSING_OOB_CODE"
      /* ServerError.MISSING_OOB_CODE */
    ]: "internal-error",
    // Operations that require ID token in request:
    [
      "CREDENTIAL_TOO_OLD_LOGIN_AGAIN"
      /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */
    ]: "requires-recent-login",
    [
      "INVALID_ID_TOKEN"
      /* ServerError.INVALID_ID_TOKEN */
    ]: "invalid-user-token",
    [
      "TOKEN_EXPIRED"
      /* ServerError.TOKEN_EXPIRED */
    ]: "user-token-expired",
    [
      "USER_NOT_FOUND"
      /* ServerError.USER_NOT_FOUND */
    ]: "user-token-expired",
    // Other errors.
    [
      "TOO_MANY_ATTEMPTS_TRY_LATER"
      /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */
    ]: "too-many-requests",
    [
      "PASSWORD_DOES_NOT_MEET_REQUIREMENTS"
      /* ServerError.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */
    ]: "password-does-not-meet-requirements",
    // Phone Auth related errors.
    [
      "INVALID_CODE"
      /* ServerError.INVALID_CODE */
    ]: "invalid-verification-code",
    [
      "INVALID_SESSION_INFO"
      /* ServerError.INVALID_SESSION_INFO */
    ]: "invalid-verification-id",
    [
      "INVALID_TEMPORARY_PROOF"
      /* ServerError.INVALID_TEMPORARY_PROOF */
    ]: "invalid-credential",
    [
      "MISSING_SESSION_INFO"
      /* ServerError.MISSING_SESSION_INFO */
    ]: "missing-verification-id",
    [
      "SESSION_EXPIRED"
      /* ServerError.SESSION_EXPIRED */
    ]: "code-expired",
    // Other action code errors when additional settings passed.
    // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.
    // This is OK as this error will be caught by client side validation.
    [
      "MISSING_ANDROID_PACKAGE_NAME"
      /* ServerError.MISSING_ANDROID_PACKAGE_NAME */
    ]: "missing-android-pkg-name",
    [
      "UNAUTHORIZED_DOMAIN"
      /* ServerError.UNAUTHORIZED_DOMAIN */
    ]: "unauthorized-continue-uri",
    // getProjectConfig errors when clientId is passed.
    [
      "INVALID_OAUTH_CLIENT_ID"
      /* ServerError.INVALID_OAUTH_CLIENT_ID */
    ]: "invalid-oauth-client-id",
    // User actions (sign-up or deletion) disabled errors.
    [
      "ADMIN_ONLY_OPERATION"
      /* ServerError.ADMIN_ONLY_OPERATION */
    ]: "admin-restricted-operation",
    // Multi factor related errors.
    [
      "INVALID_MFA_PENDING_CREDENTIAL"
      /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */
    ]: "invalid-multi-factor-session",
    [
      "MFA_ENROLLMENT_NOT_FOUND"
      /* ServerError.MFA_ENROLLMENT_NOT_FOUND */
    ]: "multi-factor-info-not-found",
    [
      "MISSING_MFA_ENROLLMENT_ID"
      /* ServerError.MISSING_MFA_ENROLLMENT_ID */
    ]: "missing-multi-factor-info",
    [
      "MISSING_MFA_PENDING_CREDENTIAL"
      /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */
    ]: "missing-multi-factor-session",
    [
      "SECOND_FACTOR_EXISTS"
      /* ServerError.SECOND_FACTOR_EXISTS */
    ]: "second-factor-already-in-use",
    [
      "SECOND_FACTOR_LIMIT_EXCEEDED"
      /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */
    ]: "maximum-second-factor-count-exceeded",
    // Blocking functions related errors.
    [
      "BLOCKING_FUNCTION_ERROR_RESPONSE"
      /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */
    ]: "internal-error",
    // Recaptcha related errors.
    [
      "RECAPTCHA_NOT_ENABLED"
      /* ServerError.RECAPTCHA_NOT_ENABLED */
    ]: "recaptcha-not-enabled",
    [
      "MISSING_RECAPTCHA_TOKEN"
      /* ServerError.MISSING_RECAPTCHA_TOKEN */
    ]: "missing-recaptcha-token",
    [
      "INVALID_RECAPTCHA_TOKEN"
      /* ServerError.INVALID_RECAPTCHA_TOKEN */
    ]: "invalid-recaptcha-token",
    [
      "INVALID_RECAPTCHA_ACTION"
      /* ServerError.INVALID_RECAPTCHA_ACTION */
    ]: "invalid-recaptcha-action",
    [
      "MISSING_CLIENT_TYPE"
      /* ServerError.MISSING_CLIENT_TYPE */
    ]: "missing-client-type",
    [
      "MISSING_RECAPTCHA_VERSION"
      /* ServerError.MISSING_RECAPTCHA_VERSION */
    ]: "missing-recaptcha-version",
    [
      "INVALID_RECAPTCHA_VERSION"
      /* ServerError.INVALID_RECAPTCHA_VERSION */
    ]: "invalid-recaptcha-version",
    [
      "INVALID_REQ_TYPE"
      /* ServerError.INVALID_REQ_TYPE */
    ]: "invalid-req-type"
    /* AuthErrorCode.INVALID_REQ_TYPE */
  };
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const DEFAULT_API_TIMEOUT_MS = new Delay(3e4, 6e4);
  function _addTidIfNecessary(auth, request) {
    if (auth.tenantId && !request.tenantId) {
      return Object.assign(Object.assign({}, request), { tenantId: auth.tenantId });
    }
    return request;
  }
  async function _performApiRequest(auth, method, path, request, customErrorMap = {}) {
    return _performFetchWithErrorHandling(auth, customErrorMap, async () => {
      let body = {};
      let params = {};
      if (request) {
        if (method === "GET") {
          params = request;
        } else {
          body = {
            body: JSON.stringify(request)
          };
        }
      }
      const query = querystring(Object.assign({ key: auth.config.apiKey }, params)).slice(1);
      const headers = await auth._getAdditionalHeaders();
      headers[
        "Content-Type"
        /* HttpHeader.CONTENT_TYPE */
      ] = "application/json";
      if (auth.languageCode) {
        headers[
          "X-Firebase-Locale"
          /* HttpHeader.X_FIREBASE_LOCALE */
        ] = auth.languageCode;
      }
      const fetchArgs = Object.assign({
        method,
        headers
      }, body);
      if (!isCloudflareWorker()) {
        fetchArgs.referrerPolicy = "no-referrer";
      }
      return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), fetchArgs);
    });
  }
  async function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {
    auth._canInitEmulator = false;
    const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);
    try {
      const networkTimeout = new NetworkTimeout(auth);
      const response = await Promise.race([
        fetchFn(),
        networkTimeout.promise
      ]);
      networkTimeout.clearNetworkTimeout();
      const json = await response.json();
      if ("needConfirmation" in json) {
        throw _makeTaggedError(auth, "account-exists-with-different-credential", json);
      }
      if (response.ok && !("errorMessage" in json)) {
        return json;
      } else {
        const errorMessage = response.ok ? json.errorMessage : json.error.message;
        const [serverErrorCode, serverErrorMessage] = errorMessage.split(" : ");
        if (serverErrorCode === "FEDERATED_USER_ID_ALREADY_LINKED") {
          throw _makeTaggedError(auth, "credential-already-in-use", json);
        } else if (serverErrorCode === "EMAIL_EXISTS") {
          throw _makeTaggedError(auth, "email-already-in-use", json);
        } else if (serverErrorCode === "USER_DISABLED") {
          throw _makeTaggedError(auth, "user-disabled", json);
        }
        const authError = errorMap[serverErrorCode] || serverErrorCode.toLowerCase().replace(/[_\s]+/g, "-");
        if (serverErrorMessage) {
          throw _errorWithCustomMessage(auth, authError, serverErrorMessage);
        } else {
          _fail(auth, authError);
        }
      }
    } catch (e) {
      if (e instanceof FirebaseError) {
        throw e;
      }
      _fail(auth, "network-request-failed", { "message": String(e) });
    }
  }
  async function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {
    const serverResponse = await _performApiRequest(auth, method, path, request, customErrorMap);
    if ("mfaPendingCredential" in serverResponse) {
      _fail(auth, "multi-factor-auth-required", {
        _serverResponse: serverResponse
      });
    }
    return serverResponse;
  }
  function _getFinalTarget(auth, host, path, query) {
    const base = `${host}${path}?${query}`;
    if (!auth.config.emulator) {
      return `${auth.config.apiScheme}://${base}`;
    }
    return _emulatorUrl(auth.config, base);
  }
  class NetworkTimeout {
    constructor(auth) {
      this.auth = auth;
      this.timer = null;
      this.promise = new Promise((_, reject) => {
        this.timer = setTimeout(() => {
          return reject(_createError(
            this.auth,
            "network-request-failed"
            /* AuthErrorCode.NETWORK_REQUEST_FAILED */
          ));
        }, DEFAULT_API_TIMEOUT_MS.get());
      });
    }
    clearNetworkTimeout() {
      clearTimeout(this.timer);
    }
  }
  function _makeTaggedError(auth, code2, response) {
    const errorParams = {
      appName: auth.name
    };
    if (response.email) {
      errorParams.email = response.email;
    }
    if (response.phoneNumber) {
      errorParams.phoneNumber = response.phoneNumber;
    }
    const error = _createError(auth, code2, errorParams);
    error.customData._tokenResponse = response;
    return error;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function deleteAccount(auth, request) {
    return _performApiRequest(auth, "POST", "/v1/accounts:delete", request);
  }
  async function getAccountInfo(auth, request) {
    return _performApiRequest(auth, "POST", "/v1/accounts:lookup", request);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function utcTimestampToDateString(utcTimestamp) {
    if (!utcTimestamp) {
      return void 0;
    }
    try {
      const date = new Date(Number(utcTimestamp));
      if (!isNaN(date.getTime())) {
        return date.toUTCString();
      }
    } catch (e) {
    }
    return void 0;
  }
  async function getIdTokenResult(user, forceRefresh = false) {
    const userInternal = getModularInstance(user);
    const token = await userInternal.getIdToken(forceRefresh);
    const claims = _parseToken(token);
    _assert(
      claims && claims.exp && claims.auth_time && claims.iat,
      userInternal.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const firebase = typeof claims.firebase === "object" ? claims.firebase : void 0;
    const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase["sign_in_provider"];
    return {
      claims,
      token,
      authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),
      issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),
      expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),
      signInProvider: signInProvider || null,
      signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase["sign_in_second_factor"]) || null
    };
  }
  function secondsStringToMilliseconds(seconds) {
    return Number(seconds) * 1e3;
  }
  function _parseToken(token) {
    const [algorithm, payload, signature] = token.split(".");
    if (algorithm === void 0 || payload === void 0 || signature === void 0) {
      _logError("JWT malformed, contained fewer than 3 sections");
      return null;
    }
    try {
      const decoded = base64Decode(payload);
      if (!decoded) {
        _logError("Failed to decode base64 JWT payload");
        return null;
      }
      return JSON.parse(decoded);
    } catch (e) {
      _logError("Caught error parsing JWT payload as JSON", e === null || e === void 0 ? void 0 : e.toString());
      return null;
    }
  }
  function _tokenExpiresIn(token) {
    const parsedToken = _parseToken(token);
    _assert(
      parsedToken,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    _assert(
      typeof parsedToken.exp !== "undefined",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    _assert(
      typeof parsedToken.iat !== "undefined",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    return Number(parsedToken.exp) - Number(parsedToken.iat);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function _logoutIfInvalidated(user, promise, bypassAuthState = false) {
    if (bypassAuthState) {
      return promise;
    }
    try {
      return await promise;
    } catch (e) {
      if (e instanceof FirebaseError && isUserInvalidated(e)) {
        if (user.auth.currentUser === user) {
          await user.auth.signOut();
        }
      }
      throw e;
    }
  }
  function isUserInvalidated({ code: code2 }) {
    return code2 === `auth/${"user-disabled"}` || code2 === `auth/${"user-token-expired"}`;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ProactiveRefresh {
    constructor(user) {
      this.user = user;
      this.isRunning = false;
      this.timerId = null;
      this.errorBackoff = 3e4;
    }
    _start() {
      if (this.isRunning) {
        return;
      }
      this.isRunning = true;
      this.schedule();
    }
    _stop() {
      if (!this.isRunning) {
        return;
      }
      this.isRunning = false;
      if (this.timerId !== null) {
        clearTimeout(this.timerId);
      }
    }
    getInterval(wasError) {
      var _a2;
      if (wasError) {
        const interval = this.errorBackoff;
        this.errorBackoff = Math.min(
          this.errorBackoff * 2,
          96e4
          /* Duration.RETRY_BACKOFF_MAX */
        );
        return interval;
      } else {
        this.errorBackoff = 3e4;
        const expTime = (_a2 = this.user.stsTokenManager.expirationTime) !== null && _a2 !== void 0 ? _a2 : 0;
        const interval = expTime - Date.now() - 3e5;
        return Math.max(0, interval);
      }
    }
    schedule(wasError = false) {
      if (!this.isRunning) {
        return;
      }
      const interval = this.getInterval(wasError);
      this.timerId = setTimeout(async () => {
        await this.iteration();
      }, interval);
    }
    async iteration() {
      try {
        await this.user.getIdToken(true);
      } catch (e) {
        if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${"network-request-failed"}`) {
          this.schedule(
            /* wasError */
            true
          );
        }
        return;
      }
      this.schedule();
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class UserMetadata {
    constructor(createdAt, lastLoginAt) {
      this.createdAt = createdAt;
      this.lastLoginAt = lastLoginAt;
      this._initializeTime();
    }
    _initializeTime() {
      this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);
      this.creationTime = utcTimestampToDateString(this.createdAt);
    }
    _copy(metadata) {
      this.createdAt = metadata.createdAt;
      this.lastLoginAt = metadata.lastLoginAt;
      this._initializeTime();
    }
    toJSON() {
      return {
        createdAt: this.createdAt,
        lastLoginAt: this.lastLoginAt
      };
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function _reloadWithoutSaving(user) {
    var _a2;
    const auth = user.auth;
    const idToken = await user.getIdToken();
    const response = await _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }));
    _assert(
      response === null || response === void 0 ? void 0 : response.users.length,
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const coreAccount = response.users[0];
    user._notifyReloadListener(coreAccount);
    const newProviderData = ((_a2 = coreAccount.providerUserInfo) === null || _a2 === void 0 ? void 0 : _a2.length) ? extractProviderData(coreAccount.providerUserInfo) : [];
    const providerData = mergeProviderData(user.providerData, newProviderData);
    const oldIsAnonymous = user.isAnonymous;
    const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
    const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;
    const updates = {
      uid: coreAccount.localId,
      displayName: coreAccount.displayName || null,
      photoURL: coreAccount.photoUrl || null,
      email: coreAccount.email || null,
      emailVerified: coreAccount.emailVerified || false,
      phoneNumber: coreAccount.phoneNumber || null,
      tenantId: coreAccount.tenantId || null,
      providerData,
      metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
      isAnonymous
    };
    Object.assign(user, updates);
  }
  async function reload(user) {
    const userInternal = getModularInstance(user);
    await _reloadWithoutSaving(userInternal);
    await userInternal.auth._persistUserIfCurrent(userInternal);
    userInternal.auth._notifyListenersIfCurrent(userInternal);
  }
  function mergeProviderData(original, newData) {
    const deduped = original.filter((o) => !newData.some((n) => n.providerId === o.providerId));
    return [...deduped, ...newData];
  }
  function extractProviderData(providers) {
    return providers.map((_a2) => {
      var { providerId } = _a2, provider = __rest(_a2, ["providerId"]);
      return {
        providerId,
        uid: provider.rawId || "",
        displayName: provider.displayName || null,
        email: provider.email || null,
        phoneNumber: provider.phoneNumber || null,
        photoURL: provider.photoUrl || null
      };
    });
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function requestStsToken(auth, refreshToken) {
    const response = await _performFetchWithErrorHandling(auth, {}, async () => {
      const body = querystring({
        "grant_type": "refresh_token",
        "refresh_token": refreshToken
      }).slice(1);
      const { tokenApiHost, apiKey } = auth.config;
      const url = _getFinalTarget(auth, tokenApiHost, "/v1/token", `key=${apiKey}`);
      const headers = await auth._getAdditionalHeaders();
      headers[
        "Content-Type"
        /* HttpHeader.CONTENT_TYPE */
      ] = "application/x-www-form-urlencoded";
      return FetchProvider.fetch()(url, {
        method: "POST",
        headers,
        body
      });
    });
    return {
      accessToken: response.access_token,
      expiresIn: response.expires_in,
      refreshToken: response.refresh_token
    };
  }
  async function revokeToken(auth, request) {
    return _performApiRequest(auth, "POST", "/v2/accounts:revokeToken", _addTidIfNecessary(auth, request));
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class StsTokenManager {
    constructor() {
      this.refreshToken = null;
      this.accessToken = null;
      this.expirationTime = null;
    }
    get isExpired() {
      return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
    }
    updateFromServerResponse(response) {
      _assert(
        response.idToken,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      _assert(
        typeof response.idToken !== "undefined",
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      _assert(
        typeof response.refreshToken !== "undefined",
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      const expiresIn = "expiresIn" in response && typeof response.expiresIn !== "undefined" ? Number(response.expiresIn) : _tokenExpiresIn(response.idToken);
      this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);
    }
    updateFromIdToken(idToken) {
      _assert(
        idToken.length !== 0,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      const expiresIn = _tokenExpiresIn(idToken);
      this.updateTokensAndExpiration(idToken, null, expiresIn);
    }
    async getToken(auth, forceRefresh = false) {
      if (!forceRefresh && this.accessToken && !this.isExpired) {
        return this.accessToken;
      }
      _assert(
        this.refreshToken,
        auth,
        "user-token-expired"
        /* AuthErrorCode.TOKEN_EXPIRED */
      );
      if (this.refreshToken) {
        await this.refresh(auth, this.refreshToken);
        return this.accessToken;
      }
      return null;
    }
    clearRefreshToken() {
      this.refreshToken = null;
    }
    async refresh(auth, oldToken) {
      const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);
      this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));
    }
    updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {
      this.refreshToken = refreshToken || null;
      this.accessToken = accessToken || null;
      this.expirationTime = Date.now() + expiresInSec * 1e3;
    }
    static fromJSON(appName, object) {
      const { refreshToken, accessToken, expirationTime } = object;
      const manager = new StsTokenManager();
      if (refreshToken) {
        _assert(typeof refreshToken === "string", "internal-error", {
          appName
        });
        manager.refreshToken = refreshToken;
      }
      if (accessToken) {
        _assert(typeof accessToken === "string", "internal-error", {
          appName
        });
        manager.accessToken = accessToken;
      }
      if (expirationTime) {
        _assert(typeof expirationTime === "number", "internal-error", {
          appName
        });
        manager.expirationTime = expirationTime;
      }
      return manager;
    }
    toJSON() {
      return {
        refreshToken: this.refreshToken,
        accessToken: this.accessToken,
        expirationTime: this.expirationTime
      };
    }
    _assign(stsTokenManager) {
      this.accessToken = stsTokenManager.accessToken;
      this.refreshToken = stsTokenManager.refreshToken;
      this.expirationTime = stsTokenManager.expirationTime;
    }
    _clone() {
      return Object.assign(new StsTokenManager(), this.toJSON());
    }
    _performRefresh() {
      return debugFail("not implemented");
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function assertStringOrUndefined(assertion, appName) {
    _assert(typeof assertion === "string" || typeof assertion === "undefined", "internal-error", { appName });
  }
  class UserImpl {
    constructor(_a2) {
      var { uid, auth, stsTokenManager } = _a2, opt = __rest(_a2, ["uid", "auth", "stsTokenManager"]);
      this.providerId = "firebase";
      this.proactiveRefresh = new ProactiveRefresh(this);
      this.reloadUserInfo = null;
      this.reloadListener = null;
      this.uid = uid;
      this.auth = auth;
      this.stsTokenManager = stsTokenManager;
      this.accessToken = stsTokenManager.accessToken;
      this.displayName = opt.displayName || null;
      this.email = opt.email || null;
      this.emailVerified = opt.emailVerified || false;
      this.phoneNumber = opt.phoneNumber || null;
      this.photoURL = opt.photoURL || null;
      this.isAnonymous = opt.isAnonymous || false;
      this.tenantId = opt.tenantId || null;
      this.providerData = opt.providerData ? [...opt.providerData] : [];
      this.metadata = new UserMetadata(opt.createdAt || void 0, opt.lastLoginAt || void 0);
    }
    async getIdToken(forceRefresh) {
      const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));
      _assert(
        accessToken,
        this.auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      if (this.accessToken !== accessToken) {
        this.accessToken = accessToken;
        await this.auth._persistUserIfCurrent(this);
        this.auth._notifyListenersIfCurrent(this);
      }
      return accessToken;
    }
    getIdTokenResult(forceRefresh) {
      return getIdTokenResult(this, forceRefresh);
    }
    reload() {
      return reload(this);
    }
    _assign(user) {
      if (this === user) {
        return;
      }
      _assert(
        this.uid === user.uid,
        this.auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      this.displayName = user.displayName;
      this.photoURL = user.photoURL;
      this.email = user.email;
      this.emailVerified = user.emailVerified;
      this.phoneNumber = user.phoneNumber;
      this.isAnonymous = user.isAnonymous;
      this.tenantId = user.tenantId;
      this.providerData = user.providerData.map((userInfo) => Object.assign({}, userInfo));
      this.metadata._copy(user.metadata);
      this.stsTokenManager._assign(user.stsTokenManager);
    }
    _clone(auth) {
      const newUser = new UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));
      newUser.metadata._copy(this.metadata);
      return newUser;
    }
    _onReload(callback) {
      _assert(
        !this.reloadListener,
        this.auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      this.reloadListener = callback;
      if (this.reloadUserInfo) {
        this._notifyReloadListener(this.reloadUserInfo);
        this.reloadUserInfo = null;
      }
    }
    _notifyReloadListener(userInfo) {
      if (this.reloadListener) {
        this.reloadListener(userInfo);
      } else {
        this.reloadUserInfo = userInfo;
      }
    }
    _startProactiveRefresh() {
      this.proactiveRefresh._start();
    }
    _stopProactiveRefresh() {
      this.proactiveRefresh._stop();
    }
    async _updateTokensIfNecessary(response, reload2 = false) {
      let tokensRefreshed = false;
      if (response.idToken && response.idToken !== this.stsTokenManager.accessToken) {
        this.stsTokenManager.updateFromServerResponse(response);
        tokensRefreshed = true;
      }
      if (reload2) {
        await _reloadWithoutSaving(this);
      }
      await this.auth._persistUserIfCurrent(this);
      if (tokensRefreshed) {
        this.auth._notifyListenersIfCurrent(this);
      }
    }
    async delete() {
      if (_isFirebaseServerApp(this.auth.app)) {
        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this.auth));
      }
      const idToken = await this.getIdToken();
      await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));
      this.stsTokenManager.clearRefreshToken();
      return this.auth.signOut();
    }
    toJSON() {
      return Object.assign(Object.assign({
        uid: this.uid,
        email: this.email || void 0,
        emailVerified: this.emailVerified,
        displayName: this.displayName || void 0,
        isAnonymous: this.isAnonymous,
        photoURL: this.photoURL || void 0,
        phoneNumber: this.phoneNumber || void 0,
        tenantId: this.tenantId || void 0,
        providerData: this.providerData.map((userInfo) => Object.assign({}, userInfo)),
        stsTokenManager: this.stsTokenManager.toJSON(),
        // Redirect event ID must be maintained in case there is a pending
        // redirect event.
        _redirectEventId: this._redirectEventId
      }, this.metadata.toJSON()), {
        // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):
        apiKey: this.auth.config.apiKey,
        appName: this.auth.name
      });
    }
    get refreshToken() {
      return this.stsTokenManager.refreshToken || "";
    }
    static _fromJSON(auth, object) {
      var _a2, _b2, _c2, _d2, _e3, _f2, _g2, _h2;
      const displayName = (_a2 = object.displayName) !== null && _a2 !== void 0 ? _a2 : void 0;
      const email = (_b2 = object.email) !== null && _b2 !== void 0 ? _b2 : void 0;
      const phoneNumber = (_c2 = object.phoneNumber) !== null && _c2 !== void 0 ? _c2 : void 0;
      const photoURL = (_d2 = object.photoURL) !== null && _d2 !== void 0 ? _d2 : void 0;
      const tenantId = (_e3 = object.tenantId) !== null && _e3 !== void 0 ? _e3 : void 0;
      const _redirectEventId = (_f2 = object._redirectEventId) !== null && _f2 !== void 0 ? _f2 : void 0;
      const createdAt = (_g2 = object.createdAt) !== null && _g2 !== void 0 ? _g2 : void 0;
      const lastLoginAt = (_h2 = object.lastLoginAt) !== null && _h2 !== void 0 ? _h2 : void 0;
      const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;
      _assert(
        uid && plainObjectTokenManager,
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);
      _assert(
        typeof uid === "string",
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      assertStringOrUndefined(displayName, auth.name);
      assertStringOrUndefined(email, auth.name);
      _assert(
        typeof emailVerified === "boolean",
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      _assert(
        typeof isAnonymous === "boolean",
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      assertStringOrUndefined(phoneNumber, auth.name);
      assertStringOrUndefined(photoURL, auth.name);
      assertStringOrUndefined(tenantId, auth.name);
      assertStringOrUndefined(_redirectEventId, auth.name);
      assertStringOrUndefined(createdAt, auth.name);
      assertStringOrUndefined(lastLoginAt, auth.name);
      const user = new UserImpl({
        uid,
        auth,
        email,
        emailVerified,
        displayName,
        isAnonymous,
        photoURL,
        phoneNumber,
        tenantId,
        stsTokenManager,
        createdAt,
        lastLoginAt
      });
      if (providerData && Array.isArray(providerData)) {
        user.providerData = providerData.map((userInfo) => Object.assign({}, userInfo));
      }
      if (_redirectEventId) {
        user._redirectEventId = _redirectEventId;
      }
      return user;
    }
    /**
     * Initialize a User from an idToken server response
     * @param auth
     * @param idTokenResponse
     */
    static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {
      const stsTokenManager = new StsTokenManager();
      stsTokenManager.updateFromServerResponse(idTokenResponse);
      const user = new UserImpl({
        uid: idTokenResponse.localId,
        auth,
        stsTokenManager,
        isAnonymous
      });
      await _reloadWithoutSaving(user);
      return user;
    }
    /**
     * Initialize a User from an idToken server response
     * @param auth
     * @param idTokenResponse
     */
    static async _fromGetAccountInfoResponse(auth, response, idToken) {
      const coreAccount = response.users[0];
      _assert(
        coreAccount.localId !== void 0,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      const providerData = coreAccount.providerUserInfo !== void 0 ? extractProviderData(coreAccount.providerUserInfo) : [];
      const isAnonymous = !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
      const stsTokenManager = new StsTokenManager();
      stsTokenManager.updateFromIdToken(idToken);
      const user = new UserImpl({
        uid: coreAccount.localId,
        auth,
        stsTokenManager,
        isAnonymous
      });
      const updates = {
        uid: coreAccount.localId,
        displayName: coreAccount.displayName || null,
        photoURL: coreAccount.photoUrl || null,
        email: coreAccount.email || null,
        emailVerified: coreAccount.emailVerified || false,
        phoneNumber: coreAccount.phoneNumber || null,
        tenantId: coreAccount.tenantId || null,
        providerData,
        metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
        isAnonymous: !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length)
      };
      Object.assign(user, updates);
      return user;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const instanceCache = /* @__PURE__ */ new Map();
  function _getInstance(cls) {
    debugAssert(cls instanceof Function, "Expected a class definition");
    let instance = instanceCache.get(cls);
    if (instance) {
      debugAssert(instance instanceof cls, "Instance stored in cache mismatched with class");
      return instance;
    }
    instance = new cls();
    instanceCache.set(cls, instance);
    return instance;
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class InMemoryPersistence {
    constructor() {
      this.type = "NONE";
      this.storage = {};
    }
    async _isAvailable() {
      return true;
    }
    async _set(key, value) {
      this.storage[key] = value;
    }
    async _get(key) {
      const value = this.storage[key];
      return value === void 0 ? null : value;
    }
    async _remove(key) {
      delete this.storage[key];
    }
    _addListener(_key, _listener) {
      return;
    }
    _removeListener(_key, _listener) {
      return;
    }
  }
  InMemoryPersistence.type = "NONE";
  const inMemoryPersistence = InMemoryPersistence;
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _persistenceKeyName(key, apiKey, appName) {
    return `${"firebase"}:${key}:${apiKey}:${appName}`;
  }
  class PersistenceUserManager {
    constructor(persistence, auth, userKey) {
      this.persistence = persistence;
      this.auth = auth;
      this.userKey = userKey;
      const { config, name: name2 } = this.auth;
      this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name2);
      this.fullPersistenceKey = _persistenceKeyName("persistence", config.apiKey, name2);
      this.boundEventHandler = auth._onStorageEvent.bind(auth);
      this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
    }
    setCurrentUser(user) {
      return this.persistence._set(this.fullUserKey, user.toJSON());
    }
    async getCurrentUser() {
      const blob = await this.persistence._get(this.fullUserKey);
      return blob ? UserImpl._fromJSON(this.auth, blob) : null;
    }
    removeCurrentUser() {
      return this.persistence._remove(this.fullUserKey);
    }
    savePersistenceForRedirect() {
      return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
    }
    async setPersistence(newPersistence) {
      if (this.persistence === newPersistence) {
        return;
      }
      const currentUser = await this.getCurrentUser();
      await this.removeCurrentUser();
      this.persistence = newPersistence;
      if (currentUser) {
        return this.setCurrentUser(currentUser);
      }
    }
    delete() {
      this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
    }
    static async create(auth, persistenceHierarchy, userKey = "authUser") {
      if (!persistenceHierarchy.length) {
        return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);
      }
      const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {
        if (await persistence._isAvailable()) {
          return persistence;
        }
        return void 0;
      }))).filter((persistence) => persistence);
      let selectedPersistence = availablePersistences[0] || _getInstance(inMemoryPersistence);
      const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);
      let userToMigrate = null;
      for (const persistence of persistenceHierarchy) {
        try {
          const blob = await persistence._get(key);
          if (blob) {
            const user = UserImpl._fromJSON(auth, blob);
            if (persistence !== selectedPersistence) {
              userToMigrate = user;
            }
            selectedPersistence = persistence;
            break;
          }
        } catch (_a2) {
        }
      }
      const migrationHierarchy = availablePersistences.filter((p) => p._shouldAllowMigration);
      if (!selectedPersistence._shouldAllowMigration || !migrationHierarchy.length) {
        return new PersistenceUserManager(selectedPersistence, auth, userKey);
      }
      selectedPersistence = migrationHierarchy[0];
      if (userToMigrate) {
        await selectedPersistence._set(key, userToMigrate.toJSON());
      }
      await Promise.all(persistenceHierarchy.map(async (persistence) => {
        if (persistence !== selectedPersistence) {
          try {
            await persistence._remove(key);
          } catch (_a2) {
          }
        }
      }));
      return new PersistenceUserManager(selectedPersistence, auth, userKey);
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _getBrowserName(userAgent) {
    const ua = userAgent.toLowerCase();
    if (ua.includes("opera/") || ua.includes("opr/") || ua.includes("opios/")) {
      return "Opera";
    } else if (_isIEMobile(ua)) {
      return "IEMobile";
    } else if (ua.includes("msie") || ua.includes("trident/")) {
      return "IE";
    } else if (ua.includes("edge/")) {
      return "Edge";
    } else if (_isFirefox(ua)) {
      return "Firefox";
    } else if (ua.includes("silk/")) {
      return "Silk";
    } else if (_isBlackBerry(ua)) {
      return "Blackberry";
    } else if (_isWebOS(ua)) {
      return "Webos";
    } else if (_isSafari(ua)) {
      return "Safari";
    } else if ((ua.includes("chrome/") || _isChromeIOS(ua)) && !ua.includes("edge/")) {
      return "Chrome";
    } else if (_isAndroid(ua)) {
      return "Android";
    } else {
      const re2 = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;
      const matches = userAgent.match(re2);
      if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {
        return matches[1];
      }
    }
    return "Other";
  }
  function _isFirefox(ua = getUA()) {
    return /firefox\//i.test(ua);
  }
  function _isSafari(userAgent = getUA()) {
    const ua = userAgent.toLowerCase();
    return ua.includes("safari/") && !ua.includes("chrome/") && !ua.includes("crios/") && !ua.includes("android");
  }
  function _isChromeIOS(ua = getUA()) {
    return /crios\//i.test(ua);
  }
  function _isIEMobile(ua = getUA()) {
    return /iemobile/i.test(ua);
  }
  function _isAndroid(ua = getUA()) {
    return /android/i.test(ua);
  }
  function _isBlackBerry(ua = getUA()) {
    return /blackberry/i.test(ua);
  }
  function _isWebOS(ua = getUA()) {
    return /webos/i.test(ua);
  }
  function _isIOS(ua = getUA()) {
    return /iphone|ipad|ipod/i.test(ua) || /macintosh/i.test(ua) && /mobile/i.test(ua);
  }
  function _isIOSStandalone(ua = getUA()) {
    var _a2;
    return _isIOS(ua) && !!((_a2 = window.navigator) === null || _a2 === void 0 ? void 0 : _a2.standalone);
  }
  function _isIE10() {
    return isIE() && document.documentMode === 10;
  }
  function _isMobileBrowser(ua = getUA()) {
    return _isIOS(ua) || _isAndroid(ua) || _isWebOS(ua) || _isBlackBerry(ua) || /windows phone/i.test(ua) || _isIEMobile(ua);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _getClientVersion(clientPlatform, frameworks = []) {
    let reportedPlatform;
    switch (clientPlatform) {
      case "Browser":
        reportedPlatform = _getBrowserName(getUA());
        break;
      case "Worker":
        reportedPlatform = `${_getBrowserName(getUA())}-${clientPlatform}`;
        break;
      default:
        reportedPlatform = clientPlatform;
    }
    const reportedFrameworks = frameworks.length ? frameworks.join(",") : "FirebaseCore-web";
    return `${reportedPlatform}/${"JsCore"}/${SDK_VERSION}/${reportedFrameworks}`;
  }
  /**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class AuthMiddlewareQueue {
    constructor(auth) {
      this.auth = auth;
      this.queue = [];
    }
    pushCallback(callback, onAbort) {
      const wrappedCallback = (user) => new Promise((resolve, reject) => {
        try {
          const result = callback(user);
          resolve(result);
        } catch (e) {
          reject(e);
        }
      });
      wrappedCallback.onAbort = onAbort;
      this.queue.push(wrappedCallback);
      const index2 = this.queue.length - 1;
      return () => {
        this.queue[index2] = () => Promise.resolve();
      };
    }
    async runMiddleware(nextUser) {
      if (this.auth.currentUser === nextUser) {
        return;
      }
      const onAbortStack = [];
      try {
        for (const beforeStateCallback of this.queue) {
          await beforeStateCallback(nextUser);
          if (beforeStateCallback.onAbort) {
            onAbortStack.push(beforeStateCallback.onAbort);
          }
        }
      } catch (e) {
        onAbortStack.reverse();
        for (const onAbort of onAbortStack) {
          try {
            onAbort();
          } catch (_) {
          }
        }
        throw this.auth._errorFactory.create("login-blocked", {
          originalMessage: e === null || e === void 0 ? void 0 : e.message
        });
      }
    }
  }
  /**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function _getPasswordPolicy(auth, request = {}) {
    return _performApiRequest(auth, "GET", "/v2/passwordPolicy", _addTidIfNecessary(auth, request));
  }
  /**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const MINIMUM_MIN_PASSWORD_LENGTH = 6;
  class PasswordPolicyImpl {
    constructor(response) {
      var _a2, _b2, _c2, _d2;
      const responseOptions = response.customStrengthOptions;
      this.customStrengthOptions = {};
      this.customStrengthOptions.minPasswordLength = (_a2 = responseOptions.minPasswordLength) !== null && _a2 !== void 0 ? _a2 : MINIMUM_MIN_PASSWORD_LENGTH;
      if (responseOptions.maxPasswordLength) {
        this.customStrengthOptions.maxPasswordLength = responseOptions.maxPasswordLength;
      }
      if (responseOptions.containsLowercaseCharacter !== void 0) {
        this.customStrengthOptions.containsLowercaseLetter = responseOptions.containsLowercaseCharacter;
      }
      if (responseOptions.containsUppercaseCharacter !== void 0) {
        this.customStrengthOptions.containsUppercaseLetter = responseOptions.containsUppercaseCharacter;
      }
      if (responseOptions.containsNumericCharacter !== void 0) {
        this.customStrengthOptions.containsNumericCharacter = responseOptions.containsNumericCharacter;
      }
      if (responseOptions.containsNonAlphanumericCharacter !== void 0) {
        this.customStrengthOptions.containsNonAlphanumericCharacter = responseOptions.containsNonAlphanumericCharacter;
      }
      this.enforcementState = response.enforcementState;
      if (this.enforcementState === "ENFORCEMENT_STATE_UNSPECIFIED") {
        this.enforcementState = "OFF";
      }
      this.allowedNonAlphanumericCharacters = (_c2 = (_b2 = response.allowedNonAlphanumericCharacters) === null || _b2 === void 0 ? void 0 : _b2.join("")) !== null && _c2 !== void 0 ? _c2 : "";
      this.forceUpgradeOnSignin = (_d2 = response.forceUpgradeOnSignin) !== null && _d2 !== void 0 ? _d2 : false;
      this.schemaVersion = response.schemaVersion;
    }
    validatePassword(password) {
      var _a2, _b2, _c2, _d2, _e3, _f2;
      const status = {
        isValid: true,
        passwordPolicy: this
      };
      this.validatePasswordLengthOptions(password, status);
      this.validatePasswordCharacterOptions(password, status);
      status.isValid && (status.isValid = (_a2 = status.meetsMinPasswordLength) !== null && _a2 !== void 0 ? _a2 : true);
      status.isValid && (status.isValid = (_b2 = status.meetsMaxPasswordLength) !== null && _b2 !== void 0 ? _b2 : true);
      status.isValid && (status.isValid = (_c2 = status.containsLowercaseLetter) !== null && _c2 !== void 0 ? _c2 : true);
      status.isValid && (status.isValid = (_d2 = status.containsUppercaseLetter) !== null && _d2 !== void 0 ? _d2 : true);
      status.isValid && (status.isValid = (_e3 = status.containsNumericCharacter) !== null && _e3 !== void 0 ? _e3 : true);
      status.isValid && (status.isValid = (_f2 = status.containsNonAlphanumericCharacter) !== null && _f2 !== void 0 ? _f2 : true);
      return status;
    }
    /**
     * Validates that the password meets the length options for the policy.
     *
     * @param password Password to validate.
     * @param status Validation status.
     */
    validatePasswordLengthOptions(password, status) {
      const minPasswordLength = this.customStrengthOptions.minPasswordLength;
      const maxPasswordLength = this.customStrengthOptions.maxPasswordLength;
      if (minPasswordLength) {
        status.meetsMinPasswordLength = password.length >= minPasswordLength;
      }
      if (maxPasswordLength) {
        status.meetsMaxPasswordLength = password.length <= maxPasswordLength;
      }
    }
    /**
     * Validates that the password meets the character options for the policy.
     *
     * @param password Password to validate.
     * @param status Validation status.
     */
    validatePasswordCharacterOptions(password, status) {
      this.updatePasswordCharacterOptionsStatuses(
        status,
        /* containsLowercaseCharacter= */
        false,
        /* containsUppercaseCharacter= */
        false,
        /* containsNumericCharacter= */
        false,
        /* containsNonAlphanumericCharacter= */
        false
      );
      let passwordChar;
      for (let i = 0; i < password.length; i++) {
        passwordChar = password.charAt(i);
        this.updatePasswordCharacterOptionsStatuses(
          status,
          /* containsLowercaseCharacter= */
          passwordChar >= "a" && passwordChar <= "z",
          /* containsUppercaseCharacter= */
          passwordChar >= "A" && passwordChar <= "Z",
          /* containsNumericCharacter= */
          passwordChar >= "0" && passwordChar <= "9",
          /* containsNonAlphanumericCharacter= */
          this.allowedNonAlphanumericCharacters.includes(passwordChar)
        );
      }
    }
    /**
     * Updates the running validation status with the statuses for the character options.
     * Expected to be called each time a character is processed to update each option status
     * based on the current character.
     *
     * @param status Validation status.
     * @param containsLowercaseCharacter Whether the character is a lowercase letter.
     * @param containsUppercaseCharacter Whether the character is an uppercase letter.
     * @param containsNumericCharacter Whether the character is a numeric character.
     * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.
     */
    updatePasswordCharacterOptionsStatuses(status, containsLowercaseCharacter, containsUppercaseCharacter, containsNumericCharacter, containsNonAlphanumericCharacter) {
      if (this.customStrengthOptions.containsLowercaseLetter) {
        status.containsLowercaseLetter || (status.containsLowercaseLetter = containsLowercaseCharacter);
      }
      if (this.customStrengthOptions.containsUppercaseLetter) {
        status.containsUppercaseLetter || (status.containsUppercaseLetter = containsUppercaseCharacter);
      }
      if (this.customStrengthOptions.containsNumericCharacter) {
        status.containsNumericCharacter || (status.containsNumericCharacter = containsNumericCharacter);
      }
      if (this.customStrengthOptions.containsNonAlphanumericCharacter) {
        status.containsNonAlphanumericCharacter || (status.containsNonAlphanumericCharacter = containsNonAlphanumericCharacter);
      }
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class AuthImpl {
    constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config) {
      this.app = app;
      this.heartbeatServiceProvider = heartbeatServiceProvider;
      this.appCheckServiceProvider = appCheckServiceProvider;
      this.config = config;
      this.currentUser = null;
      this.emulatorConfig = null;
      this.operations = Promise.resolve();
      this.authStateSubscription = new Subscription(this);
      this.idTokenSubscription = new Subscription(this);
      this.beforeStateQueue = new AuthMiddlewareQueue(this);
      this.redirectUser = null;
      this.isProactiveRefreshEnabled = false;
      this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1;
      this._canInitEmulator = true;
      this._isInitialized = false;
      this._deleted = false;
      this._initializationPromise = null;
      this._popupRedirectResolver = null;
      this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;
      this._agentRecaptchaConfig = null;
      this._tenantRecaptchaConfigs = {};
      this._projectPasswordPolicy = null;
      this._tenantPasswordPolicies = {};
      this.lastNotifiedUid = void 0;
      this.languageCode = null;
      this.tenantId = null;
      this.settings = { appVerificationDisabledForTesting: false };
      this.frameworks = [];
      this.name = app.name;
      this.clientVersion = config.sdkClientVersion;
    }
    _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {
      if (popupRedirectResolver) {
        this._popupRedirectResolver = _getInstance(popupRedirectResolver);
      }
      this._initializationPromise = this.queue(async () => {
        var _a2, _b2;
        if (this._deleted) {
          return;
        }
        this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);
        if (this._deleted) {
          return;
        }
        if ((_a2 = this._popupRedirectResolver) === null || _a2 === void 0 ? void 0 : _a2._shouldInitProactively) {
          try {
            await this._popupRedirectResolver._initialize(this);
          } catch (e) {
          }
        }
        await this.initializeCurrentUser(popupRedirectResolver);
        this.lastNotifiedUid = ((_b2 = this.currentUser) === null || _b2 === void 0 ? void 0 : _b2.uid) || null;
        if (this._deleted) {
          return;
        }
        this._isInitialized = true;
      });
      return this._initializationPromise;
    }
    /**
     * If the persistence is changed in another window, the user manager will let us know
     */
    async _onStorageEvent() {
      if (this._deleted) {
        return;
      }
      const user = await this.assertedPersistence.getCurrentUser();
      if (!this.currentUser && !user) {
        return;
      }
      if (this.currentUser && user && this.currentUser.uid === user.uid) {
        this._currentUser._assign(user);
        await this.currentUser.getIdToken();
        return;
      }
      await this._updateCurrentUser(
        user,
        /* skipBeforeStateCallbacks */
        true
      );
    }
    async initializeCurrentUserFromIdToken(idToken) {
      try {
        const response = await getAccountInfo(this, { idToken });
        const user = await UserImpl._fromGetAccountInfoResponse(this, response, idToken);
        await this.directlySetCurrentUser(user);
      } catch (err) {
        console.warn("FirebaseServerApp could not login user with provided authIdToken: ", err);
        await this.directlySetCurrentUser(null);
      }
    }
    async initializeCurrentUser(popupRedirectResolver) {
      var _a2;
      if (_isFirebaseServerApp(this.app)) {
        const idToken = this.app.settings.authIdToken;
        if (idToken) {
          return new Promise((resolve) => {
            setTimeout(() => this.initializeCurrentUserFromIdToken(idToken).then(resolve, resolve));
          });
        } else {
          return this.directlySetCurrentUser(null);
        }
      }
      const previouslyStoredUser = await this.assertedPersistence.getCurrentUser();
      let futureCurrentUser = previouslyStoredUser;
      let needsTocheckMiddleware = false;
      if (popupRedirectResolver && this.config.authDomain) {
        await this.getOrInitRedirectPersistenceManager();
        const redirectUserEventId = (_a2 = this.redirectUser) === null || _a2 === void 0 ? void 0 : _a2._redirectEventId;
        const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;
        const result = await this.tryRedirectSignIn(popupRedirectResolver);
        if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) && (result === null || result === void 0 ? void 0 : result.user)) {
          futureCurrentUser = result.user;
          needsTocheckMiddleware = true;
        }
      }
      if (!futureCurrentUser) {
        return this.directlySetCurrentUser(null);
      }
      if (!futureCurrentUser._redirectEventId) {
        if (needsTocheckMiddleware) {
          try {
            await this.beforeStateQueue.runMiddleware(futureCurrentUser);
          } catch (e) {
            futureCurrentUser = previouslyStoredUser;
            this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e));
          }
        }
        if (futureCurrentUser) {
          return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);
        } else {
          return this.directlySetCurrentUser(null);
        }
      }
      _assert(
        this._popupRedirectResolver,
        this,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
      await this.getOrInitRedirectPersistenceManager();
      if (this.redirectUser && this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {
        return this.directlySetCurrentUser(futureCurrentUser);
      }
      return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);
    }
    async tryRedirectSignIn(redirectResolver) {
      let result = null;
      try {
        result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);
      } catch (e) {
        await this._setRedirectUser(null);
      }
      return result;
    }
    async reloadAndSetCurrentUserOrClear(user) {
      try {
        await _reloadWithoutSaving(user);
      } catch (e) {
        if ((e === null || e === void 0 ? void 0 : e.code) !== `auth/${"network-request-failed"}`) {
          return this.directlySetCurrentUser(null);
        }
      }
      return this.directlySetCurrentUser(user);
    }
    useDeviceLanguage() {
      this.languageCode = _getUserLanguage();
    }
    async _delete() {
      this._deleted = true;
    }
    async updateCurrentUser(userExtern) {
      if (_isFirebaseServerApp(this.app)) {
        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));
      }
      const user = userExtern ? getModularInstance(userExtern) : null;
      if (user) {
        _assert(
          user.auth.config.apiKey === this.config.apiKey,
          this,
          "invalid-user-token"
          /* AuthErrorCode.INVALID_AUTH */
        );
      }
      return this._updateCurrentUser(user && user._clone(this));
    }
    async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {
      if (this._deleted) {
        return;
      }
      if (user) {
        _assert(
          this.tenantId === user.tenantId,
          this,
          "tenant-id-mismatch"
          /* AuthErrorCode.TENANT_ID_MISMATCH */
        );
      }
      if (!skipBeforeStateCallbacks) {
        await this.beforeStateQueue.runMiddleware(user);
      }
      return this.queue(async () => {
        await this.directlySetCurrentUser(user);
        this.notifyAuthListeners();
      });
    }
    async signOut() {
      if (_isFirebaseServerApp(this.app)) {
        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));
      }
      await this.beforeStateQueue.runMiddleware(null);
      if (this.redirectPersistenceManager || this._popupRedirectResolver) {
        await this._setRedirectUser(null);
      }
      return this._updateCurrentUser(
        null,
        /* skipBeforeStateCallbacks */
        true
      );
    }
    setPersistence(persistence) {
      if (_isFirebaseServerApp(this.app)) {
        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));
      }
      return this.queue(async () => {
        await this.assertedPersistence.setPersistence(_getInstance(persistence));
      });
    }
    _getRecaptchaConfig() {
      if (this.tenantId == null) {
        return this._agentRecaptchaConfig;
      } else {
        return this._tenantRecaptchaConfigs[this.tenantId];
      }
    }
    async validatePassword(password) {
      if (!this._getPasswordPolicyInternal()) {
        await this._updatePasswordPolicy();
      }
      const passwordPolicy = this._getPasswordPolicyInternal();
      if (passwordPolicy.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION) {
        return Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {}));
      }
      return passwordPolicy.validatePassword(password);
    }
    _getPasswordPolicyInternal() {
      if (this.tenantId === null) {
        return this._projectPasswordPolicy;
      } else {
        return this._tenantPasswordPolicies[this.tenantId];
      }
    }
    async _updatePasswordPolicy() {
      const response = await _getPasswordPolicy(this);
      const passwordPolicy = new PasswordPolicyImpl(response);
      if (this.tenantId === null) {
        this._projectPasswordPolicy = passwordPolicy;
      } else {
        this._tenantPasswordPolicies[this.tenantId] = passwordPolicy;
      }
    }
    _getPersistence() {
      return this.assertedPersistence.persistence.type;
    }
    _updateErrorMap(errorMap) {
      this._errorFactory = new ErrorFactory("auth", "Firebase", errorMap());
    }
    onAuthStateChanged(nextOrObserver, error, completed) {
      return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);
    }
    beforeAuthStateChanged(callback, onAbort) {
      return this.beforeStateQueue.pushCallback(callback, onAbort);
    }
    onIdTokenChanged(nextOrObserver, error, completed) {
      return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);
    }
    authStateReady() {
      return new Promise((resolve, reject) => {
        if (this.currentUser) {
          resolve();
        } else {
          const unsubscribe = this.onAuthStateChanged(() => {
            unsubscribe();
            resolve();
          }, reject);
        }
      });
    }
    /**
     * Revokes the given access token. Currently only supports Apple OAuth access tokens.
     */
    async revokeAccessToken(token) {
      if (this.currentUser) {
        const idToken = await this.currentUser.getIdToken();
        const request = {
          providerId: "apple.com",
          tokenType: "ACCESS_TOKEN",
          token,
          idToken
        };
        if (this.tenantId != null) {
          request.tenantId = this.tenantId;
        }
        await revokeToken(this, request);
      }
    }
    toJSON() {
      var _a2;
      return {
        apiKey: this.config.apiKey,
        authDomain: this.config.authDomain,
        appName: this.name,
        currentUser: (_a2 = this._currentUser) === null || _a2 === void 0 ? void 0 : _a2.toJSON()
      };
    }
    async _setRedirectUser(user, popupRedirectResolver) {
      const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);
      return user === null ? redirectManager.removeCurrentUser() : redirectManager.setCurrentUser(user);
    }
    async getOrInitRedirectPersistenceManager(popupRedirectResolver) {
      if (!this.redirectPersistenceManager) {
        const resolver2 = popupRedirectResolver && _getInstance(popupRedirectResolver) || this._popupRedirectResolver;
        _assert(
          resolver2,
          this,
          "argument-error"
          /* AuthErrorCode.ARGUMENT_ERROR */
        );
        this.redirectPersistenceManager = await PersistenceUserManager.create(
          this,
          [_getInstance(resolver2._redirectPersistence)],
          "redirectUser"
          /* KeyName.REDIRECT_USER */
        );
        this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
      }
      return this.redirectPersistenceManager;
    }
    async _redirectUserForId(id2) {
      var _a2, _b2;
      if (this._isInitialized) {
        await this.queue(async () => {
        });
      }
      if (((_a2 = this._currentUser) === null || _a2 === void 0 ? void 0 : _a2._redirectEventId) === id2) {
        return this._currentUser;
      }
      if (((_b2 = this.redirectUser) === null || _b2 === void 0 ? void 0 : _b2._redirectEventId) === id2) {
        return this.redirectUser;
      }
      return null;
    }
    async _persistUserIfCurrent(user) {
      if (user === this.currentUser) {
        return this.queue(async () => this.directlySetCurrentUser(user));
      }
    }
    /** Notifies listeners only if the user is current */
    _notifyListenersIfCurrent(user) {
      if (user === this.currentUser) {
        this.notifyAuthListeners();
      }
    }
    _key() {
      return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
    }
    _startProactiveRefresh() {
      this.isProactiveRefreshEnabled = true;
      if (this.currentUser) {
        this._currentUser._startProactiveRefresh();
      }
    }
    _stopProactiveRefresh() {
      this.isProactiveRefreshEnabled = false;
      if (this.currentUser) {
        this._currentUser._stopProactiveRefresh();
      }
    }
    /** Returns the current user cast as the internal type */
    get _currentUser() {
      return this.currentUser;
    }
    notifyAuthListeners() {
      var _a2, _b2;
      if (!this._isInitialized) {
        return;
      }
      this.idTokenSubscription.next(this.currentUser);
      const currentUid = (_b2 = (_a2 = this.currentUser) === null || _a2 === void 0 ? void 0 : _a2.uid) !== null && _b2 !== void 0 ? _b2 : null;
      if (this.lastNotifiedUid !== currentUid) {
        this.lastNotifiedUid = currentUid;
        this.authStateSubscription.next(this.currentUser);
      }
    }
    registerStateListener(subscription, nextOrObserver, error, completed) {
      if (this._deleted) {
        return () => {
        };
      }
      const cb = typeof nextOrObserver === "function" ? nextOrObserver : nextOrObserver.next.bind(nextOrObserver);
      let isUnsubscribed = false;
      const promise = this._isInitialized ? Promise.resolve() : this._initializationPromise;
      _assert(
        promise,
        this,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      promise.then(() => {
        if (isUnsubscribed) {
          return;
        }
        cb(this.currentUser);
      });
      if (typeof nextOrObserver === "function") {
        const unsubscribe = subscription.addObserver(nextOrObserver, error, completed);
        return () => {
          isUnsubscribed = true;
          unsubscribe();
        };
      } else {
        const unsubscribe = subscription.addObserver(nextOrObserver);
        return () => {
          isUnsubscribed = true;
          unsubscribe();
        };
      }
    }
    /**
     * Unprotected (from race conditions) method to set the current user. This
     * should only be called from within a queued callback. This is necessary
     * because the queue shouldn't rely on another queued callback.
     */
    async directlySetCurrentUser(user) {
      if (this.currentUser && this.currentUser !== user) {
        this._currentUser._stopProactiveRefresh();
      }
      if (user && this.isProactiveRefreshEnabled) {
        user._startProactiveRefresh();
      }
      this.currentUser = user;
      if (user) {
        await this.assertedPersistence.setCurrentUser(user);
      } else {
        await this.assertedPersistence.removeCurrentUser();
      }
    }
    queue(action) {
      this.operations = this.operations.then(action, action);
      return this.operations;
    }
    get assertedPersistence() {
      _assert(
        this.persistenceManager,
        this,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      return this.persistenceManager;
    }
    _logFramework(framework) {
      if (!framework || this.frameworks.includes(framework)) {
        return;
      }
      this.frameworks.push(framework);
      this.frameworks.sort();
      this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());
    }
    _getFrameworks() {
      return this.frameworks;
    }
    async _getAdditionalHeaders() {
      var _a2;
      const headers = {
        [
          "X-Client-Version"
          /* HttpHeader.X_CLIENT_VERSION */
        ]: this.clientVersion
      };
      if (this.app.options.appId) {
        headers[
          "X-Firebase-gmpid"
          /* HttpHeader.X_FIREBASE_GMPID */
        ] = this.app.options.appId;
      }
      const heartbeatsHeader = await ((_a2 = this.heartbeatServiceProvider.getImmediate({
        optional: true
      })) === null || _a2 === void 0 ? void 0 : _a2.getHeartbeatsHeader());
      if (heartbeatsHeader) {
        headers[
          "X-Firebase-Client"
          /* HttpHeader.X_FIREBASE_CLIENT */
        ] = heartbeatsHeader;
      }
      const appCheckToken = await this._getAppCheckToken();
      if (appCheckToken) {
        headers[
          "X-Firebase-AppCheck"
          /* HttpHeader.X_FIREBASE_APP_CHECK */
        ] = appCheckToken;
      }
      return headers;
    }
    async _getAppCheckToken() {
      var _a2;
      const appCheckTokenResult = await ((_a2 = this.appCheckServiceProvider.getImmediate({ optional: true })) === null || _a2 === void 0 ? void 0 : _a2.getToken());
      if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {
        _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);
      }
      return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;
    }
  }
  function _castAuth(auth) {
    return getModularInstance(auth);
  }
  class Subscription {
    constructor(auth) {
      this.auth = auth;
      this.observer = null;
      this.addObserver = createSubscribe((observer) => this.observer = observer);
    }
    get next() {
      _assert(
        this.observer,
        this.auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      return this.observer.next.bind(this.observer);
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let externalJSProvider = {
    async loadJS() {
      throw new Error("Unable to load external scripts");
    },
    recaptchaV2Script: "",
    recaptchaEnterpriseScript: "",
    gapiScript: ""
  };
  function _setExternalJSProvider(p) {
    externalJSProvider = p;
  }
  function _loadJS(url) {
    return externalJSProvider.loadJS(url);
  }
  function _gapiScriptUrl() {
    return externalJSProvider.gapiScript;
  }
  function _generateCallbackName(prefix) {
    return `__${prefix}${Math.floor(Math.random() * 1e6)}`;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function initializeAuth(app, deps) {
    const provider = _getProvider(app, "auth");
    if (provider.isInitialized()) {
      const auth2 = provider.getImmediate();
      const initialOptions = provider.getOptions();
      if (deepEqual(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {
        return auth2;
      } else {
        _fail(
          auth2,
          "already-initialized"
          /* AuthErrorCode.ALREADY_INITIALIZED */
        );
      }
    }
    const auth = provider.initialize({ options: deps });
    return auth;
  }
  function _initializeAuthInstance(auth, deps) {
    const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];
    const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);
    if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {
      auth._updateErrorMap(deps.errorMap);
    }
    auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);
  }
  function connectAuthEmulator(auth, url, options2) {
    const authInternal = _castAuth(auth);
    _assert(
      authInternal._canInitEmulator,
      authInternal,
      "emulator-config-failed"
      /* AuthErrorCode.EMULATOR_CONFIG_FAILED */
    );
    _assert(
      /^https?:\/\//.test(url),
      authInternal,
      "invalid-emulator-scheme"
      /* AuthErrorCode.INVALID_EMULATOR_SCHEME */
    );
    const disableWarnings = false;
    const protocol = extractProtocol(url);
    const { host, port } = extractHostAndPort(url);
    const portStr = port === null ? "" : `:${port}`;
    authInternal.config.emulator = { url: `${protocol}//${host}${portStr}/` };
    authInternal.settings.appVerificationDisabledForTesting = true;
    authInternal.emulatorConfig = Object.freeze({
      host,
      port,
      protocol: protocol.replace(":", ""),
      options: Object.freeze({ disableWarnings })
    });
    {
      emitEmulatorWarning();
    }
  }
  function extractProtocol(url) {
    const protocolEnd = url.indexOf(":");
    return protocolEnd < 0 ? "" : url.substr(0, protocolEnd + 1);
  }
  function extractHostAndPort(url) {
    const protocol = extractProtocol(url);
    const authority = /(\/\/)?([^?#/]+)/.exec(url.substr(protocol.length));
    if (!authority) {
      return { host: "", port: null };
    }
    const hostAndPort = authority[2].split("@").pop() || "";
    const bracketedIPv6 = /^(\[[^\]]+\])(:|$)/.exec(hostAndPort);
    if (bracketedIPv6) {
      const host = bracketedIPv6[1];
      return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };
    } else {
      const [host, port] = hostAndPort.split(":");
      return { host, port: parsePort(port) };
    }
  }
  function parsePort(portStr) {
    if (!portStr) {
      return null;
    }
    const port = Number(portStr);
    if (isNaN(port)) {
      return null;
    }
    return port;
  }
  function emitEmulatorWarning() {
    function attachBanner() {
      const el = document.createElement("p");
      const sty = el.style;
      el.innerText = "Running in emulator mode. Do not use with production credentials.";
      sty.position = "fixed";
      sty.width = "100%";
      sty.backgroundColor = "#ffffff";
      sty.border = ".1em solid #000000";
      sty.color = "#b50000";
      sty.bottom = "0px";
      sty.left = "0px";
      sty.margin = "0px";
      sty.zIndex = "10000";
      sty.textAlign = "center";
      el.classList.add("firebase-emulator-warning");
      document.body.appendChild(el);
    }
    if (typeof console !== "undefined" && typeof console.info === "function") {
      console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
    }
    if (typeof window !== "undefined" && typeof document !== "undefined") {
      if (document.readyState === "loading") {
        window.addEventListener("DOMContentLoaded", attachBanner);
      } else {
        attachBanner();
      }
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class AuthCredential {
    /** @internal */
    constructor(providerId, signInMethod) {
      this.providerId = providerId;
      this.signInMethod = signInMethod;
    }
    /**
     * Returns a JSON-serializable representation of this object.
     *
     * @returns a JSON-serializable representation of this object.
     */
    toJSON() {
      return debugFail("not implemented");
    }
    /** @internal */
    _getIdTokenResponse(_auth) {
      return debugFail("not implemented");
    }
    /** @internal */
    _linkToIdToken(_auth, _idToken) {
      return debugFail("not implemented");
    }
    /** @internal */
    _getReauthenticationResolver(_auth) {
      return debugFail("not implemented");
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function signInWithIdp(auth, request) {
    return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithIdp", _addTidIfNecessary(auth, request));
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const IDP_REQUEST_URI$1 = "http://localhost";
  class OAuthCredential extends AuthCredential {
    constructor() {
      super(...arguments);
      this.pendingToken = null;
    }
    /** @internal */
    static _fromParams(params) {
      const cred = new OAuthCredential(params.providerId, params.signInMethod);
      if (params.idToken || params.accessToken) {
        if (params.idToken) {
          cred.idToken = params.idToken;
        }
        if (params.accessToken) {
          cred.accessToken = params.accessToken;
        }
        if (params.nonce && !params.pendingToken) {
          cred.nonce = params.nonce;
        }
        if (params.pendingToken) {
          cred.pendingToken = params.pendingToken;
        }
      } else if (params.oauthToken && params.oauthTokenSecret) {
        cred.accessToken = params.oauthToken;
        cred.secret = params.oauthTokenSecret;
      } else {
        _fail(
          "argument-error"
          /* AuthErrorCode.ARGUMENT_ERROR */
        );
      }
      return cred;
    }
    /** {@inheritdoc AuthCredential.toJSON}  */
    toJSON() {
      return {
        idToken: this.idToken,
        accessToken: this.accessToken,
        secret: this.secret,
        nonce: this.nonce,
        pendingToken: this.pendingToken,
        providerId: this.providerId,
        signInMethod: this.signInMethod
      };
    }
    /**
     * Static method to deserialize a JSON representation of an object into an
     * {@link  AuthCredential}.
     *
     * @param json - Input can be either Object or the stringified representation of the object.
     * When string is provided, JSON.parse would be called first.
     *
     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
     */
    static fromJSON(json) {
      const obj = typeof json === "string" ? JSON.parse(json) : json;
      const { providerId, signInMethod } = obj, rest = __rest(obj, ["providerId", "signInMethod"]);
      if (!providerId || !signInMethod) {
        return null;
      }
      const cred = new OAuthCredential(providerId, signInMethod);
      cred.idToken = rest.idToken || void 0;
      cred.accessToken = rest.accessToken || void 0;
      cred.secret = rest.secret;
      cred.nonce = rest.nonce;
      cred.pendingToken = rest.pendingToken || null;
      return cred;
    }
    /** @internal */
    _getIdTokenResponse(auth) {
      const request = this.buildRequest();
      return signInWithIdp(auth, request);
    }
    /** @internal */
    _linkToIdToken(auth, idToken) {
      const request = this.buildRequest();
      request.idToken = idToken;
      return signInWithIdp(auth, request);
    }
    /** @internal */
    _getReauthenticationResolver(auth) {
      const request = this.buildRequest();
      request.autoCreate = false;
      return signInWithIdp(auth, request);
    }
    buildRequest() {
      const request = {
        requestUri: IDP_REQUEST_URI$1,
        returnSecureToken: true
      };
      if (this.pendingToken) {
        request.pendingToken = this.pendingToken;
      } else {
        const postBody = {};
        if (this.idToken) {
          postBody["id_token"] = this.idToken;
        }
        if (this.accessToken) {
          postBody["access_token"] = this.accessToken;
        }
        if (this.secret) {
          postBody["oauth_token_secret"] = this.secret;
        }
        postBody["providerId"] = this.providerId;
        if (this.nonce && !this.pendingToken) {
          postBody["nonce"] = this.nonce;
        }
        request.postBody = querystring(postBody);
      }
      return request;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class FederatedAuthProvider {
    /**
     * Constructor for generic OAuth providers.
     *
     * @param providerId - Provider for which credentials should be generated.
     */
    constructor(providerId) {
      this.providerId = providerId;
      this.defaultLanguageCode = null;
      this.customParameters = {};
    }
    /**
     * Set the language gode.
     *
     * @param languageCode - language code
     */
    setDefaultLanguage(languageCode) {
      this.defaultLanguageCode = languageCode;
    }
    /**
     * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in
     * operations.
     *
     * @remarks
     * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,
     * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.
     *
     * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.
     */
    setCustomParameters(customOAuthParameters) {
      this.customParameters = customOAuthParameters;
      return this;
    }
    /**
     * Retrieve the current list of {@link CustomParameters}.
     */
    getCustomParameters() {
      return this.customParameters;
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class BaseOAuthProvider extends FederatedAuthProvider {
    constructor() {
      super(...arguments);
      this.scopes = [];
    }
    /**
     * Add an OAuth scope to the credential.
     *
     * @param scope - Provider OAuth scope to add.
     */
    addScope(scope) {
      if (!this.scopes.includes(scope)) {
        this.scopes.push(scope);
      }
      return this;
    }
    /**
     * Retrieve the current list of OAuth scopes.
     */
    getScopes() {
      return [...this.scopes];
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class FacebookAuthProvider extends BaseOAuthProvider {
    constructor() {
      super(
        "facebook.com"
        /* ProviderId.FACEBOOK */
      );
    }
    /**
     * Creates a credential for Facebook.
     *
     * @example
     * ```javascript
     * // `event` from the Facebook auth.authResponseChange callback.
     * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);
     * const result = await signInWithCredential(credential);
     * ```
     *
     * @param accessToken - Facebook access token.
     */
    static credential(accessToken) {
      return OAuthCredential._fromParams({
        providerId: FacebookAuthProvider.PROVIDER_ID,
        signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
        accessToken
      });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
      return FacebookAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
      return FacebookAuthProvider.credentialFromTaggedObject(error.customData || {});
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
      if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
        return null;
      }
      if (!tokenResponse.oauthAccessToken) {
        return null;
      }
      try {
        return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);
      } catch (_a2) {
        return null;
      }
    }
  }
  FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
  FacebookAuthProvider.PROVIDER_ID = "facebook.com";
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class GoogleAuthProvider extends BaseOAuthProvider {
    constructor() {
      super(
        "google.com"
        /* ProviderId.GOOGLE */
      );
      this.addScope("profile");
    }
    /**
     * Creates a credential for Google. At least one of ID token and access token is required.
     *
     * @example
     * ```javascript
     * // \`googleUser\` from the onsuccess Google Sign In callback.
     * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);
     * const result = await signInWithCredential(credential);
     * ```
     *
     * @param idToken - Google ID token.
     * @param accessToken - Google access token.
     */
    static credential(idToken, accessToken) {
      return OAuthCredential._fromParams({
        providerId: GoogleAuthProvider.PROVIDER_ID,
        signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
        idToken,
        accessToken
      });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
      return GoogleAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
      return GoogleAuthProvider.credentialFromTaggedObject(error.customData || {});
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
      if (!tokenResponse) {
        return null;
      }
      const { oauthIdToken, oauthAccessToken } = tokenResponse;
      if (!oauthIdToken && !oauthAccessToken) {
        return null;
      }
      try {
        return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);
      } catch (_a2) {
        return null;
      }
    }
  }
  GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com";
  GoogleAuthProvider.PROVIDER_ID = "google.com";
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class GithubAuthProvider extends BaseOAuthProvider {
    constructor() {
      super(
        "github.com"
        /* ProviderId.GITHUB */
      );
    }
    /**
     * Creates a credential for GitHub.
     *
     * @param accessToken - GitHub access token.
     */
    static credential(accessToken) {
      return OAuthCredential._fromParams({
        providerId: GithubAuthProvider.PROVIDER_ID,
        signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
        accessToken
      });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
      return GithubAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
      return GithubAuthProvider.credentialFromTaggedObject(error.customData || {});
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
      if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
        return null;
      }
      if (!tokenResponse.oauthAccessToken) {
        return null;
      }
      try {
        return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);
      } catch (_a2) {
        return null;
      }
    }
  }
  GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com";
  GithubAuthProvider.PROVIDER_ID = "github.com";
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class TwitterAuthProvider extends BaseOAuthProvider {
    constructor() {
      super(
        "twitter.com"
        /* ProviderId.TWITTER */
      );
    }
    /**
     * Creates a credential for Twitter.
     *
     * @param token - Twitter access token.
     * @param secret - Twitter secret.
     */
    static credential(token, secret) {
      return OAuthCredential._fromParams({
        providerId: TwitterAuthProvider.PROVIDER_ID,
        signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
        oauthToken: token,
        oauthTokenSecret: secret
      });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
      return TwitterAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
      return TwitterAuthProvider.credentialFromTaggedObject(error.customData || {});
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
      if (!tokenResponse) {
        return null;
      }
      const { oauthAccessToken, oauthTokenSecret } = tokenResponse;
      if (!oauthAccessToken || !oauthTokenSecret) {
        return null;
      }
      try {
        return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);
      } catch (_a2) {
        return null;
      }
    }
  }
  TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com";
  TwitterAuthProvider.PROVIDER_ID = "twitter.com";
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class UserCredentialImpl {
    constructor(params) {
      this.user = params.user;
      this.providerId = params.providerId;
      this._tokenResponse = params._tokenResponse;
      this.operationType = params.operationType;
    }
    static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {
      const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);
      const providerId = providerIdForResponse(idTokenResponse);
      const userCred = new UserCredentialImpl({
        user,
        providerId,
        _tokenResponse: idTokenResponse,
        operationType
      });
      return userCred;
    }
    static async _forOperation(user, operationType, response) {
      await user._updateTokensIfNecessary(
        response,
        /* reload */
        true
      );
      const providerId = providerIdForResponse(response);
      return new UserCredentialImpl({
        user,
        providerId,
        _tokenResponse: response,
        operationType
      });
    }
  }
  function providerIdForResponse(response) {
    if (response.providerId) {
      return response.providerId;
    }
    if ("phoneNumber" in response) {
      return "phone";
    }
    return null;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class MultiFactorError extends FirebaseError {
    constructor(auth, error, operationType, user) {
      var _a2;
      super(error.code, error.message);
      this.operationType = operationType;
      this.user = user;
      Object.setPrototypeOf(this, MultiFactorError.prototype);
      this.customData = {
        appName: auth.name,
        tenantId: (_a2 = auth.tenantId) !== null && _a2 !== void 0 ? _a2 : void 0,
        _serverResponse: error.customData._serverResponse,
        operationType
      };
    }
    static _fromErrorAndOperation(auth, error, operationType, user) {
      return new MultiFactorError(auth, error, operationType, user);
    }
  }
  function _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {
    const idTokenProvider = operationType === "reauthenticate" ? credential._getReauthenticationResolver(auth) : credential._getIdTokenResponse(auth);
    return idTokenProvider.catch((error) => {
      if (error.code === `auth/${"multi-factor-auth-required"}`) {
        throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);
      }
      throw error;
    });
  }
  async function _link$1(user, credential, bypassAuthState = false) {
    const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);
    return UserCredentialImpl._forOperation(user, "link", response);
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function _reauthenticate(user, credential, bypassAuthState = false) {
    const { auth } = user;
    if (_isFirebaseServerApp(auth.app)) {
      return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));
    }
    const operationType = "reauthenticate";
    try {
      const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);
      _assert(
        response.idToken,
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      const parsed = _parseToken(response.idToken);
      _assert(
        parsed,
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      const { sub: localId } = parsed;
      _assert(
        user.uid === localId,
        auth,
        "user-mismatch"
        /* AuthErrorCode.USER_MISMATCH */
      );
      return UserCredentialImpl._forOperation(user, operationType, response);
    } catch (e) {
      if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${"user-not-found"}`) {
        _fail(
          auth,
          "user-mismatch"
          /* AuthErrorCode.USER_MISMATCH */
        );
      }
      throw e;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function _signInWithCredential(auth, credential, bypassAuthState = false) {
    if (_isFirebaseServerApp(auth.app)) {
      return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));
    }
    const operationType = "signIn";
    const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);
    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);
    if (!bypassAuthState) {
      await auth._updateCurrentUser(userCredential.user);
    }
    return userCredential;
  }
  function onIdTokenChanged(auth, nextOrObserver, error, completed) {
    return getModularInstance(auth).onIdTokenChanged(nextOrObserver, error, completed);
  }
  function beforeAuthStateChanged(auth, callback, onAbort) {
    return getModularInstance(auth).beforeAuthStateChanged(callback, onAbort);
  }
  const STORAGE_AVAILABLE_KEY = "__sak";
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class BrowserPersistenceClass {
    constructor(storageRetriever, type) {
      this.storageRetriever = storageRetriever;
      this.type = type;
    }
    _isAvailable() {
      try {
        if (!this.storage) {
          return Promise.resolve(false);
        }
        this.storage.setItem(STORAGE_AVAILABLE_KEY, "1");
        this.storage.removeItem(STORAGE_AVAILABLE_KEY);
        return Promise.resolve(true);
      } catch (_a2) {
        return Promise.resolve(false);
      }
    }
    _set(key, value) {
      this.storage.setItem(key, JSON.stringify(value));
      return Promise.resolve();
    }
    _get(key) {
      const json = this.storage.getItem(key);
      return Promise.resolve(json ? JSON.parse(json) : null);
    }
    _remove(key) {
      this.storage.removeItem(key);
      return Promise.resolve();
    }
    get storage() {
      return this.storageRetriever();
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const _POLLING_INTERVAL_MS$1 = 1e3;
  const IE10_LOCAL_STORAGE_SYNC_DELAY = 10;
  class BrowserLocalPersistence extends BrowserPersistenceClass {
    constructor() {
      super(
        () => window.localStorage,
        "LOCAL"
        /* PersistenceType.LOCAL */
      );
      this.boundEventHandler = (event, poll) => this.onStorageEvent(event, poll);
      this.listeners = {};
      this.localCache = {};
      this.pollTimer = null;
      this.fallbackToPolling = _isMobileBrowser();
      this._shouldAllowMigration = true;
    }
    forAllChangedKeys(cb) {
      for (const key of Object.keys(this.listeners)) {
        const newValue = this.storage.getItem(key);
        const oldValue = this.localCache[key];
        if (newValue !== oldValue) {
          cb(key, oldValue, newValue);
        }
      }
    }
    onStorageEvent(event, poll = false) {
      if (!event.key) {
        this.forAllChangedKeys((key2, _oldValue, newValue) => {
          this.notifyListeners(key2, newValue);
        });
        return;
      }
      const key = event.key;
      if (poll) {
        this.detachListener();
      } else {
        this.stopPolling();
      }
      const triggerListeners = () => {
        const storedValue2 = this.storage.getItem(key);
        if (!poll && this.localCache[key] === storedValue2) {
          return;
        }
        this.notifyListeners(key, storedValue2);
      };
      const storedValue = this.storage.getItem(key);
      if (_isIE10() && storedValue !== event.newValue && event.newValue !== event.oldValue) {
        setTimeout(triggerListeners, IE10_LOCAL_STORAGE_SYNC_DELAY);
      } else {
        triggerListeners();
      }
    }
    notifyListeners(key, value) {
      this.localCache[key] = value;
      const listeners = this.listeners[key];
      if (listeners) {
        for (const listener of Array.from(listeners)) {
          listener(value ? JSON.parse(value) : value);
        }
      }
    }
    startPolling() {
      this.stopPolling();
      this.pollTimer = setInterval(() => {
        this.forAllChangedKeys((key, oldValue, newValue) => {
          this.onStorageEvent(
            new StorageEvent("storage", {
              key,
              oldValue,
              newValue
            }),
            /* poll */
            true
          );
        });
      }, _POLLING_INTERVAL_MS$1);
    }
    stopPolling() {
      if (this.pollTimer) {
        clearInterval(this.pollTimer);
        this.pollTimer = null;
      }
    }
    attachListener() {
      window.addEventListener("storage", this.boundEventHandler);
    }
    detachListener() {
      window.removeEventListener("storage", this.boundEventHandler);
    }
    _addListener(key, listener) {
      if (Object.keys(this.listeners).length === 0) {
        if (this.fallbackToPolling) {
          this.startPolling();
        } else {
          this.attachListener();
        }
      }
      if (!this.listeners[key]) {
        this.listeners[key] = /* @__PURE__ */ new Set();
        this.localCache[key] = this.storage.getItem(key);
      }
      this.listeners[key].add(listener);
    }
    _removeListener(key, listener) {
      if (this.listeners[key]) {
        this.listeners[key].delete(listener);
        if (this.listeners[key].size === 0) {
          delete this.listeners[key];
        }
      }
      if (Object.keys(this.listeners).length === 0) {
        this.detachListener();
        this.stopPolling();
      }
    }
    // Update local cache on base operations:
    async _set(key, value) {
      await super._set(key, value);
      this.localCache[key] = JSON.stringify(value);
    }
    async _get(key) {
      const value = await super._get(key);
      this.localCache[key] = JSON.stringify(value);
      return value;
    }
    async _remove(key) {
      await super._remove(key);
      delete this.localCache[key];
    }
  }
  BrowserLocalPersistence.type = "LOCAL";
  const browserLocalPersistence = BrowserLocalPersistence;
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class BrowserSessionPersistence extends BrowserPersistenceClass {
    constructor() {
      super(
        () => window.sessionStorage,
        "SESSION"
        /* PersistenceType.SESSION */
      );
    }
    _addListener(_key, _listener) {
      return;
    }
    _removeListener(_key, _listener) {
      return;
    }
  }
  BrowserSessionPersistence.type = "SESSION";
  const browserSessionPersistence = BrowserSessionPersistence;
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _allSettled(promises) {
    return Promise.all(promises.map(async (promise) => {
      try {
        const value = await promise;
        return {
          fulfilled: true,
          value
        };
      } catch (reason) {
        return {
          fulfilled: false,
          reason
        };
      }
    }));
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Receiver {
    constructor(eventTarget) {
      this.eventTarget = eventTarget;
      this.handlersMap = {};
      this.boundEventHandler = this.handleEvent.bind(this);
    }
    /**
     * Obtain an instance of a Receiver for a given event target, if none exists it will be created.
     *
     * @param eventTarget - An event target (such as window or self) through which the underlying
     * messages will be received.
     */
    static _getInstance(eventTarget) {
      const existingInstance = this.receivers.find((receiver) => receiver.isListeningto(eventTarget));
      if (existingInstance) {
        return existingInstance;
      }
      const newInstance = new Receiver(eventTarget);
      this.receivers.push(newInstance);
      return newInstance;
    }
    isListeningto(eventTarget) {
      return this.eventTarget === eventTarget;
    }
    /**
     * Fans out a MessageEvent to the appropriate listeners.
     *
     * @remarks
     * Sends an {@link Status.ACK} upon receipt and a {@link Status.DONE} once all handlers have
     * finished processing.
     *
     * @param event - The MessageEvent.
     *
     */
    async handleEvent(event) {
      const messageEvent = event;
      const { eventId, eventType, data } = messageEvent.data;
      const handlers2 = this.handlersMap[eventType];
      if (!(handlers2 === null || handlers2 === void 0 ? void 0 : handlers2.size)) {
        return;
      }
      messageEvent.ports[0].postMessage({
        status: "ack",
        eventId,
        eventType
      });
      const promises = Array.from(handlers2).map(async (handler) => handler(messageEvent.origin, data));
      const response = await _allSettled(promises);
      messageEvent.ports[0].postMessage({
        status: "done",
        eventId,
        eventType,
        response
      });
    }
    /**
     * Subscribe an event handler for a particular event.
     *
     * @param eventType - Event name to subscribe to.
     * @param eventHandler - The event handler which should receive the events.
     *
     */
    _subscribe(eventType, eventHandler) {
      if (Object.keys(this.handlersMap).length === 0) {
        this.eventTarget.addEventListener("message", this.boundEventHandler);
      }
      if (!this.handlersMap[eventType]) {
        this.handlersMap[eventType] = /* @__PURE__ */ new Set();
      }
      this.handlersMap[eventType].add(eventHandler);
    }
    /**
     * Unsubscribe an event handler from a particular event.
     *
     * @param eventType - Event name to unsubscribe from.
     * @param eventHandler - Optional event handler, if none provided, unsubscribe all handlers on this event.
     *
     */
    _unsubscribe(eventType, eventHandler) {
      if (this.handlersMap[eventType] && eventHandler) {
        this.handlersMap[eventType].delete(eventHandler);
      }
      if (!eventHandler || this.handlersMap[eventType].size === 0) {
        delete this.handlersMap[eventType];
      }
      if (Object.keys(this.handlersMap).length === 0) {
        this.eventTarget.removeEventListener("message", this.boundEventHandler);
      }
    }
  }
  Receiver.receivers = [];
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _generateEventId(prefix = "", digits = 10) {
    let random = "";
    for (let i = 0; i < digits; i++) {
      random += Math.floor(Math.random() * 10);
    }
    return prefix + random;
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Sender {
    constructor(target) {
      this.target = target;
      this.handlers = /* @__PURE__ */ new Set();
    }
    /**
     * Unsubscribe the handler and remove it from our tracking Set.
     *
     * @param handler - The handler to unsubscribe.
     */
    removeMessageHandler(handler) {
      if (handler.messageChannel) {
        handler.messageChannel.port1.removeEventListener("message", handler.onMessage);
        handler.messageChannel.port1.close();
      }
      this.handlers.delete(handler);
    }
    /**
     * Send a message to the Receiver located at {@link target}.
     *
     * @remarks
     * We'll first wait a bit for an ACK , if we get one we will wait significantly longer until the
     * receiver has had a chance to fully process the event.
     *
     * @param eventType - Type of event to send.
     * @param data - The payload of the event.
     * @param timeout - Timeout for waiting on an ACK from the receiver.
     *
     * @returns An array of settled promises from all the handlers that were listening on the receiver.
     */
    async _send(eventType, data, timeout = 50) {
      const messageChannel = typeof MessageChannel !== "undefined" ? new MessageChannel() : null;
      if (!messageChannel) {
        throw new Error(
          "connection_unavailable"
          /* _MessageError.CONNECTION_UNAVAILABLE */
        );
      }
      let completionTimer;
      let handler;
      return new Promise((resolve, reject) => {
        const eventId = _generateEventId("", 20);
        messageChannel.port1.start();
        const ackTimer = setTimeout(() => {
          reject(new Error(
            "unsupported_event"
            /* _MessageError.UNSUPPORTED_EVENT */
          ));
        }, timeout);
        handler = {
          messageChannel,
          onMessage(event) {
            const messageEvent = event;
            if (messageEvent.data.eventId !== eventId) {
              return;
            }
            switch (messageEvent.data.status) {
              case "ack":
                clearTimeout(ackTimer);
                completionTimer = setTimeout(
                  () => {
                    reject(new Error(
                      "timeout"
                      /* _MessageError.TIMEOUT */
                    ));
                  },
                  3e3
                  /* _TimeoutDuration.COMPLETION */
                );
                break;
              case "done":
                clearTimeout(completionTimer);
                resolve(messageEvent.data.response);
                break;
              default:
                clearTimeout(ackTimer);
                clearTimeout(completionTimer);
                reject(new Error(
                  "invalid_response"
                  /* _MessageError.INVALID_RESPONSE */
                ));
                break;
            }
          }
        };
        this.handlers.add(handler);
        messageChannel.port1.addEventListener("message", handler.onMessage);
        this.target.postMessage({
          eventType,
          eventId,
          data
        }, [messageChannel.port2]);
      }).finally(() => {
        if (handler) {
          this.removeMessageHandler(handler);
        }
      });
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _window() {
    return window;
  }
  function _setWindowLocation(url) {
    _window().location.href = url;
  }
  /**
   * @license
   * Copyright 2020 Google LLC.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _isWorker() {
    return typeof _window()["WorkerGlobalScope"] !== "undefined" && typeof _window()["importScripts"] === "function";
  }
  async function _getActiveServiceWorker() {
    if (!(navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker)) {
      return null;
    }
    try {
      const registration = await navigator.serviceWorker.ready;
      return registration.active;
    } catch (_a2) {
      return null;
    }
  }
  function _getServiceWorkerController() {
    var _a2;
    return ((_a2 = navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker) === null || _a2 === void 0 ? void 0 : _a2.controller) || null;
  }
  function _getWorkerGlobalScope() {
    return _isWorker() ? self : null;
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const DB_NAME = "firebaseLocalStorageDb";
  const DB_VERSION = 1;
  const DB_OBJECTSTORE_NAME = "firebaseLocalStorage";
  const DB_DATA_KEYPATH = "fbase_key";
  class DBPromise {
    constructor(request) {
      this.request = request;
    }
    toPromise() {
      return new Promise((resolve, reject) => {
        this.request.addEventListener("success", () => {
          resolve(this.request.result);
        });
        this.request.addEventListener("error", () => {
          reject(this.request.error);
        });
      });
    }
  }
  function getObjectStore(db, isReadWrite) {
    return db.transaction([DB_OBJECTSTORE_NAME], isReadWrite ? "readwrite" : "readonly").objectStore(DB_OBJECTSTORE_NAME);
  }
  function _deleteDatabase() {
    const request = indexedDB.deleteDatabase(DB_NAME);
    return new DBPromise(request).toPromise();
  }
  function _openDatabase() {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    return new Promise((resolve, reject) => {
      request.addEventListener("error", () => {
        reject(request.error);
      });
      request.addEventListener("upgradeneeded", () => {
        const db = request.result;
        try {
          db.createObjectStore(DB_OBJECTSTORE_NAME, { keyPath: DB_DATA_KEYPATH });
        } catch (e) {
          reject(e);
        }
      });
      request.addEventListener("success", async () => {
        const db = request.result;
        if (!db.objectStoreNames.contains(DB_OBJECTSTORE_NAME)) {
          db.close();
          await _deleteDatabase();
          resolve(await _openDatabase());
        } else {
          resolve(db);
        }
      });
    });
  }
  async function _putObject(db, key, value) {
    const request = getObjectStore(db, true).put({
      [DB_DATA_KEYPATH]: key,
      value
    });
    return new DBPromise(request).toPromise();
  }
  async function getObject(db, key) {
    const request = getObjectStore(db, false).get(key);
    const data = await new DBPromise(request).toPromise();
    return data === void 0 ? null : data.value;
  }
  function _deleteObject(db, key) {
    const request = getObjectStore(db, true).delete(key);
    return new DBPromise(request).toPromise();
  }
  const _POLLING_INTERVAL_MS = 800;
  const _TRANSACTION_RETRY_COUNT = 3;
  class IndexedDBLocalPersistence {
    constructor() {
      this.type = "LOCAL";
      this._shouldAllowMigration = true;
      this.listeners = {};
      this.localCache = {};
      this.pollTimer = null;
      this.pendingWrites = 0;
      this.receiver = null;
      this.sender = null;
      this.serviceWorkerReceiverAvailable = false;
      this.activeServiceWorker = null;
      this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {
      }, () => {
      });
    }
    async _openDb() {
      if (this.db) {
        return this.db;
      }
      this.db = await _openDatabase();
      return this.db;
    }
    async _withRetries(op) {
      let numAttempts = 0;
      while (true) {
        try {
          const db = await this._openDb();
          return await op(db);
        } catch (e) {
          if (numAttempts++ > _TRANSACTION_RETRY_COUNT) {
            throw e;
          }
          if (this.db) {
            this.db.close();
            this.db = void 0;
          }
        }
      }
    }
    /**
     * IndexedDB events do not propagate from the main window to the worker context.  We rely on a
     * postMessage interface to send these events to the worker ourselves.
     */
    async initializeServiceWorkerMessaging() {
      return _isWorker() ? this.initializeReceiver() : this.initializeSender();
    }
    /**
     * As the worker we should listen to events from the main window.
     */
    async initializeReceiver() {
      this.receiver = Receiver._getInstance(_getWorkerGlobalScope());
      this.receiver._subscribe("keyChanged", async (_origin, data) => {
        const keys2 = await this._poll();
        return {
          keyProcessed: keys2.includes(data.key)
        };
      });
      this.receiver._subscribe("ping", async (_origin, _data) => {
        return [
          "keyChanged"
          /* _EventType.KEY_CHANGED */
        ];
      });
    }
    /**
     * As the main window, we should let the worker know when keys change (set and remove).
     *
     * @remarks
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/ready | ServiceWorkerContainer.ready}
     * may not resolve.
     */
    async initializeSender() {
      var _a2, _b2;
      this.activeServiceWorker = await _getActiveServiceWorker();
      if (!this.activeServiceWorker) {
        return;
      }
      this.sender = new Sender(this.activeServiceWorker);
      const results = await this.sender._send(
        "ping",
        {},
        800
        /* _TimeoutDuration.LONG_ACK */
      );
      if (!results) {
        return;
      }
      if (((_a2 = results[0]) === null || _a2 === void 0 ? void 0 : _a2.fulfilled) && ((_b2 = results[0]) === null || _b2 === void 0 ? void 0 : _b2.value.includes(
        "keyChanged"
        /* _EventType.KEY_CHANGED */
      ))) {
        this.serviceWorkerReceiverAvailable = true;
      }
    }
    /**
     * Let the worker know about a changed key, the exact key doesn't technically matter since the
     * worker will just trigger a full sync anyway.
     *
     * @remarks
     * For now, we only support one service worker per page.
     *
     * @param key - Storage key which changed.
     */
    async notifyServiceWorker(key) {
      if (!this.sender || !this.activeServiceWorker || _getServiceWorkerController() !== this.activeServiceWorker) {
        return;
      }
      try {
        await this.sender._send(
          "keyChanged",
          { key },
          // Use long timeout if receiver has previously responded to a ping from us.
          this.serviceWorkerReceiverAvailable ? 800 : 50
          /* _TimeoutDuration.ACK */
        );
      } catch (_a2) {
      }
    }
    async _isAvailable() {
      try {
        if (!indexedDB) {
          return false;
        }
        const db = await _openDatabase();
        await _putObject(db, STORAGE_AVAILABLE_KEY, "1");
        await _deleteObject(db, STORAGE_AVAILABLE_KEY);
        return true;
      } catch (_a2) {
      }
      return false;
    }
    async _withPendingWrite(write) {
      this.pendingWrites++;
      try {
        await write();
      } finally {
        this.pendingWrites--;
      }
    }
    async _set(key, value) {
      return this._withPendingWrite(async () => {
        await this._withRetries((db) => _putObject(db, key, value));
        this.localCache[key] = value;
        return this.notifyServiceWorker(key);
      });
    }
    async _get(key) {
      const obj = await this._withRetries((db) => getObject(db, key));
      this.localCache[key] = obj;
      return obj;
    }
    async _remove(key) {
      return this._withPendingWrite(async () => {
        await this._withRetries((db) => _deleteObject(db, key));
        delete this.localCache[key];
        return this.notifyServiceWorker(key);
      });
    }
    async _poll() {
      const result = await this._withRetries((db) => {
        const getAllRequest = getObjectStore(db, false).getAll();
        return new DBPromise(getAllRequest).toPromise();
      });
      if (!result) {
        return [];
      }
      if (this.pendingWrites !== 0) {
        return [];
      }
      const keys2 = [];
      const keysInResult = /* @__PURE__ */ new Set();
      if (result.length !== 0) {
        for (const { fbase_key: key, value } of result) {
          keysInResult.add(key);
          if (JSON.stringify(this.localCache[key]) !== JSON.stringify(value)) {
            this.notifyListeners(key, value);
            keys2.push(key);
          }
        }
      }
      for (const localKey of Object.keys(this.localCache)) {
        if (this.localCache[localKey] && !keysInResult.has(localKey)) {
          this.notifyListeners(localKey, null);
          keys2.push(localKey);
        }
      }
      return keys2;
    }
    notifyListeners(key, newValue) {
      this.localCache[key] = newValue;
      const listeners = this.listeners[key];
      if (listeners) {
        for (const listener of Array.from(listeners)) {
          listener(newValue);
        }
      }
    }
    startPolling() {
      this.stopPolling();
      this.pollTimer = setInterval(async () => this._poll(), _POLLING_INTERVAL_MS);
    }
    stopPolling() {
      if (this.pollTimer) {
        clearInterval(this.pollTimer);
        this.pollTimer = null;
      }
    }
    _addListener(key, listener) {
      if (Object.keys(this.listeners).length === 0) {
        this.startPolling();
      }
      if (!this.listeners[key]) {
        this.listeners[key] = /* @__PURE__ */ new Set();
        void this._get(key);
      }
      this.listeners[key].add(listener);
    }
    _removeListener(key, listener) {
      if (this.listeners[key]) {
        this.listeners[key].delete(listener);
        if (this.listeners[key].size === 0) {
          delete this.listeners[key];
        }
      }
      if (Object.keys(this.listeners).length === 0) {
        this.stopPolling();
      }
    }
  }
  IndexedDBLocalPersistence.type = "LOCAL";
  const indexedDBLocalPersistence = IndexedDBLocalPersistence;
  new Delay(3e4, 6e4);
  /**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function _withDefaultResolver(auth, resolverOverride) {
    if (resolverOverride) {
      return _getInstance(resolverOverride);
    }
    _assert(
      auth._popupRedirectResolver,
      auth,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    return auth._popupRedirectResolver;
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class IdpCredential extends AuthCredential {
    constructor(params) {
      super(
        "custom",
        "custom"
        /* ProviderId.CUSTOM */
      );
      this.params = params;
    }
    _getIdTokenResponse(auth) {
      return signInWithIdp(auth, this._buildIdpRequest());
    }
    _linkToIdToken(auth, idToken) {
      return signInWithIdp(auth, this._buildIdpRequest(idToken));
    }
    _getReauthenticationResolver(auth) {
      return signInWithIdp(auth, this._buildIdpRequest());
    }
    _buildIdpRequest(idToken) {
      const request = {
        requestUri: this.params.requestUri,
        sessionId: this.params.sessionId,
        postBody: this.params.postBody,
        tenantId: this.params.tenantId,
        pendingToken: this.params.pendingToken,
        returnSecureToken: true,
        returnIdpCredential: true
      };
      if (idToken) {
        request.idToken = idToken;
      }
      return request;
    }
  }
  function _signIn(params) {
    return _signInWithCredential(params.auth, new IdpCredential(params), params.bypassAuthState);
  }
  function _reauth(params) {
    const { auth, user } = params;
    _assert(
      user,
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    return _reauthenticate(user, new IdpCredential(params), params.bypassAuthState);
  }
  async function _link(params) {
    const { auth, user } = params;
    _assert(
      user,
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    return _link$1(user, new IdpCredential(params), params.bypassAuthState);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class AbstractPopupRedirectOperation {
    constructor(auth, filter2, resolver2, user, bypassAuthState = false) {
      this.auth = auth;
      this.resolver = resolver2;
      this.user = user;
      this.bypassAuthState = bypassAuthState;
      this.pendingPromise = null;
      this.eventManager = null;
      this.filter = Array.isArray(filter2) ? filter2 : [filter2];
    }
    execute() {
      return new Promise(async (resolve, reject) => {
        this.pendingPromise = { resolve, reject };
        try {
          this.eventManager = await this.resolver._initialize(this.auth);
          await this.onExecution();
          this.eventManager.registerConsumer(this);
        } catch (e) {
          this.reject(e);
        }
      });
    }
    async onAuthEvent(event) {
      const { urlResponse, sessionId, postBody, tenantId, error, type } = event;
      if (error) {
        this.reject(error);
        return;
      }
      const params = {
        auth: this.auth,
        requestUri: urlResponse,
        sessionId,
        tenantId: tenantId || void 0,
        postBody: postBody || void 0,
        user: this.user,
        bypassAuthState: this.bypassAuthState
      };
      try {
        this.resolve(await this.getIdpTask(type)(params));
      } catch (e) {
        this.reject(e);
      }
    }
    onError(error) {
      this.reject(error);
    }
    getIdpTask(type) {
      switch (type) {
        case "signInViaPopup":
        case "signInViaRedirect":
          return _signIn;
        case "linkViaPopup":
        case "linkViaRedirect":
          return _link;
        case "reauthViaPopup":
        case "reauthViaRedirect":
          return _reauth;
        default:
          _fail(
            this.auth,
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          );
      }
    }
    resolve(cred) {
      debugAssert(this.pendingPromise, "Pending promise was never set");
      this.pendingPromise.resolve(cred);
      this.unregisterAndCleanUp();
    }
    reject(error) {
      debugAssert(this.pendingPromise, "Pending promise was never set");
      this.pendingPromise.reject(error);
      this.unregisterAndCleanUp();
    }
    unregisterAndCleanUp() {
      if (this.eventManager) {
        this.eventManager.unregisterConsumer(this);
      }
      this.pendingPromise = null;
      this.cleanUp();
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const _POLL_WINDOW_CLOSE_TIMEOUT = new Delay(2e3, 1e4);
  class PopupOperation extends AbstractPopupRedirectOperation {
    constructor(auth, filter2, provider, resolver2, user) {
      super(auth, filter2, resolver2, user);
      this.provider = provider;
      this.authWindow = null;
      this.pollId = null;
      if (PopupOperation.currentPopupAction) {
        PopupOperation.currentPopupAction.cancel();
      }
      PopupOperation.currentPopupAction = this;
    }
    async executeNotNull() {
      const result = await this.execute();
      _assert(
        result,
        this.auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      return result;
    }
    async onExecution() {
      debugAssert(this.filter.length === 1, "Popup operations only handle one event");
      const eventId = _generateEventId();
      this.authWindow = await this.resolver._openPopup(
        this.auth,
        this.provider,
        this.filter[0],
        // There's always one, see constructor
        eventId
      );
      this.authWindow.associatedEvent = eventId;
      this.resolver._originValidation(this.auth).catch((e) => {
        this.reject(e);
      });
      this.resolver._isIframeWebStorageSupported(this.auth, (isSupported) => {
        if (!isSupported) {
          this.reject(_createError(
            this.auth,
            "web-storage-unsupported"
            /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */
          ));
        }
      });
      this.pollUserCancellation();
    }
    get eventId() {
      var _a2;
      return ((_a2 = this.authWindow) === null || _a2 === void 0 ? void 0 : _a2.associatedEvent) || null;
    }
    cancel() {
      this.reject(_createError(
        this.auth,
        "cancelled-popup-request"
        /* AuthErrorCode.EXPIRED_POPUP_REQUEST */
      ));
    }
    cleanUp() {
      if (this.authWindow) {
        this.authWindow.close();
      }
      if (this.pollId) {
        window.clearTimeout(this.pollId);
      }
      this.authWindow = null;
      this.pollId = null;
      PopupOperation.currentPopupAction = null;
    }
    pollUserCancellation() {
      const poll = () => {
        var _a2, _b2;
        if ((_b2 = (_a2 = this.authWindow) === null || _a2 === void 0 ? void 0 : _a2.window) === null || _b2 === void 0 ? void 0 : _b2.closed) {
          this.pollId = window.setTimeout(
            () => {
              this.pollId = null;
              this.reject(_createError(
                this.auth,
                "popup-closed-by-user"
                /* AuthErrorCode.POPUP_CLOSED_BY_USER */
              ));
            },
            8e3
            /* _Timeout.AUTH_EVENT */
          );
          return;
        }
        this.pollId = window.setTimeout(poll, _POLL_WINDOW_CLOSE_TIMEOUT.get());
      };
      poll();
    }
  }
  PopupOperation.currentPopupAction = null;
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const PENDING_REDIRECT_KEY = "pendingRedirect";
  const redirectOutcomeMap = /* @__PURE__ */ new Map();
  class RedirectAction extends AbstractPopupRedirectOperation {
    constructor(auth, resolver2, bypassAuthState = false) {
      super(auth, [
        "signInViaRedirect",
        "linkViaRedirect",
        "reauthViaRedirect",
        "unknown"
        /* AuthEventType.UNKNOWN */
      ], resolver2, void 0, bypassAuthState);
      this.eventId = null;
    }
    /**
     * Override the execute function; if we already have a redirect result, then
     * just return it.
     */
    async execute() {
      let readyOutcome = redirectOutcomeMap.get(this.auth._key());
      if (!readyOutcome) {
        try {
          const hasPendingRedirect = await _getAndClearPendingRedirectStatus(this.resolver, this.auth);
          const result = hasPendingRedirect ? await super.execute() : null;
          readyOutcome = () => Promise.resolve(result);
        } catch (e) {
          readyOutcome = () => Promise.reject(e);
        }
        redirectOutcomeMap.set(this.auth._key(), readyOutcome);
      }
      if (!this.bypassAuthState) {
        redirectOutcomeMap.set(this.auth._key(), () => Promise.resolve(null));
      }
      return readyOutcome();
    }
    async onAuthEvent(event) {
      if (event.type === "signInViaRedirect") {
        return super.onAuthEvent(event);
      } else if (event.type === "unknown") {
        this.resolve(null);
        return;
      }
      if (event.eventId) {
        const user = await this.auth._redirectUserForId(event.eventId);
        if (user) {
          this.user = user;
          return super.onAuthEvent(event);
        } else {
          this.resolve(null);
        }
      }
    }
    async onExecution() {
    }
    cleanUp() {
    }
  }
  async function _getAndClearPendingRedirectStatus(resolver2, auth) {
    const key = pendingRedirectKey(auth);
    const persistence = resolverPersistence(resolver2);
    if (!await persistence._isAvailable()) {
      return false;
    }
    const hasPendingRedirect = await persistence._get(key) === "true";
    await persistence._remove(key);
    return hasPendingRedirect;
  }
  function _overrideRedirectResult(auth, result) {
    redirectOutcomeMap.set(auth._key(), result);
  }
  function resolverPersistence(resolver2) {
    return _getInstance(resolver2._redirectPersistence);
  }
  function pendingRedirectKey(auth) {
    return _persistenceKeyName(PENDING_REDIRECT_KEY, auth.config.apiKey, auth.name);
  }
  async function _getRedirectResult(auth, resolverExtern, bypassAuthState = false) {
    if (_isFirebaseServerApp(auth.app)) {
      return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));
    }
    const authInternal = _castAuth(auth);
    const resolver2 = _withDefaultResolver(authInternal, resolverExtern);
    const action = new RedirectAction(authInternal, resolver2, bypassAuthState);
    const result = await action.execute();
    if (result && !bypassAuthState) {
      delete result.user._redirectEventId;
      await authInternal._persistUserIfCurrent(result.user);
      await authInternal._setRedirectUser(null, resolverExtern);
    }
    return result;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const EVENT_DUPLICATION_CACHE_DURATION_MS = 10 * 60 * 1e3;
  class AuthEventManager {
    constructor(auth) {
      this.auth = auth;
      this.cachedEventUids = /* @__PURE__ */ new Set();
      this.consumers = /* @__PURE__ */ new Set();
      this.queuedRedirectEvent = null;
      this.hasHandledPotentialRedirect = false;
      this.lastProcessedEventTime = Date.now();
    }
    registerConsumer(authEventConsumer) {
      this.consumers.add(authEventConsumer);
      if (this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, authEventConsumer)) {
        this.sendToConsumer(this.queuedRedirectEvent, authEventConsumer);
        this.saveEventToCache(this.queuedRedirectEvent);
        this.queuedRedirectEvent = null;
      }
    }
    unregisterConsumer(authEventConsumer) {
      this.consumers.delete(authEventConsumer);
    }
    onEvent(event) {
      if (this.hasEventBeenHandled(event)) {
        return false;
      }
      let handled = false;
      this.consumers.forEach((consumer) => {
        if (this.isEventForConsumer(event, consumer)) {
          handled = true;
          this.sendToConsumer(event, consumer);
          this.saveEventToCache(event);
        }
      });
      if (this.hasHandledPotentialRedirect || !isRedirectEvent(event)) {
        return handled;
      }
      this.hasHandledPotentialRedirect = true;
      if (!handled) {
        this.queuedRedirectEvent = event;
        handled = true;
      }
      return handled;
    }
    sendToConsumer(event, consumer) {
      var _a2;
      if (event.error && !isNullRedirectEvent(event)) {
        const code2 = ((_a2 = event.error.code) === null || _a2 === void 0 ? void 0 : _a2.split("auth/")[1]) || "internal-error";
        consumer.onError(_createError(this.auth, code2));
      } else {
        consumer.onAuthEvent(event);
      }
    }
    isEventForConsumer(event, consumer) {
      const eventIdMatches = consumer.eventId === null || !!event.eventId && event.eventId === consumer.eventId;
      return consumer.filter.includes(event.type) && eventIdMatches;
    }
    hasEventBeenHandled(event) {
      if (Date.now() - this.lastProcessedEventTime >= EVENT_DUPLICATION_CACHE_DURATION_MS) {
        this.cachedEventUids.clear();
      }
      return this.cachedEventUids.has(eventUid(event));
    }
    saveEventToCache(event) {
      this.cachedEventUids.add(eventUid(event));
      this.lastProcessedEventTime = Date.now();
    }
  }
  function eventUid(e) {
    return [e.type, e.eventId, e.sessionId, e.tenantId].filter((v) => v).join("-");
  }
  function isNullRedirectEvent({ type, error }) {
    return type === "unknown" && (error === null || error === void 0 ? void 0 : error.code) === `auth/${"no-auth-event"}`;
  }
  function isRedirectEvent(event) {
    switch (event.type) {
      case "signInViaRedirect":
      case "linkViaRedirect":
      case "reauthViaRedirect":
        return true;
      case "unknown":
        return isNullRedirectEvent(event);
      default:
        return false;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function _getProjectConfig(auth, request = {}) {
    return _performApiRequest(auth, "GET", "/v1/projects", request);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const IP_ADDRESS_REGEX = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  const HTTP_REGEX = /^https?/;
  async function _validateOrigin(auth) {
    if (auth.config.emulator) {
      return;
    }
    const { authorizedDomains } = await _getProjectConfig(auth);
    for (const domain of authorizedDomains) {
      try {
        if (matchDomain(domain)) {
          return;
        }
      } catch (_a2) {
      }
    }
    _fail(
      auth,
      "unauthorized-domain"
      /* AuthErrorCode.INVALID_ORIGIN */
    );
  }
  function matchDomain(expected) {
    const currentUrl = _getCurrentUrl();
    const { protocol, hostname } = new URL(currentUrl);
    if (expected.startsWith("chrome-extension://")) {
      const ceUrl = new URL(expected);
      if (ceUrl.hostname === "" && hostname === "") {
        return protocol === "chrome-extension:" && expected.replace("chrome-extension://", "") === currentUrl.replace("chrome-extension://", "");
      }
      return protocol === "chrome-extension:" && ceUrl.hostname === hostname;
    }
    if (!HTTP_REGEX.test(protocol)) {
      return false;
    }
    if (IP_ADDRESS_REGEX.test(expected)) {
      return hostname === expected;
    }
    const escapedDomainPattern = expected.replace(/\./g, "\\.");
    const re2 = new RegExp("^(.+\\." + escapedDomainPattern + "|" + escapedDomainPattern + ")$", "i");
    return re2.test(hostname);
  }
  /**
   * @license
   * Copyright 2020 Google LLC.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const NETWORK_TIMEOUT = new Delay(3e4, 6e4);
  function resetUnloadedGapiModules() {
    const beacon = _window().___jsl;
    if (beacon === null || beacon === void 0 ? void 0 : beacon.H) {
      for (const hint of Object.keys(beacon.H)) {
        beacon.H[hint].r = beacon.H[hint].r || [];
        beacon.H[hint].L = beacon.H[hint].L || [];
        beacon.H[hint].r = [...beacon.H[hint].L];
        if (beacon.CP) {
          for (let i = 0; i < beacon.CP.length; i++) {
            beacon.CP[i] = null;
          }
        }
      }
    }
  }
  function loadGapi(auth) {
    return new Promise((resolve, reject) => {
      var _a2, _b2, _c2;
      function loadGapiIframe() {
        resetUnloadedGapiModules();
        gapi.load("gapi.iframes", {
          callback: () => {
            resolve(gapi.iframes.getContext());
          },
          ontimeout: () => {
            resetUnloadedGapiModules();
            reject(_createError(
              auth,
              "network-request-failed"
              /* AuthErrorCode.NETWORK_REQUEST_FAILED */
            ));
          },
          timeout: NETWORK_TIMEOUT.get()
        });
      }
      if ((_b2 = (_a2 = _window().gapi) === null || _a2 === void 0 ? void 0 : _a2.iframes) === null || _b2 === void 0 ? void 0 : _b2.Iframe) {
        resolve(gapi.iframes.getContext());
      } else if (!!((_c2 = _window().gapi) === null || _c2 === void 0 ? void 0 : _c2.load)) {
        loadGapiIframe();
      } else {
        const cbName = _generateCallbackName("iframefcb");
        _window()[cbName] = () => {
          if (!!gapi.load) {
            loadGapiIframe();
          } else {
            reject(_createError(
              auth,
              "network-request-failed"
              /* AuthErrorCode.NETWORK_REQUEST_FAILED */
            ));
          }
        };
        return _loadJS(`${_gapiScriptUrl()}?onload=${cbName}`).catch((e) => reject(e));
      }
    }).catch((error) => {
      cachedGApiLoader = null;
      throw error;
    });
  }
  let cachedGApiLoader = null;
  function _loadGapi(auth) {
    cachedGApiLoader = cachedGApiLoader || loadGapi(auth);
    return cachedGApiLoader;
  }
  /**
   * @license
   * Copyright 2020 Google LLC.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const PING_TIMEOUT = new Delay(5e3, 15e3);
  const IFRAME_PATH = "__/auth/iframe";
  const EMULATED_IFRAME_PATH = "emulator/auth/iframe";
  const IFRAME_ATTRIBUTES = {
    style: {
      position: "absolute",
      top: "-100px",
      width: "1px",
      height: "1px"
    },
    "aria-hidden": "true",
    tabindex: "-1"
  };
  const EID_FROM_APIHOST = /* @__PURE__ */ new Map([
    ["identitytoolkit.googleapis.com", "p"],
    ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
    ["test-identitytoolkit.sandbox.googleapis.com", "t"]
    // test
  ]);
  function getIframeUrl(auth) {
    const config = auth.config;
    _assert(
      config.authDomain,
      auth,
      "auth-domain-config-required"
      /* AuthErrorCode.MISSING_AUTH_DOMAIN */
    );
    const url = config.emulator ? _emulatorUrl(config, EMULATED_IFRAME_PATH) : `https://${auth.config.authDomain}/${IFRAME_PATH}`;
    const params = {
      apiKey: config.apiKey,
      appName: auth.name,
      v: SDK_VERSION
    };
    const eid = EID_FROM_APIHOST.get(auth.config.apiHost);
    if (eid) {
      params.eid = eid;
    }
    const frameworks = auth._getFrameworks();
    if (frameworks.length) {
      params.fw = frameworks.join(",");
    }
    return `${url}?${querystring(params).slice(1)}`;
  }
  async function _openIframe(auth) {
    const context = await _loadGapi(auth);
    const gapi2 = _window().gapi;
    _assert(
      gapi2,
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    return context.open({
      where: document.body,
      url: getIframeUrl(auth),
      messageHandlersFilter: gapi2.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
      attributes: IFRAME_ATTRIBUTES,
      dontclear: true
    }, (iframe) => new Promise(async (resolve, reject) => {
      await iframe.restyle({
        // Prevent iframe from closing on mouse out.
        setHideOnLeave: false
      });
      const networkError = _createError(
        auth,
        "network-request-failed"
        /* AuthErrorCode.NETWORK_REQUEST_FAILED */
      );
      const networkErrorTimer = _window().setTimeout(() => {
        reject(networkError);
      }, PING_TIMEOUT.get());
      function clearTimerAndResolve() {
        _window().clearTimeout(networkErrorTimer);
        resolve(iframe);
      }
      iframe.ping(clearTimerAndResolve).then(clearTimerAndResolve, () => {
        reject(networkError);
      });
    }));
  }
  /**
   * @license
   * Copyright 2020 Google LLC.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const BASE_POPUP_OPTIONS = {
    location: "yes",
    resizable: "yes",
    statusbar: "yes",
    toolbar: "no"
  };
  const DEFAULT_WIDTH = 500;
  const DEFAULT_HEIGHT = 600;
  const TARGET_BLANK = "_blank";
  const FIREFOX_EMPTY_URL = "http://localhost";
  class AuthPopup {
    constructor(window2) {
      this.window = window2;
      this.associatedEvent = null;
    }
    close() {
      if (this.window) {
        try {
          this.window.close();
        } catch (e) {
        }
      }
    }
  }
  function _open(auth, url, name2, width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT) {
    const top = Math.max((window.screen.availHeight - height) / 2, 0).toString();
    const left = Math.max((window.screen.availWidth - width) / 2, 0).toString();
    let target = "";
    const options2 = Object.assign(Object.assign({}, BASE_POPUP_OPTIONS), {
      width: width.toString(),
      height: height.toString(),
      top,
      left
    });
    const ua = getUA().toLowerCase();
    if (name2) {
      target = _isChromeIOS(ua) ? TARGET_BLANK : name2;
    }
    if (_isFirefox(ua)) {
      url = url || FIREFOX_EMPTY_URL;
      options2.scrollbars = "yes";
    }
    const optionsString = Object.entries(options2).reduce((accum, [key, value]) => `${accum}${key}=${value},`, "");
    if (_isIOSStandalone(ua) && target !== "_self") {
      openAsNewWindowIOS(url || "", target);
      return new AuthPopup(null);
    }
    const newWin = window.open(url || "", target, optionsString);
    _assert(
      newWin,
      auth,
      "popup-blocked"
      /* AuthErrorCode.POPUP_BLOCKED */
    );
    try {
      newWin.focus();
    } catch (e) {
    }
    return new AuthPopup(newWin);
  }
  function openAsNewWindowIOS(url, target) {
    const el = document.createElement("a");
    el.href = url;
    el.target = target;
    const click = document.createEvent("MouseEvent");
    click.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 1, null);
    el.dispatchEvent(click);
  }
  /**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const WIDGET_PATH = "__/auth/handler";
  const EMULATOR_WIDGET_PATH = "emulator/auth/handler";
  const FIREBASE_APP_CHECK_FRAGMENT_ID = encodeURIComponent("fac");
  async function _getRedirectUrl(auth, provider, authType, redirectUrl, eventId, additionalParams) {
    _assert(
      auth.config.authDomain,
      auth,
      "auth-domain-config-required"
      /* AuthErrorCode.MISSING_AUTH_DOMAIN */
    );
    _assert(
      auth.config.apiKey,
      auth,
      "invalid-api-key"
      /* AuthErrorCode.INVALID_API_KEY */
    );
    const params = {
      apiKey: auth.config.apiKey,
      appName: auth.name,
      authType,
      redirectUrl,
      v: SDK_VERSION,
      eventId
    };
    if (provider instanceof FederatedAuthProvider) {
      provider.setDefaultLanguage(auth.languageCode);
      params.providerId = provider.providerId || "";
      if (!isEmpty(provider.getCustomParameters())) {
        params.customParameters = JSON.stringify(provider.getCustomParameters());
      }
      for (const [key, value] of Object.entries({})) {
        params[key] = value;
      }
    }
    if (provider instanceof BaseOAuthProvider) {
      const scopes = provider.getScopes().filter((scope) => scope !== "");
      if (scopes.length > 0) {
        params.scopes = scopes.join(",");
      }
    }
    if (auth.tenantId) {
      params.tid = auth.tenantId;
    }
    const paramsDict = params;
    for (const key of Object.keys(paramsDict)) {
      if (paramsDict[key] === void 0) {
        delete paramsDict[key];
      }
    }
    const appCheckToken = await auth._getAppCheckToken();
    const appCheckTokenFragment = appCheckToken ? `#${FIREBASE_APP_CHECK_FRAGMENT_ID}=${encodeURIComponent(appCheckToken)}` : "";
    return `${getHandlerBase(auth)}?${querystring(paramsDict).slice(1)}${appCheckTokenFragment}`;
  }
  function getHandlerBase({ config }) {
    if (!config.emulator) {
      return `https://${config.authDomain}/${WIDGET_PATH}`;
    }
    return _emulatorUrl(config, EMULATOR_WIDGET_PATH);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const WEB_STORAGE_SUPPORT_KEY = "webStorageSupport";
  class BrowserPopupRedirectResolver {
    constructor() {
      this.eventManagers = {};
      this.iframes = {};
      this.originValidationPromises = {};
      this._redirectPersistence = browserSessionPersistence;
      this._completeRedirectFn = _getRedirectResult;
      this._overrideRedirectResult = _overrideRedirectResult;
    }
    // Wrapping in async even though we don't await anywhere in order
    // to make sure errors are raised as promise rejections
    async _openPopup(auth, provider, authType, eventId) {
      var _a2;
      debugAssert((_a2 = this.eventManagers[auth._key()]) === null || _a2 === void 0 ? void 0 : _a2.manager, "_initialize() not called before _openPopup()");
      const url = await _getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId);
      return _open(auth, url, _generateEventId());
    }
    async _openRedirect(auth, provider, authType, eventId) {
      await this._originValidation(auth);
      const url = await _getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId);
      _setWindowLocation(url);
      return new Promise(() => {
      });
    }
    _initialize(auth) {
      const key = auth._key();
      if (this.eventManagers[key]) {
        const { manager, promise: promise2 } = this.eventManagers[key];
        if (manager) {
          return Promise.resolve(manager);
        } else {
          debugAssert(promise2, "If manager is not set, promise should be");
          return promise2;
        }
      }
      const promise = this.initAndGetManager(auth);
      this.eventManagers[key] = { promise };
      promise.catch(() => {
        delete this.eventManagers[key];
      });
      return promise;
    }
    async initAndGetManager(auth) {
      const iframe = await _openIframe(auth);
      const manager = new AuthEventManager(auth);
      iframe.register("authEvent", (iframeEvent) => {
        _assert(
          iframeEvent === null || iframeEvent === void 0 ? void 0 : iframeEvent.authEvent,
          auth,
          "invalid-auth-event"
          /* AuthErrorCode.INVALID_AUTH_EVENT */
        );
        const handled = manager.onEvent(iframeEvent.authEvent);
        return {
          status: handled ? "ACK" : "ERROR"
          /* GapiOutcome.ERROR */
        };
      }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
      this.eventManagers[auth._key()] = { manager };
      this.iframes[auth._key()] = iframe;
      return manager;
    }
    _isIframeWebStorageSupported(auth, cb) {
      const iframe = this.iframes[auth._key()];
      iframe.send(WEB_STORAGE_SUPPORT_KEY, { type: WEB_STORAGE_SUPPORT_KEY }, (result) => {
        var _a2;
        const isSupported = (_a2 = result === null || result === void 0 ? void 0 : result[0]) === null || _a2 === void 0 ? void 0 : _a2[WEB_STORAGE_SUPPORT_KEY];
        if (isSupported !== void 0) {
          cb(!!isSupported);
        }
        _fail(
          auth,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
      }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
    }
    _originValidation(auth) {
      const key = auth._key();
      if (!this.originValidationPromises[key]) {
        this.originValidationPromises[key] = _validateOrigin(auth);
      }
      return this.originValidationPromises[key];
    }
    get _shouldInitProactively() {
      return _isMobileBrowser() || _isSafari() || _isIOS();
    }
  }
  const browserPopupRedirectResolver = BrowserPopupRedirectResolver;
  var name = "@firebase/auth";
  var version = "1.7.9";
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class AuthInterop {
    constructor(auth) {
      this.auth = auth;
      this.internalListeners = /* @__PURE__ */ new Map();
    }
    getUid() {
      var _a2;
      this.assertAuthConfigured();
      return ((_a2 = this.auth.currentUser) === null || _a2 === void 0 ? void 0 : _a2.uid) || null;
    }
    async getToken(forceRefresh) {
      this.assertAuthConfigured();
      await this.auth._initializationPromise;
      if (!this.auth.currentUser) {
        return null;
      }
      const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);
      return { accessToken };
    }
    addAuthTokenListener(listener) {
      this.assertAuthConfigured();
      if (this.internalListeners.has(listener)) {
        return;
      }
      const unsubscribe = this.auth.onIdTokenChanged((user) => {
        listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);
      });
      this.internalListeners.set(listener, unsubscribe);
      this.updateProactiveRefresh();
    }
    removeAuthTokenListener(listener) {
      this.assertAuthConfigured();
      const unsubscribe = this.internalListeners.get(listener);
      if (!unsubscribe) {
        return;
      }
      this.internalListeners.delete(listener);
      unsubscribe();
      this.updateProactiveRefresh();
    }
    assertAuthConfigured() {
      _assert(
        this.auth._initializationPromise,
        "dependent-sdk-initialized-before-auth"
        /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
      );
    }
    updateProactiveRefresh() {
      if (this.internalListeners.size > 0) {
        this.auth._startProactiveRefresh();
      } else {
        this.auth._stopProactiveRefresh();
      }
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function getVersionForPlatform(clientPlatform) {
    switch (clientPlatform) {
      case "Node":
        return "node";
      case "ReactNative":
        return "rn";
      case "Worker":
        return "webworker";
      case "Cordova":
        return "cordova";
      case "WebExtension":
        return "web-extension";
      default:
        return void 0;
    }
  }
  function registerAuth(clientPlatform) {
    _registerComponent(new Component(
      "auth",
      (container, { options: deps }) => {
        const app = container.getProvider("app").getImmediate();
        const heartbeatServiceProvider = container.getProvider("heartbeat");
        const appCheckServiceProvider = container.getProvider("app-check-internal");
        const { apiKey, authDomain } = app.options;
        _assert(apiKey && !apiKey.includes(":"), "invalid-api-key", { appName: app.name });
        const config = {
          apiKey,
          authDomain,
          clientPlatform,
          apiHost: "identitytoolkit.googleapis.com",
          tokenApiHost: "securetoken.googleapis.com",
          apiScheme: "https",
          sdkClientVersion: _getClientVersion(clientPlatform)
        };
        const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);
        _initializeAuthInstance(authInstance, deps);
        return authInstance;
      },
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ).setInstantiationMode(
      "EXPLICIT"
      /* InstantiationMode.EXPLICIT */
    ).setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {
      const authInternalProvider = container.getProvider(
        "auth-internal"
        /* _ComponentName.AUTH_INTERNAL */
      );
      authInternalProvider.initialize();
    }));
    _registerComponent(new Component(
      "auth-internal",
      (container) => {
        const auth = _castAuth(container.getProvider(
          "auth"
          /* _ComponentName.AUTH */
        ).getImmediate());
        return ((auth2) => new AuthInterop(auth2))(auth);
      },
      "PRIVATE"
      /* ComponentType.PRIVATE */
    ).setInstantiationMode(
      "EXPLICIT"
      /* InstantiationMode.EXPLICIT */
    ));
    registerVersion(name, version, getVersionForPlatform(clientPlatform));
    registerVersion(name, version, "esm2017");
  }
  /**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const DEFAULT_ID_TOKEN_MAX_AGE = 5 * 60;
  const authIdTokenMaxAge = getExperimentalSetting("authIdTokenMaxAge") || DEFAULT_ID_TOKEN_MAX_AGE;
  let lastPostedIdToken = null;
  const mintCookieFactory = (url) => async (user) => {
    const idTokenResult = user && await user.getIdTokenResult();
    const idTokenAge = idTokenResult && ((/* @__PURE__ */ new Date()).getTime() - Date.parse(idTokenResult.issuedAtTime)) / 1e3;
    if (idTokenAge && idTokenAge > authIdTokenMaxAge) {
      return;
    }
    const idToken = idTokenResult === null || idTokenResult === void 0 ? void 0 : idTokenResult.token;
    if (lastPostedIdToken === idToken) {
      return;
    }
    lastPostedIdToken = idToken;
    await fetch(url, {
      method: idToken ? "POST" : "DELETE",
      headers: idToken ? {
        "Authorization": `Bearer ${idToken}`
      } : {}
    });
  };
  function getAuth(app = getApp$1()) {
    const provider = _getProvider(app, "auth");
    if (provider.isInitialized()) {
      return provider.getImmediate();
    }
    const auth = initializeAuth(app, {
      popupRedirectResolver: browserPopupRedirectResolver,
      persistence: [
        indexedDBLocalPersistence,
        browserLocalPersistence,
        browserSessionPersistence
      ]
    });
    const authTokenSyncPath = getExperimentalSetting("authTokenSyncURL");
    if (authTokenSyncPath && typeof isSecureContext === "boolean" && isSecureContext) {
      const authTokenSyncUrl = new URL(authTokenSyncPath, location.origin);
      if (location.origin === authTokenSyncUrl.origin) {
        const mintCookie = mintCookieFactory(authTokenSyncUrl.toString());
        beforeAuthStateChanged(auth, mintCookie, () => mintCookie(auth.currentUser));
        onIdTokenChanged(auth, (user) => mintCookie(user));
      }
    }
    const authEmulatorHost = getDefaultEmulatorHost("auth");
    if (authEmulatorHost) {
      connectAuthEmulator(auth, `http://${authEmulatorHost}`);
    }
    return auth;
  }
  function getScriptParentElement() {
    var _a2, _b2;
    return (_b2 = (_a2 = document.getElementsByTagName("head")) === null || _a2 === void 0 ? void 0 : _a2[0]) !== null && _b2 !== void 0 ? _b2 : document;
  }
  _setExternalJSProvider({
    loadJS(url) {
      return new Promise((resolve, reject) => {
        const el = document.createElement("script");
        el.setAttribute("src", url);
        el.onload = resolve;
        el.onerror = (e) => {
          const error = _createError(
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          );
          error.customData = e;
          reject(error);
        };
        el.type = "text/javascript";
        el.charset = "UTF-8";
        getScriptParentElement().appendChild(el);
      });
    },
    gapiScript: "https://apis.google.com/js/api.js",
    recaptchaV2Script: "https://www.google.com/recaptcha/api.js",
    recaptchaEnterpriseScript: "https://www.google.com/recaptcha/enterprise.js?render="
  });
  registerAuth(
    "Browser"
    /* ClientPlatform.BROWSER */
  );
  function getFirebaseConfig() {
    if (typeof window === "undefined") {
      return {
        apiKey: "",
        authDomain: "",
        projectId: "",
        storageBucket: "",
        messagingSenderId: "",
        appId: ""
      };
    }
    const env2 = window.ENV;
    if (!env2) {
      return {
        apiKey: "",
        authDomain: "",
        projectId: "",
        storageBucket: "",
        messagingSenderId: "",
        appId: ""
      };
    }
    return {
      apiKey: env2.FIREBASE_API_KEY,
      authDomain: env2.FIREBASE_AUTH_DOMAIN,
      projectId: env2.FIREBASE_PROJECT_ID,
      storageBucket: env2.FIREBASE_STORAGE_BUCKET,
      messagingSenderId: env2.FIREBASE_MESSAGING_SENDER_ID,
      appId: env2.FIREBASE_APP_ID
    };
  }
  var firebaseApp = null;
  var firebaseAuth = null;
  function initializeFirebase() {
    if (firebaseApp) return { app: firebaseApp, auth: firebaseAuth };
    try {
      const config = getFirebaseConfig();
      if (!config.apiKey || !config.authDomain || !config.projectId) {
        return { app: null, auth: null };
      }
      firebaseApp = initializeApp(config);
      firebaseAuth = getAuth(firebaseApp);
      return { app: firebaseApp, auth: firebaseAuth };
    } catch (error) {
      return { app: null, auth: null };
    }
  }
  var getApp = () => {
    if (typeof window === "undefined") return null;
    const { app: app2 } = initializeFirebase();
    return app2;
  };
  var getFirebaseAuth = () => {
    if (typeof window === "undefined") return null;
    const { auth: auth2 } = initializeFirebase();
    return auth2;
  };
  typeof window !== "undefined" ? getApp() : null;
  typeof window !== "undefined" ? getFirebaseAuth() : null;
  var setAuthToken = (token) => {
    localStorage.setItem("authToken", token);
  };
  reactExports.createContext({
    user: null,
    loading: true,
    isAuthenticated: false,
    handleAuthStateChange: async () => {
    },
    handleAuthSuccess: async () => {
    },
    handleLogout: async () => {
    },
    clearOrgAndAgentLocalStorage: async () => {
    }
  });
  typeof window !== "undefined" && window.ENV ? window.ENV.GOOGLE_ANALYTICS_ID : "";
  var ArrowLeft = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21 12C21 12.1989 20.921 12.3897 20.7803 12.5303C20.6397 12.671 20.4489 12.75 20.25 12.75H5.56029L11.0306 18.2194C11.1003 18.289 11.1556 18.3718 11.1933 18.4628C11.231 18.5539 11.2504 18.6514 11.2504 18.75C11.2504 18.8485 11.231 18.9461 11.1933 19.0372C11.1556 19.1282 11.1003 19.2109 11.0306 19.2806C10.9609 19.3503 10.8782 19.4056 10.7872 19.4433C10.6961 19.481 10.5985 19.5004 10.5 19.5004C10.4014 19.5004 10.3039 19.481 10.2128 19.4433C10.1218 19.4056 10.039 19.3503 9.96935 19.2806L3.21935 12.5306C3.14962 12.461 3.0943 12.3782 3.05656 12.2872C3.01882 12.1961 2.99939 12.0986 2.99939 12C2.99939 11.9014 3.01882 11.8038 3.05656 11.7128C3.0943 11.6217 3.14962 11.539 3.21935 11.4694L9.96935 4.71936C10.1101 4.57863 10.301 4.49957 10.5 4.49957C10.699 4.49957 10.8899 4.57863 11.0306 4.71936C11.1713 4.8601 11.2504 5.05097 11.2504 5.24999C11.2504 5.44901 11.1713 5.63988 11.0306 5.78061L5.56029 11.25H20.25C20.4489 11.25 20.6397 11.329 20.7803 11.4697C20.921 11.6103 21 11.8011 21 12Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  ArrowLeft.displayName = "ArrowLeft";
  var ArrowUp = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M10 16.6667V3.33337M10 3.33337L4.16669 9.16671M10 3.33337L15.8334 9.16671",
            stroke: "currentColor",
            strokeWidth: 1.5,
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        )
      }
    )
  );
  ArrowUp.displayName = "ArrowUp";
  var Camera = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M19.5 5.25H16.9012L15.6234 3.33375C15.555 3.23114 15.4623 3.147 15.3535 3.08879C15.2448 3.03057 15.1233 3.00007 15 3H9C8.87665 3.00007 8.75522 3.03057 8.64648 3.08879C8.53773 3.147 8.44502 3.23114 8.37656 3.33375L7.09781 5.25H4.5C3.90326 5.25 3.33097 5.48705 2.90901 5.90901C2.48705 6.33097 2.25 6.90326 2.25 7.5V18C2.25 18.5967 2.48705 19.169 2.90901 19.591C3.33097 20.0129 3.90326 20.25 4.5 20.25H19.5C20.0967 20.25 20.669 20.0129 21.091 19.591C21.5129 19.169 21.75 18.5967 21.75 18V7.5C21.75 6.90326 21.5129 6.33097 21.091 5.90901C20.669 5.48705 20.0967 5.25 19.5 5.25ZM20.25 18C20.25 18.1989 20.171 18.3897 20.0303 18.5303C19.8897 18.671 19.6989 18.75 19.5 18.75H4.5C4.30109 18.75 4.11032 18.671 3.96967 18.5303C3.82902 18.3897 3.75 18.1989 3.75 18V7.5C3.75 7.30109 3.82902 7.11032 3.96967 6.96967C4.11032 6.82902 4.30109 6.75 4.5 6.75H7.5C7.62351 6.75008 7.74512 6.71966 7.85405 6.66143C7.96297 6.60321 8.05583 6.51899 8.12438 6.41625L9.40125 4.5H14.5978L15.8756 6.41625C15.9442 6.51899 16.037 6.60321 16.146 6.66143C16.2549 6.71966 16.3765 6.75008 16.5 6.75H19.5C19.6989 6.75 19.8897 6.82902 20.0303 6.96967C20.171 7.11032 20.25 7.30109 20.25 7.5V18ZM12 8.25C11.1842 8.25 10.3866 8.49193 9.70827 8.94519C9.02992 9.39845 8.50121 10.0427 8.189 10.7964C7.87679 11.5502 7.7951 12.3796 7.95426 13.1797C8.11343 13.9799 8.50629 14.7149 9.08318 15.2918C9.66008 15.8687 10.3951 16.2616 11.1953 16.4207C11.9954 16.5799 12.8248 16.4982 13.5786 16.186C14.3323 15.8738 14.9766 15.3451 15.4298 14.6667C15.8831 13.9884 16.125 13.1908 16.125 12.375C16.1238 11.2814 15.6888 10.2329 14.9154 9.45955C14.1421 8.68624 13.0936 8.25124 12 8.25ZM12 15C11.4808 15 10.9733 14.846 10.5416 14.5576C10.1099 14.2692 9.7735 13.8592 9.57482 13.3795C9.37614 12.8999 9.32415 12.3721 9.42544 11.8629C9.52672 11.3537 9.77673 10.886 10.1438 10.5188C10.511 10.1517 10.9787 9.90172 11.4879 9.80044C11.9971 9.69915 12.5249 9.75114 13.0045 9.94982C13.4842 10.1485 13.8942 10.4849 14.1826 10.9166C14.471 11.3483 14.625 11.8558 14.625 12.375C14.625 13.0712 14.3484 13.7389 13.8562 14.2312C13.3639 14.7234 12.6962 15 12 15Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  Camera.displayName = "Camera";
  var ImageIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.25 3.75H3.75C3.35218 3.75 2.97064 3.90804 2.68934 4.18934C2.40804 4.47064 2.25 4.85218 2.25 5.25V18.75C2.25 19.1478 2.40804 19.5294 2.68934 19.8107C2.97064 20.092 3.35218 20.25 3.75 20.25H20.25C20.6478 20.25 21.0294 20.092 21.3107 19.8107C21.592 19.5294 21.75 19.1478 21.75 18.75V5.25C21.75 4.85218 21.592 4.47064 21.3107 4.18934C21.0294 3.90804 20.6478 3.75 20.25 3.75ZM20.25 5.25V14.8828L17.8059 12.4397C17.6666 12.3004 17.5013 12.1898 17.3193 12.1144C17.1372 12.039 16.9422 12.0002 16.7452 12.0002C16.5481 12.0002 16.3531 12.039 16.1711 12.1144C15.989 12.1898 15.8237 12.3004 15.6844 12.4397L13.8094 14.3147L9.68438 10.1897C9.4031 9.9086 9.02172 9.7507 8.62406 9.7507C8.22641 9.7507 7.84503 9.9086 7.56375 10.1897L3.75 14.0034V5.25H20.25ZM3.75 16.125L8.625 11.25L16.125 18.75H3.75V16.125ZM20.25 18.75H18.2466L14.8716 15.375L16.7466 13.5L20.25 17.0044V18.75ZM13.5 9.375C13.5 9.1525 13.566 8.93499 13.6896 8.74998C13.8132 8.56498 13.9889 8.42078 14.1945 8.33564C14.4 8.25049 14.6262 8.22821 14.8445 8.27162C15.0627 8.31502 15.2632 8.42217 15.4205 8.5795C15.5778 8.73684 15.685 8.93729 15.7284 9.15552C15.7718 9.37375 15.7495 9.59995 15.6644 9.80552C15.5792 10.0111 15.435 10.1868 15.25 10.3104C15.065 10.434 14.8475 10.5 14.625 10.5C14.3266 10.5 14.0405 10.3815 13.8295 10.1705C13.6185 9.95952 13.5 9.67337 13.5 9.375Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  ImageIcon.displayName = "ImageIcon";
  var MapPin = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 6C11.2583 6 10.5333 6.21993 9.91661 6.63199C9.29993 7.04404 8.81928 7.62971 8.53545 8.31494C8.25162 9.00016 8.17736 9.75416 8.32205 10.4816C8.46675 11.209 8.8239 11.8772 9.34835 12.4017C9.8728 12.9261 10.541 13.2833 11.2684 13.4279C11.9958 13.5726 12.7498 13.4984 13.4351 13.2145C14.1203 12.9307 14.706 12.4501 15.118 11.8334C15.5301 11.2167 15.75 10.4917 15.75 9.75C15.75 8.75544 15.3549 7.80161 14.6517 7.09835C13.9484 6.39509 12.9946 6 12 6ZM12 12C11.555 12 11.12 11.868 10.75 11.6208C10.38 11.3736 10.0916 11.0222 9.92127 10.611C9.75097 10.1999 9.70642 9.7475 9.79323 9.31105C9.88005 8.87459 10.0943 8.47368 10.409 8.15901C10.7237 7.84434 11.1246 7.63005 11.561 7.54323C11.9975 7.45642 12.4499 7.50097 12.861 7.67127C13.2722 7.84157 13.6236 8.12996 13.8708 8.49997C14.118 8.86998 14.25 9.30499 14.25 9.75C14.25 10.3467 14.0129 10.919 13.591 11.341C13.169 11.7629 12.5967 12 12 12ZM12 1.5C9.81273 1.50248 7.71575 2.37247 6.16911 3.91911C4.62247 5.46575 3.75248 7.56273 3.75 9.75C3.75 12.6938 5.11031 15.8138 7.6875 18.7734C8.84552 20.1108 10.1489 21.3151 11.5734 22.3641C11.6995 22.4524 11.8498 22.4998 12.0037 22.4998C12.1577 22.4998 12.308 22.4524 12.4341 22.3641C13.856 21.3147 15.1568 20.1104 16.3125 18.7734C18.8859 15.8138 20.25 12.6938 20.25 9.75C20.2475 7.56273 19.3775 5.46575 17.8309 3.91911C16.2843 2.37247 14.1873 1.50248 12 1.5ZM12 20.8125C10.4503 19.5938 5.25 15.1172 5.25 9.75C5.25 7.95979 5.96116 6.2429 7.22703 4.97703C8.4929 3.71116 10.2098 3 12 3C13.7902 3 15.5071 3.71116 16.773 4.97703C18.0388 6.2429 18.75 7.95979 18.75 9.75C18.75 15.1153 13.5497 19.5938 12 20.8125Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  MapPin.displayName = "MapPin";
  var Microphone = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 16.5C13.1931 16.4988 14.337 16.0243 15.1806 15.1806C16.0243 14.337 16.4988 13.1931 16.5 12V6C16.5 4.80653 16.0259 3.66193 15.182 2.81802C14.3381 1.97411 13.1935 1.5 12 1.5C10.8065 1.5 9.66193 1.97411 8.81802 2.81802C7.97411 3.66193 7.5 4.80653 7.5 6V12C7.50124 13.1931 7.97575 14.337 8.81939 15.1806C9.66303 16.0243 10.8069 16.4988 12 16.5ZM9 6C9 5.20435 9.31607 4.44129 9.87868 3.87868C10.4413 3.31607 11.2044 3 12 3C12.7956 3 13.5587 3.31607 14.1213 3.87868C14.6839 4.44129 15 5.20435 15 6V12C15 12.7956 14.6839 13.5587 14.1213 14.1213C13.5587 14.6839 12.7956 15 12 15C11.2044 15 10.4413 14.6839 9.87868 14.1213C9.31607 13.5587 9 12.7956 9 12V6ZM12.75 19.4625V22.5C12.75 22.6989 12.671 22.8897 12.5303 23.0303C12.3897 23.171 12.1989 23.25 12 23.25C11.8011 23.25 11.6103 23.171 11.4697 23.0303C11.329 22.8897 11.25 22.6989 11.25 22.5V19.4625C9.40091 19.2743 7.68728 18.4072 6.44048 17.0288C5.19368 15.6504 4.50228 13.8586 4.5 12C4.5 11.8011 4.57902 11.6103 4.71967 11.4697C4.86032 11.329 5.05109 11.25 5.25 11.25C5.44891 11.25 5.63968 11.329 5.78033 11.4697C5.92098 11.6103 6 11.8011 6 12C6 13.5913 6.63214 15.1174 7.75736 16.2426C8.88258 17.3679 10.4087 18 12 18C13.5913 18 15.1174 17.3679 16.2426 16.2426C17.3679 15.1174 18 13.5913 18 12C18 11.8011 18.079 11.6103 18.2197 11.4697C18.3603 11.329 18.5511 11.25 18.75 11.25C18.9489 11.25 19.1397 11.329 19.2803 11.4697C19.421 11.6103 19.5 11.8011 19.5 12C19.4977 13.8586 18.8063 15.6504 17.5595 17.0288C16.3127 18.4072 14.5991 19.2743 12.75 19.4625Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  Microphone.displayName = "Microphone";
  var Paperclip = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M19.6556 11.4694C19.7254 11.5391 19.7807 11.6218 19.8184 11.7128C19.8562 11.8039 19.8756 11.9015 19.8756 12C19.8756 12.0986 19.8562 12.1962 19.8184 12.2873C19.7807 12.3783 19.7254 12.461 19.6556 12.5307L11.9634 20.2182C10.9787 21.2028 9.64315 21.7559 8.2506 21.7558C6.85806 21.7557 5.52258 21.2024 4.53797 20.2177C3.55335 19.233 3.00025 17.8974 3.00034 16.5049C3.00042 15.1123 3.55369 13.7769 4.53843 12.7922L13.8441 3.34973C14.5471 2.64596 15.5009 2.25028 16.4957 2.24976C17.4904 2.24923 18.4447 2.64389 19.1484 3.34692C19.8522 4.04995 20.2479 5.00376 20.2484 5.99853C20.2489 6.99329 19.8543 7.94752 19.1512 8.6513L9.84375 18.0938C9.42106 18.5165 8.84777 18.754 8.25 18.754C7.65223 18.754 7.07894 18.5165 6.65625 18.0938C6.23356 17.6711 5.99609 17.0978 5.99609 16.5C5.99609 15.9023 6.23356 15.329 6.65625 14.9063L14.4656 6.97317C14.534 6.90019 14.6163 6.84164 14.7077 6.80095C14.7991 6.76026 14.8977 6.73827 14.9977 6.73625C15.0977 6.73424 15.1971 6.75225 15.2901 6.78923C15.383 6.82621 15.4676 6.8814 15.5389 6.95157C15.6102 7.02173 15.6667 7.10545 15.7052 7.19779C15.7436 7.29013 15.7632 7.38923 15.7628 7.48926C15.7624 7.58929 15.7419 7.68822 15.7027 7.78023C15.6635 7.87225 15.6063 7.95548 15.5344 8.02505L7.72406 15.9666C7.65413 16.036 7.59855 16.1185 7.56049 16.2093C7.52244 16.3002 7.50265 16.3976 7.50226 16.4961C7.50186 16.5946 7.52088 16.6922 7.55821 16.7834C7.59554 16.8746 7.65047 16.9575 7.71984 17.0274C7.78922 17.0973 7.87169 17.1529 7.96254 17.191C8.05339 17.229 8.15086 17.2488 8.24936 17.2492C8.34786 17.2496 8.44548 17.2306 8.53663 17.1932C8.62778 17.1559 8.71069 17.101 8.78062 17.0316L18.0872 7.5938C18.5099 7.17198 18.7477 6.59952 18.7483 6.00237C18.7489 5.40521 18.5123 4.83227 18.0905 4.40958C17.6686 3.98689 17.0962 3.74908 16.499 3.74846C15.9019 3.74785 15.3289 3.98448 14.9062 4.4063L5.6025 13.845C5.25396 14.193 4.97738 14.6063 4.78854 15.0611C4.5997 15.516 4.5023 16.0036 4.50191 16.4961C4.50152 16.9886 4.59814 17.4764 4.78626 17.9316C4.97437 18.3868 5.2503 18.8004 5.59828 19.149C5.94626 19.4975 6.35949 19.7741 6.81436 19.9629C7.26923 20.1518 7.75684 20.2491 8.24936 20.2495C8.74187 20.2499 9.22964 20.1533 9.68481 19.9652C10.14 19.7771 10.5536 19.5012 10.9022 19.1532L18.5953 11.4657C18.7364 11.3256 18.9274 11.2473 19.1262 11.248C19.3251 11.2488 19.5155 11.3284 19.6556 11.4694Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  Paperclip.displayName = "Paperclip";
  var PaperPlanIcon = reactExports.forwardRef(
    ({ size: size2 = 20, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M22.3031 18.7593L13.2984 3.01677C13.1679 2.7848 12.9781 2.59173 12.7483 2.45737C12.5186 2.32301 12.2572 2.2522 11.9911 2.2522C11.7249 2.2522 11.4636 2.32301 11.2338 2.45737C11.0041 2.59173 10.8142 2.7848 10.6837 3.01677L1.69405 18.7668C1.545 19.0326 1.48047 19.3376 1.50905 19.641C1.53764 19.9445 1.65798 20.232 1.85406 20.4653C2.05014 20.6987 2.31265 20.8667 2.60663 20.9472C2.90062 21.0276 3.21212 21.0166 3.49968 20.9155L12 18.0421L20.5003 20.9136C20.6609 20.9702 20.8298 20.9993 21 20.9999C21.262 20.999 21.5191 20.9296 21.7459 20.7984C21.9727 20.6673 22.1611 20.479 22.2926 20.2524C22.424 20.0258 22.4938 19.7687 22.4949 19.5067C22.4961 19.2448 22.4287 18.9871 22.2994 18.7593H22.3031ZM20.9859 19.4943L12.75 16.7118V11.2499C12.75 11.051 12.671 10.8602 12.5303 10.7196C12.3897 10.5789 12.1989 10.4999 12 10.4999C11.8011 10.4999 11.6103 10.5789 11.4697 10.7196C11.329 10.8602 11.25 11.051 11.25 11.2499V16.7118L3.01499 19.4943L2.99999 19.4999L11.9869 3.7499L21 19.4999L20.9859 19.4943Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  PaperPlanIcon.displayName = "PaperPlanIcon";
  var PaperPlanTiltIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.3112 2.68876C21.1226 2.50025 20.8872 2.36544 20.6291 2.29821C20.3711 2.23098 20.0997 2.23376 19.8431 2.30626H19.8291L1.83469 7.76625C1.54256 7.85045 1.28291 8.02142 1.09014 8.25651C0.897378 8.49161 0.780601 8.77973 0.755286 9.08269C0.729972 9.38565 0.797314 9.68916 0.94839 9.95298C1.09947 10.2168 1.32714 10.4285 1.60125 10.56L9.5625 14.4375L13.4344 22.3941C13.5548 22.6511 13.7463 22.8682 13.9862 23.0199C14.226 23.1716 14.5043 23.2514 14.7881 23.25C14.8312 23.25 14.8744 23.2481 14.9175 23.2444C15.2202 23.2199 15.5082 23.1034 15.7428 22.9105C15.9774 22.7176 16.1474 22.4576 16.23 22.1653L21.6862 4.17094C21.6862 4.16626 21.6862 4.16157 21.6862 4.15688C21.7597 3.90091 21.7637 3.63 21.6978 3.37199C21.6319 3.11397 21.4984 2.87815 21.3112 2.68876ZM14.7966 21.7359L14.7919 21.7491V21.7425L11.0363 14.0269L15.5362 9.52688C15.671 9.38508 15.745 9.19627 15.7425 9.0007C15.7399 8.80513 15.6611 8.61827 15.5228 8.47997C15.3845 8.34167 15.1977 8.26287 15.0021 8.26036C14.8065 8.25786 14.6177 8.33185 14.4759 8.46657L9.97594 12.9666L2.2575 9.21094H2.25094H2.26406L20.25 3.75001L14.7966 21.7359Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  PaperPlanTiltIcon.displayName = "PaperPlanTiltIcon";
  var RecordIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 2.25C10.0716 2.25 8.18657 2.82183 6.58319 3.89317C4.97981 4.96451 3.73013 6.48726 2.99217 8.26884C2.25422 10.0504 2.06113 12.0108 2.43734 13.9021C2.81355 15.7934 3.74214 17.5307 5.10571 18.8943C6.46927 20.2579 8.20655 21.1865 10.0979 21.5627C11.9892 21.9389 13.9496 21.7458 15.7312 21.0078C17.5127 20.2699 19.0355 19.0202 20.1068 17.4168C21.1782 15.8134 21.75 13.9284 21.75 12C21.7473 9.41498 20.7192 6.93661 18.8913 5.10872C17.0634 3.28084 14.585 2.25273 12 2.25ZM12 20.25C10.3683 20.25 8.77325 19.7661 7.41654 18.8596C6.05984 17.9531 5.00241 16.6646 4.37799 15.1571C3.75357 13.6496 3.59019 11.9908 3.90852 10.3905C4.22685 8.79016 5.01258 7.32015 6.16637 6.16637C7.32015 5.01259 8.79016 4.22685 10.3905 3.90852C11.9908 3.59019 13.6496 3.75357 15.1571 4.37799C16.6646 5.00242 17.9531 6.05984 18.8596 7.41655C19.7661 8.77325 20.25 10.3683 20.25 12C20.2475 14.1873 19.3775 16.2843 17.8309 17.8309C16.2843 19.3775 14.1873 20.2475 12 20.25ZM12 5.25C10.665 5.25 9.35993 5.64588 8.2499 6.38758C7.13987 7.12928 6.2747 8.18349 5.76381 9.41689C5.25292 10.6503 5.11925 12.0075 5.3797 13.3169C5.64015 14.6262 6.28302 15.829 7.22703 16.773C8.17103 17.717 9.37377 18.3599 10.6831 18.6203C11.9925 18.8808 13.3497 18.7471 14.5831 18.2362C15.8165 17.7253 16.8707 16.8601 17.6124 15.7501C18.3541 14.6401 18.75 13.335 18.75 12C18.748 10.2104 18.0362 8.49466 16.7708 7.22922C15.5053 5.96378 13.7896 5.25199 12 5.25ZM12 17.25C10.9616 17.25 9.94661 16.9421 9.08325 16.3652C8.2199 15.7883 7.54699 14.9684 7.14963 14.0091C6.75227 13.0498 6.6483 11.9942 6.85087 10.9758C7.05345 9.95738 7.55346 9.02192 8.28769 8.28769C9.02191 7.55346 9.95737 7.05345 10.9758 6.85088C11.9942 6.6483 13.0498 6.75227 14.0091 7.14963C14.9684 7.54699 15.7883 8.2199 16.3652 9.08326C16.9421 9.94661 17.25 10.9616 17.25 12C17.2485 13.3919 16.6949 14.7264 15.7107 15.7107C14.7264 16.6949 13.3919 17.2485 12 17.25Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  RecordIcon.displayName = "RecordIcon";
  var Trash = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: `0 0 24 24`,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.25 4.5H16.5V3.75C16.5 3.15326 16.2629 2.58097 15.841 2.15901C15.419 1.73705 14.8467 1.5 14.25 1.5H9.75C9.15326 1.5 8.58097 1.73705 8.15901 2.15901C7.73705 2.58097 7.5 3.15326 7.5 3.75V4.5H3.75C3.55109 4.5 3.36032 4.57902 3.21967 4.71967C3.07902 4.86032 3 5.05109 3 5.25C3 5.44891 3.07902 5.63968 3.21967 5.78033C3.36032 5.92098 3.55109 6 3.75 6H4.5V19.5C4.5 19.8978 4.65804 20.2794 4.93934 20.5607C5.22064 20.842 5.60218 21 6 21H18C18.3978 21 18.7794 20.842 19.0607 20.5607C19.342 20.2794 19.5 19.8978 19.5 19.5V6H20.25C20.4489 6 20.6397 5.92098 20.7803 5.78033C20.921 5.63968 21 5.44891 21 5.25C21 5.05109 20.921 4.86032 20.7803 4.71967C20.6397 4.57902 20.4489 4.5 20.25 4.5ZM9 3.75C9 3.55109 9.07902 3.36032 9.21967 3.21967C9.36032 3.07902 9.55109 3 9.75 3H14.25C14.4489 3 14.6397 3.07902 14.7803 3.21967C14.921 3.36032 15 3.55109 15 3.75V4.5H9V3.75ZM18 19.5H6V6H18V19.5ZM10.5 9.75V15.75C10.5 15.9489 10.421 16.1397 10.2803 16.2803C10.1397 16.421 9.94891 16.5 9.75 16.5C9.55109 16.5 9.36032 16.421 9.21967 16.2803C9.07902 16.1397 9 15.9489 9 15.75V9.75C9 9.55109 9.07902 9.36032 9.21967 9.21967C9.36032 9.07902 9.55109 9 9.75 9C9.94891 9 10.1397 9.07902 10.2803 9.21967C10.421 9.36032 10.5 9.55109 10.5 9.75ZM15 9.75V15.75C15 15.9489 14.921 16.1397 14.7803 16.2803C14.6397 16.421 14.4489 16.5 14.25 16.5C14.0511 16.5 13.8603 16.421 13.7197 16.2803C13.579 16.1397 13.5 15.9489 13.5 15.75V9.75C13.5 9.55109 13.579 9.36032 13.7197 9.21967C13.8603 9.07902 14.0511 9 14.25 9C14.4489 9 14.6397 9.07902 14.7803 9.21967C14.921 9.36032 15 9.55109 15 9.75Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  Trash.displayName = "Trash";
  var UserIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21.6488 19.8751C20.2209 17.4067 18.0206 15.6367 15.4528 14.7976C16.723 14.0415 17.7098 12.8893 18.2618 11.518C18.8137 10.1468 18.9003 8.63224 18.5082 7.20701C18.1161 5.78178 17.267 4.52467 16.0912 3.62873C14.9155 2.73279 13.4782 2.24756 12 2.24756C10.5218 2.24756 9.08451 2.73279 7.90878 3.62873C6.73306 4.52467 5.88394 5.78178 5.49183 7.20701C5.09971 8.63224 5.18629 10.1468 5.73825 11.518C6.29021 12.8893 7.27704 14.0415 8.5472 14.7976C5.97938 15.6357 3.77907 17.4057 2.35126 19.8751C2.2989 19.9605 2.26417 20.0555 2.24912 20.1545C2.23407 20.2535 2.239 20.3545 2.26363 20.4516C2.28825 20.5487 2.33207 20.6399 2.3925 20.7197C2.45293 20.7996 2.52874 20.8666 2.61547 20.9167C2.7022 20.9667 2.79808 20.999 2.89745 21.0114C2.99683 21.0238 3.0977 21.0163 3.19409 20.9891C3.29049 20.9619 3.38047 20.9157 3.45872 20.8532C3.53697 20.7907 3.6019 20.7131 3.6497 20.6251C5.41595 17.5726 8.53782 15.7501 12 15.7501C15.4622 15.7501 18.5841 17.5726 20.3503 20.6251C20.3981 20.7131 20.4631 20.7907 20.5413 20.8532C20.6196 20.9157 20.7095 20.9619 20.8059 20.9891C20.9023 21.0163 21.0032 21.0238 21.1026 21.0114C21.2019 20.999 21.2978 20.9667 21.3845 20.9167C21.4713 20.8666 21.5471 20.7996 21.6075 20.7197C21.6679 20.6399 21.7118 20.5487 21.7364 20.4516C21.761 20.3545 21.766 20.2535 21.7509 20.1545C21.7358 20.0555 21.7011 19.9605 21.6488 19.8751ZM6.75001 9.00011C6.75001 7.96176 7.05792 6.94672 7.63479 6.08337C8.21167 5.22001 9.03161 4.5471 9.99092 4.14974C10.9502 3.75238 12.0058 3.64841 13.0242 3.85099C14.0426 4.05356 14.9781 4.55357 15.7123 5.2878C16.4465 6.02202 16.9466 6.95748 17.1491 7.97589C17.3517 8.99429 17.2477 10.0499 16.8504 11.0092C16.453 11.9685 15.7801 12.7884 14.9168 13.3653C14.0534 13.9422 13.0384 14.2501 12 14.2501C10.6081 14.2486 9.27359 13.695 8.28934 12.7108C7.3051 11.7265 6.7515 10.392 6.75001 9.00011Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  UserIcon.displayName = "UserIcon";
  var VideoCamera = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M23.6034 6.84375C23.4838 6.77964 23.3491 6.74919 23.2135 6.75563C23.078 6.76207 22.9467 6.80516 22.8337 6.88031L19.5 9.09844V6.75C19.5 6.35218 19.342 5.97064 19.0607 5.68934C18.7794 5.40804 18.3978 5.25 18 5.25H3C2.60218 5.25 2.22064 5.40804 1.93934 5.68934C1.65804 5.97064 1.5 6.35218 1.5 6.75V17.25C1.5 17.6478 1.65804 18.0294 1.93934 18.3107C2.22064 18.592 2.60218 18.75 3 18.75H18C18.3978 18.75 18.7794 18.592 19.0607 18.3107C19.342 18.0294 19.5 17.6478 19.5 17.25V14.9062L22.8337 17.1291C22.9576 17.2095 23.1024 17.2515 23.25 17.25C23.4489 17.25 23.6397 17.171 23.7803 17.0303C23.921 16.8897 24 16.6989 24 16.5V7.5C23.9991 7.36506 23.9617 7.23287 23.8919 7.11737C23.8221 7.00187 23.7225 6.90734 23.6034 6.84375ZM18 17.25H3V6.75H18V17.25ZM22.5 15.0984L19.5 13.0988V10.9012L22.5 8.90625V15.0984Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  VideoCamera.displayName = "VideoCamera";
  var XIcon = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M19.2806 18.2193C19.3503 18.289 19.4056 18.3717 19.4433 18.4628C19.481 18.5538 19.5004 18.6514 19.5004 18.7499C19.5004 18.8485 19.481 18.9461 19.4433 19.0371C19.4056 19.1281 19.3503 19.2109 19.2806 19.2806C19.2109 19.3502 19.1282 19.4055 19.0372 19.4432C18.9461 19.4809 18.8485 19.5003 18.75 19.5003C18.6514 19.5003 18.5539 19.4809 18.4628 19.4432C18.3718 19.4055 18.289 19.3502 18.2194 19.2806L12 13.0602L5.78061 19.2806C5.63988 19.4213 5.44901 19.5003 5.24999 19.5003C5.05097 19.5003 4.8601 19.4213 4.71936 19.2806C4.57863 19.1398 4.49957 18.949 4.49957 18.7499C4.49957 18.5509 4.57863 18.36 4.71936 18.2193L10.9397 11.9999L4.71936 5.78055C4.57863 5.63982 4.49957 5.44895 4.49957 5.24993C4.49957 5.05091 4.57863 4.86003 4.71936 4.7193C4.8601 4.57857 5.05097 4.49951 5.24999 4.49951C5.44901 4.49951 5.63988 4.57857 5.78061 4.7193L12 10.9396L18.2194 4.7193C18.3601 4.57857 18.551 4.49951 18.75 4.49951C18.949 4.49951 19.1399 4.57857 19.2806 4.7193C19.4213 4.86003 19.5004 5.05091 19.5004 5.24993C19.5004 5.44895 19.4213 5.63982 19.2806 5.78055L13.0603 11.9999L19.2806 18.2193Z",
            fill: props.color || "black"
          }
        )
      }
    )
  );
  XIcon.displayName = "XIcon";
  var Logo = reactExports.forwardRef(
    ({ size: size2 = 24, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: size2,
        height: size2,
        viewBox: "0 0 32 32",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M19.1988 4.61268C19.1988 2.61447 17.8296 0.936016 15.9781 0.464416C16.6069 0.157861 17.2975 -0.000988396 17.9971 4.62724e-06C20.5446 4.62724e-06 22.6098 2.06519 22.6098 4.61268C22.6098 7.16017 20.5446 9.22536 17.9971 9.22536C17.2975 9.22635 16.6069 9.06751 15.9781 8.76095C17.8294 8.28935 19.1988 6.61089 19.1988 4.61268Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint0_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M19.1988 4.61268C19.1988 2.61447 17.8296 0.936016 15.9781 0.464416C16.6069 0.157861 17.2975 -0.000988396 17.9971 4.62724e-06C20.5446 4.62724e-06 22.6098 2.06519 22.6098 4.61268C22.6098 7.16017 20.5446 9.22536 17.9971 9.22536C17.2975 9.22635 16.6069 9.06751 15.9781 8.76095C17.8294 8.28935 19.1988 6.61089 19.1988 4.61268Z",
              "data-figma-gradient-fill": '{"type":"GRADIENT_ANGULAR","stops":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"stopsVar":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"transform":{"m00":22.266670227050781,"m01":-23.733333587646484,"m02":16.733337402343750,"m10":23.733339309692383,"m11":22.266677856445312,"m12":-7.0000061988830566},"opacity":1.0,"blendMode":"NORMAL","visible":true}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M13.0767 4.53889C12.077 2.8084 10.0524 2.03956 8.21323 2.55673C8.60453 1.97683 9.12316 1.49399 9.72951 1.14507C11.9357 -0.128032 14.7568 0.62716 16.0306 2.83349C17.3045 5.03983 16.5483 7.86076 14.3422 9.13441C13.7368 9.48509 13.0594 9.69283 12.3615 9.74181C13.7291 8.40763 14.0758 6.26938 13.0767 4.53889Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint1_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M13.0767 4.53889C12.077 2.8084 10.0524 2.03956 8.21323 2.55673C8.60453 1.97683 9.12316 1.49399 9.72951 1.14507C11.9357 -0.128032 14.7568 0.62716 16.0306 2.83349C17.3045 5.03983 16.5483 7.86076 14.3422 9.13441C13.7368 9.48509 13.0594 9.69283 12.3615 9.74181C13.7291 8.40763 14.0758 6.26938 13.0767 4.53889Z",
              "data-figma-gradient-fill": '{"type":"GRADIENT_ANGULAR","stops":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"stopsVar":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"transform":{"m00":22.266670227050781,"m01":-23.733333587646484,"m02":16.733337402343750,"m10":23.733339309692383,"m11":22.266677856445312,"m12":-7.0000061988830566},"opacity":1.0,"blendMode":"NORMAL","visible":true}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.73768 7.53658C6.007 6.53729 3.86893 6.88398 2.53458 8.25173C2.58352 7.55379 2.79127 6.87627 3.14197 6.27086C4.41507 4.06471 7.23674 3.30879 9.44289 4.58262C11.649 5.85646 12.405 8.67739 11.1313 10.8835C10.7823 11.4899 10.2994 12.0085 9.71947 12.3998C10.237 10.5603 9.46817 8.53532 7.73768 7.53658Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint2_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.73768 7.53658C6.007 6.53729 3.86893 6.88398 2.53458 8.25173C2.58352 7.55379 2.79127 6.87627 3.14197 6.27086C4.41507 4.06471 7.23674 3.30879 9.44289 4.58262C11.649 5.85646 12.405 8.67739 11.1313 10.8835C10.7823 11.4899 10.2994 12.0085 9.71947 12.3998C10.237 10.5603 9.46817 8.53532 7.73768 7.53658Z",
              "data-figma-gradient-fill": '{"type":"GRADIENT_ANGULAR","stops":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"stopsVar":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"transform":{"m00":22.266670227050781,"m01":-23.733333587646484,"m02":16.733337402343750,"m10":23.733339309692383,"m11":22.266677856445312,"m12":-7.0000061988830566},"opacity":1.0,"blendMode":"NORMAL","visible":true}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4.61268 12.8013C2.61429 12.8013 0.93601 14.1705 0.464409 16.0221C0.157854 15.3932 -0.000988397 14.7026 4.62746e-06 14.003C4.62746e-06 11.4555 2.06519 9.39035 4.61268 9.39035C7.16018 9.39035 9.22536 11.4555 9.22536 14.003C9.22627 14.7026 9.06743 15.3932 8.76096 16.0221C8.28936 14.1705 6.6109 12.8013 4.61268 12.8013Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint3_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4.61268 12.8013C2.61429 12.8013 0.93601 14.1705 0.464409 16.0221C0.157854 15.3932 -0.000988397 14.7026 4.62746e-06 14.003C4.62746e-06 11.4555 2.06519 9.39035 4.61268 9.39035C7.16018 9.39035 9.22536 11.4555 9.22536 14.003C9.22627 14.7026 9.06743 15.3932 8.76096 16.0221C8.28936 14.1705 6.6109 12.8013 4.61268 12.8013Z",
              "data-figma-gradient-fill": '{"type":"GRADIENT_ANGULAR","stops":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"stopsVar":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"transform":{"m00":22.266670227050781,"m01":-23.733333587646484,"m02":16.733337402343750,"m10":23.733339309692383,"m11":22.266677856445312,"m12":-7.0000061988830566},"opacity":1.0,"blendMode":"NORMAL","visible":true}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4.5389 18.9234C2.80823 19.9225 2.03975 21.9477 2.55637 23.7869C1.97647 23.3956 1.49363 22.8769 1.14471 22.2706C-0.128761 20.0646 0.627165 17.2433 2.83313 15.9695C5.0391 14.6956 7.8604 15.4516 9.13405 17.6579C9.48473 18.2633 9.69248 18.9407 9.74145 19.6386C8.40765 18.271 6.2694 17.9243 4.5389 18.9234Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint4_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4.5389 18.9234C2.80823 19.9225 2.03975 21.9477 2.55637 23.7869C1.97647 23.3956 1.49363 22.8769 1.14471 22.2706C-0.128761 20.0646 0.627165 17.2433 2.83313 15.9695C5.0391 14.6956 7.8604 15.4516 9.13405 17.6579C9.48473 18.2633 9.69248 18.9407 9.74145 19.6386C8.40765 18.271 6.2694 17.9243 4.5389 18.9234Z",
              "data-figma-gradient-fill": '{"type":"GRADIENT_ANGULAR","stops":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"stopsVar":[{"color":{"r":0.0,"g":0.59215688705444336,"b":1.0,"a":1.0},"position":0.0},{"color":{"r":0.60000002384185791,"g":0.37254902720451355,"b":0.97254902124404907,"a":1.0},"position":0.11999999731779099},{"color":{"r":0.96470588445663452,"g":0.20000000298023224,"b":0.63529413938522339,"a":1.0},"position":0.23999999463558197},{"color":{"r":1.0,"g":0.011764706112444401,"b":0.25882354378700256,"a":1.0},"position":0.36000001430511475},{"color":{"r":1.0,"g":0.54117649793624878,"b":0.0,"a":1.0},"position":0.47999998927116394},{"color":{"r":1.0,"g":0.76862746477127075,"b":0.45490196347236633,"a":1.0},"position":0.60000002384185791},{"color":{"r":0.67843139171600342,"g":0.86666667461395264,"b":1.0,"a":1.0},"position":0.83999997377395630}],"transform":{"m00":22.266670227050781,"m01":-23.733333587646484,"m02":16.733337402343750,"m10":23.733339309692383,"m11":22.266677856445312,"m12":-7.0000061988830566},"opacity":1.0,"blendMode":"NORMAL","visible":true}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.53607 24.2623C6.53697 25.993 6.88365 28.131 8.25122 29.4654C7.55335 29.4164 6.87589 29.2087 6.27054 28.858C4.06438 27.5849 3.30846 24.7632 4.58211 22.5571C5.85576 20.3509 8.67706 19.595 10.8832 20.8687C11.4896 21.2176 12.0082 21.7004 12.3995 22.2803C10.5603 21.763 8.53536 22.5318 7.53607 24.2623Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint5_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.8011 27.3873C12.8011 29.3857 14.1705 31.064 16.022 31.5356C15.3932 31.8421 14.7026 32.001 14.003 32C11.4555 32 9.3903 29.9348 9.3903 27.3873C9.3903 24.8398 11.4555 22.7747 14.003 22.7747C14.7026 22.7738 15.3931 22.9326 16.022 23.2391C14.1705 23.7107 12.8011 25.3891 12.8011 27.3873Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint6_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M18.9234 27.4611C19.9225 29.1916 21.9476 29.9604 23.7868 29.4433C23.3955 30.0231 22.8768 30.506 22.2705 30.8549C20.0642 32.128 17.2433 31.3728 15.9694 29.1665C14.6956 26.9602 15.4515 24.1392 17.6579 22.8656C18.2632 22.5149 18.9407 22.3072 19.6385 22.2582C18.271 23.5924 17.9243 25.7306 18.9234 27.4611Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint7_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M24.2624 24.464C25.9929 25.4631 28.1311 25.1164 29.4655 23.7486C29.4164 24.4464 29.2086 25.1237 28.8579 25.729C27.5848 27.9351 24.7631 28.691 22.557 27.4174C20.3508 26.1437 19.5947 23.323 20.8686 21.1163C21.2175 20.5099 21.7003 19.9913 22.2802 19.6C21.7636 21.4397 22.5319 23.4647 24.2624 24.464Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint8_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M27.3873 19.1987C29.3855 19.1987 31.064 17.8295 31.5356 15.9779C31.8421 16.6068 32.001 17.2974 32 17.997C32 20.5445 29.9348 22.6097 27.3873 22.6097C24.8398 22.6097 22.7746 20.5445 22.7746 17.997C22.7738 17.2974 22.9328 16.6068 23.2396 15.9779C23.7106 17.8295 25.3891 19.1987 27.3873 19.1987Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint9_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M27.4611 13.0766C29.1916 12.0775 29.9605 10.0523 29.4431 8.21315C30.0231 8.60449 30.5059 9.1231 30.855 9.72943C32.1281 11.9358 31.3729 14.7567 29.1665 16.0305C26.9602 17.3044 24.1393 16.5484 22.8656 14.3421C22.515 13.7368 22.3072 13.0593 22.2582 12.3614C23.5924 13.729 25.7305 14.0757 27.4611 13.0766Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint10_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M24.4638 7.73767C25.4631 6.00718 25.1164 3.86893 23.7487 2.53458C24.4469 2.58344 25.1248 2.79126 25.7305 3.14216C27.9366 4.41526 28.6925 7.23692 27.4187 9.44307C26.1449 11.6492 23.3239 12.4053 21.1178 11.1315C20.5114 10.7825 19.9927 10.2997 19.6013 9.71984C21.4397 10.237 23.4647 9.46816 24.4638 7.73767Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              clipPath: "url(#paint11_angular_764_1431_clip_path)",
              "data-figma-skip-parse": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "matrix(0.0111333 0.0118667 -0.0118667 0.0111333 16 16)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "-1391.49",
                  y: "-1391.49",
                  width: "2782.99",
                  height: "2782.99",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        background: "conic-gradient(from 90deg,rgba(0, 151, 255, 1) 0deg,rgba(153, 95, 248, 1) 43.2deg,rgba(246, 51, 162, 1) 86.4deg,rgba(255, 3, 66, 1) 129.6deg,rgba(255, 138, 0, 1) 172.8deg,rgba(255, 196, 116, 1) 216deg,rgba(173, 221, 255, 1) 302.4deg,rgba(0, 151, 255, 1) 360deg)",
                        height: "100%",
                        width: "100%",
                        opacity: 1
                      }
                    }
                  )
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint0_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.1988 4.61268C19.1988 2.61447 17.8296 0.936016 15.9781 0.464416C16.6069 0.157861 17.2975 -0.000988396 17.9971 4.62724e-06C20.5446 4.62724e-06 22.6098 2.06519 22.6098 4.61268C22.6098 7.16017 20.5446 9.22536 17.9971 9.22536C17.2975 9.22635 16.6069 9.06751 15.9781 8.76095C17.8294 8.28935 19.1988 6.61089 19.1988 4.61268Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint1_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.0767 4.53889C12.077 2.8084 10.0524 2.03956 8.21323 2.55673C8.60453 1.97683 9.12316 1.49399 9.72951 1.14507C11.9357 -0.128032 14.7568 0.62716 16.0306 2.83349C17.3045 5.03983 16.5483 7.86076 14.3422 9.13441C13.7368 9.48509 13.0594 9.69283 12.3615 9.74181C13.7291 8.40763 14.0758 6.26938 13.0767 4.53889Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint2_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.73768 7.53658C6.007 6.53729 3.86893 6.88398 2.53458 8.25173C2.58352 7.55379 2.79127 6.87627 3.14197 6.27086C4.41507 4.06471 7.23674 3.30879 9.44289 4.58262C11.649 5.85646 12.405 8.67739 11.1313 10.8835C10.7823 11.4899 10.2994 12.0085 9.71947 12.3998C10.237 10.5603 9.46817 8.53532 7.73768 7.53658Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint3_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4.61268 12.8013C2.61429 12.8013 0.93601 14.1705 0.464409 16.0221C0.157854 15.3932 -0.000988397 14.7026 4.62746e-06 14.003C4.62746e-06 11.4555 2.06519 9.39035 4.61268 9.39035C7.16018 9.39035 9.22536 11.4555 9.22536 14.003C9.22627 14.7026 9.06743 15.3932 8.76096 16.0221C8.28936 14.1705 6.6109 12.8013 4.61268 12.8013Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint4_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4.5389 18.9234C2.80823 19.9225 2.03975 21.9477 2.55637 23.7869C1.97647 23.3956 1.49363 22.8769 1.14471 22.2706C-0.128761 20.0646 0.627165 17.2433 2.83313 15.9695C5.0391 14.6956 7.8604 15.4516 9.13405 17.6579C9.48473 18.2633 9.69248 18.9407 9.74145 19.6386C8.40765 18.271 6.2694 17.9243 4.5389 18.9234Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint5_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.53607 24.2623C6.53697 25.993 6.88365 28.131 8.25122 29.4654C7.55335 29.4164 6.87589 29.2087 6.27054 28.858C4.06438 27.5849 3.30846 24.7632 4.58211 22.5571C5.85576 20.3509 8.67706 19.595 10.8832 20.8687C11.4896 21.2176 12.0082 21.7004 12.3995 22.2803C10.5603 21.763 8.53536 22.5318 7.53607 24.2623Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint6_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.8011 27.3873C12.8011 29.3857 14.1705 31.064 16.022 31.5356C15.3932 31.8421 14.7026 32.001 14.003 32C11.4555 32 9.3903 29.9348 9.3903 27.3873C9.3903 24.8398 11.4555 22.7747 14.003 22.7747C14.7026 22.7738 15.3931 22.9326 16.022 23.2391C14.1705 23.7107 12.8011 25.3891 12.8011 27.3873Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint7_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18.9234 27.4611C19.9225 29.1916 21.9476 29.9604 23.7868 29.4433C23.3955 30.0231 22.8768 30.506 22.2705 30.8549C20.0642 32.128 17.2433 31.3728 15.9694 29.1665C14.6956 26.9602 15.4515 24.1392 17.6579 22.8656C18.2632 22.5149 18.9407 22.3072 19.6385 22.2582C18.271 23.5924 17.9243 25.7306 18.9234 27.4611Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint8_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.2624 24.464C25.9929 25.4631 28.1311 25.1164 29.4655 23.7486C29.4164 24.4464 29.2086 25.1237 28.8579 25.729C27.5848 27.9351 24.7631 28.691 22.557 27.4174C20.3508 26.1437 19.5947 23.323 20.8686 21.1163C21.2175 20.5099 21.7003 19.9913 22.2802 19.6C21.7636 21.4397 22.5319 23.4647 24.2624 24.464Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint9_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M27.3873 19.1987C29.3855 19.1987 31.064 17.8295 31.5356 15.9779C31.8421 16.6068 32.001 17.2974 32 17.997C32 20.5445 29.9348 22.6097 27.3873 22.6097C24.8398 22.6097 22.7746 20.5445 22.7746 17.997C22.7738 17.2974 22.9328 16.6068 23.2396 15.9779C23.7106 17.8295 25.3891 19.1987 27.3873 19.1987Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint10_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M27.4611 13.0766C29.1916 12.0775 29.9605 10.0523 29.4431 8.21315C30.0231 8.60449 30.5059 9.1231 30.855 9.72943C32.1281 11.9358 31.3729 14.7567 29.1665 16.0305C26.9602 17.3044 24.1393 16.5484 22.8656 14.3421C22.515 13.7368 22.3072 13.0593 22.2582 12.3614C23.5924 13.729 25.7305 14.0757 27.4611 13.0766Z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "paint11_angular_764_1431_clip_path", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.4638 7.73767C25.4631 6.00718 25.1164 3.86893 23.7487 2.53458C24.4469 2.58344 25.1248 2.79126 25.7305 3.14216C27.9366 4.41526 28.6925 7.23692 27.4187 9.44307C26.1449 11.6492 23.3239 12.4053 21.1178 11.1315C20.5114 10.7825 19.9927 10.2997 19.6013 9.71984C21.4397 10.237 23.4647 9.46816 24.4638 7.73767Z" }) })
          ] })
        ]
      }
    )
  );
  Logo.displayName = "Logo";
  var AEP = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5101)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M14.0932 65H10.7977L15.819 50.4545H19.7821L24.7963 65H21.5009L17.8574 53.7784H17.7437L14.0932 65ZM13.8872 59.2827H21.6713V61.6832H13.8872V59.2827ZM26.147 65V50.4545H35.9482V52.9901H29.2223V56.456H35.4439V58.9915H29.2223V62.4645H35.9766V65H26.147ZM37.9931 65V50.4545H43.7317C44.835 50.4545 45.7748 50.6652 46.5514 51.0866C47.3279 51.5033 47.9197 52.0833 48.3269 52.8267C48.7389 53.5653 48.9448 54.4176 48.9448 55.3835C48.9448 56.3494 48.7365 57.2017 48.3198 57.9403C47.9031 58.679 47.2995 59.2543 46.5087 59.6662C45.7228 60.0781 44.771 60.2841 43.6536 60.2841H39.996V57.8196H43.1565C43.7483 57.8196 44.236 57.7178 44.6195 57.5142C45.0078 57.3059 45.2966 57.0194 45.486 56.6548C45.6801 56.2855 45.7772 55.8617 45.7772 55.3835C45.7772 54.9006 45.6801 54.4792 45.486 54.1193C45.2966 53.7547 45.0078 53.473 44.6195 53.2741C44.2313 53.0705 43.7388 52.9688 43.1423 52.9688H41.0684V65H37.9931Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5101", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  AEP.displayName = "AEP";
  var AI = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5079)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#FF5C00"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M24.1881 65H20.8926L25.914 50.4545H29.877L34.8912 65H31.5958L27.9523 53.7784H27.8387L24.1881 65ZM23.9821 59.2827H31.7662V61.6832H23.9821V59.2827ZM39.3172 50.4545V65H36.2419V50.4545H39.3172Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5079", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  AI.displayName = "AI";
  var AVI = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5095)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M17.8158 65H14.5204L19.5417 50.4545H23.5048L28.519 65H25.2235L21.58 53.7784H21.4664L17.8158 65ZM17.6099 59.2827H25.394V61.6832H17.6099V59.2827ZM30.6811 50.4545L34.1967 61.5057H34.3317L37.8544 50.4545H41.2635L36.2493 65H32.2862L27.2649 50.4545H30.6811ZM45.6895 50.4545V65H42.6142V50.4545H45.6895Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5095", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  AVI.displayName = "AVI";
  var Blend = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5094)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#FF8A00"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M5.22168 64V52.3636H9.88077C10.7368 52.3636 11.4508 52.4905 12.0228 52.7443C12.5948 52.9981 13.0247 53.3504 13.3126 53.8011C13.6005 54.2481 13.7444 54.7633 13.7444 55.3466C13.7444 55.8011 13.6535 56.2008 13.4717 56.5455C13.2899 56.8864 13.0399 57.1667 12.7217 57.3864C12.4073 57.6023 12.0474 57.7557 11.6421 57.8466V57.9602C12.0853 57.9792 12.5001 58.1042 12.8864 58.3352C13.2766 58.5663 13.5929 58.8902 13.8353 59.3068C14.0777 59.7197 14.1989 60.2121 14.1989 60.7841C14.1989 61.4015 14.0455 61.9527 13.7387 62.4375C13.4357 62.9186 12.9868 63.2992 12.3921 63.5795C11.7974 63.8598 11.0645 64 10.1933 64H5.22168ZM7.6819 61.9886H9.68758C10.3732 61.9886 10.8732 61.858 11.1876 61.5966C11.502 61.3314 11.6592 60.9792 11.6592 60.5398C11.6592 60.2178 11.5815 59.9337 11.4262 59.6875C11.2709 59.4413 11.0493 59.2481 10.7614 59.108C10.4774 58.9678 10.1383 58.8977 9.7444 58.8977H7.6819V61.9886ZM7.6819 57.233H9.50577C9.84289 57.233 10.1421 57.1742 10.4035 57.0568C10.6686 56.9356 10.877 56.7652 11.0285 56.5455C11.1838 56.3258 11.2614 56.0625 11.2614 55.7557C11.2614 55.3352 11.1118 54.9962 10.8126 54.7386C10.5171 54.4811 10.0967 54.3523 9.55122 54.3523H7.6819V57.233ZM15.4798 64V52.3636H17.94V61.9716H22.9287V64H15.4798ZM24.2379 64V52.3636H32.0788V54.392H26.6982V57.1648H31.6754V59.1932H26.6982V61.9716H32.1016V64H24.2379ZM43.4478 52.3636V64H41.3228L36.2603 56.6761H36.175V64H33.7148V52.3636H35.8739L40.8966 59.6818H40.9989V52.3636H43.4478ZM49.2854 64H45.1604V52.3636H49.3195C50.49 52.3636 51.4975 52.5966 52.3422 53.0625C53.1869 53.5246 53.8366 54.1894 54.2911 55.0568C54.7494 55.9242 54.9786 56.9621 54.9786 58.1705C54.9786 59.3826 54.7494 60.4242 54.2911 61.2955C53.8366 62.1667 53.1832 62.8352 52.3309 63.3011C51.4824 63.767 50.4672 64 49.2854 64ZM47.6207 61.892H49.1832C49.9104 61.892 50.5222 61.7633 51.0184 61.5057C51.5184 61.2443 51.8934 60.8409 52.1434 60.2955C52.3972 59.7462 52.5241 59.0379 52.5241 58.1705C52.5241 57.3106 52.3972 56.608 52.1434 56.0625C51.8934 55.517 51.5203 55.1155 51.0241 54.858C50.5279 54.6004 49.9161 54.4716 49.1888 54.4716H47.6207V61.892Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5094", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Blend.displayName = "Blend";
  var C4D = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5096)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#344054"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M23.4257 55.5469H20.315C20.2581 55.1444 20.1421 54.7869 19.9669 54.4744C19.7917 54.1572 19.5668 53.8873 19.2922 53.6648C19.0176 53.4422 18.7004 53.2718 18.3405 53.1534C17.9854 53.035 17.5995 52.9759 17.1828 52.9759C16.43 52.9759 15.7742 53.1629 15.2155 53.5369C14.6568 53.9062 14.2236 54.446 13.9158 55.1562C13.608 55.8617 13.4542 56.7187 13.4542 57.7273C13.4542 58.7642 13.608 59.6354 13.9158 60.3409C14.2283 61.0464 14.6639 61.5791 15.2226 61.9389C15.7813 62.2988 16.4276 62.4787 17.1615 62.4787C17.5735 62.4787 17.9546 62.4242 18.305 62.3153C18.6601 62.2064 18.975 62.0478 19.2496 61.8395C19.5242 61.6264 19.7515 61.3684 19.9314 61.0653C20.1161 60.7623 20.2439 60.4167 20.315 60.0284L23.4257 60.0426C23.3453 60.7102 23.144 61.3542 22.8221 61.9744C22.5048 62.59 22.0763 63.1416 21.5365 63.6293C21.0015 64.1122 20.3623 64.4957 19.6189 64.7798C18.8803 65.0592 18.0446 65.1989 17.1118 65.1989C15.8145 65.1989 14.6544 64.9053 13.6317 64.3182C12.6137 63.7311 11.8088 62.8812 11.2169 61.7685C10.6298 60.6558 10.3363 59.3087 10.3363 57.7273C10.3363 56.1411 10.6346 54.7917 11.2311 53.679C11.8277 52.5663 12.6374 51.7187 13.6601 51.1364C14.6828 50.5492 15.8334 50.2557 17.1118 50.2557C17.9546 50.2557 18.7359 50.3741 19.4556 50.6108C20.18 50.8475 20.8216 51.1932 21.3803 51.6477C21.939 52.0975 22.3935 52.6491 22.7439 53.3026C23.099 53.956 23.3263 54.7041 23.4257 55.5469ZM24.9256 62.4432V60.0213L30.998 50.4545H33.0861V53.8068H31.8503L28.0222 59.8651V59.9787H36.6515V62.4432H24.9256ZM31.9071 65V61.7045L31.964 60.6321V50.4545H34.8475V65H31.9071ZM43.5419 65H38.3857V50.4545H43.5846C45.0476 50.4545 46.3071 50.7457 47.363 51.3281C48.4188 51.9058 49.2309 52.7367 49.799 53.821C50.372 54.9053 50.6584 56.2027 50.6584 57.7131C50.6584 59.2282 50.372 60.5303 49.799 61.6193C49.2309 62.7083 48.4141 63.544 47.3488 64.1264C46.2882 64.7088 45.0192 65 43.5419 65ZM41.461 62.3651H43.4141C44.3232 62.3651 45.0879 62.2041 45.7081 61.8821C46.3331 61.5554 46.8019 61.0511 47.1144 60.3693C47.4316 59.6828 47.5902 58.7973 47.5902 57.7131C47.5902 56.6383 47.4316 55.7599 47.1144 55.0781C46.8019 54.3963 46.3355 53.8944 45.7152 53.5724C45.095 53.2505 44.3303 53.0895 43.4212 53.0895H41.461V62.3651Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5096", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  C4D.displayName = "C4D";
  var CDR = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5098)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M23.1406 55.5469H20.0298C19.973 55.1444 19.857 54.7869 19.6818 54.4744C19.5066 54.1572 19.2817 53.8873 19.0071 53.6648C18.7324 53.4422 18.4152 53.2718 18.0554 53.1534C17.7002 53.035 17.3144 52.9759 16.8977 52.9759C16.1449 52.9759 15.4891 53.1629 14.9304 53.5369C14.3717 53.9062 13.9384 54.446 13.6306 55.1562C13.3229 55.8617 13.169 56.7187 13.169 57.7273C13.169 58.7642 13.3229 59.6354 13.6306 60.3409C13.9431 61.0464 14.3788 61.5791 14.9375 61.9389C15.4962 62.2988 16.1425 62.4787 16.8764 62.4787C17.2883 62.4787 17.6695 62.4242 18.0199 62.3153C18.375 62.2064 18.6898 62.0478 18.9645 61.8395C19.2391 61.6264 19.4663 61.3684 19.6463 61.0653C19.8309 60.7623 19.9588 60.4167 20.0298 60.0284L23.1406 60.0426C23.0601 60.7102 22.8589 61.3542 22.5369 61.9744C22.2197 62.59 21.7912 63.1416 21.2514 63.6293C20.7163 64.1122 20.0771 64.4957 19.3338 64.7798C18.5951 65.0592 17.7594 65.1989 16.8267 65.1989C15.5293 65.1989 14.3693 64.9053 13.3466 64.3182C12.3286 63.7311 11.5236 62.8812 10.9318 61.7685C10.3447 60.6558 10.0511 59.3087 10.0511 57.7273C10.0511 56.1411 10.3494 54.7917 10.946 53.679C11.5426 52.5663 12.3522 51.7187 13.375 51.1364C14.3977 50.5492 15.5483 50.2557 16.8267 50.2557C17.6695 50.2557 18.4507 50.3741 19.1704 50.6108C19.8949 50.8475 20.5364 51.1932 21.0951 51.6477C21.6538 52.0975 22.1084 52.6491 22.4588 53.3026C22.8139 53.956 23.0412 54.7041 23.1406 55.5469ZM30.1021 65H24.9458V50.4545H30.1447C31.6078 50.4545 32.8672 50.7457 33.9231 51.3281C34.979 51.9058 35.791 52.7367 36.3592 53.821C36.9321 54.9053 37.2186 56.2027 37.2186 57.7131C37.2186 59.2282 36.9321 60.5303 36.3592 61.6193C35.791 62.7083 34.9743 63.544 33.9089 64.1264C32.8483 64.7088 31.5794 65 30.1021 65ZM28.0211 62.3651H29.9743C30.8833 62.3651 31.648 62.2041 32.2683 61.8821C32.8933 61.5554 33.362 61.0511 33.6745 60.3693C33.9918 59.6828 34.1504 58.7973 34.1504 57.7131C34.1504 56.6383 33.9918 55.7599 33.6745 55.0781C33.362 54.3963 32.8957 53.8944 32.2754 53.5724C31.6551 53.2505 30.8904 53.0895 29.9814 53.0895H28.0211V62.3651ZM39.0966 65V50.4545H44.8353C45.9337 50.4545 46.8712 50.651 47.6478 51.044C48.429 51.4323 49.0232 51.9839 49.4304 52.6989C49.8424 53.4091 50.0483 54.2448 50.0483 55.206C50.0483 56.1719 49.84 57.0028 49.4233 57.6989C49.0067 58.3902 48.403 58.9205 47.6123 59.2898C46.8263 59.6591 45.8746 59.8438 44.7571 59.8438H40.9148V57.3722H44.26C44.8471 57.3722 45.3348 57.2917 45.723 57.1307C46.1113 56.9697 46.4001 56.7282 46.5895 56.4062C46.7837 56.0843 46.8807 55.6842 46.8807 55.206C46.8807 54.723 46.7837 54.3158 46.5895 53.9844C46.4001 53.6529 46.1089 53.402 45.7159 53.2315C45.3277 53.0563 44.8376 52.9688 44.2458 52.9688H42.1719V65H39.0966ZM46.9517 58.3807L50.5668 65H47.1719L43.635 58.3807H46.9517Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5098", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  CDR.displayName = "CDR";
  var CSS$1 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5071)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M24.373 55.5469H21.2622C21.2054 55.1444 21.0894 54.7869 20.9142 54.4744C20.739 54.1572 20.5141 53.8873 20.2395 53.6648C19.9649 53.4422 19.6476 53.2718 19.2878 53.1534C18.9327 53.035 18.5468 52.9759 18.1301 52.9759C17.3773 52.9759 16.7215 53.1629 16.1628 53.5369C15.6041 53.9062 15.1708 54.446 14.8631 55.1562C14.5553 55.8617 14.4014 56.7187 14.4014 57.7273C14.4014 58.7642 14.5553 59.6354 14.8631 60.3409C15.1756 61.0464 15.6112 61.5791 16.1699 61.9389C16.7286 62.2988 17.3749 62.4787 18.1088 62.4787C18.5207 62.4787 18.9019 62.4242 19.2523 62.3153C19.6074 62.2064 19.9223 62.0478 20.1969 61.8395C20.4715 61.6264 20.6988 61.3684 20.8787 61.0653C21.0634 60.7623 21.1912 60.4167 21.2622 60.0284L24.373 60.0426C24.2925 60.7102 24.0913 61.3542 23.7693 61.9744C23.4521 62.59 23.0236 63.1416 22.4838 63.6293C21.9488 64.1122 21.3096 64.4957 20.5662 64.7798C19.8276 65.0592 18.9919 65.1989 18.0591 65.1989C16.7617 65.1989 15.6017 64.9053 14.579 64.3182C13.561 63.7311 12.7561 62.8812 12.1642 61.7685C11.5771 60.6558 11.2835 59.3087 11.2835 57.7273C11.2835 56.1411 11.5818 54.7917 12.1784 53.679C12.775 52.5663 13.5847 51.7187 14.6074 51.1364C15.6301 50.5492 16.7807 50.2557 18.0591 50.2557C18.9019 50.2557 19.6831 50.3741 20.4028 50.6108C21.1273 50.8475 21.7688 51.1932 22.3276 51.6477C22.8863 52.0975 23.3408 52.6491 23.6912 53.3026C24.0463 53.956 24.2736 54.7041 24.373 55.5469ZM34.0689 54.6378C34.0121 54.0649 33.7682 53.6198 33.3374 53.3026C32.9065 52.9853 32.3217 52.8267 31.5831 52.8267C31.0812 52.8267 30.6574 52.8977 30.3118 53.0398C29.9661 53.1771 29.701 53.3688 29.5163 53.6151C29.3364 53.8613 29.2464 54.1406 29.2464 54.4531C29.237 54.7135 29.2914 54.9408 29.4098 55.1349C29.5329 55.3291 29.701 55.4972 29.9141 55.6392C30.1271 55.7765 30.3733 55.8973 30.6527 56.0014C30.9321 56.1009 31.2304 56.1861 31.5476 56.2571L32.8544 56.5696C33.4889 56.7116 34.0713 56.901 34.6016 57.1378C35.1319 57.3745 35.5911 57.6657 35.9794 58.0114C36.3677 58.357 36.6683 58.7642 36.8814 59.233C37.0992 59.7017 37.2105 60.2391 37.2152 60.8452C37.2105 61.7353 36.9832 62.5071 36.5334 63.1605C36.0883 63.8092 35.4444 64.3134 34.6016 64.6733C33.7635 65.0284 32.7526 65.206 31.5689 65.206C30.3946 65.206 29.3719 65.026 28.5007 64.6662C27.6342 64.3063 26.9571 63.7737 26.4695 63.0682C25.9865 62.358 25.7332 61.4796 25.7095 60.4332H28.6854C28.7185 60.9209 28.8582 61.3281 29.1044 61.6548C29.3554 61.9768 29.6892 62.2206 30.1058 62.3864C30.5272 62.5473 31.0031 62.6278 31.5334 62.6278C32.0542 62.6278 32.5064 62.5521 32.8899 62.4006C33.2782 62.2491 33.5788 62.0384 33.7919 61.7685C34.005 61.4986 34.1115 61.1884 34.1115 60.8381C34.1115 60.5114 34.0144 60.2367 33.8203 60.0142C33.6309 59.7917 33.3516 59.6023 32.9822 59.446C32.6177 59.2898 32.1702 59.1477 31.6399 59.0199L30.0561 58.6222C28.8298 58.3239 27.8615 57.8575 27.1513 57.223C26.4411 56.5885 26.0883 55.7339 26.093 54.6591C26.0883 53.7784 26.3227 53.009 26.7962 52.3509C27.2744 51.6927 27.9302 51.179 28.7635 50.8097C29.5968 50.4403 30.5438 50.2557 31.6044 50.2557C32.6839 50.2557 33.6262 50.4403 34.4311 50.8097C35.2408 51.179 35.8705 51.6927 36.3203 52.3509C36.7701 53.009 37.0021 53.7713 37.0163 54.6378H34.0689ZM46.7744 54.6378C46.7175 54.0649 46.4737 53.6198 46.0428 53.3026C45.612 52.9853 45.0272 52.8267 44.2886 52.8267C43.7867 52.8267 43.3629 52.8977 43.0173 53.0398C42.6716 53.1771 42.4065 53.3688 42.2218 53.6151C42.0419 53.8613 41.9519 54.1406 41.9519 54.4531C41.9424 54.7135 41.9969 54.9408 42.1153 55.1349C42.2384 55.3291 42.4065 55.4972 42.6195 55.6392C42.8326 55.7765 43.0788 55.8973 43.3582 56.0014C43.6375 56.1009 43.9358 56.1861 44.2531 56.2571L45.5599 56.5696C46.1943 56.7116 46.7767 56.901 47.307 57.1378C47.8373 57.3745 48.2966 57.6657 48.6849 58.0114C49.0731 58.357 49.3738 58.7642 49.5869 59.233C49.8047 59.7017 49.9159 60.2391 49.9207 60.8452C49.9159 61.7353 49.6887 62.5071 49.2389 63.1605C48.7938 63.8092 48.1498 64.3134 47.307 64.6733C46.469 65.0284 45.4581 65.206 44.2744 65.206C43.1001 65.206 42.0774 65.026 41.2062 64.6662C40.3397 64.3063 39.6626 63.7737 39.1749 63.0682C38.692 62.358 38.4387 61.4796 38.415 60.4332H41.3908C41.424 60.9209 41.5637 61.3281 41.8099 61.6548C42.0608 61.9768 42.3946 62.2206 42.8113 62.3864C43.2327 62.5473 43.7085 62.6278 44.2388 62.6278C44.7597 62.6278 45.2119 62.5521 45.5954 62.4006C45.9836 62.2491 46.2843 62.0384 46.4974 61.7685C46.7104 61.4986 46.817 61.1884 46.817 60.8381C46.817 60.5114 46.7199 60.2367 46.5258 60.0142C46.3364 59.7917 46.057 59.6023 45.6877 59.446C45.3231 59.2898 44.8757 59.1477 44.3454 59.0199L42.7616 58.6222C41.5353 58.3239 40.567 57.8575 39.8567 57.223C39.1465 56.5885 38.7938 55.7339 38.7985 54.6591C38.7938 53.7784 39.0281 53.009 39.5016 52.3509C39.9799 51.6927 40.6356 51.179 41.469 50.8097C42.3023 50.4403 43.2493 50.2557 44.3099 50.2557C45.3894 50.2557 46.3317 50.4403 47.1366 50.8097C47.9462 51.179 48.576 51.6927 49.0258 52.3509C49.4756 53.009 49.7076 53.7713 49.7218 54.6378H46.7744Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5071", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  CSS$1.displayName = "CSS";
  var CSV = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5075)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M23.4453 55.5469H20.3345C20.2777 55.1444 20.1617 54.7869 19.9865 54.4744C19.8113 54.1572 19.5864 53.8873 19.3118 53.6648C19.0371 53.4422 18.7199 53.2718 18.36 53.1534C18.0049 53.035 17.619 52.9759 17.2024 52.9759C16.4495 52.9759 15.7938 53.1629 15.235 53.5369C14.6763 53.9062 14.2431 54.446 13.9353 55.1562C13.6276 55.8617 13.4737 56.7187 13.4737 57.7273C13.4737 58.7642 13.6276 59.6354 13.9353 60.3409C14.2478 61.0464 14.6834 61.5791 15.2422 61.9389C15.8009 62.2988 16.4472 62.4787 17.1811 62.4787C17.593 62.4787 17.9742 62.4242 18.3245 62.3153C18.6797 62.2064 18.9945 62.0478 19.2691 61.8395C19.5438 61.6264 19.771 61.3684 19.951 61.0653C20.1356 60.7623 20.2635 60.4167 20.3345 60.0284L23.4453 60.0426C23.3648 60.7102 23.1636 61.3542 22.8416 61.9744C22.5243 62.59 22.0958 63.1416 21.5561 63.6293C21.021 64.1122 20.3818 64.4957 19.6385 64.7798C18.8998 65.0592 18.0641 65.1989 17.1314 65.1989C15.834 65.1989 14.674 64.9053 13.6512 64.3182C12.6333 63.7311 11.8283 62.8812 11.2365 61.7685C10.6493 60.6558 10.3558 59.3087 10.3558 57.7273C10.3558 56.1411 10.6541 54.7917 11.2507 53.679C11.8473 52.5663 12.6569 51.7187 13.6797 51.1364C14.7024 50.5492 15.8529 50.2557 17.1314 50.2557C17.9742 50.2557 18.7554 50.3741 19.4751 50.6108C20.1995 50.8475 20.8411 51.1932 21.3998 51.6477C21.9585 52.0975 22.4131 52.6491 22.7635 53.3026C23.1186 53.956 23.3458 54.7041 23.4453 55.5469ZM33.1412 54.6378C33.0843 54.0649 32.8405 53.6198 32.4096 53.3026C31.9788 52.9853 31.394 52.8267 30.6554 52.8267C30.1535 52.8267 29.7297 52.8977 29.3841 53.0398C29.0384 53.1771 28.7733 53.3688 28.5886 53.6151C28.4087 53.8613 28.3187 54.1406 28.3187 54.4531C28.3092 54.7135 28.3637 54.9408 28.4821 55.1349C28.6052 55.3291 28.7733 55.4972 28.9863 55.6392C29.1994 55.7765 29.4456 55.8973 29.725 56.0014C30.0043 56.1009 30.3026 56.1861 30.6199 56.2571L31.9267 56.5696C32.5611 56.7116 33.1435 56.901 33.6738 57.1378C34.2041 57.3745 34.6634 57.6657 35.0517 58.0114C35.4399 58.357 35.7406 58.7642 35.9537 59.233C36.1715 59.7017 36.2827 60.2391 36.2875 60.8452C36.2827 61.7353 36.0555 62.5071 35.6056 63.1605C35.1606 63.8092 34.5166 64.3134 33.6738 64.6733C32.8358 65.0284 31.8249 65.206 30.6412 65.206C29.4669 65.206 28.4442 65.026 27.573 64.6662C26.7065 64.3063 26.0294 63.7737 25.5417 63.0682C25.0588 62.358 24.8055 61.4796 24.7818 60.4332H27.7576C27.7908 60.9209 27.9305 61.3281 28.1767 61.6548C28.4276 61.9768 28.7614 62.2206 29.1781 62.3864C29.5995 62.5473 30.0753 62.6278 30.6056 62.6278C31.1265 62.6278 31.5787 62.5521 31.9622 62.4006C32.3504 62.2491 32.6511 62.0384 32.8642 61.7685C33.0772 61.4986 33.1838 61.1884 33.1838 60.8381C33.1838 60.5114 33.0867 60.2367 32.8926 60.0142C32.7032 59.7917 32.4238 59.6023 32.0545 59.446C31.6899 59.2898 31.2425 59.1477 30.7122 59.0199L29.1284 58.6222C27.902 58.3239 26.9338 57.8575 26.2235 57.223C25.5133 56.5885 25.1606 55.7339 25.1653 54.6591C25.1606 53.7784 25.3949 53.009 25.8684 52.3509C26.3467 51.6927 27.0024 51.179 27.8358 50.8097C28.6691 50.4403 29.6161 50.2557 30.6767 50.2557C31.7562 50.2557 32.6984 50.4403 33.5034 50.8097C34.313 51.179 34.9428 51.6927 35.3926 52.3509C35.8424 53.009 36.0744 53.7713 36.0886 54.6378H33.1412ZM40.5838 50.4545L44.0995 61.5057H44.2344L47.7571 50.4545H51.1662L46.152 65H42.189L37.1676 50.4545H40.5838Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5075", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  CSV.displayName = "CSV";
  var DMG = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5091)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.7873 65H7.631V50.4545H12.8299C14.2929 50.4545 15.5524 50.7457 16.6083 51.3281C17.6641 51.9058 18.4762 52.7367 19.0444 53.821C19.6173 54.9053 19.9037 56.2027 19.9037 57.7131C19.9037 59.2282 19.6173 60.5303 19.0444 61.6193C18.4762 62.7083 17.6594 63.544 16.5941 64.1264C15.5335 64.7088 14.2645 65 12.7873 65ZM10.7063 62.3651H12.6594C13.5685 62.3651 14.3332 62.2041 14.9534 61.8821C15.5784 61.5554 16.0472 61.0511 16.3597 60.3693C16.6769 59.6828 16.8355 58.7973 16.8355 57.7131C16.8355 56.6383 16.6769 55.7599 16.3597 55.0781C16.0472 54.3963 15.5808 53.8944 14.9605 53.5724C14.3403 53.2505 13.5756 53.0895 12.6665 53.0895H10.7063V62.3651ZM21.7818 50.4545H25.5744L29.5801 60.2273H29.7505L33.7562 50.4545H37.5488V65H34.5659V55.5327H34.4451L30.6809 64.929H28.6497L24.8855 55.4972H24.7647V65H21.7818V50.4545ZM49.3274 55.1562C49.228 54.8106 49.0883 54.5052 48.9084 54.2401C48.7285 53.9702 48.5083 53.7429 48.2479 53.5582C47.9922 53.3688 47.6987 53.2244 47.3672 53.125C47.0405 53.0256 46.6783 52.9759 46.2806 52.9759C45.5372 52.9759 44.8838 53.1605 44.3203 53.5298C43.7616 53.8991 43.326 54.4366 43.0135 55.142C42.701 55.8428 42.5448 56.6998 42.5448 57.7131C42.5448 58.7263 42.6987 59.5881 43.0064 60.2983C43.3142 61.0085 43.7498 61.5507 44.3132 61.9247C44.8767 62.294 45.5419 62.4787 46.309 62.4787C47.005 62.4787 47.5992 62.3556 48.0917 62.1094C48.5888 61.8584 48.9676 61.5057 49.228 61.0511C49.4932 60.5966 49.6257 60.0592 49.6257 59.4389L50.2507 59.5312H46.5007V57.2159H52.5874V59.0483C52.5874 60.3267 52.3175 61.4252 51.7777 62.3438C51.238 63.2576 50.4946 63.9631 49.5476 64.4602C48.6006 64.9527 47.5164 65.1989 46.2948 65.1989C44.9311 65.1989 43.7332 64.8982 42.701 64.2969C41.6688 63.6908 40.8639 62.8314 40.2863 61.7188C39.7133 60.6013 39.4269 59.2756 39.4269 57.7415C39.4269 56.5625 39.5973 55.5114 39.9382 54.5881C40.2839 53.66 40.7668 52.8741 41.3871 52.2301C42.0074 51.5862 42.7294 51.0961 43.5533 50.7599C44.3772 50.4238 45.2697 50.2557 46.2309 50.2557C47.0547 50.2557 47.8218 50.3764 48.532 50.6179C49.2422 50.8546 49.872 51.1908 50.4212 51.6264C50.9752 52.062 51.4274 52.5805 51.7777 53.1818C52.1281 53.7784 52.353 54.4366 52.4524 55.1562H49.3274Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5091", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  DMG.displayName = "DMG";
  var DOC = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5078)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M14.7033 65H9.54702V50.4545H14.7459C16.2089 50.4545 17.4684 50.7457 18.5243 51.3281C19.5802 51.9058 20.3922 52.7367 20.9604 53.821C21.5333 54.9053 21.8197 56.2027 21.8197 57.7131C21.8197 59.2282 21.5333 60.5303 20.9604 61.6193C20.3922 62.7083 19.5754 63.544 18.5101 64.1264C17.4495 64.7088 16.1805 65 14.7033 65ZM12.6223 62.3651H14.5754C15.4845 62.3651 16.2492 62.2041 16.8695 61.8821C17.4945 61.5554 17.9632 61.0511 18.2757 60.3693C18.5929 59.6828 18.7516 58.7973 18.7516 57.7131C18.7516 56.6383 18.5929 55.7599 18.2757 55.0781C17.9632 54.3963 17.4968 53.8944 16.8766 53.5724C16.2563 53.2505 15.4916 53.0895 14.5825 53.0895H12.6223V62.3651ZM37.0643 57.7273C37.0643 59.3134 36.7636 60.6629 36.1623 61.7756C35.5657 62.8883 34.7513 63.7382 33.7191 64.3253C32.6916 64.9077 31.5363 65.1989 30.2532 65.1989C28.9606 65.1989 27.8005 64.9053 26.7731 64.3182C25.7456 63.7311 24.9336 62.8812 24.337 61.7685C23.7404 60.6558 23.4421 59.3087 23.4421 57.7273C23.4421 56.1411 23.7404 54.7917 24.337 53.679C24.9336 52.5663 25.7456 51.7187 26.7731 51.1364C27.8005 50.5492 28.9606 50.2557 30.2532 50.2557C31.5363 50.2557 32.6916 50.5492 33.7191 51.1364C34.7513 51.7187 35.5657 52.5663 36.1623 53.679C36.7636 54.7917 37.0643 56.1411 37.0643 57.7273ZM33.9464 57.7273C33.9464 56.6998 33.7925 55.8333 33.4847 55.1278C33.1817 54.4223 32.7532 53.8873 32.1992 53.5227C31.6452 53.1581 30.9966 52.9759 30.2532 52.9759C29.5098 52.9759 28.8612 53.1581 28.3072 53.5227C27.7532 53.8873 27.3223 54.4223 27.0146 55.1278C26.7115 55.8333 26.56 56.6998 26.56 57.7273C26.56 58.7547 26.7115 59.6212 27.0146 60.3267C27.3223 61.0322 27.7532 61.5672 28.3072 61.9318C28.8612 62.2964 29.5098 62.4787 30.2532 62.4787C30.9966 62.4787 31.6452 62.2964 32.1992 61.9318C32.7532 61.5672 33.1817 61.0322 33.4847 60.3267C33.7925 59.6212 33.9464 58.7547 33.9464 57.7273ZM51.7761 55.5469H48.6653C48.6085 55.1444 48.4925 54.7869 48.3173 54.4744C48.1421 54.1572 47.9172 53.8873 47.6426 53.6648C47.368 53.4422 47.0508 53.2718 46.6909 53.1534C46.3358 53.035 45.9499 52.9759 45.5332 52.9759C44.7804 52.9759 44.1246 53.1629 43.5659 53.5369C43.0072 53.9062 42.574 54.446 42.2662 55.1562C41.9584 55.8617 41.8045 56.7187 41.8045 57.7273C41.8045 58.7642 41.9584 59.6354 42.2662 60.3409C42.5787 61.0464 43.0143 61.5791 43.573 61.9389C44.1317 62.2988 44.778 62.4787 45.5119 62.4787C45.9239 62.4787 46.305 62.4242 46.6554 62.3153C47.0105 62.2064 47.3254 62.0478 47.6 61.8395C47.8746 61.6264 48.1019 61.3684 48.2818 61.0653C48.4665 60.7623 48.5943 60.4167 48.6653 60.0284L51.7761 60.0426C51.6956 60.7102 51.4944 61.3542 51.1724 61.9744C50.8552 62.59 50.4267 63.1416 49.8869 63.6293C49.3519 64.1122 48.7127 64.4957 47.9693 64.7798C47.2307 65.0592 46.395 65.1989 45.4622 65.1989C44.1649 65.1989 43.0048 64.9053 41.9821 64.3182C40.9641 63.7311 40.1592 62.8812 39.5673 61.7685C38.9802 60.6558 38.6866 59.3087 38.6866 57.7273C38.6866 56.1411 38.9849 54.7917 39.5815 53.679C40.1781 52.5663 40.9878 51.7187 42.0105 51.1364C43.0332 50.5492 44.1838 50.2557 45.4622 50.2557C46.305 50.2557 47.0863 50.3741 47.806 50.6108C48.5304 50.8475 49.172 51.1932 49.7307 51.6477C50.2894 52.0975 50.7439 52.6491 51.0943 53.3026C51.4494 53.956 51.6767 54.7041 51.7761 55.5469Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5078", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  DOC.displayName = "DOC";
  var EXE = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5082)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.2697 65V50.4545H22.0708V52.9901H15.345V56.456H21.5665V58.9915H15.345V62.4645H22.0992V65H12.2697ZM26.9993 50.4545L29.9325 55.4119H30.0462L32.9936 50.4545H36.4666L32.0277 57.7273L36.5661 65H33.0291L30.0462 60.0355H29.9325L26.9496 65H23.4268L27.9794 57.7273L23.5121 50.4545H26.9993ZM38.0126 65V50.4545H47.8138V52.9901H41.0879V56.456H47.3095V58.9915H41.0879V62.4645H47.8422V65H38.0126Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5082", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  EXE.displayName = "EXE";
  var Fig = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5083)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M15.4044 65V50.4545H25.0351V52.9901H18.4797V56.456H24.3959V58.9915H18.4797V65H15.4044ZM29.7789 50.4545V65H26.7037V50.4545H29.7789ZM41.554 55.1562C41.4546 54.8106 41.3149 54.5052 41.135 54.2401C40.9551 53.9702 40.7349 53.7429 40.4745 53.5582C40.2188 53.3688 39.9252 53.2244 39.5938 53.125C39.2671 53.0256 38.9049 52.9759 38.5071 52.9759C37.7638 52.9759 37.1104 53.1605 36.5469 53.5298C35.9882 53.8991 35.5526 54.4366 35.2401 55.142C34.9276 55.8428 34.7713 56.6998 34.7713 57.7131C34.7713 58.7263 34.9252 59.5881 35.233 60.2983C35.5408 61.0085 35.9764 61.5507 36.5398 61.9247C37.1033 62.294 37.7685 62.4787 38.5355 62.4787C39.2316 62.4787 39.8258 62.3556 40.3182 62.1094C40.8154 61.8584 41.1942 61.5057 41.4546 61.0511C41.7197 60.5966 41.8523 60.0592 41.8523 59.4389L42.4773 59.5312H38.7273V57.2159H44.814V59.0483C44.814 60.3267 44.5441 61.4252 44.0043 62.3438C43.4645 63.2576 42.7212 63.9631 41.7742 64.4602C40.8272 64.9527 39.7429 65.1989 38.5213 65.1989C37.1577 65.1989 35.9598 64.8982 34.9276 64.2969C33.8954 63.6908 33.0905 62.8314 32.5128 61.7188C31.9399 60.6013 31.6534 59.2756 31.6534 57.7415C31.6534 56.5625 31.8239 55.5114 32.1648 54.5881C32.5105 53.66 32.9934 52.8741 33.6137 52.2301C34.2339 51.5862 34.956 51.0961 35.7799 50.7599C36.6037 50.4238 37.4962 50.2557 38.4574 50.2557C39.2813 50.2557 40.0483 50.3764 40.7586 50.6179C41.4688 50.8546 42.0985 51.1908 42.6478 51.6264C43.2017 52.062 43.6539 52.5805 44.0043 53.1818C44.3547 53.7784 44.5796 54.4366 44.679 55.1562H41.554Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5083", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Fig.displayName = "Fig";
  var GIF = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5105)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M25.0493 55.1562C24.9499 54.8106 24.8102 54.5052 24.6303 54.2401C24.4504 53.9702 24.2302 53.7429 23.9698 53.5582C23.7141 53.3688 23.4205 53.2244 23.0891 53.125C22.7624 53.0256 22.4002 52.9759 22.0025 52.9759C21.2591 52.9759 20.6057 53.1605 20.0422 53.5298C19.4835 53.8991 19.0479 54.4366 18.7354 55.142C18.4229 55.8428 18.2667 56.6998 18.2667 57.7131C18.2667 58.7263 18.4205 59.5881 18.7283 60.2983C19.0361 61.0085 19.4717 61.5507 20.0351 61.9247C20.5986 62.294 21.2638 62.4787 22.0309 62.4787C22.7269 62.4787 23.3211 62.3556 23.8135 62.1094C24.3107 61.8584 24.6895 61.5057 24.9499 61.0511C25.215 60.5966 25.3476 60.0592 25.3476 59.4389L25.9726 59.5312H22.2226V57.2159H28.3093V59.0483C28.3093 60.3267 28.0394 61.4252 27.4996 62.3438C26.9598 63.2576 26.2165 63.9631 25.2695 64.4602C24.3225 64.9527 23.2382 65.1989 22.0167 65.1989C20.653 65.1989 19.4551 64.8982 18.4229 64.2969C17.3907 63.6908 16.5858 62.8314 16.0081 61.7188C15.4352 60.6013 15.1488 59.2756 15.1488 57.7415C15.1488 56.5625 15.3192 55.5114 15.6601 54.5881C16.0058 53.66 16.4887 52.8741 17.109 52.2301C17.7292 51.5862 18.4513 51.0961 19.2752 50.7599C20.099 50.4238 20.9916 50.2557 21.9527 50.2557C22.7766 50.2557 23.5436 50.3764 24.2539 50.6179C24.9641 50.8546 25.5938 51.1908 26.1431 51.6264C26.6971 52.062 27.1492 52.5805 27.4996 53.1818C27.85 53.7784 28.0749 54.4366 28.1743 55.1562H25.0493ZM33.2946 50.4545V65H30.2193V50.4545H33.2946ZM35.4248 65V50.4545H45.0554V52.9901H38.5V56.456H44.4162V58.9915H38.5V65H35.4248Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5105", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  GIF.displayName = "GIF";
  var HTML = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5072)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M5.60943 65V51.9091H8.37718V57.3104H13.9958V51.9091H16.7572V65H13.9958V59.5923H8.37718V65H5.60943ZM18.1805 54.1911V51.9091H28.932V54.1911H24.9241V65H22.1883V54.1911H18.1805ZM30.3426 51.9091H33.7559L37.361 60.7045H37.5144L41.1195 51.9091H44.5329V65H41.8482V56.4794H41.7396L38.3518 64.9361H36.5237L33.1359 56.4474H33.0272V65H30.3426V51.9091ZM46.4533 65V51.9091H49.221V62.718H54.8332V65H46.4533Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5072", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  HTML.displayName = "HTML";
  var ICO = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5088)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M16.595 50.4545V65H13.5197V50.4545H16.595ZM31.5589 55.5469H28.4482C28.3913 55.1444 28.2753 54.7869 28.1001 54.4744C27.925 54.1572 27.7 53.8873 27.4254 53.6648C27.1508 53.4422 26.8336 53.2718 26.4737 53.1534C26.1186 53.035 25.7327 52.9759 25.3161 52.9759C24.5632 52.9759 23.9074 53.1629 23.3487 53.5369C22.79 53.9062 22.3568 54.446 22.049 55.1562C21.7412 55.8617 21.5874 56.7187 21.5874 57.7273C21.5874 58.7642 21.7412 59.6354 22.049 60.3409C22.3615 61.0464 22.7971 61.5791 23.3558 61.9389C23.9145 62.2988 24.5608 62.4787 25.2947 62.4787C25.7067 62.4787 26.0878 62.4242 26.4382 62.3153C26.7933 62.2064 27.1082 62.0478 27.3828 61.8395C27.6574 61.6264 27.8847 61.3684 28.0646 61.0653C28.2493 60.7623 28.3771 60.4167 28.4482 60.0284L31.5589 60.0426C31.4785 60.7102 31.2772 61.3542 30.9553 61.9744C30.638 62.59 30.2095 63.1416 29.6697 63.6293C29.1347 64.1122 28.4955 64.4957 27.7521 64.7798C27.0135 65.0592 26.1778 65.1989 25.245 65.1989C23.9477 65.1989 22.7876 64.9053 21.7649 64.3182C20.7469 63.7311 19.942 62.8812 19.3501 61.7685C18.763 60.6558 18.4695 59.3087 18.4695 57.7273C18.4695 56.1411 18.7678 54.7917 19.3643 53.679C19.9609 52.5663 20.7706 51.7187 21.7933 51.1364C22.8161 50.5492 23.9666 50.2557 25.245 50.2557C26.0878 50.2557 26.8691 50.3741 27.5888 50.6108C28.3132 50.8475 28.9548 51.1932 29.5135 51.6477C30.0722 52.0975 30.5268 52.6491 30.8771 53.3026C31.2322 53.956 31.4595 54.7041 31.5589 55.5469ZM46.7307 57.7273C46.7307 59.3134 46.43 60.6629 45.8287 61.7756C45.2321 62.8883 44.4177 63.7382 43.3855 64.3253C42.358 64.9077 41.2027 65.1989 39.9196 65.1989C38.627 65.1989 37.467 64.9053 36.4395 64.3182C35.412 63.7311 34.6 62.8812 34.0034 61.7685C33.4068 60.6558 33.1085 59.3087 33.1085 57.7273C33.1085 56.1411 33.4068 54.7917 34.0034 53.679C34.6 52.5663 35.412 51.7187 36.4395 51.1364C37.467 50.5492 38.627 50.2557 39.9196 50.2557C41.2027 50.2557 42.358 50.5492 43.3855 51.1364C44.4177 51.7187 45.2321 52.5663 45.8287 53.679C46.43 54.7917 46.7307 56.1411 46.7307 57.7273ZM43.6128 57.7273C43.6128 56.6998 43.4589 55.8333 43.1511 55.1278C42.8481 54.4223 42.4196 53.8873 41.8656 53.5227C41.3116 53.1581 40.663 52.9759 39.9196 52.9759C39.1762 52.9759 38.5276 53.1581 37.9736 53.5227C37.4196 53.8873 36.9887 54.4223 36.681 55.1278C36.3779 55.8333 36.2264 56.6998 36.2264 57.7273C36.2264 58.7547 36.3779 59.6212 36.681 60.3267C36.9887 61.0322 37.4196 61.5672 37.9736 61.9318C38.5276 62.2964 39.1762 62.4787 39.9196 62.4787C40.663 62.4787 41.3116 62.2964 41.8656 61.9318C42.4196 61.5672 42.8481 61.0322 43.1511 60.3267C43.4589 59.6212 43.6128 58.7547 43.6128 57.7273Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5088", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  ICO.displayName = "ICO";
  var Java = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5070)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M13.7767 51.9091H16.5125V61.0369C16.5125 61.8807 16.3228 62.6136 15.9436 63.2358C15.5686 63.858 15.0466 64.3374 14.3775 64.674C13.7085 65.0107 12.9308 65.179 12.0444 65.179C11.2561 65.179 10.5402 65.0405 9.89671 64.7635C9.25751 64.4822 8.75041 64.0561 8.37541 63.4851C8.00041 62.9098 7.81504 62.1875 7.8193 61.3182H10.5743C10.5828 61.6634 10.6531 61.9595 10.7852 62.2067C10.9216 62.4496 11.1069 62.6371 11.3413 62.7692C11.58 62.897 11.8612 62.9609 12.1851 62.9609C12.526 62.9609 12.8136 62.8885 13.048 62.7436C13.2866 62.5945 13.4677 62.3771 13.5913 62.0916C13.7149 61.8061 13.7767 61.4545 13.7767 61.0369V51.9091ZM20.6972 65H17.7313L22.2505 51.9091H25.8173L30.33 65H27.3641L24.085 54.9006H23.9827L20.6972 65ZM20.5119 59.8544H27.5175V62.0149H20.5119V59.8544ZM32.276 51.9091L35.44 61.8551H35.5615L38.7319 51.9091H41.8001L37.2873 65H33.7206L29.2014 51.9091H32.276ZM43.5319 65H40.566L45.0852 51.9091H48.6519L53.1647 65H50.1988L46.9197 54.9006H46.8174L43.5319 65ZM43.3465 59.8544H50.3522V62.0149H43.3465V59.8544Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5070", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Java.displayName = "Java";
  var JPEG = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5085)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.2799 50.4545H15.3196V60.5966C15.3196 61.5341 15.1089 62.3485 14.6875 63.0398C14.2709 63.7311 13.6909 64.2637 12.9475 64.6378C12.2041 65.0118 11.34 65.1989 10.3551 65.1989C9.4792 65.1989 8.68375 65.045 7.96879 64.7372C7.25856 64.4247 6.69511 63.9512 6.27844 63.3168C5.86178 62.6776 5.65581 61.875 5.66055 60.9091H8.72163C8.7311 61.2926 8.80922 61.6217 8.956 61.8963C9.10752 62.1662 9.31348 62.3745 9.5739 62.5213C9.83905 62.6634 10.1516 62.7344 10.5114 62.7344C10.8902 62.7344 11.2098 62.6539 11.4702 62.4929C11.7354 62.3272 11.9366 62.0857 12.0739 61.7685C12.2112 61.4512 12.2799 61.0606 12.2799 60.5966V50.4545ZM17.4623 65V50.4545H23.2009C24.3041 50.4545 25.244 50.6652 26.0205 51.0866C26.797 51.5033 27.3889 52.0833 27.7961 52.8267C28.208 53.5653 28.414 54.4176 28.414 55.3835C28.414 56.3494 28.2056 57.2017 27.789 57.9403C27.3723 58.679 26.7686 59.2543 25.9779 59.6662C25.1919 60.0781 24.2402 60.2841 23.1228 60.2841H19.4651V57.8196H22.6256C23.2175 57.8196 23.7052 57.7178 24.0887 57.5142C24.4769 57.3059 24.7658 57.0194 24.9552 56.6548C25.1493 56.2855 25.2463 55.8617 25.2463 55.3835C25.2463 54.9006 25.1493 54.4792 24.9552 54.1193C24.7658 53.7547 24.4769 53.473 24.0887 53.2741C23.7004 53.0705 23.208 52.9688 22.6114 52.9688H20.5375V65H17.4623ZM30.0115 65V50.4545H39.8126V52.9901H33.0868V56.456H39.3083V58.9915H33.0868V62.4645H39.841V65H30.0115ZM51.5025 55.1562C51.403 54.8106 51.2633 54.5052 51.0834 54.2401C50.9035 53.9702 50.6833 53.7429 50.4229 53.5582C50.1672 53.3688 49.8737 53.2244 49.5422 53.125C49.2155 53.0256 48.8533 52.9759 48.4556 52.9759C47.7122 52.9759 47.0588 53.1605 46.4953 53.5298C45.9366 53.8991 45.501 54.4366 45.1885 55.142C44.876 55.8428 44.7198 56.6998 44.7198 57.7131C44.7198 58.7263 44.8737 59.5881 45.1814 60.2983C45.4892 61.0085 45.9248 61.5507 46.4882 61.9247C47.0517 62.294 47.7169 62.4787 48.484 62.4787C49.18 62.4787 49.7742 62.3556 50.2667 62.1094C50.7638 61.8584 51.1426 61.5057 51.403 61.0511C51.6682 60.5966 51.8007 60.0592 51.8007 59.4389L52.4257 59.5312H48.6757V57.2159H54.7624V59.0483C54.7624 60.3267 54.4925 61.4252 53.9527 62.3438C53.413 63.2576 52.6696 63.9631 51.7226 64.4602C50.7757 64.9527 49.6914 65.1989 48.4698 65.1989C47.1061 65.1989 45.9082 64.8982 44.876 64.2969C43.8438 63.6908 43.0389 62.8314 42.4613 61.7188C41.8883 60.6013 41.6019 59.2756 41.6019 57.7415C41.6019 56.5625 41.7723 55.5114 42.1132 54.5881C42.4589 53.66 42.9418 52.8741 43.5621 52.2301C44.1824 51.5862 44.9044 51.0961 45.7283 50.7599C46.5522 50.4238 47.4447 50.2557 48.4059 50.2557C49.2297 50.2557 49.9968 50.3764 50.707 50.6179C51.4172 50.8546 52.047 51.1908 52.5962 51.6264C53.1502 52.062 53.6024 52.5805 53.9527 53.1818C54.3031 53.7784 54.528 54.4366 54.6275 55.1562H51.5025Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5085", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  JPEG.displayName = "JPEG";
  var JPG = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5093)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M18.2029 50.4545H21.2427V60.5966C21.2427 61.5341 21.032 62.3485 20.6106 63.0398C20.1939 63.7311 19.6139 64.2637 18.8705 64.6378C18.1272 65.0118 17.263 65.1989 16.2782 65.1989C15.4022 65.1989 14.6068 65.045 13.8918 64.7372C13.1816 64.4247 12.6182 63.9512 12.2015 63.3168C11.7848 62.6776 11.5789 61.875 11.5836 60.9091H14.6447C14.6541 61.2926 14.7323 61.6217 14.879 61.8963C15.0306 62.1662 15.2365 62.3745 15.4969 62.5213C15.7621 62.6634 16.0746 62.7344 16.4344 62.7344C16.8132 62.7344 17.1328 62.6539 17.3933 62.4929C17.6584 62.3272 17.8596 62.0857 17.9969 61.7685C18.1343 61.4512 18.2029 61.0606 18.2029 60.5966V50.4545ZM23.3853 65V50.4545H29.1239C30.2272 50.4545 31.167 50.6652 31.9435 51.0866C32.7201 51.5033 33.3119 52.0833 33.7191 52.8267C34.131 53.5653 34.337 54.4176 34.337 55.3835C34.337 56.3494 34.1287 57.2017 33.712 57.9403C33.2953 58.679 32.6916 59.2543 31.9009 59.6662C31.1149 60.0781 30.1632 60.2841 29.0458 60.2841H25.3881V57.8196H28.5487C29.1405 57.8196 29.6282 57.7178 30.0117 57.5142C30.4 57.3059 30.6888 57.0194 30.8782 56.6548C31.0723 56.2855 31.1694 55.8617 31.1694 55.3835C31.1694 54.9006 31.0723 54.4792 30.8782 54.1193C30.6888 53.7547 30.4 53.473 30.0117 53.2741C29.6235 53.0705 29.131 52.9688 28.5344 52.9688H26.4606V65H23.3853ZM45.5794 55.1562C45.48 54.8106 45.3403 54.5052 45.1604 54.2401C44.9804 53.9702 44.7603 53.7429 44.4999 53.5582C44.2442 53.3688 43.9506 53.2244 43.6192 53.125C43.2925 53.0256 42.9303 52.9759 42.5325 52.9759C41.7892 52.9759 41.1357 53.1605 40.5723 53.5298C40.0136 53.8991 39.578 54.4366 39.2655 55.142C38.953 55.8428 38.7967 56.6998 38.7967 57.7131C38.7967 58.7263 38.9506 59.5881 39.2584 60.2983C39.5661 61.0085 40.0018 61.5507 40.5652 61.9247C41.1286 62.294 41.7939 62.4787 42.5609 62.4787C43.257 62.4787 43.8512 62.3556 44.3436 62.1094C44.8408 61.8584 45.2196 61.5057 45.48 61.0511C45.7451 60.5966 45.8777 60.0592 45.8777 59.4389L46.5027 59.5312H42.7527V57.2159H48.8393V59.0483C48.8393 60.3267 48.5695 61.4252 48.0297 62.3438C47.4899 63.2576 46.7465 63.9631 45.7996 64.4602C44.8526 64.9527 43.7683 65.1989 42.5467 65.1989C41.1831 65.1989 39.9852 64.8982 38.953 64.2969C37.9208 63.6908 37.1159 62.8314 36.5382 61.7188C35.9653 60.6013 35.6788 59.2756 35.6788 57.7415C35.6788 56.5625 35.8493 55.5114 36.1902 54.5881C36.5358 53.66 37.0188 52.8741 37.6391 52.2301C38.2593 51.5862 38.9814 51.0961 39.8053 50.7599C40.6291 50.4238 41.5216 50.2557 42.4828 50.2557C43.3067 50.2557 44.0737 50.3764 44.7839 50.6179C45.4942 50.8546 46.1239 51.1908 46.6732 51.6264C47.2271 52.062 47.6793 52.5805 48.0297 53.1818C48.3801 53.7784 48.605 54.4366 48.7044 55.1562H45.5794Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5093", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  JPG.displayName = "JPG";
  var JS = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5076)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M25.5322 50.4545H28.572V60.5966C28.572 61.5341 28.3613 62.3485 27.9399 63.0398C27.5232 63.7311 26.9432 64.2637 26.1998 64.6378C25.4565 65.0118 24.5923 65.1989 23.6075 65.1989C22.7315 65.1989 21.9361 65.045 21.2211 64.7372C20.5109 64.4247 19.9475 63.9512 19.5308 63.3168C19.1141 62.6776 18.9082 61.875 18.9129 60.9091H21.974C21.9834 61.2926 22.0616 61.6217 22.2083 61.8963C22.3599 62.1662 22.5658 62.3745 22.8262 62.5213C23.0914 62.6634 23.4039 62.7344 23.7637 62.7344C24.1425 62.7344 24.4621 62.6539 24.7225 62.4929C24.9877 62.3272 25.1889 62.0857 25.3262 61.7685C25.4636 61.4512 25.5322 61.0606 25.5322 60.5966V50.4545ZM38.6052 54.6378C38.5484 54.0649 38.3046 53.6198 37.8737 53.3026C37.4428 52.9853 36.8581 52.8267 36.1194 52.8267C35.6175 52.8267 35.1938 52.8977 34.8481 53.0398C34.5025 53.1771 34.2373 53.3688 34.0527 53.6151C33.8727 53.8613 33.7828 54.1406 33.7828 54.4531C33.7733 54.7135 33.8278 54.9408 33.9461 55.1349C34.0692 55.3291 34.2373 55.4972 34.4504 55.6392C34.6635 55.7765 34.9097 55.8973 35.189 56.0014C35.4684 56.1009 35.7667 56.1861 36.0839 56.2571L37.3907 56.5696C38.0252 56.7116 38.6076 56.901 39.1379 57.1378C39.6682 57.3745 40.1275 57.6657 40.5157 58.0114C40.904 58.357 41.2047 58.7642 41.4177 59.233C41.6355 59.7017 41.7468 60.2391 41.7515 60.8452C41.7468 61.7353 41.5195 62.5071 41.0697 63.1605C40.6246 63.8092 39.9807 64.3134 39.1379 64.6733C38.2998 65.0284 37.2889 65.206 36.1052 65.206C34.931 65.206 33.9083 65.026 33.037 64.6662C32.1706 64.3063 31.4935 63.7737 31.0058 63.0682C30.5228 62.358 30.2695 61.4796 30.2458 60.4332H33.2217C33.2548 60.9209 33.3945 61.3281 33.6407 61.6548C33.8917 61.9768 34.2255 62.2206 34.6422 62.3864C35.0636 62.5473 35.5394 62.6278 36.0697 62.6278C36.5905 62.6278 37.0427 62.5521 37.4262 62.4006C37.8145 62.2491 38.1152 62.0384 38.3282 61.7685C38.5413 61.4986 38.6478 61.1884 38.6478 60.8381C38.6478 60.5114 38.5508 60.2367 38.3566 60.0142C38.1672 59.7917 37.8879 59.6023 37.5186 59.446C37.154 59.2898 36.7065 59.1477 36.1762 59.0199L34.5924 58.6222C33.3661 58.3239 32.3978 57.8575 31.6876 57.223C30.9774 56.5885 30.6246 55.7339 30.6294 54.6591C30.6246 53.7784 30.859 53.009 31.3325 52.3509C31.8107 51.6927 32.4665 51.179 33.2998 50.8097C34.1332 50.4403 35.0801 50.2557 36.1407 50.2557C37.2203 50.2557 38.1625 50.4403 38.9674 50.8097C39.7771 51.179 40.4068 51.6927 40.8566 52.3509C41.3065 53.009 41.5385 53.7713 41.5527 54.6378H38.6052Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5076", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  JS.displayName = "JS";
  var JSON2 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5081)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.7308 51.9091H15.4666V61.0369C15.4666 61.8807 15.277 62.6136 14.8977 63.2358C14.5227 63.858 14.0007 64.3374 13.3316 64.674C12.6626 65.0107 11.8849 65.179 10.9985 65.179C10.2102 65.179 9.49428 65.0405 8.85081 64.7635C8.21161 64.4822 7.70451 64.0561 7.32951 63.4851C6.95451 62.9098 6.76914 62.1875 6.7734 61.3182H9.52837C9.53689 61.6634 9.60721 61.9595 9.73931 62.2067C9.87567 62.4496 10.061 62.6371 10.2954 62.7692C10.5341 62.897 10.8153 62.9609 11.1392 62.9609C11.4801 62.9609 11.7677 62.8885 12.0021 62.7436C12.2407 62.5945 12.4218 62.3771 12.5454 62.0916C12.669 61.8061 12.7308 61.4545 12.7308 61.0369V51.9091ZM24.4965 55.674C24.4454 55.1584 24.2259 54.7578 23.8381 54.4723C23.4503 54.1868 22.9241 54.044 22.2593 54.044C21.8076 54.044 21.4262 54.108 21.1151 54.2358C20.804 54.3594 20.5654 54.532 20.3992 54.7536C20.2373 54.9751 20.1563 55.2266 20.1563 55.5078C20.1478 55.7422 20.1968 55.9467 20.3033 56.1214C20.4141 56.2962 20.5654 56.4474 20.7571 56.5753C20.9489 56.6989 21.1705 56.8075 21.4219 56.9013C21.6733 56.9908 21.9418 57.0675 22.2273 57.1314L23.4035 57.4126C23.9745 57.5405 24.4986 57.7109 24.9759 57.924C25.4532 58.1371 25.8665 58.3991 26.216 58.7102C26.5654 59.0213 26.836 59.3878 27.0277 59.8097C27.2238 60.2315 27.3239 60.7152 27.3282 61.2607C27.3239 62.0618 27.1194 62.7564 26.7145 63.3445C26.314 63.9283 25.7344 64.3821 24.9759 64.706C24.2216 65.0256 23.3118 65.1854 22.2465 65.1854C21.1897 65.1854 20.2692 65.0234 19.4851 64.6996C18.7053 64.3757 18.0959 63.8963 17.657 63.2614C17.2223 62.6222 16.9944 61.8317 16.9731 60.8899H19.6513C19.6812 61.3288 19.8069 61.6953 20.0285 61.9893C20.2543 62.2791 20.5547 62.4986 20.9297 62.6477C21.309 62.7926 21.7373 62.8651 22.2145 62.8651C22.6833 62.8651 23.0902 62.7969 23.4354 62.6605C23.7848 62.5241 24.0554 62.3345 24.2472 62.0916C24.439 61.8487 24.5348 61.5696 24.5348 61.2543C24.5348 60.9602 24.4475 60.7131 24.2728 60.5128C24.1023 60.3125 23.8509 60.142 23.5185 60.0014C23.1904 59.8608 22.7877 59.733 22.3104 59.6179L20.885 59.2599C19.7813 58.9915 18.9098 58.5717 18.2706 58.0007C17.6314 57.4297 17.314 56.6605 17.3182 55.6932C17.314 54.9006 17.5249 54.2081 17.951 53.6158C18.3814 53.0234 18.9716 52.5611 19.7216 52.2287C20.4716 51.8963 21.3239 51.7301 22.2785 51.7301C23.25 51.7301 24.0981 51.8963 24.8225 52.2287C25.5512 52.5611 26.1179 53.0234 26.5228 53.6158C26.9276 54.2081 27.1364 54.8942 27.1492 55.674H24.4965ZM40.8597 58.4545C40.8597 59.8821 40.5891 61.0966 40.0479 62.098C39.511 63.0994 38.778 63.8643 37.849 64.3928C36.9243 64.9169 35.8845 65.179 34.7297 65.179C33.5664 65.179 32.5223 64.9148 31.5976 64.3864C30.6729 63.858 29.9421 63.093 29.4051 62.0916C28.8682 61.0902 28.5997 59.8778 28.5997 58.4545C28.5997 57.027 28.8682 55.8125 29.4051 54.8111C29.9421 53.8097 30.6729 53.0469 31.5976 52.5227C32.5223 51.9943 33.5664 51.7301 34.7297 51.7301C35.8845 51.7301 36.9243 51.9943 37.849 52.5227C38.778 53.0469 39.511 53.8097 40.0479 54.8111C40.5891 55.8125 40.8597 57.027 40.8597 58.4545ZM38.0536 58.4545C38.0536 57.5298 37.9151 56.75 37.6381 56.1151C37.3654 55.4801 36.9797 54.9986 36.4811 54.6705C35.9826 54.3423 35.3987 54.1783 34.7297 54.1783C34.0607 54.1783 33.4769 54.3423 32.9783 54.6705C32.4797 54.9986 32.0919 55.4801 31.8149 56.1151C31.5422 56.75 31.4059 57.5298 31.4059 58.4545C31.4059 59.3793 31.5422 60.1591 31.8149 60.794C32.0919 61.429 32.4797 61.9105 32.9783 62.2386C33.4769 62.5668 34.0607 62.7308 34.7297 62.7308C35.3987 62.7308 35.9826 62.5668 36.4811 62.2386C36.9797 61.9105 37.3654 61.429 37.6381 60.794C37.9151 60.1591 38.0536 59.3793 38.0536 58.4545ZM53.4995 51.9091V65H51.1089L45.4136 56.7607H45.3177V65H42.5499V51.9091H44.9789L50.6295 60.142H50.7445V51.9091H53.4995Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5081", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  JSON2.displayName = "JSON";
  var MOV = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5084)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.62124 50.4545H11.4138L15.4195 60.2273H15.59L19.5957 50.4545H23.3883V65H20.4053V55.5327H20.2846L16.5204 64.929H14.4891L10.7249 55.4972H10.6042V65H7.62124V50.4545ZM38.8885 57.7273C38.8885 59.3134 38.5878 60.6629 37.9865 61.7756C37.3899 62.8883 36.5755 63.7382 35.5433 64.3253C34.5159 64.9077 33.3606 65.1989 32.0774 65.1989C30.7848 65.1989 29.6248 64.9053 28.5973 64.3182C27.5698 63.7311 26.7578 62.8812 26.1612 61.7685C25.5646 60.6558 25.2663 59.3087 25.2663 57.7273C25.2663 56.1411 25.5646 54.7917 26.1612 53.679C26.7578 52.5663 27.5698 51.7187 28.5973 51.1364C29.6248 50.5492 30.7848 50.2557 32.0774 50.2557C33.3606 50.2557 34.5159 50.5492 35.5433 51.1364C36.5755 51.7187 37.3899 52.5663 37.9865 53.679C38.5878 54.7917 38.8885 56.1411 38.8885 57.7273ZM35.7706 57.7273C35.7706 56.6998 35.6167 55.8333 35.3089 55.1278C35.0059 54.4223 34.5774 53.8873 34.0234 53.5227C33.4695 53.1581 32.8208 52.9759 32.0774 52.9759C31.334 52.9759 30.6854 53.1581 30.1314 53.5227C29.5774 53.8873 29.1465 54.4223 28.8388 55.1278C28.5357 55.8333 28.3842 56.6998 28.3842 57.7273C28.3842 58.7547 28.5357 59.6212 28.8388 60.3267C29.1465 61.0322 29.5774 61.5672 30.1314 61.9318C30.6854 62.2964 31.334 62.4787 32.0774 62.4787C32.8208 62.4787 33.4695 62.2964 34.0234 61.9318C34.5774 61.5672 35.0059 61.0322 35.3089 60.3267C35.6167 59.6212 35.7706 58.7547 35.7706 57.7273ZM42.5741 50.4545L46.0897 61.5057H46.2246L49.7474 50.4545H53.1565L48.1423 65H44.1792L39.1579 50.4545H42.5741Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5084", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  MOV.displayName = "MOV";
  var MP3 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5100)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9.44741 50.4545H13.24L17.2457 60.2273H17.4162L21.4218 50.4545H25.2145V65H22.2315V55.5327H22.1108L18.3466 64.929H16.3153L12.5511 55.4972H12.4304V65H9.44741V50.4545ZM27.3482 65V50.4545H33.0868C34.19 50.4545 35.1299 50.6652 35.9064 51.0866C36.6829 51.5033 37.2748 52.0833 37.682 52.8267C38.0939 53.5653 38.2999 54.4176 38.2999 55.3835C38.2999 56.3494 38.0916 57.2017 37.6749 57.9403C37.2582 58.679 36.6545 59.2543 35.8638 59.6662C35.0778 60.0781 34.1261 60.2841 33.0087 60.2841H29.351V57.8196H32.5115C33.1034 57.8196 33.5911 57.7178 33.9746 57.5142C34.3629 57.3059 34.6517 57.0194 34.8411 56.6548C35.0352 56.2855 35.1323 55.8617 35.1323 55.3835C35.1323 54.9006 35.0352 54.4792 34.8411 54.1193C34.6517 53.7547 34.3629 53.473 33.9746 53.2741C33.5864 53.0705 33.0939 52.9688 32.4973 52.9688H30.4235V65H27.3482ZM45.1886 65.1989C44.128 65.1989 43.1834 65.0166 42.3548 64.652C41.5309 64.2827 40.8799 63.776 40.4017 63.1321C39.9282 62.4834 39.6843 61.7353 39.6701 60.8878H42.7667C42.7857 61.2429 42.9017 61.5554 43.1147 61.8253C43.3325 62.0904 43.6214 62.2964 43.9812 62.4432C44.3411 62.59 44.7459 62.6634 45.1957 62.6634C45.6645 62.6634 46.0788 62.5805 46.4386 62.4148C46.7984 62.2491 47.0802 62.0194 47.2838 61.7259C47.4874 61.4323 47.5892 61.0937 47.5892 60.7102C47.5892 60.322 47.4803 59.9787 47.2625 59.6804C47.0494 59.3774 46.7416 59.1406 46.3392 58.9702C45.9414 58.7997 45.468 58.7145 44.9187 58.7145H43.5622V56.456H44.9187C45.3827 56.456 45.7923 56.3755 46.1474 56.2145C46.5073 56.0535 46.7866 55.831 46.9855 55.5469C47.1843 55.258 47.2838 54.9219 47.2838 54.5384C47.2838 54.1738 47.1962 53.8542 47.021 53.5795C46.8505 53.3002 46.6091 53.0824 46.2966 52.9261C45.9888 52.7699 45.6289 52.6918 45.217 52.6918C44.8003 52.6918 44.4192 52.7675 44.0735 52.919C43.7279 53.0658 43.4509 53.2765 43.2426 53.5511C43.0342 53.8258 42.923 54.1477 42.9088 54.517H39.9613C39.9755 53.679 40.2146 52.9403 40.6787 52.3011C41.1427 51.6619 41.7677 51.1624 42.5537 50.8026C43.3444 50.438 44.2369 50.2557 45.2312 50.2557C46.235 50.2557 47.1133 50.438 47.8662 50.8026C48.619 51.1671 49.2038 51.6596 49.6204 52.2798C50.0418 52.8954 50.2502 53.5866 50.2454 54.3537C50.2502 55.1681 49.9968 55.8475 49.4855 56.392C48.9788 56.9366 48.3183 57.2822 47.5039 57.429V57.5426C48.574 57.6799 49.3884 58.0516 49.9471 58.6577C50.5106 59.259 50.7899 60.0118 50.7852 60.9162C50.7899 61.7448 50.5508 62.4811 50.0679 63.125C49.5896 63.7689 48.9291 64.2756 48.0863 64.6449C47.2435 65.0142 46.2776 65.1989 45.1886 65.1989Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  MP3.displayName = "MP3";
  var MP4 = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5086)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9.76186 50.4545H13.5545L17.5602 60.2273H17.7306L21.7363 50.4545H25.5289V65H22.546V55.5327H22.4252L18.661 64.929H16.6298L12.8656 55.4972H12.7448V65H9.76186V50.4545ZM27.6626 65V50.4545H33.4013C34.5045 50.4545 35.4444 50.6652 36.2209 51.0866C36.9974 51.5033 37.5893 52.0833 37.9964 52.8267C38.4084 53.5653 38.6143 54.4176 38.6143 55.3835C38.6143 56.3494 38.406 57.2017 37.9893 57.9403C37.5727 58.679 36.969 59.2543 36.1783 59.6662C35.3923 60.0781 34.4406 60.2841 33.3232 60.2841H29.6655V57.8196H32.826C33.4179 57.8196 33.9055 57.7178 34.2891 57.5142C34.6773 57.3059 34.9661 57.0194 35.1555 56.6548C35.3497 56.2855 35.4467 55.8617 35.4467 55.3835C35.4467 54.9006 35.3497 54.4792 35.1555 54.1193C34.9661 53.7547 34.6773 53.473 34.2891 53.2741C33.9008 53.0705 33.4084 52.9688 32.8118 52.9688H30.7379V65H27.6626ZM39.9065 62.4432V60.0213L45.9789 50.4545H48.067V53.8068H46.8312L43.0031 59.8651V59.9787H51.6323V62.4432H39.9065ZM46.888 65V61.7045L46.9448 60.6321V50.4545H49.8283V65H46.888Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5086", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  MP4.displayName = "MP4";
  var MPG = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5092)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M8.43178 50.4545H12.2244L16.2301 60.2273H16.4005L20.4062 50.4545H24.1988V65H21.2159V55.5327H21.0951L17.3309 64.929H15.2997L11.5355 55.4972H11.4147V65H8.43178V50.4545ZM26.3326 65V50.4545H32.0712C33.1744 50.4545 34.1143 50.6652 34.8908 51.0866C35.6673 51.5033 36.2592 52.0833 36.6664 52.8267C37.0783 53.5653 37.2843 54.4176 37.2843 55.3835C37.2843 56.3494 37.0759 57.2017 36.6593 57.9403C36.2426 58.679 35.6389 59.2543 34.8482 59.6662C34.0622 60.0781 33.1105 60.2841 31.9931 60.2841H28.3354V57.8196H31.4959C32.0878 57.8196 32.5755 57.7178 32.959 57.5142C33.3472 57.3059 33.6361 57.0194 33.8255 56.6548C34.0196 56.2855 34.1167 55.8617 34.1167 55.3835C34.1167 54.9006 34.0196 54.4792 33.8255 54.1193C33.6361 53.7547 33.3472 53.473 32.959 53.2741C32.5707 53.0705 32.0783 52.9688 31.4817 52.9688H29.4078V65H26.3326ZM48.5267 55.1562C48.4272 54.8106 48.2876 54.5052 48.1076 54.2401C47.9277 53.9702 47.7075 53.7429 47.4471 53.5582C47.1914 53.3688 46.8979 53.2244 46.5664 53.125C46.2397 53.0256 45.8775 52.9759 45.4798 52.9759C44.7364 52.9759 44.083 53.1605 43.5196 53.5298C42.9609 53.8991 42.5252 54.4366 42.2127 55.142C41.9002 55.8428 41.744 56.6998 41.744 57.7131C41.744 58.7263 41.8979 59.5881 42.2056 60.2983C42.5134 61.0085 42.949 61.5507 43.5125 61.9247C44.0759 62.294 44.7412 62.4787 45.5082 62.4787C46.2042 62.4787 46.7984 62.3556 47.2909 62.1094C47.788 61.8584 48.1668 61.5057 48.4272 61.0511C48.6924 60.5966 48.825 60.0592 48.825 59.4389L49.45 59.5312H45.7V57.2159H51.7866V59.0483C51.7866 60.3267 51.5167 61.4252 50.977 62.3438C50.4372 63.2576 49.6938 63.9631 48.7468 64.4602C47.7999 64.9527 46.7156 65.1989 45.494 65.1989C44.1304 65.1989 42.9324 64.8982 41.9002 64.2969C40.8681 63.6908 40.0631 62.8314 39.4855 61.7188C38.9126 60.6013 38.6261 59.2756 38.6261 57.7415C38.6261 56.5625 38.7966 55.5114 39.1375 54.5881C39.4831 53.66 39.9661 52.8741 40.5863 52.2301C41.2066 51.5862 41.9287 51.0961 42.7525 50.7599C43.5764 50.4238 44.4689 50.2557 45.4301 50.2557C46.2539 50.2557 47.021 50.3764 47.7312 50.6179C48.4414 50.8546 49.0712 51.1908 49.6204 51.6264C50.1744 52.062 50.6266 52.5805 50.977 53.1818C51.3273 53.7784 51.5522 54.4366 51.6517 55.1562H48.5267Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5092", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  MPG.displayName = "MPG";
  var PDF = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { "clip-path": "url(#clip0_163_5102)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#FF1607"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                "fill-opacity": "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.5646 65V50.4545H18.3032C19.4065 50.4545 20.3463 50.6652 21.1228 51.0866C21.8993 51.5033 22.4912 52.0833 22.8984 52.8267C23.3103 53.5653 23.5163 54.4176 23.5163 55.3835C23.5163 56.3494 23.308 57.2017 22.8913 57.9403C22.4746 58.679 21.8709 59.2543 21.0802 59.6662C20.2942 60.0781 19.3425 60.2841 18.2251 60.2841H14.5674V57.8196H17.7279C18.3198 57.8196 18.8075 57.7178 19.191 57.5142C19.5793 57.3059 19.8681 57.0194 20.0575 56.6548C20.2516 56.2855 20.3487 55.8617 20.3487 55.3835C20.3487 54.9006 20.2516 54.4792 20.0575 54.1193C19.8681 53.7547 19.5793 53.473 19.191 53.2741C18.8028 53.0705 18.3103 52.9688 17.7137 52.9688H15.6399V65H12.5646ZM30.2701 65H25.1138V50.4545H30.3127C31.7757 50.4545 33.0352 50.7457 34.0911 51.3281C35.147 51.9058 35.959 52.7367 36.5272 53.821C37.1001 54.9053 37.3865 56.2027 37.3865 57.7131C37.3865 59.2282 37.1001 60.5303 36.5272 61.6193C35.959 62.7083 35.1422 63.544 34.0769 64.1264C33.0163 64.7088 31.7473 65 30.2701 65ZM28.1891 62.3651H30.1422C31.0513 62.3651 31.816 62.2041 32.4363 61.8821C33.0613 61.5554 33.53 61.0511 33.8425 60.3693C34.1597 59.6828 34.3184 58.7973 34.3184 57.7131C34.3184 56.6383 34.1597 55.7599 33.8425 55.0781C33.53 54.3963 33.0636 53.8944 32.4434 53.5724C31.8231 53.2505 31.0584 53.0895 30.1493 53.0895H28.1891V62.3651ZM39.2646 65V50.4545H48.8953V52.9901H42.3399V56.456H48.2561V58.9915H42.3399V65H39.2646Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5102", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  PDF.displayName = "PDF";
  var PNG = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5087)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10.7287 65V50.4545H16.4673C17.5705 50.4545 18.5104 50.6652 19.2869 51.0866C20.0634 51.5033 20.6553 52.0833 21.0625 52.8267C21.4744 53.5653 21.6804 54.4176 21.6804 55.3835C21.6804 56.3494 21.472 57.2017 21.0554 57.9403C20.6387 58.679 20.035 59.2543 19.2443 59.6662C18.4583 60.0781 17.5066 60.2841 16.3892 60.2841H12.7315V57.8196H15.892C16.4839 57.8196 16.9716 57.7178 17.3551 57.5142C17.7433 57.3059 18.0322 57.0194 18.2216 56.6548C18.4157 56.2855 18.5127 55.8617 18.5127 55.3835C18.5127 54.9006 18.4157 54.4792 18.2216 54.1193C18.0322 53.7547 17.7433 53.473 17.3551 53.2741C16.9668 53.0705 16.4744 52.9688 15.8778 52.9688H13.8039V65H10.7287ZM35.4441 50.4545V65H32.7878L26.4597 55.8452H26.3532V65H23.2779V50.4545H25.9767L32.2551 59.6023H32.383V50.4545H35.4441ZM47.2298 55.1562C47.1304 54.8106 46.9907 54.5052 46.8108 54.2401C46.6308 53.9702 46.4107 53.7429 46.1502 53.5582C45.8946 53.3688 45.601 53.2244 45.2696 53.125C44.9429 53.0256 44.5806 52.9759 44.1829 52.9759C43.4395 52.9759 42.7861 53.1605 42.2227 53.5298C41.664 53.8991 41.2284 54.4366 40.9159 55.142C40.6034 55.8428 40.4471 56.6998 40.4471 57.7131C40.4471 58.7263 40.601 59.5881 40.9088 60.2983C41.2165 61.0085 41.6521 61.5507 42.2156 61.9247C42.779 62.294 43.4443 62.4787 44.2113 62.4787C44.9074 62.4787 45.5016 62.3556 45.994 62.1094C46.4912 61.8584 46.8699 61.5057 47.1304 61.0511C47.3955 60.5966 47.5281 60.0592 47.5281 59.4389L48.1531 59.5312H44.4031V57.2159H50.4897V59.0483C50.4897 60.3267 50.2199 61.4252 49.6801 62.3438C49.1403 63.2576 48.3969 63.9631 47.45 64.4602C46.503 64.9527 45.4187 65.1989 44.1971 65.1989C42.8335 65.1989 41.6356 64.8982 40.6034 64.2969C39.5712 63.6908 38.7663 62.8314 38.1886 61.7188C37.6157 60.6013 37.3292 59.2756 37.3292 57.7415C37.3292 56.5625 37.4997 55.5114 37.8406 54.5881C38.1862 53.66 38.6692 52.8741 39.2895 52.2301C39.9097 51.5862 40.6318 51.0961 41.4556 50.7599C42.2795 50.4238 43.172 50.2557 44.1332 50.2557C44.9571 50.2557 45.7241 50.3764 46.4343 50.6179C47.1446 50.8546 47.7743 51.1908 48.3235 51.6264C48.8775 52.062 49.3297 52.5805 49.6801 53.1818C50.0305 53.7784 50.2554 54.4366 50.3548 55.1562H47.2298Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5087", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  PNG.displayName = "PNG";
  var PPT = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5077)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#FF1607"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.5353 65V50.4545H18.2739C19.3772 50.4545 20.317 50.6652 21.0935 51.0866C21.8701 51.5033 22.4619 52.0833 22.8691 52.8267C23.281 53.5653 23.487 54.4176 23.487 55.3835C23.487 56.3494 23.2787 57.2017 22.862 57.9403C22.4453 58.679 21.8416 59.2543 21.0509 59.6662C20.2649 60.0781 19.3132 60.2841 18.1958 60.2841H14.5381V57.8196H17.6987C18.2905 57.8196 18.7782 57.7178 19.1617 57.5142C19.55 57.3059 19.8388 57.0194 20.0282 56.6548C20.2223 56.2855 20.3194 55.8617 20.3194 55.3835C20.3194 54.9006 20.2223 54.4792 20.0282 54.1193C19.8388 53.7547 19.55 53.473 19.1617 53.2741C18.7735 53.0705 18.281 52.9688 17.6844 52.9688H15.6106V65H12.5353ZM25.0845 65V50.4545H30.8232C31.9264 50.4545 32.8662 50.6652 33.6428 51.0866C34.4193 51.5033 35.0111 52.0833 35.4183 52.8267C35.8303 53.5653 36.0362 54.4176 36.0362 55.3835C36.0362 56.3494 35.8279 57.2017 35.4112 57.9403C34.9946 58.679 34.3909 59.2543 33.6001 59.6662C32.8142 60.0781 31.8625 60.2841 30.745 60.2841H27.0874V57.8196H30.2479C30.8397 57.8196 31.3274 57.7178 31.7109 57.5142C32.0992 57.3059 32.388 57.0194 32.5774 56.6548C32.7715 56.2855 32.8686 55.8617 32.8686 55.3835C32.8686 54.9006 32.7715 54.4792 32.5774 54.1193C32.388 53.7547 32.0992 53.473 31.7109 53.2741C31.3227 53.0705 30.8303 52.9688 30.2337 52.9688H28.1598V65H25.0845ZM37.0798 52.9901V50.4545H49.0258V52.9901H44.5727V65H41.5329V52.9901H37.0798Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5077", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  PPT.displayName = "PPT";
  var PSD = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5097)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.3615 65V50.4545H17.1001C18.2033 50.4545 19.1432 50.6652 19.9197 51.0866C20.6962 51.5033 21.2881 52.0833 21.6953 52.8267C22.1072 53.5653 22.3132 54.4176 22.3132 55.3835C22.3132 56.3494 22.1048 57.2017 21.6882 57.9403C21.2715 58.679 20.6678 59.2543 19.8771 59.6662C19.0911 60.0781 18.1394 60.2841 17.022 60.2841H13.3643V57.8196H16.5248C17.1167 57.8196 17.6044 57.7178 17.9879 57.5142C18.3761 57.3059 18.665 57.0194 18.8544 56.6548C19.0485 56.2855 19.1456 55.8617 19.1456 55.3835C19.1456 54.9006 19.0485 54.4792 18.8544 54.1193C18.665 53.7547 18.3761 53.473 17.9879 53.2741C17.5996 53.0705 17.1072 52.9688 16.5106 52.9688H14.4368V65H11.3615ZM31.8013 54.6378C31.7445 54.0649 31.5007 53.6198 31.0698 53.3026C30.6389 52.9853 30.0542 52.8267 29.3155 52.8267C28.8136 52.8267 28.3899 52.8977 28.0442 53.0398C27.6986 53.1771 27.4334 53.3688 27.2488 53.6151C27.0688 53.8613 26.9789 54.1406 26.9789 54.4531C26.9694 54.7135 27.0239 54.9408 27.1422 55.1349C27.2653 55.3291 27.4334 55.4972 27.6465 55.6392C27.8596 55.7765 28.1058 55.8973 28.3851 56.0014C28.6645 56.1009 28.9628 56.1861 29.28 56.2571L30.5868 56.5696C31.2213 56.7116 31.8037 56.901 32.334 57.1378C32.8643 57.3745 33.3236 57.6657 33.7118 58.0114C34.1001 58.357 34.4007 58.7642 34.6138 59.233C34.8316 59.7017 34.9429 60.2391 34.9476 60.8452C34.9429 61.7353 34.7156 62.5071 34.2658 63.1605C33.8207 63.8092 33.1768 64.3134 32.334 64.6733C31.4959 65.0284 30.485 65.206 29.3013 65.206C28.1271 65.206 27.1043 65.026 26.2331 64.6662C25.3667 64.3063 24.6896 63.7737 24.2019 63.0682C23.7189 62.358 23.4656 61.4796 23.4419 60.4332H26.4178C26.4509 60.9209 26.5906 61.3281 26.8368 61.6548C27.0878 61.9768 27.4216 62.2206 27.8382 62.3864C28.2596 62.5473 28.7355 62.6278 29.2658 62.6278C29.7866 62.6278 30.2388 62.5521 30.6223 62.4006C31.0106 62.2491 31.3113 62.0384 31.5243 61.7685C31.7374 61.4986 31.8439 61.1884 31.8439 60.8381C31.8439 60.5114 31.7469 60.2367 31.5527 60.0142C31.3633 59.7917 31.084 59.6023 30.7147 59.446C30.3501 59.2898 29.9026 59.1477 29.3723 59.0199L27.7885 58.6222C26.5622 58.3239 25.5939 57.8575 24.8837 57.223C24.1735 56.5885 23.8207 55.7339 23.8255 54.6591C23.8207 53.7784 24.0551 53.009 24.5286 52.3509C25.0068 51.6927 25.6626 51.179 26.4959 50.8097C27.3292 50.4403 28.2762 50.2557 29.3368 50.2557C30.4164 50.2557 31.3586 50.4403 32.1635 50.8097C32.9732 51.179 33.6029 51.6927 34.0527 52.3509C34.5025 53.009 34.7346 53.7713 34.7488 54.6378H31.8013ZM41.7724 65H36.6162V50.4545H41.815C43.2781 50.4545 44.5376 50.7457 45.5934 51.3281C46.6493 51.9058 47.4613 52.7367 48.0295 53.821C48.6024 54.9053 48.8889 56.2027 48.8889 57.7131C48.8889 59.2282 48.6024 60.5303 48.0295 61.6193C47.4613 62.7083 46.6446 63.544 45.5792 64.1264C44.5186 64.7088 43.2497 65 41.7724 65ZM39.6914 62.3651H41.6446C42.5537 62.3651 43.3183 62.2041 43.9386 61.8821C44.5636 61.5554 45.0324 61.0511 45.3449 60.3693C45.6621 59.6828 45.8207 58.7973 45.8207 57.7131C45.8207 56.6383 45.6621 55.7599 45.3449 55.0781C45.0324 54.3963 44.566 53.8944 43.9457 53.5724C43.3254 53.2505 42.5608 53.0895 41.6517 53.0895H39.6914V62.3651Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5097", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  PSD.displayName = "PSD";
  var Rar = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5073)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#344054"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.5587 65V50.4545H17.2974C18.3959 50.4545 19.3334 50.651 20.1099 51.044C20.8911 51.4323 21.4853 51.9839 21.8925 52.6989C22.3045 53.4091 22.5104 54.2448 22.5104 55.206C22.5104 56.1719 22.3021 57.0028 21.8854 57.6989C21.4688 58.3902 20.8651 58.9205 20.0744 59.2898C19.2884 59.6591 18.3367 59.8438 17.2192 59.8438H13.3769V57.3722H16.7221C17.3092 57.3722 17.7969 57.2917 18.1852 57.1307C18.5734 56.9697 18.8622 56.7282 19.0516 56.4062C19.2458 56.0843 19.3428 55.6842 19.3428 55.206C19.3428 54.723 19.2458 54.3158 19.0516 53.9844C18.8622 53.6529 18.571 53.402 18.1781 53.2315C17.7898 53.0563 17.2997 52.9688 16.7079 52.9688H14.634V65H11.5587ZM19.4138 58.3807L23.0289 65H19.634L16.0971 58.3807H19.4138ZM26.7908 65H23.4954L28.5167 50.4545H32.4798L37.494 65H34.1985L30.555 53.7784H30.4414L26.7908 65ZM26.5849 59.2827H34.369V61.6832H26.5849V59.2827ZM38.8447 65V50.4545H44.5833C45.6818 50.4545 46.6193 50.651 47.3958 51.044C48.1771 51.4323 48.7713 51.9839 49.1785 52.6989C49.5904 53.4091 49.7964 54.2448 49.7964 55.206C49.7964 56.1719 49.588 57.0028 49.1714 57.6989C48.7547 58.3902 48.151 58.9205 47.3603 59.2898C46.5743 59.6591 45.6226 59.8438 44.5052 59.8438H40.6629V57.3722H44.008C44.5951 57.3722 45.0828 57.2917 45.4711 57.1307C45.8594 56.9697 46.1482 56.7282 46.3376 56.4062C46.5317 56.0843 46.6288 55.6842 46.6288 55.206C46.6288 54.723 46.5317 54.3158 46.3376 53.9844C46.1482 53.6529 45.857 53.402 45.464 53.2315C45.0757 53.0563 44.5857 52.9688 43.9938 52.9688H41.92V65H38.8447ZM46.6998 58.3807L50.3148 65H46.92L43.383 58.3807H46.6998Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5073", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Rar.displayName = "Rar";
  var Sketch = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5106)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#FFBA35"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.3739 55.7102C11.3284 55.2519 11.1333 54.8958 10.7886 54.642C10.4439 54.3883 9.97614 54.2614 9.38523 54.2614C8.98371 54.2614 8.6447 54.3182 8.36818 54.4318C8.09167 54.5417 7.87954 54.6951 7.73182 54.892C7.58788 55.089 7.51591 55.3125 7.51591 55.5625C7.50833 55.7708 7.55189 55.9527 7.64659 56.108C7.74508 56.2633 7.87954 56.3977 8.05 56.5114C8.22045 56.6212 8.41742 56.7178 8.64091 56.8011C8.86439 56.8807 9.10303 56.9489 9.35682 57.0057L10.4023 57.2557C10.9098 57.3693 11.3758 57.5208 11.8 57.7102C12.2242 57.8996 12.5917 58.1326 12.9023 58.4091C13.2129 58.6856 13.4534 59.0114 13.6239 59.3864C13.7981 59.7614 13.8871 60.1913 13.8909 60.6761C13.8871 61.3883 13.7053 62.0057 13.3455 62.5284C12.9894 63.0473 12.4742 63.4508 11.8 63.7386C11.1295 64.0227 10.3208 64.1648 9.37386 64.1648C8.43447 64.1648 7.61629 64.0208 6.91932 63.733C6.22614 63.4451 5.68447 63.0189 5.29432 62.4545C4.90795 61.8864 4.7053 61.1837 4.68636 60.3466H7.06704C7.09356 60.7367 7.2053 61.0625 7.40227 61.3239C7.60303 61.5814 7.87008 61.7765 8.20341 61.9091C8.54053 62.0379 8.92121 62.1023 9.34545 62.1023C9.76212 62.1023 10.1239 62.0417 10.4307 61.9205C10.7413 61.7992 10.9818 61.6307 11.1523 61.4148C11.3227 61.1989 11.408 60.9508 11.408 60.6705C11.408 60.4091 11.3303 60.1894 11.175 60.0114C11.0235 59.8333 10.8 59.6818 10.5045 59.5568C10.2129 59.4318 9.85492 59.3182 9.43068 59.2159L8.16364 58.8977C7.18258 58.6591 6.40795 58.286 5.83977 57.7784C5.27159 57.2708 4.98939 56.5871 4.99318 55.7273C4.98939 55.0227 5.17689 54.4072 5.55568 53.8807C5.93826 53.3542 6.46288 52.9432 7.12954 52.6477C7.79621 52.3523 8.55379 52.2045 9.40227 52.2045C10.2659 52.2045 11.0197 52.3523 11.6636 52.6477C12.3114 52.9432 12.8152 53.3542 13.175 53.8807C13.5348 54.4072 13.7205 55.017 13.7318 55.7102H11.3739ZM17.3735 61.4886L17.3791 58.5852H17.7314L20.5269 55.2727H23.3053L19.5496 59.6591H18.9757L17.3735 61.4886ZM15.1803 64V52.3636H17.6007V64H15.1803ZM20.6348 64L18.0666 60.1989L19.6803 58.4886L23.4701 64H20.6348ZM27.7907 64.1705C26.893 64.1705 26.1202 63.9886 25.4725 63.625C24.8286 63.2576 24.3323 62.7386 23.9839 62.0682C23.6354 61.3939 23.4611 60.5966 23.4611 59.6761C23.4611 58.7784 23.6354 57.9905 23.9839 57.3125C24.3323 56.6345 24.8229 56.1061 25.4555 55.7273C26.0918 55.3485 26.838 55.1591 27.6941 55.1591C28.2698 55.1591 28.8058 55.2519 29.302 55.4375C29.802 55.6193 30.2377 55.8939 30.6089 56.2614C30.9839 56.6288 31.2755 57.0909 31.4839 57.6477C31.6922 58.2008 31.7964 58.8485 31.7964 59.5909V60.2557H24.427V58.7557H29.518C29.518 58.4072 29.4422 58.0985 29.2907 57.8295C29.1392 57.5606 28.9289 57.3504 28.66 57.1989C28.3948 57.0436 28.0861 56.9659 27.7339 56.9659C27.3664 56.9659 27.0407 57.0511 26.7566 57.2216C26.4763 57.3883 26.2566 57.6136 26.0975 57.8977C25.9384 58.178 25.857 58.4905 25.8532 58.8352V60.2614C25.8532 60.6932 25.9327 61.0663 26.0918 61.3807C26.2547 61.6951 26.4839 61.9375 26.7793 62.108C27.0748 62.2784 27.4252 62.3636 27.8305 62.3636C28.0994 62.3636 28.3456 62.3258 28.5691 62.25C28.7926 62.1742 28.9839 62.0606 29.143 61.9091C29.302 61.7576 29.4233 61.572 29.5066 61.3523L31.7452 61.5C31.6316 62.0379 31.3986 62.5076 31.0464 62.9091C30.6979 63.3068 30.2471 63.6174 29.6941 63.8409C29.1448 64.0606 28.5104 64.1705 27.7907 64.1705ZM37.698 55.2727V57.0909H32.4423V55.2727H37.698ZM33.6355 53.1818H36.0559V61.3182C36.0559 61.5417 36.09 61.7159 36.1582 61.8409C36.2264 61.9621 36.3211 62.0473 36.4423 62.0966C36.5673 62.1458 36.7112 62.1705 36.8741 62.1705C36.9877 62.1705 37.1014 62.161 37.215 62.142C37.3286 62.1193 37.4158 62.1023 37.4764 62.0909L37.857 63.892C37.7358 63.9299 37.5654 63.9735 37.3457 64.0227C37.126 64.0758 36.8589 64.108 36.5445 64.1193C35.9612 64.142 35.4498 64.0644 35.0105 63.8864C34.5748 63.7083 34.2358 63.4318 33.9934 63.0568C33.751 62.6818 33.6317 62.2083 33.6355 61.6364V53.1818ZM42.8041 64.1705C41.9102 64.1705 41.1412 63.9811 40.4973 63.6023C39.8571 63.2197 39.3647 62.6894 39.02 62.0114C38.6791 61.3333 38.5086 60.553 38.5086 59.6705C38.5086 58.7765 38.681 57.9924 39.0257 57.3182C39.3742 56.6402 39.8685 56.1117 40.5086 55.733C41.1488 55.3504 41.9102 55.1591 42.7927 55.1591C43.5541 55.1591 44.2208 55.2973 44.7927 55.5739C45.3647 55.8504 45.8173 56.2386 46.1507 56.7386C46.484 57.2386 46.6677 57.8258 46.7018 58.5H44.4177C44.3533 58.0644 44.1829 57.714 43.9064 57.4489C43.6336 57.1799 43.2757 57.0455 42.8325 57.0455C42.4575 57.0455 42.1298 57.1477 41.8495 57.3523C41.573 57.553 41.3571 57.8466 41.2018 58.233C41.0465 58.6193 40.9689 59.0871 40.9689 59.6364C40.9689 60.1932 41.0446 60.6667 41.1961 61.0568C41.3514 61.447 41.5692 61.7443 41.8495 61.9489C42.1298 62.1534 42.4575 62.2557 42.8325 62.2557C43.109 62.2557 43.3571 62.1989 43.5768 62.0852C43.8003 61.9716 43.984 61.8068 44.128 61.5909C44.2757 61.3712 44.3723 61.108 44.4177 60.8011H46.7018C46.6639 61.4678 46.4821 62.0549 46.1564 62.5625C45.8344 63.0663 45.3893 63.4602 44.8211 63.7443C44.253 64.0284 43.5806 64.1705 42.8041 64.1705ZM50.352 58.9545V64H47.9315V52.3636H50.2838V56.8125H50.3861C50.5831 56.2973 50.9012 55.8939 51.3406 55.6023C51.78 55.3068 52.3312 55.1591 52.994 55.1591C53.6001 55.1591 54.1285 55.2917 54.5793 55.5568C55.0338 55.8182 55.3861 56.1951 55.6361 56.6875C55.8899 57.1761 56.0149 57.7614 56.0111 58.4432V64H53.5906V58.875C53.5944 58.3371 53.4581 57.9186 53.1815 57.6193C52.9088 57.3201 52.5262 57.1705 52.0338 57.1705C51.7043 57.1705 51.4126 57.2405 51.1588 57.3807C50.9088 57.5208 50.7118 57.7254 50.5679 57.9943C50.4277 58.2595 50.3558 58.5795 50.352 58.9545Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5106", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Sketch.displayName = "Sketch";
  var SVG = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5089)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M18.3244 54.6378C18.2675 54.0649 18.0237 53.6198 17.5928 53.3026C17.162 52.9853 16.5772 52.8267 15.8386 52.8267C15.3367 52.8267 14.9129 52.8977 14.5673 53.0398C14.2216 53.1771 13.9565 53.3688 13.7718 53.6151C13.5919 53.8613 13.5019 54.1406 13.5019 54.4531C13.4924 54.7135 13.5469 54.9408 13.6653 55.1349C13.7884 55.3291 13.9565 55.4972 14.1695 55.6392C14.3826 55.7765 14.6288 55.8973 14.9082 56.0014C15.1875 56.1009 15.4858 56.1861 15.8031 56.2571L17.1099 56.5696C17.7443 56.7116 18.3267 56.901 18.857 57.1378C19.3873 57.3745 19.8466 57.6657 20.2349 58.0114C20.6231 58.357 20.9238 58.7642 21.1369 59.233C21.3547 59.7017 21.4659 60.2391 21.4707 60.8452C21.4659 61.7353 21.2387 62.5071 20.7888 63.1605C20.3438 63.8092 19.6998 64.3134 18.857 64.6733C18.019 65.0284 17.0081 65.206 15.8244 65.206C14.6501 65.206 13.6274 65.026 12.7562 64.6662C11.8897 64.3063 11.2126 63.7737 10.7249 63.0682C10.242 62.358 9.98866 61.4796 9.96499 60.4332H12.9408C12.974 60.9209 13.1137 61.3281 13.3599 61.6548C13.6108 61.9768 13.9446 62.2206 14.3613 62.3864C14.7827 62.5473 15.2585 62.6278 15.7888 62.6278C16.3097 62.6278 16.7619 62.5521 17.1454 62.4006C17.5336 62.2491 17.8343 62.0384 18.0474 61.7685C18.2604 61.4986 18.367 61.1884 18.367 60.8381C18.367 60.5114 18.2699 60.2367 18.0758 60.0142C17.8864 59.7917 17.607 59.6023 17.2377 59.446C16.8731 59.2898 16.4257 59.1477 15.8954 59.0199L14.3116 58.6222C13.0853 58.3239 12.117 57.8575 11.4067 57.223C10.6965 56.5885 10.3438 55.7339 10.3485 54.6591C10.3438 53.7784 10.5781 53.009 11.0516 52.3509C11.5299 51.6927 12.1856 51.179 13.019 50.8097C13.8523 50.4403 14.7993 50.2557 15.8599 50.2557C16.9394 50.2557 17.8817 50.4403 18.6866 50.8097C19.4962 51.179 20.126 51.6927 20.5758 52.3509C21.0256 53.009 21.2576 53.7713 21.2718 54.6378H18.3244ZM25.767 50.4545L29.2827 61.5057H29.4176L32.9403 50.4545H36.3494L31.3352 65H27.3722L22.3509 50.4545H25.767ZM46.5247 55.1562C46.4253 54.8106 46.2856 54.5052 46.1057 54.2401C45.9258 53.9702 45.7056 53.7429 45.4452 53.5582C45.1895 53.3688 44.8959 53.2244 44.5645 53.125C44.2378 53.0256 43.8756 52.9759 43.4778 52.9759C42.7345 52.9759 42.0811 53.1605 41.5176 53.5298C40.9589 53.8991 40.5233 54.4366 40.2108 55.142C39.8983 55.8428 39.742 56.6998 39.742 57.7131C39.742 58.7263 39.8959 59.5881 40.2037 60.2983C40.5115 61.0085 40.9471 61.5507 41.5105 61.9247C42.074 62.294 42.7392 62.4787 43.5063 62.4787C44.2023 62.4787 44.7965 62.3556 45.2889 62.1094C45.7861 61.8584 46.1649 61.5057 46.4253 61.0511C46.6904 60.5966 46.823 60.0592 46.823 59.4389L47.448 59.5312H43.698V57.2159H49.7847V59.0483C49.7847 60.3267 49.5148 61.4252 48.975 62.3438C48.4352 63.2576 47.6919 63.9631 46.7449 64.4602C45.7979 64.9527 44.7136 65.1989 43.492 65.1989C42.1284 65.1989 40.9305 64.8982 39.8983 64.2969C38.8661 63.6908 38.0612 62.8314 37.4835 61.7188C36.9106 60.6013 36.6241 59.2756 36.6241 57.7415C36.6241 56.5625 36.7946 55.5114 37.1355 54.5881C37.4812 53.66 37.9641 52.8741 38.5844 52.2301C39.2046 51.5862 39.9267 51.0961 40.7506 50.7599C41.5744 50.4238 42.467 50.2557 43.4281 50.2557C44.252 50.2557 45.019 50.3764 45.7293 50.6179C46.4395 50.8546 47.0692 51.1908 47.6185 51.6264C48.1724 52.062 48.6246 52.5805 48.975 53.1818C49.3254 53.7784 49.5503 54.4366 49.6497 55.1562H46.5247Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5089", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  SVG.displayName = "SVG";
  var TIFF = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5090)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10.1286 52.9901V50.4545H22.0746V52.9901H17.6215V65H14.5817V52.9901H10.1286ZM26.7172 50.4545V65H23.6419V50.4545H26.7172ZM28.8474 65V50.4545H38.4781V52.9901H31.9227V56.456H37.8389V58.9915H31.9227V65H28.8474ZM40.1466 65V50.4545H49.7773V52.9901H43.2219V56.456H49.1381V58.9915H43.2219V65H40.1466Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5090", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  TIFF.displayName = "TIFF";
  var TXT = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5080)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#344054"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.1024 52.9901V50.4545H23.0484V52.9901H18.5953V65H15.5555V52.9901H11.1024ZM27.4993 50.4545L30.4325 55.4119H30.5462L33.4936 50.4545H36.9666L32.5277 57.7273L37.0661 65H33.5291L30.5462 60.0355H30.4325L27.4496 65H23.9268L28.4794 57.7273L24.0121 50.4545H27.4993ZM37.9587 52.9901V50.4545H49.9047V52.9901H45.4516V65H42.4118V52.9901H37.9587Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5080", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  TXT.displayName = "TXT";
  var WAV = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5104)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#6E45F0"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.7567 65L7.59478 50.4545H10.9542L13.3618 60.5611H13.4826L16.1388 50.4545H19.0152L21.6644 60.5824H21.7922L24.1999 50.4545H27.5593L23.3973 65H20.4002L17.6303 55.4901H17.5167L14.7539 65H11.7567ZM29.8475 65H26.552L31.5733 50.4545H35.5364L40.5506 65H37.2551L33.6117 53.7784H33.498L29.8475 65ZM29.6415 59.2827H37.4256V61.6832H29.6415V59.2827ZM42.7127 50.4545L46.2284 61.5057H46.3633L49.886 50.4545H53.2951L48.2809 65H44.3179L39.2966 50.4545H42.7127Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5104", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  WAV.displayName = "WAV";
  var WEBP = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5103)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#3873FF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9.23283 65L5.69519 52.6364H8.55066L10.5972 61.2269H10.6998L12.9576 52.6364H15.4026L17.6544 61.245H17.763L19.8095 52.6364H22.665L19.1274 65H16.5798L14.2254 56.9165H14.1288L11.7804 65H9.23283ZM23.7241 65V52.6364H32.055V54.7915H26.3381V57.7376H31.6264V59.8928H26.3381V62.8448H32.0792V65H23.7241ZM33.7932 65V52.6364H38.7435C39.6531 52.6364 40.4117 52.7712 41.0195 53.0408C41.6272 53.3105 42.084 53.6848 42.3898 54.1637C42.6957 54.6386 42.8486 55.186 42.8486 55.8058C42.8486 56.2887 42.7521 56.7133 42.5589 57.0795C42.3657 57.4418 42.1001 57.7396 41.762 57.973C41.428 58.2024 41.0456 58.3654 40.615 58.462V58.5827C41.0859 58.6029 41.5266 58.7357 41.9371 58.9812C42.3516 59.2267 42.6877 59.5708 42.9452 60.0135C43.2028 60.4522 43.3316 60.9754 43.3316 61.5831C43.3316 62.2391 43.1686 62.8247 42.8426 63.3398C42.5206 63.851 42.0437 64.2554 41.4119 64.5533C40.78 64.8511 40.0012 65 39.0756 65H33.7932ZM36.4072 62.8629H38.5383C39.2667 62.8629 39.798 62.7241 40.132 62.4464C40.4661 62.1647 40.6331 61.7904 40.6331 61.3235C40.6331 60.9814 40.5506 60.6796 40.3856 60.418C40.2206 60.1564 39.9851 59.9511 39.6793 59.8022C39.3774 59.6533 39.0172 59.5788 38.5986 59.5788H36.4072V62.8629ZM36.4072 57.81H38.3451C38.7033 57.81 39.0212 57.7476 39.2989 57.6229C39.5807 57.4941 39.802 57.313 39.963 57.0795C40.128 56.8461 40.2105 56.5664 40.2105 56.2404C40.2105 55.7937 40.0515 55.4335 39.7336 55.1598C39.4197 54.8861 38.9729 54.7493 38.3934 54.7493H36.4072V57.81ZM44.6925 65V52.6364H49.5703C50.5081 52.6364 51.307 52.8155 51.967 53.1737C52.627 53.5278 53.1301 54.0208 53.4762 54.6527C53.8264 55.2805 54.0015 56.005 54.0015 56.826C54.0015 57.647 53.8244 58.3714 53.4702 58.9993C53.116 59.6271 52.6029 60.1161 51.9308 60.4663C51.2627 60.8164 50.4537 60.9915 49.5039 60.9915H46.3949V58.8967H49.0814C49.5844 58.8967 49.999 58.8101 50.325 58.6371C50.655 58.46 50.9005 58.2165 51.0615 57.9066C51.2265 57.5927 51.309 57.2325 51.309 56.826C51.309 56.4155 51.2265 56.0573 51.0615 55.7514C50.9005 55.4415 50.655 55.2021 50.325 55.033C49.9949 54.86 49.5764 54.7734 49.0693 54.7734H47.3065V65H44.6925Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5103", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  WEBP.displayName = "WEBP";
  var XLS = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5099)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#0DB664"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M15.1727 50.4545L18.106 55.4119H18.2196L21.167 50.4545H24.6401L20.2011 57.7273L24.7395 65H21.2026L18.2196 60.0355H18.106L15.123 65H11.6003L16.1528 57.7273L11.6855 50.4545H15.1727ZM26.1861 65V50.4545H29.2614V62.4645H35.4972V65H26.1861ZM45.0244 54.6378C44.9675 54.0649 44.7237 53.6198 44.2928 53.3026C43.862 52.9853 43.2772 52.8267 42.5386 52.8267C42.0367 52.8267 41.6129 52.8977 41.2673 53.0398C40.9216 53.1771 40.6565 53.3688 40.4718 53.6151C40.2919 53.8613 40.2019 54.1406 40.2019 54.4531C40.1924 54.7135 40.2469 54.9408 40.3653 55.1349C40.4884 55.3291 40.6565 55.4972 40.8695 55.6392C41.0826 55.7765 41.3288 55.8973 41.6082 56.0014C41.8875 56.1009 42.1858 56.1861 42.5031 56.2571L43.8099 56.5696C44.4443 56.7116 45.0267 56.901 45.557 57.1378C46.0873 57.3745 46.5466 57.6657 46.9349 58.0114C47.3231 58.357 47.6238 58.7642 47.8369 59.233C48.0547 59.7017 48.1659 60.2391 48.1707 60.8452C48.1659 61.7353 47.9387 62.5071 47.4889 63.1605C47.0438 63.8092 46.3998 64.3134 45.557 64.6733C44.719 65.0284 43.7081 65.206 42.5244 65.206C41.3501 65.206 40.3274 65.026 39.4562 64.6662C38.5897 64.3063 37.9126 63.7737 37.4249 63.0682C36.942 62.358 36.6887 61.4796 36.665 60.4332H39.6408C39.674 60.9209 39.8137 61.3281 40.0599 61.6548C40.3108 61.9768 40.6446 62.2206 41.0613 62.3864C41.4827 62.5473 41.9585 62.6278 42.4888 62.6278C43.0097 62.6278 43.4619 62.5521 43.8454 62.4006C44.2336 62.2491 44.5343 62.0384 44.7474 61.7685C44.9604 61.4986 45.067 61.1884 45.067 60.8381C45.067 60.5114 44.9699 60.2367 44.7758 60.0142C44.5864 59.7917 44.307 59.6023 43.9377 59.446C43.5731 59.2898 43.1257 59.1477 42.5954 59.0199L41.0116 58.6222C39.7853 58.3239 38.817 57.8575 38.1067 57.223C37.3965 56.5885 37.0438 55.7339 37.0485 54.6591C37.0438 53.7784 37.2781 53.009 37.7516 52.3509C38.2299 51.6927 38.8856 51.179 39.719 50.8097C40.5523 50.4403 41.4993 50.2557 42.5599 50.2557C43.6394 50.2557 44.5817 50.4403 45.3866 50.8097C46.1962 51.179 46.826 51.6927 47.2758 52.3509C47.7256 53.009 47.9576 53.7713 47.9718 54.6378H45.0244Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5099", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  XLS.displayName = "XLS";
  var Zip = reactExports.forwardRef(
    ({ ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref,
        width: "30",
        height: "40",
        viewBox: "0 0 60 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_163_5074)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M0 8C0 3.58172 3.58172 0 8 0H34L60 26V72C60 76.4183 56.4183 80 52 80H8C3.58172 80 0 76.4183 0 72V8Z",
                fill: "#344054"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M40 26H60L34 0V20C34 23.3137 36.6863 26 40 26Z",
                fill: "white",
                fillOpacity: "0.5"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M15.5607 65V63.1747L22.8192 52.9901H15.5465V50.4545H26.6828V52.2798L19.4172 62.4645H26.6971V65H15.5607ZM31.7321 50.4545V65H28.6568V50.4545H31.7321ZM33.8623 65V50.4545H39.6009C40.7041 50.4545 41.644 50.6652 42.4205 51.0866C43.197 51.5033 43.7889 52.0833 44.1961 52.8267C44.608 53.5653 44.814 54.4176 44.814 55.3835C44.814 56.3494 44.6056 57.2017 44.189 57.9403C43.7723 58.679 43.1686 59.2543 42.3779 59.6662C41.5919 60.0781 40.6402 60.2841 39.5228 60.2841H35.8651V57.8196H39.0256C39.6175 57.8196 40.1051 57.7178 40.4887 57.5142C40.8769 57.3059 41.1658 57.0194 41.3551 56.6548C41.5493 56.2855 41.6463 55.8617 41.6463 55.3835C41.6463 54.9006 41.5493 54.4792 41.3551 54.1193C41.1658 53.7547 40.8769 53.473 40.4887 53.2741C40.1004 53.0705 39.608 52.9688 39.0114 52.9688H36.9375V65H33.8623Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_163_5074", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "80", fill: "white" }) }) })
        ]
      }
    )
  );
  Zip.displayName = "Zip";
  function EmbeddedLoadingIndicator({
    config
  }) {
    if (config.displayMode !== "embedded") {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua-pop-embedded-loading", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua-pop-embedded-loading-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua-pop-embedded-loading-spinner", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { size: 32 }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lua-pop-embedded-loading-text", children: "Initialising..." })
    ] }) });
  }
  function PopButton({ onClick, config }) {
    const [hasBeenHovered, setHasBeenHovered] = reactExports.useState(false);
    const { hasUnreadMessages } = hn();
    const handleMouseEnter = () => {
      if (!hasBeenHovered) {
        setHasBeenHovered(true);
      }
    };
    const {
      buttonText: text2,
      buttonColor: color2,
      buttonIcon: icon,
      popupButtonStyles,
      position: position2
    } = config;
    const getBadgePositionClasses = () => {
      if (position2 === "bottom-left" || position2 === "top-left") {
        return "lua:absolute lua:-top-1 lua:right-1";
      } else {
        return "lua:absolute lua:-top-1 lua:-right-1";
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        initial: { scale: 0, opacity: 0 },
        animate: { scale: 1, opacity: 1 },
        transition: {
          type: "spring",
          stiffness: 300,
          damping: 20,
          mass: 0.8
        },
        className: "lua:relative",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:absolute lua:inset-2 lua:rounded-full lua:bg-black lua:opacity-30 animate-pulse-ring-expand lua:pointer-events-none" }),
          hasUnreadMessages && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `${getBadgePositionClasses()} lua:z-10 lua:w-4 lua:h-4 lua:bg-red-600 lua:rounded-full lua:border-2 lua:border-white lua:flex lua:items-center lua:justify-center`
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              onClick,
              className: `lua-pop-button ${!hasBeenHovered ? `animate-pulse-ring lua:before:bg-[var(--pulse-color)]/80` : ""}`,
              onMouseEnter: handleMouseEnter,
              "aria-label": "Open support chat",
              style: {
                ...color2 && { background: color2 },
                ...popupButtonStyles && popupButtonStyles,
                // @ts-ignore
                "--pulse-color": color2 || "#000000"
              },
              children: [
                icon ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: icon, alt: "Brand Icon", className: "lua:w-4 lua-h-4" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { size: 16 }),
                text2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:font-medium", children: text2 }) : null
              ]
            }
          )
        ]
      }
    );
  }
  /*!---------------------------------------------------------------------------------------------
   *  Copyright (c) StackBlitz. All rights reserved.
   *  Licensed under the MIT License. See License.txt in the project root for license information.
   *--------------------------------------------------------------------------------------------*/
  const DEFAULT_SPRING_ANIMATION = {
    /**
     * A value from 0 to 1, on how much to damp the animation.
     * 0 means no damping, 1 means full damping.
     *
     * @default 0.7
     */
    damping: 0.7,
    /**
     * The stiffness of how fast/slow the animation gets up to speed.
     *
     * @default 0.05
     */
    stiffness: 0.05,
    /**
     * The inertial mass associated with the animation.
     * Higher numbers make the animation slower.
     *
     * @default 1.25
     */
    mass: 1.25
  };
  const STICK_TO_BOTTOM_OFFSET_PX = 70;
  const SIXTY_FPS_INTERVAL_MS = 1e3 / 60;
  const RETAIN_ANIMATION_DURATION_MS = 350;
  let mouseDown = false;
  (_k = globalThis.document) == null ? void 0 : _k.addEventListener("mousedown", () => {
    mouseDown = true;
  });
  (_l = globalThis.document) == null ? void 0 : _l.addEventListener("mouseup", () => {
    mouseDown = false;
  });
  (_m = globalThis.document) == null ? void 0 : _m.addEventListener("click", () => {
    mouseDown = false;
  });
  const useStickToBottom = (options2 = {}) => {
    const [escapedFromLock, updateEscapedFromLock] = reactExports.useState(false);
    const [isAtBottom, updateIsAtBottom] = reactExports.useState(options2.initial !== false);
    const [isNearBottom, setIsNearBottom] = reactExports.useState(false);
    const optionsRef = reactExports.useRef(null);
    optionsRef.current = options2;
    const isSelecting = reactExports.useCallback(() => {
      var _a2;
      if (!mouseDown) {
        return false;
      }
      const selection = window.getSelection();
      if (!selection || !selection.rangeCount) {
        return false;
      }
      const range = selection.getRangeAt(0);
      return range.commonAncestorContainer.contains(scrollRef.current) || ((_a2 = scrollRef.current) == null ? void 0 : _a2.contains(range.commonAncestorContainer));
    }, []);
    const setIsAtBottom = reactExports.useCallback((isAtBottom2) => {
      state.isAtBottom = isAtBottom2;
      updateIsAtBottom(isAtBottom2);
    }, []);
    const setEscapedFromLock = reactExports.useCallback((escapedFromLock2) => {
      state.escapedFromLock = escapedFromLock2;
      updateEscapedFromLock(escapedFromLock2);
    }, []);
    const state = reactExports.useMemo(() => {
      let lastCalculation;
      return {
        escapedFromLock,
        isAtBottom,
        resizeDifference: 0,
        accumulated: 0,
        velocity: 0,
        listeners: /* @__PURE__ */ new Set(),
        get scrollTop() {
          var _a2;
          return ((_a2 = scrollRef.current) == null ? void 0 : _a2.scrollTop) ?? 0;
        },
        set scrollTop(scrollTop) {
          if (scrollRef.current) {
            scrollRef.current.scrollTop = scrollTop;
            state.ignoreScrollToTop = scrollRef.current.scrollTop;
          }
        },
        get targetScrollTop() {
          if (!scrollRef.current || !contentRef.current) {
            return 0;
          }
          return scrollRef.current.scrollHeight - 1 - scrollRef.current.clientHeight;
        },
        get calculatedTargetScrollTop() {
          if (!scrollRef.current || !contentRef.current) {
            return 0;
          }
          const { targetScrollTop } = this;
          if (!options2.targetScrollTop) {
            return targetScrollTop;
          }
          if ((lastCalculation == null ? void 0 : lastCalculation.targetScrollTop) === targetScrollTop) {
            return lastCalculation.calculatedScrollTop;
          }
          const calculatedScrollTop = Math.max(Math.min(options2.targetScrollTop(targetScrollTop, {
            scrollElement: scrollRef.current,
            contentElement: contentRef.current
          }), targetScrollTop), 0);
          lastCalculation = { targetScrollTop, calculatedScrollTop };
          requestAnimationFrame(() => {
            lastCalculation = void 0;
          });
          return calculatedScrollTop;
        },
        get scrollDifference() {
          return this.calculatedTargetScrollTop - this.scrollTop;
        },
        get isNearBottom() {
          return this.scrollDifference <= STICK_TO_BOTTOM_OFFSET_PX;
        }
      };
    }, []);
    const scrollToBottom = reactExports.useCallback((scrollOptions = {}) => {
      var _a2;
      if (typeof scrollOptions === "string") {
        scrollOptions = { animation: scrollOptions };
      }
      if (!scrollOptions.preserveScrollPosition) {
        setIsAtBottom(true);
      }
      const waitElapsed = Date.now() + (Number(scrollOptions.wait) || 0);
      const behavior = mergeAnimations(optionsRef.current, scrollOptions.animation);
      const { ignoreEscapes = false } = scrollOptions;
      let durationElapsed;
      let startTarget = state.calculatedTargetScrollTop;
      if (scrollOptions.duration instanceof Promise) {
        scrollOptions.duration.finally(() => {
          durationElapsed = Date.now();
        });
      } else {
        durationElapsed = waitElapsed + (scrollOptions.duration ?? 0);
      }
      const next = async () => {
        const promise = new Promise(requestAnimationFrame).then(() => {
          var _a3;
          if (!state.isAtBottom) {
            state.animation = void 0;
            return false;
          }
          const { scrollTop } = state;
          const tick = performance.now();
          const tickDelta = (tick - (state.lastTick ?? tick)) / SIXTY_FPS_INTERVAL_MS;
          state.animation || (state.animation = { behavior, promise, ignoreEscapes });
          if (state.animation.behavior === behavior) {
            state.lastTick = tick;
          }
          if (isSelecting()) {
            return next();
          }
          if (waitElapsed > Date.now()) {
            return next();
          }
          if (scrollTop < Math.min(startTarget, state.calculatedTargetScrollTop)) {
            if (((_a3 = state.animation) == null ? void 0 : _a3.behavior) === behavior) {
              if (behavior === "instant") {
                state.scrollTop = state.calculatedTargetScrollTop;
                return next();
              }
              state.velocity = (behavior.damping * state.velocity + behavior.stiffness * state.scrollDifference) / behavior.mass;
              state.accumulated += state.velocity * tickDelta;
              state.scrollTop += state.accumulated;
              if (state.scrollTop !== scrollTop) {
                state.accumulated = 0;
              }
            }
            return next();
          }
          if (durationElapsed > Date.now()) {
            startTarget = state.calculatedTargetScrollTop;
            return next();
          }
          state.animation = void 0;
          if (state.scrollTop < state.calculatedTargetScrollTop) {
            return scrollToBottom({
              animation: mergeAnimations(optionsRef.current, optionsRef.current.resize),
              ignoreEscapes,
              duration: Math.max(0, durationElapsed - Date.now()) || void 0
            });
          }
          return state.isAtBottom;
        });
        return promise.then((isAtBottom2) => {
          requestAnimationFrame(() => {
            if (!state.animation) {
              state.lastTick = void 0;
              state.velocity = 0;
            }
          });
          return isAtBottom2;
        });
      };
      if (scrollOptions.wait !== true) {
        state.animation = void 0;
      }
      if (((_a2 = state.animation) == null ? void 0 : _a2.behavior) === behavior) {
        return state.animation.promise;
      }
      return next();
    }, [setIsAtBottom, isSelecting, state]);
    const stopScroll = reactExports.useCallback(() => {
      setEscapedFromLock(true);
      setIsAtBottom(false);
    }, [setEscapedFromLock, setIsAtBottom]);
    const handleScroll2 = reactExports.useCallback(({ target }) => {
      if (target !== scrollRef.current) {
        return;
      }
      const { scrollTop, ignoreScrollToTop } = state;
      let { lastScrollTop = scrollTop } = state;
      state.lastScrollTop = scrollTop;
      state.ignoreScrollToTop = void 0;
      if (ignoreScrollToTop && ignoreScrollToTop > scrollTop) {
        lastScrollTop = ignoreScrollToTop;
      }
      setIsNearBottom(state.isNearBottom);
      setTimeout(() => {
        var _a2;
        if (state.resizeDifference || scrollTop === ignoreScrollToTop) {
          return;
        }
        if (isSelecting()) {
          setEscapedFromLock(true);
          setIsAtBottom(false);
          return;
        }
        const isScrollingDown = scrollTop > lastScrollTop;
        const isScrollingUp = scrollTop < lastScrollTop;
        if ((_a2 = state.animation) == null ? void 0 : _a2.ignoreEscapes) {
          state.scrollTop = lastScrollTop;
          return;
        }
        if (isScrollingUp) {
          setEscapedFromLock(true);
          setIsAtBottom(false);
        }
        if (isScrollingDown) {
          setEscapedFromLock(false);
        }
        if (!state.escapedFromLock && state.isNearBottom) {
          setIsAtBottom(true);
        }
      }, 1);
    }, [setEscapedFromLock, setIsAtBottom, isSelecting, state]);
    const handleWheel = reactExports.useCallback(({ target, deltaY }) => {
      var _a2;
      let element2 = target;
      while (!["scroll", "auto"].includes(getComputedStyle(element2).overflow)) {
        if (!element2.parentElement) {
          return;
        }
        element2 = element2.parentElement;
      }
      if (element2 === scrollRef.current && deltaY < 0 && scrollRef.current.scrollHeight > scrollRef.current.clientHeight && !((_a2 = state.animation) == null ? void 0 : _a2.ignoreEscapes)) {
        setEscapedFromLock(true);
        setIsAtBottom(false);
      }
    }, [setEscapedFromLock, setIsAtBottom, state]);
    const scrollRef = useRefCallback((scroll) => {
      var _a2, _b2;
      (_a2 = scrollRef.current) == null ? void 0 : _a2.removeEventListener("scroll", handleScroll2);
      (_b2 = scrollRef.current) == null ? void 0 : _b2.removeEventListener("wheel", handleWheel);
      scroll == null ? void 0 : scroll.addEventListener("scroll", handleScroll2, { passive: true });
      scroll == null ? void 0 : scroll.addEventListener("wheel", handleWheel, { passive: true });
    }, []);
    const contentRef = useRefCallback((content2) => {
      var _a2, _b2;
      (_a2 = state.resizeObserver) == null ? void 0 : _a2.disconnect();
      if (!content2) {
        return;
      }
      let previousHeight;
      state.resizeObserver = new ResizeObserver(([entry]) => {
        const { height } = entry.contentRect;
        const difference = height - (previousHeight ?? height);
        state.resizeDifference = difference;
        if (state.scrollTop > state.targetScrollTop) {
          state.scrollTop = state.targetScrollTop;
        }
        setIsNearBottom(state.isNearBottom);
        if (difference >= 0) {
          const animation = mergeAnimations(optionsRef.current, previousHeight ? optionsRef.current.resize : optionsRef.current.initial);
          scrollToBottom({
            animation,
            wait: true,
            preserveScrollPosition: true,
            duration: animation === "instant" ? void 0 : RETAIN_ANIMATION_DURATION_MS
          });
        } else {
          if (state.isNearBottom) {
            setEscapedFromLock(false);
            setIsAtBottom(true);
          }
        }
        previousHeight = height;
        requestAnimationFrame(() => {
          setTimeout(() => {
            if (state.resizeDifference === difference) {
              state.resizeDifference = 0;
            }
          }, 1);
        });
      });
      (_b2 = state.resizeObserver) == null ? void 0 : _b2.observe(content2);
    }, []);
    return {
      contentRef,
      scrollRef,
      scrollToBottom,
      stopScroll,
      isAtBottom: isAtBottom || isNearBottom,
      isNearBottom,
      escapedFromLock,
      state
    };
  };
  function useRefCallback(callback, deps) {
    const result = reactExports.useCallback((ref) => {
      result.current = ref;
      return callback(ref);
    }, deps);
    return result;
  }
  const animationCache = /* @__PURE__ */ new Map();
  function mergeAnimations(...animations2) {
    const result = { ...DEFAULT_SPRING_ANIMATION };
    let instant = false;
    for (const animation of animations2) {
      if (animation === "instant") {
        instant = true;
        continue;
      }
      if (typeof animation !== "object") {
        continue;
      }
      instant = false;
      result.damping = animation.damping ?? result.damping;
      result.stiffness = animation.stiffness ?? result.stiffness;
      result.mass = animation.mass ?? result.mass;
    }
    const key = JSON.stringify(result);
    if (!animationCache.has(key)) {
      animationCache.set(key, Object.freeze(result));
    }
    return instant ? "instant" : animationCache.get(key);
  }
  const StickToBottomContext = reactExports.createContext(null);
  const useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  function StickToBottom({ instance, children, resize, initial, mass, damping, stiffness, targetScrollTop: currentTargetScrollTop, contextRef, ...props }) {
    const customTargetScrollTop = reactExports.useRef(null);
    const targetScrollTop = reactExports.useCallback((target, elements) => {
      const get = (context == null ? void 0 : context.targetScrollTop) ?? currentTargetScrollTop;
      return (get == null ? void 0 : get(target, elements)) ?? target;
    }, [currentTargetScrollTop]);
    const defaultInstance = useStickToBottom({
      mass,
      damping,
      stiffness,
      resize,
      initial,
      targetScrollTop
    });
    const { scrollRef, contentRef, scrollToBottom, stopScroll, isAtBottom, escapedFromLock, state } = instance ?? defaultInstance;
    const context = reactExports.useMemo(() => ({
      scrollToBottom,
      stopScroll,
      scrollRef,
      isAtBottom,
      escapedFromLock,
      contentRef,
      state,
      get targetScrollTop() {
        return customTargetScrollTop.current;
      },
      set targetScrollTop(targetScrollTop2) {
        customTargetScrollTop.current = targetScrollTop2;
      }
    }), [
      scrollToBottom,
      isAtBottom,
      contentRef,
      scrollRef,
      stopScroll,
      escapedFromLock,
      state
    ]);
    reactExports.useImperativeHandle(contextRef, () => context, [context]);
    useIsomorphicLayoutEffect(() => {
      if (!scrollRef.current) {
        return;
      }
      if (getComputedStyle(scrollRef.current).overflow === "visible") {
        scrollRef.current.style.overflow = "auto";
      }
    }, []);
    return jsxRuntimeExports.jsx(StickToBottomContext.Provider, { value: context, children: jsxRuntimeExports.jsx("div", { ...props, children: typeof children === "function" ? children(context) : children }) });
  }
  (function(StickToBottom2) {
    function Content3({ children, ...props }) {
      const context = useStickToBottomContext();
      return jsxRuntimeExports.jsx("div", { ref: context.scrollRef, style: {
        height: "100%",
        width: "100%"
      }, children: jsxRuntimeExports.jsx("div", { ...props, ref: context.contentRef, children: typeof children === "function" ? children(context) : children }) });
    }
    StickToBottom2.Content = Content3;
  })(StickToBottom || (StickToBottom = {}));
  function useStickToBottomContext() {
    const context = reactExports.useContext(StickToBottomContext);
    if (!context) {
      throw new Error("use-stick-to-bottom component context must be used within a StickToBottom component");
    }
    return context;
  }
  function isMobileViewport() {
    if (typeof window === "undefined") return false;
    return window.innerWidth < 640;
  }
  function isMobileDevice() {
    if (typeof navigator === "undefined") return false;
    const userAgent = navigator.userAgent.toLowerCase();
    const mobileKeywords = [
      "mobile",
      "android",
      "iphone",
      "ipad",
      "ipod",
      "blackberry",
      "windows phone",
      "opera mini"
    ];
    return mobileKeywords.some((keyword) => userAgent.includes(keyword));
  }
  function isMobile() {
    return isMobileViewport() || isMobileDevice();
  }
  function useMobileDetection() {
    const [mobile, setMobile] = reactExports.useState(isMobile);
    reactExports.useEffect(() => {
      const handleResize = () => {
        setMobile(isMobile());
      };
      window.addEventListener("resize", handleResize);
      return () => window.removeEventListener("resize", handleResize);
    }, []);
    return mobile;
  }
  function ChatInput({
    onSendMessage,
    isLoading,
    onAudioRecorded,
    onVoiceChatToggle,
    isVoiceChatActive = false,
    voiceAudioData = [],
    luaPopConfig,
    cdnUrl,
    authToken: authToken2
  }) {
    const [message, setMessage] = reactExports.useState("");
    const [isAudioRecording, setIsAudioRecording] = reactExports.useState(false);
    const [selectedFiles, setSelectedFiles] = reactExports.useState([]);
    const [fileMetadata, setFileMetadata] = reactExports.useState(/* @__PURE__ */ new Map());
    const textareaRef = reactExports.useRef(null);
    const fileInputRef = reactExports.useRef(null);
    const isMobile2 = useMobileDetection();
    reactExports.useEffect(() => {
      if (authToken2) {
        try {
          setAuthToken(authToken2);
        } catch (_) {
        }
      }
    }, [authToken2]);
    reactExports.useEffect(() => {
      if (textareaRef.current) {
        textareaRef.current.style.height = "initial";
        const scrollHeight = textareaRef.current.scrollHeight;
        textareaRef.current.style.height = `${Math.min(scrollHeight, 120)}px`;
      }
    }, [message]);
    reactExports.useEffect(() => {
      if (!isLoading && textareaRef.current) {
        const timeoutId = setTimeout(() => {
          var _a2;
          (_a2 = textareaRef.current) == null ? void 0 : _a2.focus();
        }, 100);
        return () => clearTimeout(timeoutId);
      }
    }, [isLoading]);
    const handleKeyDown = (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        handleSendMessage();
      }
    };
    const areFilesReady = () => {
      if (selectedFiles.length === 0) return false;
      return selectedFiles.every((file) => {
        var _a2;
        return Boolean((_a2 = fileMetadata.get(file)) == null ? void 0 : _a2.url);
      });
    };
    const collectUploadedFiles = () => {
      return selectedFiles.map((file) => fileMetadata.get(file)).filter(
        (m2) => Boolean(m2 && m2.url)
      ).map((m2) => ({ url: m2.url, mediaType: m2.mediaType }));
    };
    const handleSendMessage = () => {
      if (isLoading) return;
      const text2 = message.trim();
      const files = collectUploadedFiles();
      if (!text2 && files.length === 0) {
        return;
      }
      onSendMessage(text2, files.length > 0 ? files : void 0);
      setMessage("");
      setSelectedFiles([]);
      setFileMetadata(/* @__PURE__ */ new Map());
      if (textareaRef.current) {
        textareaRef.current.style.height = "40px";
      }
    };
    const handleMicrophoneClick = () => {
      if (!isLoading && !isAudioRecording) {
        setIsAudioRecording(true);
      }
    };
    const handleAudioRecordingComplete = (audioBlob, messageText) => {
      setIsAudioRecording(false);
      if (onAudioRecorded) {
        onAudioRecorded(audioBlob, messageText);
      }
    };
    const handleAudioRecordingClose = () => {
      setIsAudioRecording(false);
    };
    const handleVoiceChatToggle = () => {
      if (onVoiceChatToggle) {
        onVoiceChatToggle(!isVoiceChatActive);
      }
    };
    const handleFileSelect = () => {
      var _a2;
      (_a2 = fileInputRef.current) == null ? void 0 : _a2.click();
    };
    const handleFileChange = (event) => {
      const files = event.target.files;
      if (files && files.length > 0) {
        const fileArray = Array.from(files);
        setSelectedFiles((prev) => [...prev, ...fileArray]);
      }
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    };
    const handleRemoveFile = (index2) => {
      const fileToRemove = selectedFiles[index2];
      if (fileMetadata.has(fileToRemove)) {
        const metadata = fileMetadata.get(fileToRemove);
        if (metadata == null ? void 0 : metadata.url) {
          URL.revokeObjectURL(metadata.url);
        }
        const newMetadata = new Map(fileMetadata);
        newMetadata.delete(fileToRemove);
        setFileMetadata(newMetadata);
      }
      setSelectedFiles((prev) => prev.filter((_, i) => i !== index2));
    };
    const handleFileUploadComplete = (file, url) => {
      setFileMetadata(
        (prev) => new Map(prev).set(file, {
          url,
          type: file.type,
          mediaType: file.type,
          propertyName: file.type.startsWith("image/") ? "image" : "data"
        })
      );
    };
    const handlePaste = (event) => {
      const { items } = event.clipboardData;
      if (!items) {
        return;
      }
      const files = [];
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (item.kind === "file") {
          const file = item.getAsFile();
          if (file) {
            files.push(file);
          }
        }
      }
      if (files.length > 0) {
        event.preventDefault();
        setSelectedFiles((prev) => [...prev, ...files]);
      }
    };
    const handleFocus = () => {
      if (isMobile2 && textareaRef.current) {
        setTimeout(() => {
          var _a2;
          (_a2 = textareaRef.current) == null ? void 0 : _a2.scrollIntoView({
            behavior: "smooth",
            block: "center"
          });
        }, 300);
      }
    };
    if (isAudioRecording) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        $l,
        {
          onAudioRecorded: handleAudioRecordingComplete,
          onClose: handleAudioRecordingClose,
          inputMessage: message
        }
      );
    }
    if (isVoiceChatActive) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:items-center lua:gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex-1 lua:flex lua:items-center lua:justify-start lua:gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:items-center lua:h-6 lua:gap-0.5 lua:justify-start lua:pl-1", children: voiceAudioData.length > 0 ? voiceAudioData.slice(0, 15).map((value, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "lua:bg-black lua:w-0.5 lua:min-h-1 lua:rounded-full lua:transition-all lua:duration-75",
            style: {
              height: `${Math.max(4, value * 20)}px`,
              opacity: Math.max(0.3, value)
            }
          },
          index2
        )) : (
          // Static dots when no audio data
          Array.from({ length: 8 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "lua:bg-gray-400 lua:w-0.5 lua:h-1 lua:rounded-full lua:animate-pulse",
              style: {
                animationDelay: `${index2 * 100}ms`
              }
            },
            index2
          ))
        ) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            variant: "muted",
            onClick: handleVoiceChatToggle,
            disabled: isLoading,
            "aria-label": "Cancel voice chat",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(XIcon$1, {})
          }
        )
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-0", children: [
      selectedFiles.length > 0 && cdnUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Ni,
        {
          files: selectedFiles,
          onRemove: handleRemoveFile,
          cdnUrl,
          fileMetadata: Array.from(fileMetadata.entries()).map(
            ([file, metadata]) => ({
              file,
              url: metadata.url,
              type: metadata.type,
              mediaType: metadata.mediaType,
              propertyName: metadata.propertyName
            })
          ),
          onFileUploadComplete: handleFileUploadComplete
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:bg-white lua:px-3 lua:py-4 lua:flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          id: "lua-pop-chat-input",
          ref: textareaRef,
          placeholder: luaPopConfig.chatInputPlaceholder || "Ask anything, about anything",
          value: message,
          onChange: (event) => setMessage(event.target.value),
          onKeyDown: handleKeyDown,
          onPaste: handlePaste,
          onFocus: handleFocus,
          rows: 1,
          disabled: isLoading,
          className: "lua:w-full lua:overflow-hidden lua:border-0 lua:focus:outline-none lua:focus:ring-0"
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua-pop-toolbar lua:flex lua:items-center lua:justify-between lua:bg-gray-50 lua:px-3 lua:py-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:items-center lua:gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              className: "lua:rounded-lg",
              variant: "muted",
              onClick: handleFileSelect,
              disabled: isLoading,
              "aria-label": "Attach files",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Paperclip$1, { color: "#00000099" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              className: "lua:rounded-lg",
              variant: "muted",
              onClick: handleMicrophoneClick,
              disabled: isLoading,
              "aria-label": "Record voice message",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Microphone$1, { color: "#00000099" })
            }
          ),
          luaPopConfig.voiceModeEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              className: "lua:rounded-lg",
              variant: "muted",
              onClick: handleVoiceChatToggle,
              disabled: isLoading,
              "aria-label": "Start voice chat",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Waveform, { color: "#00000099" })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            className: "lua:rounded-full",
            onClick: handleSendMessage,
            disabled: isLoading || !message.trim() && !areFilesReady(),
            "aria-label": "Send message",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ArrowUp$1,
              {
                color: message.trim() || areFilesReady() ? "#FFFFFF" : "#00000099"
              }
            )
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          ref: fileInputRef,
          type: "file",
          multiple: true,
          onChange: handleFileChange,
          className: "lua:hidden",
          accept: "image/*,video/*,audio/*,.pdf,.doc,.docx,.txt"
        }
      )
    ] });
  }
  const stripNavigateBlocks = (content2) => {
    return content2.replace(/::: navigate[\s\S]*?:::/g, "").trim();
  };
  const ChatMessages = reactExports.memo(function ChatMessages2({
    onMessageSend,
    luaApiUrl,
    authToken: authToken2,
    luaPopConfig
  }) {
    const { messages, setMessages } = pn();
    const handleSendMessage = (message) => {
      onMessageSend(message);
    };
    const handleCardSelect = reactExports.useCallback(
      (title) => {
        handleSendMessage(title);
      },
      [handleSendMessage]
    );
    const messageList = reactExports.useMemo(() => {
      return messages.map((message) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        nn,
        {
          message,
          onSelect: handleCardSelect,
          luaApiUrl,
          authToken: authToken2,
          disablePreviewOnLinks: luaPopConfig.disablePreviewOnLinks,
          onNavigate: (pathname, options2) => {
            if (luaPopConfig.onNavigate) {
              const updatedMessages = [...messages];
              const lastMessageIndex = updatedMessages.length - 1;
              if (lastMessageIndex >= 0) {
                const lastMessage = updatedMessages[lastMessageIndex];
                updatedMessages[lastMessageIndex] = {
                  ...lastMessage,
                  content: stripNavigateBlocks(lastMessage.content)
                };
                setMessages(updatedMessages);
              }
              luaPopConfig.onNavigate(pathname, options2);
            }
          }
        },
        message.id
      ));
    }, [messages, handleCardSelect, setMessages, luaPopConfig.onNavigate]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "lua:flex-1 lua:py-4 lua:sm:py-6 lua:flex lua:flex-col lua:space-y-4 lua:px-4",
        "data-testid": "chat-messages",
        children: messages.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:justify-center lua:items-center lua:h-full lua:text-gray-500" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          messageList,
          /* @__PURE__ */ jsxRuntimeExports.jsx(In, { onSelect: handleCardSelect }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(wn, {})
        ] })
      }
    );
  });
  function Chat({
    onMessageSend,
    luaApiUrl,
    authToken: authToken2,
    luaPopConfig
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:items-center lua:justify-center lua:bg-gray-100 lua:p-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        id: "chat-feed",
        className: "lua:w-full lua:bg-white lua:rounded-none lua:flex lua:flex-col lua:relative lua:h-full",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ChatMessages,
          {
            onMessageSend,
            luaApiUrl,
            authToken: authToken2,
            luaPopConfig
          }
        )
      }
    ) });
  }
  function ChatWithScrollControl({
    handleSendMessage,
    apiUrl,
    authToken: authToken2,
    luaPopConfig
  }) {
    const handleMessageSend = async (message) => {
      await handleSendMessage(message);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Chat,
      {
        onMessageSend: handleMessageSend,
        luaApiUrl: apiUrl,
        authToken: authToken2,
        luaPopConfig
      }
    );
  }
  function FormSuccess({ onBack, onClose }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:bg-white lua:flex lua:flex-col lua:items-center lua:justify-between lua:overflow-clip lua:relative lua:rounded-2xl lua:shadow-[0px_2px_10px_0px_rgba(0,0,0,0.2)] lua:size-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:border-[#ededed] lua:border-b lua:border-solid lua:relative lua:shrink-0 lua:w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:items-start lua:justify-between lua:overflow-clip lua:p-2.5 lua:relative lua:rounded-[inherit] lua:w-full", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:gap-2 lua:items-center lua:min-h-px lua:min-w-px lua:relative lua:shrink-0 lua:flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:overflow-clip lua:relative lua:shrink-0 lua:size-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              width: "16",
              height: "16",
              viewBox: "0 0 16 16",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
              className: "lua:shrink-0",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M10 12L6 8L10 4",
                  stroke: "currentColor",
                  strokeWidth: "1.5",
                  strokeLinecap: "round",
                  strokeLinejoin: "round"
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:flex-col lua:gap-1 lua:items-start lua:min-h-px lua:min-w-px lua:relative lua:shrink-0 lua:flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: onBack,
              className: "lua:font-['Onest',_sans-serif] lua:font-medium lua:leading-6 lua:relative lua:shrink-0 lua:text-[#040404] lua:text-base lua:text-nowrap lua:whitespace-pre lua:cursor-pointer",
              children: "Back to chat"
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:gap-2.5 lua:items-center lua:px-0 lua:py-0.5 lua:relative lua:shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: onClose,
            className: "lua:overflow-clip lua:relative lua:shrink-0 lua:size-[18px] lua:cursor-pointer",
            "aria-label": "Close chat",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                width: "18",
                height: "18",
                viewBox: "0 0 18 18",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M13.5 4.5L4.5 13.5M4.5 4.5L13.5 13.5",
                    stroke: "currentColor",
                    strokeWidth: "1.5",
                    strokeLinecap: "round",
                    strokeLinejoin: "round"
                  }
                )
              }
            )
          }
        ) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:items-center lua:justify-center lua:min-h-px lua:min-w-px lua:overflow-clip lua:relative lua:shrink-0 lua:w-full lua:flex-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-8 lua:items-center lua:justify-center lua:p-4 lua:relative lua:shrink-0 lua:w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:flex-col lua:gap-2 lua:items-center lua:justify-center lua:relative lua:shrink-0 lua:size-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:gap-2.5 lua:items-center lua:justify-center lua:min-h-px lua:min-w-px lua:relative lua:shrink-0 lua:w-full lua:flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:min-h-px lua:min-w-px lua:relative lua:shrink-0 lua:flex-1 lua:h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Logo$1, { className: "lua:block lua:max-w-none lua:size-full" }) }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:flex-col lua:font-['Onest',_sans-serif] lua:font-normal lua:justify-center lua:leading-[0] lua:relative lua:shrink-0 lua:text-[#3f3f3f] lua:text-sm lua:text-center lua:w-[316px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lua:leading-5", children: "Your information was successfully submitted, and a confirmation email should arrive shortly." }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:flex-col lua:font-['Onest',_sans-serif] lua:font-medium lua:justify-center lua:leading-[0] lua:relative lua:shrink-0 lua:text-[#040404] lua:text-[0px] lua:text-center lua:w-[248px]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "lua:leading-5 lua:text-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:text-[#3f3f3f]", children: "While you wait, feel free to" }),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:font-['Onest',_sans-serif] lua:font-semibold", children: "try out Lua" }),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:text-[#3f3f3f]", children: "or " }),
            "book a demo",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:text-[#3f3f3f]", children: " with the team." })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:flex-col lua:gap-2.5 lua:items-start lua:px-3 lua:py-0 lua:relative lua:shrink-0 lua:w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:backdrop-blur-[2px] lua:backdrop-filter lua:bg-[rgba(255,255,255,0.4)] lua:flex lua:flex-col lua:gap-4 lua:items-center lua:justify-center lua:pb-4 lua:pt-3 lua:px-2 lua:relative lua:rounded-xl lua:shrink-0 lua:w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => window.open("https://heylua.ai/", "_blank"),
              className: "lua:bg-black lua:flex lua:gap-1.5 lua:items-center lua:justify-center lua:overflow-clip lua:px-3 lua:py-2 lua:relative lua:rounded-xl lua:shrink-0",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:gap-2.5 lua:items-center lua:justify-center lua:px-0.5 lua:py-0 lua:relative lua:shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lua:font-['Onest',_sans-serif] lua:font-semibold lua:leading-5 lua:relative lua:shrink-0 lua:text-sm lua:text-nowrap lua:text-white lua:whitespace-pre", children: "Launch my Agent" }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => window.open(
                "https://meetings-eu1.hubspot.com/lorcan-o-cathain/demo-booking",
                "_blank"
              ),
              className: "lua:bg-white lua:border lua:border-[#e0e0e0] lua:border-solid lua:relative lua:rounded-xl lua:shrink-0 lua:shadow-[0px_-0.5px_0px_0px_inset_rgba(22,25,29,0.12)]",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:gap-1.5 lua:items-center lua:justify-center lua:overflow-clip lua:px-3 lua:py-2 lua:relative lua:rounded-[inherit]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:overflow-clip lua:relative lua:shrink-0 lua:size-[10.667px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    width: "11",
                    height: "11",
                    viewBox: "0 0 11 11",
                    fill: "none",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "path",
                      {
                        d: "M9.5 1.5L1.5 5.5L4.5 7L6 10L9.5 1.5Z",
                        stroke: "currentColor",
                        strokeWidth: "1.5",
                        strokeLinecap: "round",
                        strokeLinejoin: "round"
                      }
                    )
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:gap-2.5 lua:items-center lua:justify-center lua:px-0.5 lua:py-0 lua:relative lua:shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lua:font-['Onest',_sans-serif] lua:font-semibold lua:leading-5 lua:relative lua:shrink-0 lua:text-sm lua:text-black lua:text-nowrap lua:whitespace-pre", children: "Book demo" }) })
              ] })
            }
          )
        ] }) })
      ] })
    ] });
  }
  function GetInTouchForm({
    onBack,
    onClose,
    onSuccess
  }) {
    const [formData, setFormData] = reactExports.useState({
      fullName: "",
      email: "",
      companyName: "",
      role: "",
      message: ""
    });
    const [isSubmitting, setIsSubmitting] = reactExports.useState(false);
    const handleSubmit = async (e) => {
      e.preventDefault();
      setIsSubmitting(true);
      try {
        const formPayload = new FormData();
        formPayload.append("name", formData.fullName);
        formPayload.append("email", formData.email);
        formPayload.append("company", formData.companyName);
        formPayload.append("role", formData.role);
        formPayload.append("message", formData.message);
        await fetch(
          "https://script.google.com/macros/s/AKfycbxdIMQ0oEN0jRGCAX0HMJiebOMHiNF6Tk6nIEdyEkf65y4MiudFV7M10aaJxNm2PPdgIQ/exec",
          {
            method: "POST",
            body: formPayload
          }
        );
        onSuccess();
      } catch (error) {
        console.error("Error submitting form:", error);
      } finally {
        setIsSubmitting(false);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:h-full lua:overflow-hidden lua:max-h-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:border-b lua:border-[#ededed] lua:flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:items-center lua:justify-between lua:p-2.5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            type: "button",
            onClick: onBack,
            className: "lua:flex lua:items-center lua:gap-2 lua:flex-1 lua:cursor-pointer",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  width: "16",
                  height: "16",
                  viewBox: "0 0 16 16",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  className: "lua:shrink-0",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "M10 12L6 8L10 4",
                      stroke: "currentColor",
                      strokeWidth: "1.5",
                      strokeLinecap: "round",
                      strokeLinejoin: "round"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lua:text-base lua:font-medium lua:text-[#040404]", children: "Back to chat" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: onClose,
            className: "lua:p-1 lua:rounded-full lua:hover:bg-gray-100 lua:cursor-pointer",
            "aria-label": "Close chat",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                width: "18",
                height: "18",
                viewBox: "0 0 18 18",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M13.5 4.5L4.5 13.5M4.5 4.5L13.5 13.5",
                    stroke: "currentColor",
                    strokeWidth: "1.5",
                    strokeLinecap: "round",
                    strokeLinejoin: "round"
                  }
                )
              }
            )
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex-1 lua:overflow-y-auto lua:min-h-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:px-4 lua:pt-4 lua:pb-3 lua:flex lua:flex-col lua:gap-1.5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "lua:text-lg lua:font-semibold lua:text-[#040404] lua:tracking-[-0.72px] lua:text-left lua:leading-tight", children: "Share our journey" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:text-sm lua:text-[#3f3f3f] lua:leading-[1.4]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Launching AI agents for sales, support, and bookings should be easy  that's our mission.",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:font-semibold", children: "Tell us how to reach you and we'll get back within 12 days." })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:px-3 lua:pb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "form",
          {
            onSubmit: handleSubmit,
            className: "lua:bg-white/40 lua:backdrop-blur-[2px] lua:rounded-xl lua:p-2 lua:pt-2.5 lua:pb-3 lua:flex lua:flex-col lua:gap-4 lua:shadow-none",
            style: {
              backgroundColor: "rgba(255, 255, 255, 0.4)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-3.5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-1.5", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "lua:text-sm lua:text-[#11171f] lua:flex lua:items-center lua:gap-0.5 lua:leading-tight", children: [
                    "Full name",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:text-[#dd0030]", children: "*" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      value: formData.fullName,
                      onChange: (e) => setFormData({ ...formData, fullName: e.target.value }),
                      placeholder: "Mick Jonas",
                      className: "lua:w-full lua:text-sm lua:py-2",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-1.5", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "lua:text-sm lua:text-[#11171f] lua:flex lua:items-center lua:gap-0.5 lua:leading-tight", children: [
                    "Email",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:text-[#dd0030]", children: "*" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      type: "email",
                      value: formData.email,
                      onChange: (e) => setFormData({ ...formData, email: e.target.value }),
                      placeholder: "mick.jonas@email.com",
                      className: "lua:w-full lua:text-sm lua:py-2",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-1.5", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "lua:text-sm lua:text-[#11171f] lua:flex lua:items-center lua:gap-0.5 lua:leading-tight", children: [
                    "Company name",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:text-[#dd0030]", children: "*" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      value: formData.companyName,
                      onChange: (e) => setFormData({ ...formData, companyName: e.target.value }),
                      placeholder: "Acme Inc.",
                      className: "lua:w-full lua:text-sm lua:py-2",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-1.5", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "lua:text-sm lua:text-[#11171f] lua:flex lua:items-center lua:gap-0.5 lua:leading-tight", children: [
                    "Role",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:text-[#dd0030]", children: "*" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      value: formData.role,
                      onChange: (e) => setFormData({ ...formData, role: e.target.value }),
                      placeholder: "e.g., Founder, CEO, Developer",
                      className: "lua:w-full lua:text-sm lua:py-2",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:flex-col lua:gap-1.5", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "lua:text-sm lua:text-[#11171f] lua:flex lua:items-center lua:gap-0.5 lua:leading-tight", children: [
                    "Message",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lua:text-[#dd0030]", children: "*" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Textarea,
                    {
                      value: formData.message,
                      onChange: (e) => setFormData({ ...formData, message: e.target.value }),
                      placeholder: "Your message",
                      className: "lua:w-full lua:text-sm lua:py-2",
                      required: true
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button,
                {
                  type: "submit",
                  disabled: isSubmitting,
                  className: "lua:bg-black lua:text-white lua:rounded-xl lua:px-3 lua:py-2 lua:flex lua:items-center lua:gap-1.5 lua:text-sm lua:font-semibold",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "svg",
                      {
                        width: "11",
                        height: "11",
                        viewBox: "0 0 11 11",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg",
                        className: "lua:shrink-0",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "path",
                          {
                            d: "M9.5 1.5L1.5 5.5L4.5 7L6 10L9.5 1.5Z",
                            stroke: "white",
                            strokeWidth: "1.5",
                            strokeLinecap: "round",
                            strokeLinejoin: "round"
                          }
                        )
                      }
                    ),
                    isSubmitting ? "Sending..." : "Send information"
                  ]
                }
              ) })
            ]
          }
        ) })
      ] })
    ] });
  }
  function VoiceChat({
    authToken: authToken2,
    agentId,
    channel,
    apiUrl,
    luaPopConfig,
    onAudioData
  }) {
    const [voiceChatStartTime, setVoiceChatStartTime] = reactExports.useState(
      null
    );
    const { messages } = pn();
    const wsRef = reactExports.useRef(null);
    const streamRef = reactExports.useRef(null);
    const audioContextRef = reactExports.useRef(null);
    const workletNodeRef = reactExports.useRef(null);
    const analyserRef = reactExports.useRef(null);
    const scheduledTimeRef = reactExports.useRef(0);
    const heartbeatRef = reactExports.useRef(null);
    const processorUrlRef = reactExports.useRef(null);
    const reconnectTimeoutRef = reactExports.useRef(null);
    const isReconnectingRef = reactExports.useRef(false);
    const lastAudioTimeRef = reactExports.useRef(0);
    const audioChunkCountRef = reactExports.useRef(0);
    const totalAudioDurationRef = reactExports.useRef(0);
    const debugModeRef = reactExports.useRef(true);
    const debugStartTimeRef = reactExports.useRef(0);
    const hiccupCountRef = reactExports.useRef(0);
    const getWebSocketUrl = () => {
      const baseUrl = apiUrl.includes("lua.dev") ? "wss://api.lua.dev/chat/voice" : "wss://api.heylua.ai/chat/voice";
      const params = new URLSearchParams();
      params.append("token", authToken2);
      if (agentId) params.append("agentId", agentId);
      if (channel) params.append("channel", channel);
      return `${baseUrl}?${params.toString()}`;
    };
    const resampleToSR = (float32, inRate) => {
      const SR = 24e3;
      if (inRate === SR) return float32;
      const ratio = inRate / SR;
      const outLen = Math.floor(float32.length / ratio);
      const out = new Float32Array(outLen);
      for (let i = 0; i < outLen; i++) {
        const idx = i * ratio;
        const i0 = Math.floor(idx);
        const i1 = Math.min(i0 + 1, float32.length - 1);
        const frac = idx - i0;
        out[i] = float32[i0] * (1 - frac) + float32[i1] * frac;
      }
      return out;
    };
    const floatToInt16PCM = (f32) => {
      const out = new Int16Array(f32.length);
      for (let i = 0; i < f32.length; i++) {
        let s = f32[i];
        if (s > 1) s = 1;
        else if (s < -1) s = -1;
        out[i] = s < 0 ? s * 32768 : s * 32767;
      }
      return out;
    };
    const ensureAudioContext = () => {
      if (!audioContextRef.current) {
        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24e3 });
        scheduledTimeRef.current = audioContextRef.current.currentTime;
      }
      return audioContextRef.current;
    };
    const playPCMInt16 = (i16) => {
      const now2 = Date.now();
      if (!i16 || i16.length === 0) {
        if (debugModeRef.current) {
          console.log("[AUDIO DEBUG] Empty chunk received");
        }
        return;
      }
      try {
        const ctx = ensureAudioContext();
        const f32 = new Float32Array(i16.length);
        for (let i = 0; i < i16.length; i++) {
          f32[i] = i16[i] / 32768;
        }
        const SAMPLE_RATE = 24e3;
        const buf = ctx.createBuffer(1, f32.length, SAMPLE_RATE);
        buf.copyToChannel(f32, 0);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        src.connect(ctx.destination);
        const audioContextNow = ctx.currentTime;
        const bufferDuration = buf.length / SAMPLE_RATE;
        const startAt = Math.max(
          scheduledTimeRef.current,
          audioContextNow + 1e-3
        );
        if (debugModeRef.current) {
          const timeSinceLastChunk = lastAudioTimeRef.current > 0 ? now2 - lastAudioTimeRef.current : 0;
          const schedulingGap = (startAt - audioContextNow) * 1e3;
          audioChunkCountRef.current++;
          totalAudioDurationRef.current += bufferDuration * 1e3;
          const chunkType = i16.length === 480 ? "normal" : i16.length > 6e3 ? "very-large" : "large";
          console.log(
            `[AUDIO DEBUG] Chunk #${audioChunkCountRef.current}: ${i16.length} samples (${(bufferDuration * 1e3).toFixed(1)}ms) ${chunkType}, gap: ${timeSinceLastChunk}ms, schedule: ${schedulingGap.toFixed(1)}ms`
          );
          if (schedulingGap > 100) {
            hiccupCountRef.current++;
            console.warn(
              `[HICCUP #${hiccupCountRef.current}] Large scheduling gap: ${schedulingGap.toFixed(1)}ms`
            );
          }
        }
        src.start(startAt);
        scheduledTimeRef.current = startAt + bufferDuration;
        lastAudioTimeRef.current = now2;
      } catch (error) {
        console.error("[AUDIO ERROR] Playback failed:", error);
      }
    };
    const startVoiceChat = async () => {
      try {
        if (wsRef.current && wsRef.current.readyState === WebSocket.CONNECTING) {
          console.log("WebSocket already connecting, skipping...");
          return;
        }
        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
          wsRef.current.close();
        }
        const wsUrl = getWebSocketUrl();
        const ws = new WebSocket(wsUrl);
        wsRef.current = ws;
        ws.binaryType = "arraybuffer";
        ws.onopen = async () => {
          if (debugModeRef.current) {
            debugStartTimeRef.current = Date.now();
            audioChunkCountRef.current = 0;
            totalAudioDurationRef.current = 0;
            hiccupCountRef.current = 0;
            lastAudioTimeRef.current = 0;
            console.log("[AUDIO DEBUG] Voice chat started - debugging enabled");
            console.log(
              "[AUDIO DEBUG] Expected: 480 samples per chunk, 20ms intervals, 24kHz sample rate"
            );
          }
          heartbeatRef.current = setInterval(() => {
            if (ws.readyState === WebSocket.OPEN) {
              try {
                ws.send(new ArrayBuffer(0));
              } catch (error) {
                console.warn("Failed to send heartbeat:", error);
              }
            }
          }, 25e3);
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                channelCount: 1,
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
              }
            });
            streamRef.current = stream;
            const ac = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24e3 });
            audioContextRef.current = ac;
            const source = ac.createMediaStreamSource(stream);
            const analyser = ac.createAnalyser();
            analyser.fftSize = 256;
            analyserRef.current = analyser;
            source.connect(analyser);
            const processorCode = `
            class VoiceProcessor extends AudioWorkletProcessor {
              constructor() {
                super();
              }

              process(inputs, outputs, parameters) {
                const input = inputs[0];
                
                if (input && input.length > 0) {
                  const inputChannel = input[0];
                  
                  if (inputChannel && inputChannel.length > 0) {
                    // Send audio data to main thread
                    this.port.postMessage({
                      type: 'audioData',
                      data: inputChannel
                    });
                  }
                }
                
                // Return true to keep the processor alive
                return true;
              }
            }

            registerProcessor('voice-processor', VoiceProcessor);
          `;
            const blob = new Blob([processorCode], {
              type: "application/javascript"
            });
            const processorUrl = URL.createObjectURL(blob);
            processorUrlRef.current = processorUrl;
            await ac.audioWorklet.addModule(processorUrl);
            const workletNode = new AudioWorkletNode(ac, "voice-processor");
            workletNodeRef.current = workletNode;
            workletNode.port.onmessage = (event) => {
              if (event.data.type === "audioData" && ws.readyState === WebSocket.OPEN) {
                const input = event.data.data;
                const res = resampleToSR(input, ac.sampleRate);
                const i16 = floatToInt16PCM(res);
                ws.send(i16.buffer);
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(dataArray);
                const normalizedData = Array.from(dataArray).map((v) => v / 255);
                const slicedData = normalizedData.slice(0, 50);
                if (onAudioData) {
                  onAudioData(slicedData);
                }
              }
            };
            source.connect(workletNode);
            const silent = ac.createGain();
            silent.gain.value = 0;
            workletNode.connect(silent);
            silent.connect(ac.destination);
          } catch (error) {
            console.error("Microphone access error:", error);
          }
        };
        ws.onmessage = (ev) => {
          try {
            if (!ev.data || ev.data instanceof ArrayBuffer && ev.data.byteLength === 0) {
              if (debugModeRef.current) {
                console.log("[WEBSOCKET DEBUG] Heartbeat response received");
              }
              return;
            }
            if (typeof ev.data === "string") {
              try {
                const notification = JSON.parse(ev.data);
                if (notification.type === "stop-playback") {
                  console.log(
                    `[PLAYBACK] Stop requested: ${notification.reason}`
                  );
                  if (audioContextRef.current) {
                    audioContextRef.current.close();
                    audioContextRef.current = null;
                  }
                  scheduledTimeRef.current = 0;
                  console.log(
                    `[PLAYBACK] Audio playback stopped due to ${notification.reason}`
                  );
                }
                return;
              } catch (parseError) {
                console.warn(
                  "[WEBSOCKET] Received non-JSON string message:",
                  ev.data
                );
              }
            }
            if (ev.data instanceof ArrayBuffer) {
              const i16 = new Int16Array(ev.data);
              if (i16.length > 0) {
                const maxVal = Math.max(...Array.from(i16));
                const minVal = Math.min(...Array.from(i16));
                if (Math.abs(maxVal) > 32767 || Math.abs(minVal) > 32767) {
                  console.warn(
                    "[AUDIO FORMAT] Audio values exceed Int16 range - possible format mismatch"
                  );
                }
              }
              playPCMInt16(i16);
            }
          } catch (error) {
            console.error("Error processing WebSocket message:", error);
          }
        };
        ws.onclose = (ev) => {
          if (ev.code !== 1e3) {
            console.warn(
              `WebSocket closed abnormally: code=${ev.code} reason="${ev.reason}"`
            );
            if (!isReconnectingRef.current && ev.code === 1005) {
              console.log("Attempting to reconnect in 2 seconds...");
              isReconnectingRef.current = true;
              reconnectTimeoutRef.current = setTimeout(() => {
                var _a2;
                if (((_a2 = wsRef.current) == null ? void 0 : _a2.readyState) !== WebSocket.OPEN) {
                  console.log("Reconnecting WebSocket...");
                  startVoiceChat();
                }
                isReconnectingRef.current = false;
              }, 2e3);
            }
          } else {
            cleanup();
          }
        };
        ws.onerror = (e) => {
          console.error("WebSocket error:", e);
          cleanup();
        };
      } catch (error) {
        console.error("Voice chat start error:", error);
      }
    };
    const stopVoiceChat = () => {
      isReconnectingRef.current = false;
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
        reconnectTimeoutRef.current = null;
      }
      if (wsRef.current) {
        wsRef.current.close(1e3, "User disconnected");
      }
      cleanup();
    };
    const cleanup = () => {
      if (debugModeRef.current && debugStartTimeRef.current > 0) {
        const sessionDuration = Date.now() - debugStartTimeRef.current;
        const avgChunkInterval = sessionDuration / Math.max(audioChunkCountRef.current, 1);
        const hiccupRate = hiccupCountRef.current / Math.max(audioChunkCountRef.current, 1) * 100;
        console.log("[AUDIO DEBUG SUMMARY]", {
          sessionDuration: `${(sessionDuration / 1e3).toFixed(1)}s`,
          totalChunks: audioChunkCountRef.current,
          totalAudioDuration: `${(totalAudioDurationRef.current / 1e3).toFixed(1)}s`,
          avgChunkInterval: `${avgChunkInterval.toFixed(1)}ms`,
          expectedInterval: "20ms",
          totalHiccups: hiccupCountRef.current,
          hiccupRate: `${hiccupRate.toFixed(1)}%`,
          verdict: hiccupRate < 5 ? "GOOD" : hiccupRate < 15 ? "FAIR" : "POOR"
        });
      }
      if (streamRef.current) {
        streamRef.current.getTracks().forEach((track) => track.stop());
        streamRef.current = null;
      }
      if (audioContextRef.current) {
        audioContextRef.current.close();
        audioContextRef.current = null;
      }
      if (workletNodeRef.current) {
        workletNodeRef.current.disconnect();
        workletNodeRef.current = null;
      }
      if (heartbeatRef.current) {
        clearInterval(heartbeatRef.current);
        heartbeatRef.current = null;
      }
      if (processorUrlRef.current) {
        URL.revokeObjectURL(processorUrlRef.current);
        processorUrlRef.current = null;
      }
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
        reconnectTimeoutRef.current = null;
      }
      isReconnectingRef.current = false;
      if (onAudioData) {
        onAudioData([]);
      }
    };
    reactExports.useEffect(() => {
      setVoiceChatStartTime(/* @__PURE__ */ new Date());
      startVoiceChat();
      if (typeof window !== "undefined") {
        window.voiceChatDebug = {
          toggle: () => {
            debugModeRef.current = !debugModeRef.current;
            console.log(
              `[AUDIO DEBUG] Debug mode ${debugModeRef.current ? "enabled" : "disabled"}`
            );
          },
          enable: () => {
            debugModeRef.current = true;
            console.log("[AUDIO DEBUG] Debug mode enabled");
          },
          disable: () => {
            debugModeRef.current = false;
            console.log("[AUDIO DEBUG] Debug mode disabled");
          },
          getStats: () => ({
            debugMode: debugModeRef.current,
            totalChunks: audioChunkCountRef.current,
            totalHiccups: hiccupCountRef.current,
            hiccupRate: `${(hiccupCountRef.current / Math.max(audioChunkCountRef.current, 1) * 100).toFixed(1)}%`
          })
        };
      }
      return () => {
        stopVoiceChat();
      };
    }, []);
    const voiceChatMessages = messages.filter((msg) => {
      if (!voiceChatStartTime) return false;
      return new Date(msg.createdAt) >= voiceChatStartTime;
    });
    const messageList = reactExports.useMemo(() => {
      return voiceChatMessages.slice(-3).map((message) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        nn,
        {
          message,
          onSelect: () => {
          },
          luaApiUrl: apiUrl,
          authToken: authToken2,
          disablePreviewOnLinks: luaPopConfig.disablePreviewOnLinks,
          onNavigate: luaPopConfig.onNavigate
        },
        message.id
      ));
    }, [voiceChatMessages, apiUrl, authToken2, luaPopConfig]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "voice-chat-container lua:p-4 lua:text-center", children: voiceChatMessages.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:space-y-4 lua:text-left", children: messageList }) });
  }
  function PopChat({
    authToken: authToken2,
    onClose,
    cdnUrl,
    luaPopConfig,
    apiUrl,
    isLoadingHistory
  }) {
    var _a2, _b2, _c2, _d2, _e3;
    const { setMessages, messages } = pn();
    const { setLoadingMessage } = gn();
    const [isLoading, setIsLoading] = reactExports.useState(false);
    const [isManualResponseActive, setIsManualResponseActive] = reactExports.useState(false);
    const [isVoiceChatActive, setIsVoiceChatActive] = reactExports.useState(false);
    const [voiceAudioData, setVoiceAudioData] = reactExports.useState([]);
    const [voiceChatStartTime, setVoiceChatStartTime] = reactExports.useState(
      null
    );
    const [showGetInTouchForm, setShowGetInTouchForm] = reactExports.useState(false);
    const [showFormSuccess, setShowFormSuccess] = reactExports.useState(false);
    const activeStreams = reactExports.useRef(/* @__PURE__ */ new Map());
    const isMobile2 = useMobileDetection();
    const updateLoadingState = () => {
      setIsLoading(activeStreams.current.size > 0);
    };
    const streamChatMutation = useMutation({
      mutationFn: (payload) => chatApi.streamChat(
        payload.chatMessages,
        luaPopConfig.runtimeContext,
        Boolean(luaPopConfig.onNavigate)
      ),
      onMutate: ({ streamId, messageId }) => {
        activeStreams.current.set(streamId, { content: "", messageId });
        updateLoadingState();
        setLoadingMessage("Assistant is typing...");
        setMessages((prev) => [
          ...prev,
          {
            id: messageId,
            role: "assistant",
            content: "...",
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        ]);
      },
      onSuccess: async (reader, variables) => {
        var _a3, _b3;
        if (!reader) {
          return;
        }
        const { streamId, messageId } = variables;
        const streamData = activeStreams.current.get(streamId);
        if (!streamData) {
          console.error("Stream data not found for streamId:", streamId);
          return;
        }
        let currentWaitingMessage;
        const decoder = new TextDecoder();
        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value);
            const lines = chunk.split("\n");
            for (const line of lines) {
              if (!line.trim()) continue;
              try {
                const parsed = JSON.parse(line);
                if (parsed.type === "text-delta") {
                  if (streamData.content.length > 20) {
                    setLoadingMessage(null);
                  }
                  const delta = parsed.textDelta || "";
                  streamData.content += delta;
                  setMessages((prev) => {
                    return prev.map(
                      (msg) => msg.id === messageId ? { ...msg, content: streamData.content } : msg
                    );
                  });
                } else if (parsed.type === "system") {
                  if (parsed.data && parsed.data.trim() !== "") {
                    try {
                      const systemData = JSON.parse(parsed.data);
                      if (systemData.status423) {
                        setIsManualResponseActive(true);
                        setMessages(
                          (prev) => prev.filter((msg) => msg.id !== messageId)
                        );
                        activeStreams.current.delete(streamId);
                        updateLoadingState();
                        if (activeStreams.current.size === 0) {
                          setLoadingMessage(null);
                        }
                        return;
                      }
                      if (systemData.finishReason) {
                        setLoadingMessage(null);
                      }
                    } catch {
                      console.log("Could not parse system data:", parsed.data);
                    }
                  }
                } else if (parsed.type === "tool" && ((_b3 = (_a3 = parsed.tool) == null ? void 0 : _a3.args) == null ? void 0 : _b3.waitingMessage)) {
                  currentWaitingMessage = parsed.tool.args.waitingMessage;
                  setLoadingMessage(
                    currentWaitingMessage || "Assistant is typing..."
                  );
                }
              } catch (e) {
                console.log("Error parsing streaming chunk:", line, e);
              }
            }
          }
          activeStreams.current.delete(streamId);
          updateLoadingState();
          if (activeStreams.current.size === 0) {
            setLoadingMessage(null);
          }
          setIsManualResponseActive(false);
        } catch (error) {
          console.error("Error processing stream:", error);
          if (streamData.content.trim()) {
            setMessages((prev) => {
              return prev.map(
                (msg) => msg.id === messageId ? { ...msg, content: streamData.content } : msg
              );
            });
          }
          activeStreams.current.delete(streamId);
          updateLoadingState();
          if (activeStreams.current.size === 0) {
            setLoadingMessage(null);
          }
        }
      },
      onError: (error, variables) => {
        console.error("Error sending message:", error);
        const { streamId, messageId } = variables;
        activeStreams.current.delete(streamId);
        updateLoadingState();
        if (activeStreams.current.size === 0) {
          setLoadingMessage(null);
        }
        setIsManualResponseActive(false);
        setMessages(
          (prev) => prev.map(
            (msg) => msg.id === messageId ? {
              ...msg,
              content: "Sorry, there was an error processing your request. Please try again."
            } : msg
          )
        );
      },
      retry: true,
      retryDelay: 200
    });
    const handleSendMessage = async (message, files) => {
      if (!message.trim()) {
        if (!files || files.length === 0) return;
      }
      const streamId = generateUuid();
      const assistantMessageId = generateUuid();
      const baseMessage = {
        id: generateUuid(),
        role: "user",
        content: message,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      setMessages((prev) => [
        ...prev,
        baseMessage,
        ...(files == null ? void 0 : files.map((f) => ({
          id: generateUuid(),
          role: "user",
          content: "",
          type: "file",
          url: f.url,
          mediaType: f.mediaType,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        }))) || []
      ]);
      const chatMessages = [];
      if (files && files.length > 0) {
        for (const f of files) {
          chatMessages.push({ type: "file", data: f.url, mediaType: f.mediaType });
        }
      }
      if (message.trim()) {
        chatMessages.push({ type: "text", text: message });
      }
      streamChatMutation.mutate({
        chatMessages,
        streamId,
        messageId: assistantMessageId
      });
    };
    const handleAudioRecorded = async (audioBlob, messageText) => {
      try {
        const audioUrl = URL.createObjectURL(audioBlob);
        const uploadingMessage = {
          id: generateUuid(),
          role: "user",
          content: messageText || "",
          type: "audio",
          mediaType: audioBlob.type,
          url: audioUrl,
          isUploading: true,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        setMessages((prev) => [...prev, uploadingMessage]);
        const formData = new FormData();
        formData.append("file", audioBlob);
        const uploadResponse = await fetch(`${cdnUrl}/upload`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${authToken2}`
          },
          body: formData
        });
        if (!uploadResponse.ok) {
          throw new Error("Failed to upload audio");
        }
        const { fileId } = await uploadResponse.json();
        const fileCdnUrl = `${cdnUrl}/${fileId}.webm`;
        const chatMessages = [
          {
            type: "file",
            data: fileCdnUrl,
            mediaType: "audio/webm"
          }
        ];
        if (messageText && messageText.trim()) {
          chatMessages.push({
            type: "text",
            text: messageText
          });
        }
        setMessages(
          (prev) => prev.map(
            (msg) => msg.id === uploadingMessage.id ? { ...msg, isUploading: false, url: fileCdnUrl } : msg
          )
        );
        URL.revokeObjectURL(audioUrl);
        const streamId = generateUuid();
        const assistantMessageId = generateUuid();
        streamChatMutation.mutate({
          chatMessages,
          streamId,
          messageId: assistantMessageId
        });
      } catch (error) {
        console.error("Error processing audio message:", error);
        const errorMessage = {
          id: generateUuid(),
          role: "assistant",
          content: "Sorry, there was an error processing your audio message.",
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        setMessages((prev) => [...prev, errorMessage]);
      } finally {
      }
    };
    const handleVoiceChatToggle = (isActive) => {
      setIsVoiceChatActive(isActive);
      if (isActive) {
        setVoiceChatStartTime(/* @__PURE__ */ new Date());
      } else {
        setVoiceAudioData([]);
        setVoiceChatStartTime(null);
      }
    };
    const handleVoiceChatMessage = (message) => {
      const newMessage = {
        id: generateUuid(),
        role: message.role,
        content: message.content,
        createdAt: message.timestamp
      };
      setMessages((prev) => [...prev, newMessage]);
    };
    const handleVoiceAudioData = (audioData) => {
      setVoiceAudioData(audioData);
    };
    const voiceChatMessages = messages.filter((msg) => {
      if (!voiceChatStartTime) return false;
      return new Date(msg.createdAt) >= voiceChatStartTime;
    });
    const getVoiceChatContainerHeight = () => {
      if (voiceChatMessages.length === 0) {
        return "0px";
      }
      return "auto";
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `lua-pop-chat lua:flex lua:flex-col lua:relative ${isMobile2 && luaPopConfig.displayMode === "floating" ? "lua-pop-chat-mobile-fullscreen" : ""}`,
        style: {
          // Desktop/tablet styles
          ...!isMobile2 && {
            ...luaPopConfig.chatWindowHeight && {
              height: luaPopConfig.chatWindowHeight || "500px"
            },
            ...luaPopConfig.chatWindowWidth && {
              width: luaPopConfig.chatWindowWidth || "350px"
            },
            ...isVoiceChatActive && {
              height: "auto",
              maxHeight: luaPopConfig.chatWindowHeight || "500px"
            }
          },
          // Mobile fullscreen styles
          ...isMobile2 && luaPopConfig.displayMode === "floating" && {
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            width: "100vw",
            height: "100vh",
            maxHeight: "100vh",
            zIndex: 2147483647,
            borderRadius: 0
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `lua-pop-chat-header lua:flex-shrink-0 lua:flex lua:items-start lua:justify-between lua:p-3 lua:border-b lua:border-gray-200`,
              style: {
                ...luaPopConfig.chatTitleHeaderStyles && luaPopConfig.chatTitleHeaderStyles
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "lua:font-semibold", children: luaPopConfig.chatTitle ? luaPopConfig.chatTitle : "Lua Assistant" }),
                  ((_a2 = luaPopConfig.chatHeaderSubtitle) == null ? void 0 : _a2.visible) !== false && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lua:flex lua:items-center lua:mt-1 lua:gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "a",
                      {
                        href: ((_b2 = luaPopConfig.chatHeaderSubtitle) == null ? void 0 : _b2.linkUrl) ?? "https://heylua.ai",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "lua:flex lua:items-center",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lua:text-xs lua:text-slate-500", children: "Powered by" }),
                          ((_c2 = luaPopConfig.chatHeaderSubtitle) == null ? void 0 : _c2.linkUrl) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "img",
                            {
                              src: (_d2 = luaPopConfig.chatHeaderSubtitle) == null ? void 0 : _d2.iconUrl,
                              alt: "Brand Icon",
                              className: "lua:h-[14px] lua:w-[14px] lua:mx-[2.5px]"
                            }
                          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Logo$1, { className: "lua:h-[14px] lua:w-[14px] lua:mx-[2.5px]" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lua:text-xs lua:font-semibold", children: ((_e3 = luaPopConfig.chatHeaderSubtitle) == null ? void 0 : _e3.brandName) ?? "Lua" })
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:w-1 lua:h-1 lua:rounded-full lua:bg-slate-400" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        type: "button",
                        className: "lua:text-xs lua:font-semibold lua:text-[#2c7bff] hover:lua:underline lua:cursor-pointer",
                        onClick: () => setShowGetInTouchForm(true),
                        children: "Get in touch"
                      }
                    )
                  ] })
                ] }),
                luaPopConfig.displayMode !== "embedded" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: onClose,
                    className: "lua:p-1 lua:rounded-full lua:hover:bg-muted lua:cursor-pointer lua-close-button",
                    "aria-label": "Close chat",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      XIcon$1,
                      {
                        size: 18,
                        className: "lua:mix-blend-difference lua:text-white"
                      }
                    )
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:overflow-hidden lua:flex lua:flex-col lua:flex-1", children: isVoiceChatActive ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "lua:overflow-hidden lua:transition-all lua:duration-300 lua:ease-in-out",
              style: {
                height: getVoiceChatContainerHeight()
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                VoiceChat,
                {
                  authToken: authToken2,
                  agentId: luaPopConfig.agentId,
                  channel: luaPopConfig.sessionId,
                  apiUrl,
                  luaPopConfig,
                  onMessage: handleVoiceChatMessage,
                  onAudioData: handleVoiceAudioData
                }
              )
            }
          ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(StickToBottom, { className: "lua:flex-1 lua:overflow-scroll", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(StickToBottom.Content, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChatWithScrollControl,
              {
                handleSendMessage,
                isLoading,
                isLoadingHistory,
                apiUrl,
                authToken: authToken2,
                luaPopConfig
              }
            ),
            isManualResponseActive && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua:flex lua:justify-center lua:items-center lua:px-5 lua:mb-5 lua:text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lua:text-xs lua:font-light", children: "You're now connected with our support team. Thank you for your patience  replies may take up to 1 working day." }) })
          ] }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua-chat-input-wrapper lua:flex-shrink-0 lua:border-t lua:border-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ChatInput,
            {
              onSendMessage: handleSendMessage,
              isLoading: isLoading || isLoadingHistory,
              onAudioRecorded: handleAudioRecorded,
              onVoiceChatToggle: handleVoiceChatToggle,
              isVoiceChatActive,
              voiceAudioData,
              luaPopConfig,
              cdnUrl,
              authToken: authToken2
            }
          ) }),
          showGetInTouchForm && !showFormSuccess && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "lua:absolute lua:inset-0 lua:bg-white lua:z-50",
              style: {
                borderRadius: "16px",
                boxShadow: "0 2px 10px 0 rgba(0, 0, 0, 0.2)",
                overflow: "hidden"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                GetInTouchForm,
                {
                  onBack: () => setShowGetInTouchForm(false),
                  onClose,
                  onSuccess: () => {
                    setShowFormSuccess(true);
                    setShowGetInTouchForm(false);
                  }
                }
              )
            }
          ),
          showFormSuccess && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "lua:absolute lua:inset-0 lua:bg-white lua:z-50",
              style: {
                borderRadius: "16px",
                boxShadow: "0 2px 10px 0 rgba(0, 0, 0, 0.2)",
                overflow: "hidden"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FormSuccess,
                {
                  onBack: () => {
                    setShowFormSuccess(false);
                    setShowGetInTouchForm(false);
                  },
                  onClose
                }
              )
            }
          )
        ]
      }
    );
  }
  function LuaPopWidget({ config, apiUrl, cdnUrl }) {
    const { setHasUnreadMessages } = hn();
    const {
      authToken: authToken2,
      isAuthenticating,
      isAuthSuccess,
      isAuthError,
      isPusherReady,
      isReady,
      setIsChatOpen
    } = useLuaPop();
    const [isOpen, setIsOpen] = reactExports.useState(
      config.displayMode === "embedded" ? true : false
    );
    const { isLoadingHistory } = useChatHistory({
      authToken: authToken2 || void 0,
      enabled: isReady
    });
    reactExports.useEffect(() => {
      if (isOpen) {
        setHasUnreadMessages(false);
      }
    }, [isOpen, setHasUnreadMessages]);
    reactExports.useEffect(() => {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage(
          {
            type: "LUA_POP_RESIZE",
            width: isOpen ? "350px" : "auto",
            height: isOpen ? "500px" : "auto"
          },
          "*"
        );
      }
    }, [isOpen]);
    const toggleChat = () => {
      const newIsOpen = !isOpen;
      setIsOpen(newIsOpen);
      setIsChatOpen(newIsOpen);
      if (window.parent && window.parent !== window) {
        window.parent.postMessage(
          {
            type: "LUA_POP_EVENT",
            eventType: isOpen ? "widget_closed" : "widget_opened"
          },
          "*"
        );
      }
    };
    const getPositionStyles = () => {
      switch (config.position) {
        case "bottom-left":
          return "lua:left-4 lua:bottom-4 lua:sm:left-8 lua:sm:bottom-8";
        case "top-right":
          return "lua:right-4 lua:top-4 lua:sm:right-8 lua:sm:top-8";
        case "top-left":
          return "lua:left-4 lua:top-4 lua:sm:left-8 lua:sm:top-8";
        case "bottom-right":
        default:
          return "lua:right-4 lua:bottom-4 lua:sm:right-8 lua:sm:bottom-8";
      }
    };
    const getLayoutStyles = () => {
      switch (config.position) {
        case "bottom-left":
          return "lua:flex lua:flex-col lua:items-start lua:gap-1";
        case "top-right":
          return "lua:flex lua:flex-col lua:items-end lua:gap-1";
        case "top-left":
          return "lua:flex lua:flex-col lua:items-start lua:gap-1";
        case "bottom-right":
        default:
          return "lua:flex lua:flex-col lua:items-end lua:gap-1";
      }
    };
    if (isAuthenticating || !isPusherReady) {
      if (config.displayMode === "embedded") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(EmbeddedLoadingIndicator, { config });
      }
      return null;
    }
    if (isAuthError) {
      console.error("LuaPop widget authentication error");
      return null;
    }
    if (!isAuthSuccess) {
      if (config.displayMode === "embedded") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(EmbeddedLoadingIndicator, { config });
      }
      return null;
    }
    if (config.displayMode === "embedded") {
      if (isLoadingHistory) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(EmbeddedLoadingIndicator, { config });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lua-pop-embedded", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        PopChat,
        {
          apiUrl,
          cdnUrl,
          authToken: authToken2 || "",
          onClose: () => {
          },
          luaPopConfig: config,
          isLoadingHistory
        }
      ) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: cn("lua-pop-widget", getPositionStyles(), getLayoutStyles()),
        style: {
          ...config.popupButtonPositionalContainerStyles && config.popupButtonPositionalContainerStyles
        },
        children: config.position === "top-left" || config.position === "top-right" ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AnimatePresence, { initial: false, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(PopButton, { onClick: toggleChat, config }),
          isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              initial: { opacity: 0, scale: 0 },
              animate: { opacity: 1, scale: 1 },
              exit: { opacity: 0, scale: 0 },
              transition: { duration: 0.2, ease: "easeInOut" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                PopChat,
                {
                  apiUrl,
                  cdnUrl,
                  authToken: authToken2 || "",
                  onClose: toggleChat,
                  luaPopConfig: config,
                  isLoadingHistory
                }
              )
            }
          )
        ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { initial: false, children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              initial: { opacity: 0, scale: 0 },
              animate: { opacity: 1, scale: 1 },
              exit: { opacity: 0, scale: 0 },
              transition: { duration: 0.2, ease: "easeInOut" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                PopChat,
                {
                  apiUrl,
                  cdnUrl,
                  authToken: authToken2 || "",
                  onClose: toggleChat,
                  luaPopConfig: config,
                  isLoadingHistory
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(PopButton, { onClick: toggleChat, config })
        ] })
      }
    );
  }
  const createQueryClient = () => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 1e3 * 60 * 5,
        // 5 minutes
        gcTime: 1e3 * 60 * 10,
        // 10 minutes
        retry: 1,
        // Only retry once
        refetchOnWindowFocus: false
      }
    }
  });
  function QueryClientProvider({ children }) {
    const [queryClient] = reactExports.useState(() => createQueryClient());
    return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider$1, { client: queryClient, children });
  }
  const defaultConfig = {
    authToken: "",
    sessionId: "",
    agentId: "",
    position: "bottom-right",
    buttonText: "Chat with us",
    environment: "staging",
    chatInputPlaceholder: "Ask anything, about anything",
    displayMode: "floating"
  };
  let widgetInstance = null;
  const SESSION_ID_STORAGE_KEY = "lua_pop_session_id";
  const devApiUrl = "https://api.lua.dev";
  const prodApiUrl = "https://api.heylua.ai";
  function setupSessionId(config) {
    if (config.sessionId) {
      localStorage.setItem(SESSION_ID_STORAGE_KEY, config.sessionId);
    } else {
      const storedSessionId = localStorage.getItem(SESSION_ID_STORAGE_KEY);
      if (storedSessionId) {
        config.sessionId = storedSessionId;
      } else {
        config.sessionId = generateUuid();
        localStorage.setItem(SESSION_ID_STORAGE_KEY, config.sessionId);
      }
    }
  }
  const devCdnUrl = "https://cdn.lua.dev";
  const prodCdnUrl = "https://cdn.heylua.ai";
  const devAuthUrl = "https://auth.lua.dev";
  const prodAuthUrl = "https://auth.heylua.ai";
  function mountShadowDomWidget(config) {
    const environment = config.environment || "production";
    let hostElement = document.getElementById("lua-shadow-root");
    if (!hostElement) {
      hostElement = document.createElement("div");
      hostElement.id = "lua-shadow-root";
      hostElement.style.display = "block";
      document.body.appendChild(hostElement);
    }
    const shadowRoot = hostElement.shadowRoot || hostElement.attachShadow({ mode: "open" });
    const interFontLink = document.createElement("link");
    interFontLink.setAttribute("rel", "stylesheet");
    interFontLink.setAttribute(
      "href",
      "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Onest:wght@400;500;600;700&display=swap"
    );
    shadowRoot.appendChild(interFontLink);
    const styleLink = document.createElement("link");
    styleLink.setAttribute("rel", "stylesheet");
    styleLink.setAttribute(
      "href",
      "https://lua-ai-global.github.io/lua-pop/style.css"
    );
    shadowRoot.appendChild(styleLink);
    const appContainer = document.createElement("div");
    appContainer.id = "lua-root";
    appContainer.className = `lua-pop-${config.displayMode || "floating"}`;
    shadowRoot.appendChild(appContainer);
    const apiUrlEnvironmentMap = {
      staging: devApiUrl,
      production: prodApiUrl,
      custom: config.customBaseApiUri || prodApiUrl
    };
    const apiUrl = apiUrlEnvironmentMap[environment];
    const cdnUrl = config.environment === "production" ? prodCdnUrl : devCdnUrl;
    const authUrl = config.environment === "production" ? prodAuthUrl : devAuthUrl;
    setupSessionId(config);
    createApiClient({ baseURL: apiUrl });
    const renderReactApp = () => {
      const root22 = client.createRoot(appContainer);
      root22.render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(mn, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuaPopProvider, { config, authUrl, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuaPopWidget, { config, apiUrl, cdnUrl }) }) }) }) }) })
      );
      return root22;
    };
    let root2;
    let hasRendered = false;
    styleLink.onload = () => {
      if (!hasRendered) {
        hasRendered = true;
        root2 = renderReactApp();
      }
    };
    if (styleLink.sheet) {
      hasRendered = true;
      root2 = renderReactApp();
    }
    return {
      destroy: () => {
        if (root2) {
          root2.unmount();
        }
        hostElement.remove();
      }
    };
  }
  function mountEmbeddedWidget(config) {
    var _a2;
    if (config.environment && !["staging", "production"].includes(config.environment)) {
      console.error(
        `LuaPop: Invalid environment value "${config.environment}". Supported values are: "staging", "production". Defaulting to "staging".`
      );
      config.environment = "staging";
    }
    if (!((_a2 = config.embeddedDisplayConfig) == null ? void 0 : _a2.targetContainerId)) {
      console.error(
        "LuaPop: embeddedDisplayConfig.targetContainerId is required when displayMode is 'embedded'"
      );
      return null;
    }
    const targetContainer = document.getElementById(
      config.embeddedDisplayConfig.targetContainerId
    );
    if (!targetContainer) {
      console.error(
        `LuaPop: Target container with id "${config.embeddedDisplayConfig.targetContainerId}" not found`
      );
      return null;
    }
    const environment = config.environment || "production";
    const apiUrlEnvironmentMap = {
      staging: devApiUrl,
      production: prodApiUrl,
      custom: config.customBaseApiUri || prodApiUrl
    };
    const apiUrl = apiUrlEnvironmentMap[environment];
    const cdnUrl = config.environment === "production" ? prodCdnUrl : devCdnUrl;
    const authUrl = config.environment === "production" ? prodAuthUrl : devAuthUrl;
    setupSessionId(config);
    createApiClient({
      baseURL: apiUrl
    });
    const hostElement = document.createElement("div");
    hostElement.id = "lua-shadow-root-embedded";
    hostElement.className = "lua-pop-embedded";
    hostElement.style.display = "block";
    hostElement.style.width = "100%";
    hostElement.style.height = "100%";
    targetContainer.appendChild(hostElement);
    const shadowRoot = hostElement.shadowRoot || hostElement.attachShadow({ mode: "open" });
    const interFontLink = document.createElement("link");
    interFontLink.setAttribute("rel", "stylesheet");
    interFontLink.setAttribute(
      "href",
      "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Onest:wght@400;500;600;700&display=swap"
    );
    shadowRoot.appendChild(interFontLink);
    const styleLink = document.createElement("link");
    styleLink.setAttribute("rel", "stylesheet");
    styleLink.setAttribute(
      "href",
      "https://lua-ai-global.github.io/lua-pop/style.css"
    );
    shadowRoot.appendChild(styleLink);
    const appContainer = document.createElement("div");
    appContainer.id = "lua-root";
    appContainer.className = `lua-pop-embedded-root lua-pop-${config.displayMode || "embedded"}`;
    shadowRoot.appendChild(appContainer);
    const renderReactApp = () => {
      const root22 = client.createRoot(appContainer);
      root22.render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(mn, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuaPopProvider, { config, authUrl, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuaPopWidget, { config, apiUrl, cdnUrl }) }) }) }) }) })
      );
      return root22;
    };
    let root2;
    let hasRendered = false;
    styleLink.onload = () => {
      if (!hasRendered) {
        hasRendered = true;
        root2 = renderReactApp();
      }
    };
    if (styleLink.sheet) {
      hasRendered = true;
      root2 = renderReactApp();
    }
    return {
      destroy: () => {
        if (root2) {
          root2.unmount();
        }
        hostElement.remove();
      }
    };
  }
  const LuaPopGlobal = {
    config: { ...defaultConfig },
    init: async (customConfig = {}) => {
      if (widgetInstance) {
        widgetInstance.destroy();
      }
      const environment = "production";
      const apiUrl = prodApiUrl;
      createApiClient({ baseURL: apiUrl });
      let config;
      let apiConfig = {};
      try {
        const website = window.location.hostname;
        const isDev = false;
        const response = await webchatApi.getWebchatConfig(website, isDev);
        apiConfig = {
          ...response.config,
          agentId: response.agentId,
          environment
        };
      } catch (error) {
      }
      const hasApiConfig = Object.keys(apiConfig).length > 0;
      const hasUserConfig = Object.keys(customConfig).length > 0;
      if (!hasApiConfig && !hasUserConfig) {
        return null;
      }
      config = {
        ...defaultConfig,
        ...apiConfig,
        ...customConfig
      };
      LuaPopGlobal.config = config;
      if (config.displayMode === "embedded") {
        widgetInstance = mountEmbeddedWidget(config);
      } else {
        widgetInstance = mountShadowDomWidget(config);
      }
      return widgetInstance;
    }
  };
  if (typeof window !== "undefined") {
    window.LuaPop = LuaPopGlobal;
  }
  exports2.LuaPopWidget = LuaPopWidget;
  exports2.default = LuaPopGlobal;
  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
});
//# sourceMappingURL=lua-pop.umd.js.map
